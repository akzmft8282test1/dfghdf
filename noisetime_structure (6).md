# noisetime 프로젝트 구조

## 프로젝트 정보

- **스캔 일시**: 2025-10-03T10:34:15.321706
- **경로**: /home/user/noisetime
- **파일 수**: 444개
- **디렉토리 수**: 406개
- **총 크기**: 3.27MB
- **제외된 파일**: file.py

## 스캔 설정

- **바이너리 파일 포함**: 아니오
- **특정 폴더**: android, ios, lib, .idx
- **제외 폴더**: 없음
- **최대 미리보기 크기**: 500000 characters

## 통계

- **텍스트 파일**: 444개

## 디렉토리 구조

```
noisetime/
    ├── .idx/
    │   ├── airules.md
    │   └── dev.nix
    ├── noisetime/
    │   ├── .dart_tool/
    │   │   ├── dartpad/
    │   │   │   └── web_plugin_registrant.dart
    │   │   ├── extension_discovery/
    │   │   │   ├── README.md
    │   │   │   └── vs_code.json
    │   │   ├── package_config.json
    │   │   ├── package_config_subset
    │   │   └── version
    │   ├── .idea/
    │   │   ├── libraries/
    │   │   │   ├── Dart_SDK.xml
    │   │   │   └── KotlinJavaRuntime.xml
    │   │   ├── runConfigurations/
    │   │   │   └── main_dart.xml
    │   │   ├── modules.xml
    │   │   └── workspace.xml
    │   ├── android/
    │   │   ├── app/
    │   │   │   ├── src/
    │   │   │   │   ├── debug/
    │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │   ├── main/
    │   │   │   │   │   ├── java/
    │   │   │   │   │   │   └── io/
    │   │   │   │   │   │       └── flutter/
    │   │   │   │   │   │           └── plugins/
    │   │   │   │   │   │               └── GeneratedPluginRegistrant.java
    │   │   │   │   │   ├── kotlin/
    │   │   │   │   │   │   └── com/
    │   │   │   │   │   │       └── example/
    │   │   │   │   │   │           └── noisetime/
    │   │   │   │   │   │               └── MainActivity.kt
    │   │   │   │   │   ├── res/
    │   │   │   │   │   │   ├── drawable/
    │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │   │   │   ├── drawable-v21/
    │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │   │   │   ├── mipmap-hdpi/
    │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │   │   │   ├── mipmap-mdpi/
    │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │   │   │   ├── mipmap-xhdpi/
    │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │   │   │   ├── mipmap-xxhdpi/
    │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │   │   │   ├── mipmap-xxxhdpi/
    │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │   │   │   ├── values/
    │   │   │   │   │   │   │   └── styles.xml
    │   │   │   │   │   │   └── values-night/
    │   │   │   │   │   │       └── styles.xml
    │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │   └── profile/
    │   │   │   │       └── AndroidManifest.xml
    │   │   │   ├── build.gradle
    │   │   │   └── google-services.json
    │   │   ├── gradle/
    │   │   │   └── wrapper/
    │   │   │       ├── gradle-wrapper.jar
    │   │   │       └── gradle-wrapper.properties
    │   │   ├── .gitignore
    │   │   ├── build.gradle
    │   │   ├── gradle.properties
    │   │   ├── gradlew
    │   │   ├── gradlew.bat
    │   │   ├── local.properties
    │   │   ├── noisetime_android.iml
    │   │   └── settings.gradle
    │   ├── ios/
    │   │   ├── Flutter/
    │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   ├── Debug.xcconfig
    │   │   │   ├── Generated.xcconfig
    │   │   │   ├── Release.xcconfig
    │   │   │   └── flutter_export_environment.sh
    │   │   ├── Runner/
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   ├── Contents.json
    │   │   │   │   │   ├── Icon-App-1024x1024@1x.png
    │   │   │   │   │   ├── Icon-App-20x20@1x.png
    │   │   │   │   │   ├── Icon-App-20x20@2x.png
    │   │   │   │   │   ├── Icon-App-20x20@3x.png
    │   │   │   │   │   ├── Icon-App-29x29@1x.png
    │   │   │   │   │   ├── Icon-App-29x29@2x.png
    │   │   │   │   │   ├── Icon-App-29x29@3x.png
    │   │   │   │   │   ├── Icon-App-40x40@1x.png
    │   │   │   │   │   ├── Icon-App-40x40@2x.png
    │   │   │   │   │   ├── Icon-App-40x40@3x.png
    │   │   │   │   │   ├── Icon-App-60x60@2x.png
    │   │   │   │   │   ├── Icon-App-60x60@3x.png
    │   │   │   │   │   ├── Icon-App-76x76@1x.png
    │   │   │   │   │   ├── Icon-App-76x76@2x.png
    │   │   │   │   │   └── Icon-App-83.5x83.5@2x.png
    │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       ├── Contents.json
    │   │   │   │       ├── LaunchImage.png
    │   │   │   │       ├── LaunchImage@2x.png
    │   │   │   │       ├── LaunchImage@3x.png
    │   │   │   │       └── README.md
    │   │   │   ├── Base.lproj/
    │   │   │   │   ├── LaunchScreen.storyboard
    │   │   │   │   └── Main.storyboard
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── GeneratedPluginRegistrant.h
    │   │   │   ├── GeneratedPluginRegistrant.m
    │   │   │   ├── Info.plist
    │   │   │   └── Runner-Bridging-Header.h
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   ├── xcshareddata/
    │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │   └── contents.xcworkspacedata
    │   │   │   ├── xcshareddata/
    │   │   │   │   └── xcschemes/
    │   │   │   │       └── Runner.xcscheme
    │   │   │   └── project.pbxproj
    │   │   ├── Runner.xcworkspace/
    │   │   │   ├── xcshareddata/
    │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   └── contents.xcworkspacedata
    │   │   ├── RunnerTests/
    │   │   │   └── RunnerTests.swift
    │   │   └── .gitignore
    │   ├── lib/
    │   │   ├── auth_screen.dart
    │   │   ├── firebase_options.dart
    │   │   ├── main.dart
    │   │   ├── noise_screen.dart
    │   │   └── noise_service.dart
    │   ├── linux/
    │   │   ├── flutter/
    │   │   │   ├── ephemeral/
    │   │   │   │   └── .plugin_symlinks/
    │   │   │   ├── CMakeLists.txt
    │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   ├── generated_plugin_registrant.h
    │   │   │   └── generated_plugins.cmake
    │   │   ├── .gitignore
    │   │   ├── CMakeLists.txt
    │   │   ├── main.cc
    │   │   ├── my_application.cc
    │   │   └── my_application.h
    │   ├── macos/
    │   │   ├── Flutter/
    │   │   │   ├── ephemeral/
    │   │   │   │   ├── Flutter-Generated.xcconfig
    │   │   │   │   └── flutter_export_environment.sh
    │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   ├── Runner/
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       ├── Contents.json
    │   │   │   │       ├── app_icon_1024.png
    │   │   │   │       ├── app_icon_128.png
    │   │   │   │       ├── app_icon_16.png
    │   │   │   │       ├── app_icon_256.png
    │   │   │   │       ├── app_icon_32.png
    │   │   │   │       ├── app_icon_512.png
    │   │   │   │       └── app_icon_64.png
    │   │   │   ├── Base.lproj/
    │   │   │   │   └── MainMenu.xib
    │   │   │   ├── Configs/
    │   │   │   │   ├── AppInfo.xcconfig
    │   │   │   │   ├── Debug.xcconfig
    │   │   │   │   ├── Release.xcconfig
    │   │   │   │   └── Warnings.xcconfig
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── DebugProfile.entitlements
    │   │   │   ├── Info.plist
    │   │   │   ├── MainFlutterWindow.swift
    │   │   │   └── Release.entitlements
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   └── xcshareddata/
    │   │   │   │       └── IDEWorkspaceChecks.plist
    │   │   │   ├── xcshareddata/
    │   │   │   │   └── xcschemes/
    │   │   │   │       └── Runner.xcscheme
    │   │   │   └── project.pbxproj
    │   │   ├── Runner.xcworkspace/
    │   │   │   ├── xcshareddata/
    │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   └── contents.xcworkspacedata
    │   │   ├── RunnerTests/
    │   │   │   └── RunnerTests.swift
    │   │   └── .gitignore
    │   ├── test/
    │   │   └── widget_test.dart
    │   ├── web/
    │   │   ├── icons/
    │   │   │   ├── Icon-192.png
    │   │   │   ├── Icon-512.png
    │   │   │   ├── Icon-maskable-192.png
    │   │   │   └── Icon-maskable-512.png
    │   │   ├── favicon.png
    │   │   ├── index.html
    │   │   └── manifest.json
    │   ├── windows/
    │   │   ├── flutter/
    │   │   │   ├── ephemeral/
    │   │   │   │   └── .plugin_symlinks/
    │   │   │   │       ├── cloud_firestore/
    │   │   │   │       │   ├── android/
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   └── main/
    │   │   │   │       │   │   │       ├── java/
    │   │   │   │       │   │   │       │   └── io/
    │   │   │   │       │   │   │       │       └── flutter/
    │   │   │   │       │   │   │       │           └── plugins/
    │   │   │   │       │   │   │       │               └── firebase/
    │   │   │   │       │   │   │       │                   └── firestore/
    │   │   │   │       │   │   │       │                       ├── streamhandler/
    │   │   │   │       │   │   │       │                       │   ├── DocumentSnapshotsStreamHandler.java
    │   │   │   │       │   │   │       │                       │   ├── LoadBundleStreamHandler.java
    │   │   │   │       │   │   │       │                       │   ├── OnTransactionResultListener.java
    │   │   │   │       │   │   │       │                       │   ├── QuerySnapshotsStreamHandler.java
    │   │   │   │       │   │   │       │                       │   ├── SnapshotsInSyncStreamHandler.java
    │   │   │   │       │   │   │       │                       │   └── TransactionStreamHandler.java
    │   │   │   │       │   │   │       │                       ├── utils/
    │   │   │   │       │   │   │       │                       │   ├── ExceptionConverter.java
    │   │   │   │       │   │   │       │                       │   ├── PigeonParser.java
    │   │   │   │       │   │   │       │                       │   └── ServerTimestampBehaviorConverter.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestoreException.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestoreExtension.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestoreMessageCodec.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestorePlugin.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestoreRegistrar.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseFirestoreTransactionResult.java
    │   │   │   │       │   │   │       │                       └── GeneratedAndroidFirebaseFirestore.java
    │   │   │   │       │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   ├── build.gradle
    │   │   │   │       │   │   ├── local-config.gradle
    │   │   │   │       │   │   ├── settings.gradle
    │   │   │   │       │   │   └── user-agent.gradle
    │   │   │   │       │   ├── dartpad/
    │   │   │   │       │   │   ├── lib/
    │   │   │   │       │   │   │   └── main.dart
    │   │   │   │       │   │   └── dartpad_metadata.yaml
    │   │   │   │       │   ├── example/
    │   │   │   │       │   │   ├── android/
    │   │   │   │       │   │   │   ├── app/
    │   │   │   │       │   │   │   │   ├── src/
    │   │   │   │       │   │   │   │   │   ├── debug/
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   ├── main/
    │   │   │   │       │   │   │   │   │   │   ├── java/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   ├── kotlin/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   │               └── firebase/
    │   │   │   │       │   │   │   │   │   │   │                   └── firestore/
    │   │   │   │       │   │   │   │   │   │   │                       └── example/
    │   │   │   │       │   │   │   │   │   │   │                           └── MainActivity.kt
    │   │   │   │       │   │   │   │   │   │   ├── res/
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable-v21/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-hdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-mdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── values/
    │   │   │   │       │   │   │   │   │   │   │   │   └── styles.xml
    │   │   │   │       │   │   │   │   │   │   │   └── values-night/
    │   │   │   │       │   │   │   │   │   │   │       └── styles.xml
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   └── profile/
    │   │   │   │       │   │   │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   │   └── google-services.json
    │   │   │   │       │   │   │   ├── gradle/
    │   │   │   │       │   │   │   │   └── wrapper/
    │   │   │   │       │   │   │   │       └── gradle-wrapper.properties
    │   │   │   │       │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   ├── gradle.properties
    │   │   │   │       │   │   │   └── settings.gradle
    │   │   │   │       │   │   ├── integration_test/
    │   │   │   │       │   │   │   ├── collection_reference_e2e.dart
    │   │   │   │       │   │   │   ├── document_change_e2e.dart
    │   │   │   │       │   │   │   ├── document_reference_e2e.dart
    │   │   │   │       │   │   │   ├── e2e_test.dart
    │   │   │   │       │   │   │   ├── field_value_e2e.dart
    │   │   │   │       │   │   │   ├── firebase_options.dart
    │   │   │   │       │   │   │   ├── firebase_options_secondary.dart
    │   │   │   │       │   │   │   ├── geo_point_e2e.dart
    │   │   │   │       │   │   │   ├── instance_e2e.dart
    │   │   │   │       │   │   │   ├── load_bundle_e2e.dart
    │   │   │   │       │   │   │   ├── query_e2e.dart
    │   │   │   │       │   │   │   ├── second_database.dart
    │   │   │   │       │   │   │   ├── settings_e2e.dart
    │   │   │   │       │   │   │   ├── snapshot_metadata_e2e.dart
    │   │   │   │       │   │   │   ├── timestamp_e2e.dart
    │   │   │   │       │   │   │   ├── transaction_e2e.dart
    │   │   │   │       │   │   │   ├── vector_value_e2e.dart
    │   │   │   │       │   │   │   ├── web_snapshot_listeners.dart
    │   │   │   │       │   │   │   └── write_batch_e2e.dart
    │   │   │   │       │   │   ├── ios/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │       │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │   │   ├── Contents.json
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-1024x1024@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@2x.png
    │   │   │   │       │   │   │   │   │   │   └── Icon-App-83.5x83.5@2x.png
    │   │   │   │       │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── LaunchImage.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@2x.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@3x.png
    │   │   │   │       │   │   │   │   │       └── README.md
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   ├── LaunchScreen.storyboard
    │   │   │   │       │   │   │   │   │   └── Main.storyboard
    │   │   │   │       │   │   │   │   ├── AppDelegate.swift
    │   │   │   │       │   │   │   │   ├── GoogleService-Info.plist
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   └── Runner-Bridging-Header.h
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   │   ├── swiftpm/
    │   │   │   │       │   │   │   │   │   │   │   └── configuration/
    │   │   │   │       │   │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   ├── swiftpm/
    │   │   │   │       │   │   │   │   │   │   └── configuration/
    │   │   │   │       │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   ├── Podfile
    │   │   │   │       │   │   │   └── firebase_app_id_file.json
    │   │   │   │       │   │   ├── lib/
    │   │   │   │       │   │   │   ├── firebase_options.dart
    │   │   │   │       │   │   │   └── main.dart
    │   │   │   │       │   │   ├── macos/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Flutter-Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── app_icon_1024.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_128.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_16.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_256.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_32.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_512.png
    │   │   │   │       │   │   │   │   │       └── app_icon_64.png
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   └── MainMenu.xib
    │   │   │   │       │   │   │   │   ├── Configs/
    │   │   │   │       │   │   │   │   │   ├── AppInfo.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Release.xcconfig
    │   │   │   │       │   │   │   │   │   └── Warnings.xcconfig
    │   │   │   │       │   │   │   │   ├── AppDelegate.swift
    │   │   │   │       │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │       │   │   │   │   ├── GoogleService-Info.plist
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │       │   │   │   │   └── Release.entitlements
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   └── xcshareddata/
    │   │   │   │       │   │   │   │   │       ├── swiftpm/
    │   │   │   │       │   │   │   │   │       │   └── configuration/
    │   │   │   │       │   │   │   │   │       └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   ├── swiftpm/
    │   │   │   │       │   │   │   │   │   │   └── configuration/
    │   │   │   │       │   │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   ├── RunnerTests/
    │   │   │   │       │   │   │   │   └── RunnerTests.swift
    │   │   │   │       │   │   │   ├── Podfile
    │   │   │   │       │   │   │   └── firebase_app_id_file.json
    │   │   │   │       │   │   ├── test_driver/
    │   │   │   │       │   │   │   └── integration_test.dart
    │   │   │   │       │   │   ├── web/
    │   │   │   │       │   │   │   ├── icons/
    │   │   │   │       │   │   │   │   ├── Icon-192.png
    │   │   │   │       │   │   │   │   ├── Icon-512.png
    │   │   │   │       │   │   │   │   ├── Icon-maskable-192.png
    │   │   │   │       │   │   │   │   └── Icon-maskable-512.png
    │   │   │   │       │   │   │   ├── favicon.png
    │   │   │   │       │   │   │   ├── index.html
    │   │   │   │       │   │   │   ├── manifest.json
    │   │   │   │       │   │   │   └── wasm_index.html
    │   │   │   │       │   │   ├── windows/
    │   │   │   │       │   │   │   ├── flutter/
    │   │   │   │       │   │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   │   ├── runner/
    │   │   │   │       │   │   │   │   ├── resources/
    │   │   │   │       │   │   │   │   │   └── app_icon.ico
    │   │   │   │       │   │   │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   │   │   ├── Runner.rc
    │   │   │   │       │   │   │   │   ├── flutter_window.cpp
    │   │   │   │       │   │   │   │   ├── flutter_window.h
    │   │   │   │       │   │   │   │   ├── main.cpp
    │   │   │   │       │   │   │   │   ├── resource.h
    │   │   │   │       │   │   │   │   ├── runner.exe.manifest
    │   │   │   │       │   │   │   │   ├── utils.cpp
    │   │   │   │       │   │   │   │   ├── utils.h
    │   │   │   │       │   │   │   │   ├── win32_window.cpp
    │   │   │   │       │   │   │   │   └── win32_window.h
    │   │   │   │       │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   ├── README.md
    │   │   │   │       │   │   ├── analysis_options.yaml
    │   │   │   │       │   │   ├── firebase.json
    │   │   │   │       │   │   └── pubspec.yaml
    │   │   │   │       │   ├── ios/
    │   │   │   │       │   │   ├── cloud_firestore/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── cloud_firestore/
    │   │   │   │       │   │   │   │       ├── Resources/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   └── cloud_firestore/
    │   │   │   │       │   │   │   │       │       ├── Private/
    │   │   │   │       │   │   │   │       │       │   ├── FLTDocumentSnapshotStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreExtension.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreReader.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreUtils.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreWriter.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTLoadBundleStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTQuerySnapshotStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTSnapshotsInSyncStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTTransactionStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   └── FirestorePigeonParser.h
    │   │   │   │       │   │   │   │       │       └── Public/
    │   │   │   │       │   │   │   │       │           ├── CustomPigeonHeaderFirestore.h
    │   │   │   │       │   │   │   │       │           ├── FLTFirebaseFirestorePlugin.h
    │   │   │   │       │   │   │   │       │           └── FirestoreMessages.g.h
    │   │   │   │       │   │   │   │       ├── FLTDocumentSnapshotStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreExtension.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestorePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreReader.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreUtils.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreWriter.m
    │   │   │   │       │   │   │   │       ├── FLTLoadBundleStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTQuerySnapshotStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTSnapshotsInSyncStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTTransactionStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FirestoreMessages.g.m
    │   │   │   │       │   │   │   │       └── FirestorePigeonParser.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   ├── cloud_firestore.podspec
    │   │   │   │       │   │   └── generated_firebase_sdk_version.txt
    │   │   │   │       │   ├── lib/
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   ├── utils/
    │   │   │   │       │   │   │   │   └── codec_utility.dart
    │   │   │   │       │   │   │   ├── aggregate_query.dart
    │   │   │   │       │   │   │   ├── aggregate_query_snapshot.dart
    │   │   │   │       │   │   │   ├── collection_reference.dart
    │   │   │   │       │   │   │   ├── document_change.dart
    │   │   │   │       │   │   │   ├── document_reference.dart
    │   │   │   │       │   │   │   ├── document_snapshot.dart
    │   │   │   │       │   │   │   ├── field_value.dart
    │   │   │   │       │   │   │   ├── filters.dart
    │   │   │   │       │   │   │   ├── firestore.dart
    │   │   │   │       │   │   │   ├── load_bundle_task.dart
    │   │   │   │       │   │   │   ├── load_bundle_task_snapshot.dart
    │   │   │   │       │   │   │   ├── persistent_cache_index_manager.dart
    │   │   │   │       │   │   │   ├── query.dart
    │   │   │   │       │   │   │   ├── query_document_snapshot.dart
    │   │   │   │       │   │   │   ├── query_snapshot.dart
    │   │   │   │       │   │   │   ├── snapshot_metadata.dart
    │   │   │   │       │   │   │   ├── transaction.dart
    │   │   │   │       │   │   │   └── write_batch.dart
    │   │   │   │       │   │   └── cloud_firestore.dart
    │   │   │   │       │   ├── macos/
    │   │   │   │       │   │   ├── cloud_firestore/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── cloud_firestore/
    │   │   │   │       │   │   │   │       ├── Resources/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   └── cloud_firestore/
    │   │   │   │       │   │   │   │       │       ├── Private/
    │   │   │   │       │   │   │   │       │       │   ├── FLTDocumentSnapshotStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreExtension.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreReader.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreUtils.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTFirebaseFirestoreWriter.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTLoadBundleStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTQuerySnapshotStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTSnapshotsInSyncStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   ├── FLTTransactionStreamHandler.h
    │   │   │   │       │   │   │   │       │       │   └── FirestorePigeonParser.h
    │   │   │   │       │   │   │   │       │       └── Public/
    │   │   │   │       │   │   │   │       │           ├── CustomPigeonHeaderFirestore.h
    │   │   │   │       │   │   │   │       │           ├── FLTFirebaseFirestorePlugin.h
    │   │   │   │       │   │   │   │       │           └── FirestoreMessages.g.h
    │   │   │   │       │   │   │   │       ├── FLTDocumentSnapshotStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreExtension.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestorePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreReader.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreUtils.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseFirestoreWriter.m
    │   │   │   │       │   │   │   │       ├── FLTLoadBundleStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTQuerySnapshotStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTSnapshotsInSyncStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTTransactionStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FirestoreMessages.g.m
    │   │   │   │       │   │   │   │       └── FirestorePigeonParser.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   └── cloud_firestore.podspec
    │   │   │   │       │   ├── test/
    │   │   │   │       │   │   ├── cloud_firestore_test.dart
    │   │   │   │       │   │   ├── collection_reference_test.dart
    │   │   │   │       │   │   ├── field_value_test.dart
    │   │   │   │       │   │   ├── mock.dart
    │   │   │   │       │   │   ├── query_test.dart
    │   │   │   │       │   │   └── test_firestore_message_codec.dart
    │   │   │   │       │   ├── windows/
    │   │   │   │       │   │   ├── include/
    │   │   │   │       │   │   │   └── cloud_firestore/
    │   │   │   │       │   │   │       └── cloud_firestore_plugin_c_api.h
    │   │   │   │       │   │   ├── test/
    │   │   │   │       │   │   │   └── cloud_firestore_plugin_test.cpp
    │   │   │   │       │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   ├── cloud_firestore_plugin.cpp
    │   │   │   │       │   │   ├── cloud_firestore_plugin.h
    │   │   │   │       │   │   ├── cloud_firestore_plugin_c_api.cpp
    │   │   │   │       │   │   ├── firestore_codec.cpp
    │   │   │   │       │   │   ├── firestore_codec.h
    │   │   │   │       │   │   ├── messages.g.cpp
    │   │   │   │       │   │   ├── messages.g.h
    │   │   │   │       │   │   └── plugin_version.h.in
    │   │   │   │       │   ├── CHANGELOG.md
    │   │   │   │       │   ├── LICENSE
    │   │   │   │       │   ├── README.md
    │   │   │   │       │   └── pubspec.yaml
    │   │   │   │       ├── firebase_auth/
    │   │   │   │       │   ├── android/
    │   │   │   │       │   │   ├── gradle/
    │   │   │   │       │   │   │   └── wrapper/
    │   │   │   │       │   │   │       └── gradle-wrapper.properties
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   └── main/
    │   │   │   │       │   │   │       ├── java/
    │   │   │   │       │   │   │       │   └── io/
    │   │   │   │       │   │   │       │       └── flutter/
    │   │   │   │       │   │   │       │           └── plugins/
    │   │   │   │       │   │   │       │               └── firebase/
    │   │   │   │       │   │   │       │                   └── auth/
    │   │   │   │       │   │   │       │                       ├── AuthStateChannelStreamHandler.java
    │   │   │   │       │   │   │       │                       ├── Constants.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseAuthPlugin.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseAuthPluginException.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseAuthRegistrar.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseAuthUser.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseMultiFactor.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseTotpMultiFactor.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseTotpSecret.java
    │   │   │   │       │   │   │       │                       ├── GeneratedAndroidFirebaseAuth.java
    │   │   │   │       │   │   │       │                       ├── IdTokenChannelStreamHandler.java
    │   │   │   │       │   │   │       │                       ├── PhoneNumberVerificationStreamHandler.java
    │   │   │   │       │   │   │       │                       └── PigeonParser.java
    │   │   │   │       │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   ├── build.gradle
    │   │   │   │       │   │   ├── gradle.properties
    │   │   │   │       │   │   ├── settings.gradle
    │   │   │   │       │   │   └── user-agent.gradle
    │   │   │   │       │   ├── example/
    │   │   │   │       │   │   ├── android/
    │   │   │   │       │   │   │   ├── app/
    │   │   │   │       │   │   │   │   ├── src/
    │   │   │   │       │   │   │   │   │   ├── debug/
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   ├── main/
    │   │   │   │       │   │   │   │   │   │   ├── java/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   ├── kotlin/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   │               └── firebase/
    │   │   │   │       │   │   │   │   │   │   │                   └── auth/
    │   │   │   │       │   │   │   │   │   │   │                       └── example/
    │   │   │   │       │   │   │   │   │   │   │                           └── MainActivity.kt
    │   │   │   │       │   │   │   │   │   │   ├── res/
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable-v21/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-hdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-mdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── values/
    │   │   │   │       │   │   │   │   │   │   │   │   └── styles.xml
    │   │   │   │       │   │   │   │   │   │   │   └── values-night/
    │   │   │   │       │   │   │   │   │   │   │       └── styles.xml
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   └── profile/
    │   │   │   │       │   │   │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   │   └── google-services.json
    │   │   │   │       │   │   │   ├── gradle/
    │   │   │   │       │   │   │   │   └── wrapper/
    │   │   │   │       │   │   │   │       └── gradle-wrapper.properties
    │   │   │   │       │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   ├── gradle.properties
    │   │   │   │       │   │   │   └── settings.gradle
    │   │   │   │       │   │   ├── ios/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │       │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │   │   ├── Contents.json
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-1024x1024@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@2x.png
    │   │   │   │       │   │   │   │   │   │   └── Icon-App-83.5x83.5@2x.png
    │   │   │   │       │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── LaunchImage.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@2x.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@3x.png
    │   │   │   │       │   │   │   │   │       └── README.md
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   ├── LaunchScreen.storyboard
    │   │   │   │       │   │   │   │   │   └── Main.storyboard
    │   │   │   │       │   │   │   │   ├── AppDelegate.h
    │   │   │   │       │   │   │   │   ├── AppDelegate.m
    │   │   │   │       │   │   │   │   ├── AppDelegate.swift
    │   │   │   │       │   │   │   │   ├── GoogleService-Info.plist
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   │       │   │   │   │   ├── Runner.entitlements
    │   │   │   │       │   │   │   │   └── main.m
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   │   ├── swiftpm/
    │   │   │   │       │   │   │   │   │   │   │   └── configuration/
    │   │   │   │       │   │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   ├── swiftpm/
    │   │   │   │       │   │   │   │   │   │   └── configuration/
    │   │   │   │       │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   ├── Podfile
    │   │   │   │       │   │   │   └── firebase_app_id_file.json
    │   │   │   │       │   │   ├── lib/
    │   │   │   │       │   │   │   ├── auth.dart
    │   │   │   │       │   │   │   ├── firebase_options.dart
    │   │   │   │       │   │   │   ├── main.dart
    │   │   │   │       │   │   │   └── profile.dart
    │   │   │   │       │   │   ├── macos/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Flutter-Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── app_icon_1024.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_128.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_16.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_256.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_32.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_512.png
    │   │   │   │       │   │   │   │   │       └── app_icon_64.png
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   └── MainMenu.xib
    │   │   │   │       │   │   │   │   ├── Configs/
    │   │   │   │       │   │   │   │   │   ├── AppInfo.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Release.xcconfig
    │   │   │   │       │   │   │   │   │   └── Warnings.xcconfig
    │   │   │   │       │   │   │   │   ├── AppDelegate.swift
    │   │   │   │       │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │       │   │   │   │   ├── GoogleService-Info.plist
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │       │   │   │   │   └── Release.entitlements
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   ├── Podfile
    │   │   │   │       │   │   │   └── firebase_app_id_file.json
    │   │   │   │       │   │   ├── web/
    │   │   │   │       │   │   │   ├── icons/
    │   │   │   │       │   │   │   │   ├── Icon-192.png
    │   │   │   │       │   │   │   │   ├── Icon-512.png
    │   │   │   │       │   │   │   │   ├── Icon-maskable-192.png
    │   │   │   │       │   │   │   │   └── Icon-maskable-512.png
    │   │   │   │       │   │   │   ├── favicon.png
    │   │   │   │       │   │   │   ├── index.html
    │   │   │   │       │   │   │   └── manifest.json
    │   │   │   │       │   │   ├── windows/
    │   │   │   │       │   │   │   ├── flutter/
    │   │   │   │       │   │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   │   ├── runner/
    │   │   │   │       │   │   │   │   ├── resources/
    │   │   │   │       │   │   │   │   │   └── app_icon.ico
    │   │   │   │       │   │   │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   │   │   ├── Runner.rc
    │   │   │   │       │   │   │   │   ├── flutter_window.cpp
    │   │   │   │       │   │   │   │   ├── flutter_window.h
    │   │   │   │       │   │   │   │   ├── main.cpp
    │   │   │   │       │   │   │   │   ├── resource.h
    │   │   │   │       │   │   │   │   ├── runner.exe.manifest
    │   │   │   │       │   │   │   │   ├── utils.cpp
    │   │   │   │       │   │   │   │   ├── utils.h
    │   │   │   │       │   │   │   │   ├── win32_window.cpp
    │   │   │   │       │   │   │   │   └── win32_window.h
    │   │   │   │       │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   ├── README.md
    │   │   │   │       │   │   ├── analysis_options.yaml
    │   │   │   │       │   │   └── pubspec.yaml
    │   │   │   │       │   ├── ios/
    │   │   │   │       │   │   ├── firebase_auth/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── firebase_auth/
    │   │   │   │       │   │   │   │       ├── Resources/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   ├── Private/
    │   │   │   │       │   │   │   │       │   │   ├── FLTAuthStateChannelStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTIdTokenChannelStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTPhoneNumberVerificationStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   └── PigeonParser.h
    │   │   │   │       │   │   │   │       │   └── Public/
    │   │   │   │       │   │   │   │       │       ├── CustomPigeonHeader.h
    │   │   │   │       │   │   │   │       │       ├── FLTFirebaseAuthPlugin.h
    │   │   │   │       │   │   │   │       │       └── firebase_auth_messages.g.h
    │   │   │   │       │   │   │   │       ├── FLTAuthStateChannelStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseAuthPlugin.m
    │   │   │   │       │   │   │   │       ├── FLTIdTokenChannelStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTPhoneNumberVerificationStreamHandler.m
    │   │   │   │       │   │   │   │       ├── PigeonParser.m
    │   │   │   │       │   │   │   │       └── firebase_auth_messages.g.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   ├── firebase_auth.podspec
    │   │   │   │       │   │   └── generated_firebase_sdk_version.txt
    │   │   │   │       │   ├── lib/
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   ├── confirmation_result.dart
    │   │   │   │       │   │   │   ├── firebase_auth.dart
    │   │   │   │       │   │   │   ├── multi_factor.dart
    │   │   │   │       │   │   │   ├── recaptcha_verifier.dart
    │   │   │   │       │   │   │   ├── user.dart
    │   │   │   │       │   │   │   └── user_credential.dart
    │   │   │   │       │   │   └── firebase_auth.dart
    │   │   │   │       │   ├── macos/
    │   │   │   │       │   │   ├── firebase_auth/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── firebase_auth/
    │   │   │   │       │   │   │   │       ├── Resource/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   ├── Private/
    │   │   │   │       │   │   │   │       │   │   ├── FLTAuthStateChannelStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTIdTokenChannelStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTPhoneNumberVerificationStreamHandler.h
    │   │   │   │       │   │   │   │       │   │   └── PigeonParser.h
    │   │   │   │       │   │   │   │       │   └── Public/
    │   │   │   │       │   │   │   │       │       ├── CustomPigeonHeader.h
    │   │   │   │       │   │   │   │       │       ├── FLTFirebaseAuthPlugin.h
    │   │   │   │       │   │   │   │       │       └── firebase_auth_messages.g.h
    │   │   │   │       │   │   │   │       ├── FLTAuthStateChannelStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTFirebaseAuthPlugin.m
    │   │   │   │       │   │   │   │       ├── FLTIdTokenChannelStreamHandler.m
    │   │   │   │       │   │   │   │       ├── FLTPhoneNumberVerificationStreamHandler.m
    │   │   │   │       │   │   │   │       ├── PigeonParser.m
    │   │   │   │       │   │   │   │       └── firebase_auth_messages.g.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   └── firebase_auth.podspec
    │   │   │   │       │   ├── test/
    │   │   │   │       │   │   ├── firebase_auth_test.dart
    │   │   │   │       │   │   ├── mock.dart
    │   │   │   │       │   │   └── user_test.dart
    │   │   │   │       │   ├── windows/
    │   │   │   │       │   │   ├── include/
    │   │   │   │       │   │   │   └── firebase_auth/
    │   │   │   │       │   │   │       └── firebase_auth_plugin_c_api.h
    │   │   │   │       │   │   ├── test/
    │   │   │   │       │   │   │   └── firebase_auth_plugin_test.cpp
    │   │   │   │       │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   ├── firebase_auth_plugin.cpp
    │   │   │   │       │   │   ├── firebase_auth_plugin.h
    │   │   │   │       │   │   ├── firebase_auth_plugin_c_api.cpp
    │   │   │   │       │   │   ├── messages.g.cpp
    │   │   │   │       │   │   ├── messages.g.h
    │   │   │   │       │   │   └── plugin_version.h.in
    │   │   │   │       │   ├── CHANGELOG.md
    │   │   │   │       │   ├── LICENSE
    │   │   │   │       │   ├── README.md
    │   │   │   │       │   └── pubspec.yaml
    │   │   │   │       ├── firebase_core/
    │   │   │   │       │   ├── android/
    │   │   │   │       │   │   ├── gradle/
    │   │   │   │       │   │   │   └── wrapper/
    │   │   │   │       │   │   │       └── gradle-wrapper.properties
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   └── main/
    │   │   │   │       │   │   │       ├── java/
    │   │   │   │       │   │   │       │   └── io/
    │   │   │   │       │   │   │       │       └── flutter/
    │   │   │   │       │   │   │       │           └── plugins/
    │   │   │   │       │   │   │       │               └── firebase/
    │   │   │   │       │   │   │       │                   └── core/
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseCorePlugin.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebaseCoreRegistrar.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebasePlugin.java
    │   │   │   │       │   │   │       │                       ├── FlutterFirebasePluginRegistry.java
    │   │   │   │       │   │   │       │                       └── GeneratedAndroidFirebaseCore.java
    │   │   │   │       │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   ├── build.gradle
    │   │   │   │       │   │   ├── gradle.properties
    │   │   │   │       │   │   ├── local-config.gradle
    │   │   │   │       │   │   ├── settings.gradle
    │   │   │   │       │   │   └── user-agent.gradle
    │   │   │   │       │   ├── example/
    │   │   │   │       │   │   ├── android/
    │   │   │   │       │   │   │   ├── app/
    │   │   │   │       │   │   │   │   ├── src/
    │   │   │   │       │   │   │   │   │   ├── debug/
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   ├── main/
    │   │   │   │       │   │   │   │   │   │   ├── java/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   ├── kotlin/
    │   │   │   │       │   │   │   │   │   │   │   └── io/
    │   │   │   │       │   │   │   │   │   │   │       └── flutter/
    │   │   │   │       │   │   │   │   │   │   │           └── plugins/
    │   │   │   │       │   │   │   │   │   │   │               └── firebasecoreexample/
    │   │   │   │       │   │   │   │   │   │   │                   └── MainActivity.kt
    │   │   │   │       │   │   │   │   │   │   ├── res/
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── drawable-v21/
    │   │   │   │       │   │   │   │   │   │   │   │   └── launch_background.xml
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-hdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-mdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── mipmap-xxxhdpi/
    │   │   │   │       │   │   │   │   │   │   │   │   └── ic_launcher.png
    │   │   │   │       │   │   │   │   │   │   │   ├── values/
    │   │   │   │       │   │   │   │   │   │   │   │   └── styles.xml
    │   │   │   │       │   │   │   │   │   │   │   └── values-night/
    │   │   │   │       │   │   │   │   │   │   │       └── styles.xml
    │   │   │   │       │   │   │   │   │   │   └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   │   └── profile/
    │   │   │   │       │   │   │   │   │       └── AndroidManifest.xml
    │   │   │   │       │   │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   │   └── google-services.json
    │   │   │   │       │   │   │   ├── gradle/
    │   │   │   │       │   │   │   │   └── wrapper/
    │   │   │   │       │   │   │   │       └── gradle-wrapper.properties
    │   │   │   │       │   │   │   ├── build.gradle
    │   │   │   │       │   │   │   ├── gradle.properties
    │   │   │   │       │   │   │   └── settings.gradle
    │   │   │   │       │   │   ├── ios/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │       │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │   │   ├── Contents.json
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-1024x1024@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-20x20@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-29x29@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-40x40@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@2x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-60x60@3x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@1x.png
    │   │   │   │       │   │   │   │   │   │   ├── Icon-App-76x76@2x.png
    │   │   │   │       │   │   │   │   │   │   └── Icon-App-83.5x83.5@2x.png
    │   │   │   │       │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── LaunchImage.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@2x.png
    │   │   │   │       │   │   │   │   │       ├── LaunchImage@3x.png
    │   │   │   │       │   │   │   │   │       └── README.md
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   ├── LaunchScreen.storyboard
    │   │   │   │       │   │   │   │   │   └── Main.storyboard
    │   │   │   │       │   │   │   │   ├── AppDelegate.h
    │   │   │   │       │   │   │   │   ├── AppDelegate.m
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   └── main.m
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   └── Podfile
    │   │   │   │       │   │   ├── lib/
    │   │   │   │       │   │   │   ├── firebase_options.dart
    │   │   │   │       │   │   │   └── main.dart
    │   │   │   │       │   │   ├── macos/
    │   │   │   │       │   │   │   ├── Flutter/
    │   │   │   │       │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │       │   │   │   │   └── Flutter-Release.xcconfig
    │   │   │   │       │   │   │   ├── Runner/
    │   │   │   │       │   │   │   │   ├── Assets.xcassets/
    │   │   │   │       │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       │   │   │   │   │       ├── Contents.json
    │   │   │   │       │   │   │   │   │       ├── app_icon_1024.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_128.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_16.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_256.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_32.png
    │   │   │   │       │   │   │   │   │       ├── app_icon_512.png
    │   │   │   │       │   │   │   │   │       └── app_icon_64.png
    │   │   │   │       │   │   │   │   ├── Base.lproj/
    │   │   │   │       │   │   │   │   │   └── MainMenu.xib
    │   │   │   │       │   │   │   │   ├── Configs/
    │   │   │   │       │   │   │   │   │   ├── AppInfo.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Debug.xcconfig
    │   │   │   │       │   │   │   │   │   ├── Release.xcconfig
    │   │   │   │       │   │   │   │   │   └── Warnings.xcconfig
    │   │   │   │       │   │   │   │   ├── AppDelegate.swift
    │   │   │   │       │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │       │   │   │   │   ├── Info.plist
    │   │   │   │       │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │       │   │   │   │   └── Release.entitlements
    │   │   │   │       │   │   │   ├── Runner.xcodeproj/
    │   │   │   │       │   │   │   │   ├── project.xcworkspace/
    │   │   │   │       │   │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   │   └── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   └── xcschemes/
    │   │   │   │       │   │   │   │   │       └── Runner.xcscheme
    │   │   │   │       │   │   │   │   └── project.pbxproj
    │   │   │   │       │   │   │   ├── Runner.xcworkspace/
    │   │   │   │       │   │   │   │   ├── xcshareddata/
    │   │   │   │       │   │   │   │   │   ├── IDEWorkspaceChecks.plist
    │   │   │   │       │   │   │   │   │   └── WorkspaceSettings.xcsettings
    │   │   │   │       │   │   │   │   └── contents.xcworkspacedata
    │   │   │   │       │   │   │   └── Podfile
    │   │   │   │       │   │   ├── web/
    │   │   │   │       │   │   │   ├── icons/
    │   │   │   │       │   │   │   │   ├── Icon-192.png
    │   │   │   │       │   │   │   │   ├── Icon-512.png
    │   │   │   │       │   │   │   │   ├── Icon-maskable-192.png
    │   │   │   │       │   │   │   │   └── Icon-maskable-512.png
    │   │   │   │       │   │   │   ├── favicon.png
    │   │   │   │       │   │   │   ├── index.html
    │   │   │   │       │   │   │   └── manifest.json
    │   │   │   │       │   │   ├── windows/
    │   │   │   │       │   │   │   ├── flutter/
    │   │   │   │       │   │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   │   ├── runner/
    │   │   │   │       │   │   │   │   ├── resources/
    │   │   │   │       │   │   │   │   │   └── app_icon.ico
    │   │   │   │       │   │   │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   │   │   ├── Runner.rc
    │   │   │   │       │   │   │   │   ├── flutter_window.cpp
    │   │   │   │       │   │   │   │   ├── flutter_window.h
    │   │   │   │       │   │   │   │   ├── main.cpp
    │   │   │   │       │   │   │   │   ├── resource.h
    │   │   │   │       │   │   │   │   ├── runner.exe.manifest
    │   │   │   │       │   │   │   │   ├── utils.cpp
    │   │   │   │       │   │   │   │   ├── utils.h
    │   │   │   │       │   │   │   │   ├── win32_window.cpp
    │   │   │   │       │   │   │   │   └── win32_window.h
    │   │   │   │       │   │   │   └── CMakeLists.txt
    │   │   │   │       │   │   ├── README.md
    │   │   │   │       │   │   ├── analysis_options.yaml
    │   │   │   │       │   │   └── pubspec.yaml
    │   │   │   │       │   ├── ios/
    │   │   │   │       │   │   ├── firebase_core/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── firebase_core/
    │   │   │   │       │   │   │   │       ├── Resources/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   └── firebase_core/
    │   │   │   │       │   │   │   │       │       ├── FLTFirebaseCorePlugin.h
    │   │   │   │       │   │   │   │       │       ├── FLTFirebasePlugin.h
    │   │   │   │       │   │   │   │       │       ├── FLTFirebasePluginRegistry.h
    │   │   │   │       │   │   │   │       │       ├── dummy.h
    │   │   │   │       │   │   │   │       │       └── messages.g.h
    │   │   │   │       │   │   │   │       ├── FLTFirebaseCorePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebasePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebasePluginRegistry.m
    │   │   │   │       │   │   │   │       ├── dummy.m
    │   │   │   │       │   │   │   │       └── messages.g.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   ├── firebase_core.podspec
    │   │   │   │       │   │   └── firebase_sdk_version.rb
    │   │   │   │       │   ├── lib/
    │   │   │   │       │   │   ├── src/
    │   │   │   │       │   │   │   ├── firebase.dart
    │   │   │   │       │   │   │   ├── firebase_app.dart
    │   │   │   │       │   │   │   └── port_mapping.dart
    │   │   │   │       │   │   └── firebase_core.dart
    │   │   │   │       │   ├── macos/
    │   │   │   │       │   │   ├── firebase_core/
    │   │   │   │       │   │   │   ├── Sources/
    │   │   │   │       │   │   │   │   └── firebase_core/
    │   │   │   │       │   │   │   │       ├── Resources/
    │   │   │   │       │   │   │   │       ├── include/
    │   │   │   │       │   │   │   │       │   ├── firebase_core/
    │   │   │   │       │   │   │   │       │   │   ├── FLTFirebaseCorePlugin.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTFirebasePlugin.h
    │   │   │   │       │   │   │   │       │   │   ├── FLTFirebasePluginRegistry.h
    │   │   │   │       │   │   │   │       │   │   └── messages.g.h
    │   │   │   │       │   │   │   │       │   └── dummy.h
    │   │   │   │       │   │   │   │       ├── FLTFirebaseCorePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebasePlugin.m
    │   │   │   │       │   │   │   │       ├── FLTFirebasePluginRegistry.m
    │   │   │   │       │   │   │   │       ├── dummy.m
    │   │   │   │       │   │   │   │       └── messages.g.m
    │   │   │   │       │   │   │   └── Package.swift
    │   │   │   │       │   │   └── firebase_core.podspec
    │   │   │   │       │   ├── test/
    │   │   │   │       │   │   └── firebase_core_test.dart
    │   │   │   │       │   ├── windows/
    │   │   │   │       │   │   ├── include/
    │   │   │   │       │   │   │   └── firebase_core/
    │   │   │   │       │   │   │       └── firebase_core_plugin_c_api.h
    │   │   │   │       │   │   ├── CMakeLists.txt
    │   │   │   │       │   │   ├── firebase_core_plugin.cpp
    │   │   │   │       │   │   ├── firebase_core_plugin.h
    │   │   │   │       │   │   ├── firebase_core_plugin_c_api.cpp
    │   │   │   │       │   │   ├── messages.g.cpp
    │   │   │   │       │   │   ├── messages.g.h
    │   │   │   │       │   │   └── plugin_version.h.in
    │   │   │   │       │   ├── CHANGELOG.md
    │   │   │   │       │   ├── LICENSE
    │   │   │   │       │   ├── README.md
    │   │   │   │       │   └── pubspec.yaml
    │   │   │   │       └── permission_handler_windows/
    │   │   │   │           ├── example/
    │   │   │   │           │   ├── lib/
    │   │   │   │           │   │   └── main.dart
    │   │   │   │           │   ├── res/
    │   │   │   │           │   │   └── images/
    │   │   │   │           │   │       ├── baseflow_logo_def_light-02.png
    │   │   │   │           │   │       ├── poweredByBaseflowLogoLight.png
    │   │   │   │           │   │       ├── poweredByBaseflowLogoLight@2x.png
    │   │   │   │           │   │       └── poweredByBaseflowLogoLight@3x.png
    │   │   │   │           │   ├── windows/
    │   │   │   │           │   │   ├── flutter/
    │   │   │   │           │   │   │   ├── CMakeLists.txt
    │   │   │   │           │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   │           │   │   │   ├── generated_plugin_registrant.h
    │   │   │   │           │   │   │   └── generated_plugins.cmake
    │   │   │   │           │   │   ├── runner/
    │   │   │   │           │   │   │   ├── resources/
    │   │   │   │           │   │   │   │   └── app_icon.ico
    │   │   │   │           │   │   │   ├── CMakeLists.txt
    │   │   │   │           │   │   │   ├── Runner.rc
    │   │   │   │           │   │   │   ├── flutter_window.cpp
    │   │   │   │           │   │   │   ├── flutter_window.h
    │   │   │   │           │   │   │   ├── main.cpp
    │   │   │   │           │   │   │   ├── resource.h
    │   │   │   │           │   │   │   ├── runner.exe.manifest
    │   │   │   │           │   │   │   ├── utils.cpp
    │   │   │   │           │   │   │   ├── utils.h
    │   │   │   │           │   │   │   ├── win32_window.cpp
    │   │   │   │           │   │   │   └── win32_window.h
    │   │   │   │           │   │   └── CMakeLists.txt
    │   │   │   │           │   ├── README.md
    │   │   │   │           │   └── pubspec.yaml
    │   │   │   │           ├── windows/
    │   │   │   │           │   ├── include/
    │   │   │   │           │   │   └── permission_handler_windows/
    │   │   │   │           │   │       └── permission_handler_windows_plugin.h
    │   │   │   │           │   ├── CMakeLists.txt
    │   │   │   │           │   ├── permission_constants.h
    │   │   │   │           │   └── permission_handler_windows_plugin.cpp
    │   │   │   │           ├── AUTHORS
    │   │   │   │           ├── CHANGELOG.md
    │   │   │   │           ├── LICENSE
    │   │   │   │           ├── README.md
    │   │   │   │           └── pubspec.yaml
    │   │   │   ├── CMakeLists.txt
    │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   ├── generated_plugin_registrant.h
    │   │   │   └── generated_plugins.cmake
    │   │   ├── runner/
    │   │   │   ├── resources/
    │   │   │   │   └── app_icon.ico
    │   │   │   ├── CMakeLists.txt
    │   │   │   ├── Runner.rc
    │   │   │   ├── flutter_window.cpp
    │   │   │   ├── flutter_window.h
    │   │   │   ├── main.cpp
    │   │   │   ├── resource.h
    │   │   │   ├── runner.exe.manifest
    │   │   │   ├── utils.cpp
    │   │   │   ├── utils.h
    │   │   │   ├── win32_window.cpp
    │   │   │   └── win32_window.h
    │   │   ├── .gitignore
    │   │   └── CMakeLists.txt
    │   ├── .flutter-plugins
    │   ├── .flutter-plugins-dependencies
    │   ├── .gitignore
    │   ├── .metadata
    │   ├── README.md
    │   ├── analysis_options.yaml
    │   ├── firebase.json
    │   ├── noisetime.iml
    │   ├── pubspec.lock
    │   └── pubspec.yaml
    └── README.md
```

## 파일 내용

### .idx/airules.md

**크기**: 4751 bytes | **라인 수**: 187 | **타입**: text

```
# Gemini AI Rules for Firebase Studio Nix Projects

## 1. Persona & Expertise

You are an expert in configuring development environments within Firebase Studio. You are proficient in using the `dev.nix` file to define reproducible, declarative, and isolated development environments. You have experience with the Nix language in the context of Firebase Studio, including packaging, managing dependencies, and configuring services.

## 2. Project Context

This project is a Nix-based environment for Firebase Studio, defined by a `.idx/dev.nix` file. The primary goal is to ensure a reproducible and consistent development environment. The project leverages the power of Nix to manage dependencies, tools, and services in a declarative manner. **Note:** This is not a Nix Flake-based environment.

## 3. `dev.nix` Configuration

The `.idx/dev.nix` file is the single source of truth for the development environment. Here are some of the most common configuration options:

### `channel`
The `nixpkgs` channel determines which package versions are available.

```nix
{ pkgs, ... }: {
  channel = "stable-24.05"; # or "unstable"
}
```

### `packages`
A list of packages to install from the specified channel. You can search for packages on the [NixOS package search](https://search.nixos.org/packages).

```nix
{ pkgs, ... }: {
  packages = [
    pkgs.nodejs_20
    pkgs.go
  ];
}
```

### `env`
A set of environment variables to define within the workspace.

```nix
{ pkgs, ... }: {
  env = {
    API_KEY = "your-secret-key";
  };
}
```

### `idx.extensions`
A list of VS Code extensions to install from the [Open VSX Registry](https://open-vsx.org/).

```nix
{ pkgs, ... }: {
  idx = {
    extensions = [
      "vscodevim.vim"
      "golang.go"
    ];
  };
}
```

### `idx.workspace`
Workspace lifecycle hooks.

- **`onCreate`:** Runs when a workspace is first created.
- **`onStart`:** Runs every time the workspace is (re)started.

```nix
{ pkgs, ... }: {
  idx = {
    workspace = {
      onCreate = {
        npm-install = "npm install";
      };
      onStart = {
        start-server = "npm run dev";
      };
    };
  };
}
```

### `idx.previews`
Configure a web preview for your application. The `$PORT` variable is dynamically assigned.

```nix
{ pkgs, ... }: {
  idx = {
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["npm" "run" "dev" "--" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

## 4. Example Setups for Common Frameworks

Here are some examples of how to configure your `dev.nix` for common languages and frameworks.

### Node.js Web Server
This example sets up a Node.js environment, installs dependencies, and runs a development server with a web preview.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.nodejs_20 ];
  idx = {
    extensions = [ "dbaeumer.vscode-eslint" ];
    workspace = {
      onCreate = {
        npm-install = "npm install";
      };
      onStart = {
        dev-server = "npm run dev";
      };
    };
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["npm" "run" "dev" "--" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

### Python with Flask
This example sets up a Python environment for a Flask web server. Remember to create a `requirements.txt` file with `Flask` in it.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.python3 pkgs.pip ];
  idx = {
    extensions = [ "ms-python.python" ];
    workspace = {
      onCreate = {
        pip-install = "pip install -r requirements.txt";
      };
    };
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["flask" "run" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

### Go CLI
This example sets up a Go environment for building a command-line interface.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.go ];
  idx = {
    extensions = [ "golang.go" ];
    workspace = {
      onCreate = {
        go-mod = "go mod tidy";
      };
      onStart = {
        run-app = "go run .";
      };
    };
  };
}
```

## 5. Interaction Guidelines

- Assume the user is familiar with general software development concepts but may be new to Nix and Firebase Studio.
- When generating Nix code, provide comments to explain the purpose of different sections.
- Explain the benefits of using `dev.nix` for reproducibility and dependency management.
- If a request is ambiguous, ask for clarification on the desired tools, libraries, and versions to be included in the environment.
- When suggesting changes to `dev.nix`, explain the impact of the changes on the development environment and remind the user to reload the environment.

```

### noisetime/.dart_tool/dartpad/web_plugin_registrant.dart

**크기**: 898 bytes | **라인 수**: 25 | **타입**: text

```
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:cloud_firestore_web/cloud_firestore_web.dart';
import 'package:firebase_auth_web/firebase_auth_web.dart';
import 'package:firebase_core_web/firebase_core_web.dart';
import 'package:google_sign_in_web/google_sign_in_web.dart';
import 'package:permission_handler_html/permission_handler_html.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  FirebaseFirestoreWeb.registerWith(registrar);
  FirebaseAuthWeb.registerWith(registrar);
  FirebaseCoreWeb.registerWith(registrar);
  GoogleSignInPlugin.registerWith(registrar);
  WebPermissionHandler.registerWith(registrar);
  registrar.registerMessageHandler();
}

```

### noisetime/.dart_tool/extension_discovery/README.md

**크기**: 1051 bytes | **라인 수**: 32 | **타입**: text

```
Extension Discovery Cache
=========================

This folder is used by `package:extension_discovery` to cache lists of
packages that contains extensions for other packages.

DO NOT USE THIS FOLDER
----------------------

 * Do not read (or rely) the contents of this folder.
 * Do write to this folder.

If you're interested in the lists of extensions stored in this folder use the
API offered by package `extension_discovery` to get this information.

If this package doesn't work for your use-case, then don't try to read the
contents of this folder. It may change, and will not remain stable.

Use package `extension_discovery`
---------------------------------

If you want to access information from this folder.

Feel free to delete this folder
-------------------------------

Files in this folder act as a cache, and the cache is discarded if the files
are older than the modification time of `.dart_tool/package_config.json`.

Hence, it should never be necessary to clear this cache manually, if you find a
need to do please file a bug.

```

### noisetime/.dart_tool/extension_discovery/vs_code.json

**크기**: 85 bytes | **라인 수**: 1 | **타입**: text

```
{"version":2,"entries":[{"package":"noisetime","rootUri":"../","packageUri":"lib/"}]}
```

### noisetime/.dart_tool/package_config.json

**크기**: 12009 bytes | **라인 수**: 372 | **타입**: text

```
{
  "configVersion": 2,
  "packages": [
    {
      "name": "_flutterfire_internals",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/_flutterfire_internals-1.3.62",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "async",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/async-2.11.0",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "audio_streamer",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/audio_streamer-4.2.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "boolean_selector",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/boolean_selector-2.1.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "characters",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/characters-1.3.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "clock",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/clock-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "cloud_firestore",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/cloud_firestore-6.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "cloud_firestore_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/cloud_firestore_platform_interface-7.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "cloud_firestore_web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/cloud_firestore_web-5.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "collection",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/collection-1.18.0",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "cupertino_icons",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/cupertino_icons-1.0.8",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "fake_async",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/fake_async-1.3.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "firebase_auth",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_auth-6.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "firebase_auth_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_auth_platform_interface-8.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "firebase_auth_web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_auth_web-6.0.3",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "firebase_core",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_core-4.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "firebase_core_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_core_platform_interface-6.0.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "firebase_core_web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/firebase_core_web-3.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "flutter",
      "rootUri": "file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/packages/flutter",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "flutter_lints",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/flutter_lints-3.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "flutter_test",
      "rootUri": "file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/packages/flutter_test",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "flutter_web_plugins",
      "rootUri": "file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/packages/flutter_web_plugins",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "google_identity_services_web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_identity_services_web-0.3.3+1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "google_sign_in",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_sign_in-6.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "google_sign_in_android",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_sign_in_android-6.1.31",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "google_sign_in_ios",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_sign_in_ios-5.9.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "google_sign_in_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_sign_in_platform_interface-2.5.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "google_sign_in_web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/google_sign_in_web-0.12.4+4",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "http",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/http-1.5.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "http_parser",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/http_parser-4.0.2",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "leak_tracker",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/leak_tracker-10.0.4",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_flutter_testing",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/leak_tracker_flutter_testing-3.0.3",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_testing",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/leak_tracker_testing-3.0.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "lints",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/lints-3.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "matcher",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/matcher-0.12.16+1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "material_color_utilities",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/material_color_utilities-0.8.0",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "meta",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/meta-1.12.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "nested",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/nested-1.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "noise_meter",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/noise_meter-5.0.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "path",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/path-1.9.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "permission_handler",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler-11.3.1",
      "packageUri": "lib/",
      "languageVersion": "2.15"
    },
    {
      "name": "permission_handler_android",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler_android-12.0.13",
      "packageUri": "lib/",
      "languageVersion": "2.15"
    },
    {
      "name": "permission_handler_apple",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler_apple-9.4.7",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "permission_handler_html",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler_html-0.1.3+5",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "permission_handler_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler_platform_interface-4.2.3",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "permission_handler_windows",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/permission_handler_windows-0.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "plugin_platform_interface",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/plugin_platform_interface-2.1.8",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "provider",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/provider-6.1.5+1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "sky_engine",
      "rootUri": "file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/pkg/sky_engine",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "source_span",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/source_span-1.10.0",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "stack_trace",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/stack_trace-1.11.1",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "stream_channel",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/stream_channel-2.1.2",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "string_scanner",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/string_scanner-1.2.0",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "term_glyph",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/term_glyph-1.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "test_api",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/test_api-0.7.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "typed_data",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/typed_data-1.3.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "vector_math",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/vector_math-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "vm_service",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/vm_service-14.2.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "web",
      "rootUri": "file:///home/user/.pub-cache/hosted/pub.dev/web-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "noisetime",
      "rootUri": "../",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    }
  ],
  "generated": "2025-10-03T07:42:01.254471Z",
  "generator": "pub",
  "generatorVersion": "3.4.0",
  "flutterRoot": "file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links",
  "flutterVersion": "3.22.0",
  "pubCache": "file:///home/user/.pub-cache"
}

```

### noisetime/.idea/libraries/Dart_SDK.xml

**크기**: 1634 bytes | **라인 수**: 19 | **타입**: text

```
<component name="libraryTable">
  <library name="Dart SDK">
    <CLASSES>
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/async" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/collection" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/convert" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/core" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/developer" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/html" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/io" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/isolate" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/math" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/mirrors" />
      <root url="file:///nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links/bin/cache/dart-sdk/lib/typed_data" />
    </CLASSES>
    <JAVADOC />
    <SOURCES />
  </library>
</component>
```

### noisetime/.idea/libraries/KotlinJavaRuntime.xml

**크기**: 599 bytes | **라인 수**: 16 | **타입**: text

```
<component name="libraryTable">
  <library name="KotlinJavaRuntime">
    <CLASSES>
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-stdlib.jar!/" />
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-reflect.jar!/" />
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-test.jar!/" />
    </CLASSES>
    <JAVADOC />
    <SOURCES>
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-stdlib-sources.jar!/" />
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-reflect-sources.jar!/" />
      <root url="jar://$KOTLIN_BUNDLED$/lib/kotlin-test-sources.jar!/" />
    </SOURCES>
  </library>
</component>

```

### noisetime/.idea/runConfigurations/main_dart.xml

**크기**: 271 bytes | **라인 수**: 6 | **타입**: text

```
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="main.dart" type="FlutterRunConfigurationType" factoryName="Flutter">
    <option name="filePath" value="$PROJECT_DIR$/lib/main.dart" />
    <method />
  </configuration>
</component>
```

### noisetime/.idea/modules.xml

**크기**: 392 bytes | **라인 수**: 10 | **타입**: text

```
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/noisetime.iml" filepath="$PROJECT_DIR$/noisetime.iml" />
      <module fileurl="file://$PROJECT_DIR$/android/noisetime_android.iml" filepath="$PROJECT_DIR$/android/noisetime_android.iml" />
    </modules>
  </component>
</project>

```

### noisetime/.idea/workspace.xml

**크기**: 1517 bytes | **라인 수**: 37 | **타입**: text

```
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="FileEditorManager">
    <leaf>
      <file leaf-file-name="main.dart" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/lib/main.dart">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="0">
              <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="ToolWindowManager">
    <editor active="true" />
    <layout>
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
    </layout>
  </component>
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
    </navigator>
    <panes>
      <pane id="ProjectPane">
        <option name="show-excluded-files" value="false" />
      </pane>
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="dart.analysis.tool.window.force.activate" value="true" />
    <property name="show.migrate.to.gradle.popup" value="false" />
  </component>
</project>

```

### noisetime/android/app/src/debug/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java

**크기**: 2145 bytes | **라인 수**: 50 | **타입**: text

```
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new plugins.cachet.audio_streamer.AudioStreamerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin audio_streamer, plugins.cachet.audio_streamer.AudioStreamerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.baseflow.permissionhandler.PermissionHandlerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin permission_handler_android, com.baseflow.permissionhandler.PermissionHandlerPlugin", e);
    }
  }
}

```

### noisetime/android/app/src/main/kotlin/com/example/noisetime/MainActivity.kt

**크기**: 122 bytes | **라인 수**: 6 | **타입**: text

```
package com.example.noisetime

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()

```

### noisetime/android/app/src/main/res/drawable/launch_background.xml

**크기**: 434 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/android/app/src/main/res/drawable-v21/launch_background.xml

**크기**: 438 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/android/app/src/main/res/values/styles.xml

**크기**: 996 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/android/app/src/main/res/values-night/styles.xml

**크기**: 995 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/android/app/src/main/AndroidManifest.xml

**크기**: 2267 bytes | **라인 수**: 47 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="noisetime"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
</manifest>

```

### noisetime/android/app/src/profile/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/android/app/google-services.json

**크기**: 692 bytes | **라인 수**: 29 | **타입**: text

```
{
  "project_info": {
    "project_number": "130019319095",
    "project_id": "noisetime-youth",
    "storage_bucket": "noisetime-youth.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:130019319095:android:def30a9ce1dc05db1b0eb2",
        "android_client_info": {
          "package_name": "com.akzmft8282.project.noisetime"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyAGPUbl4Ob6Argz-0jfFlRHZDXDBCtMhgI"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}
```

### noisetime/android/gradlew.bat

**크기**: 2404 bytes | **라인 수**: 91 | **타입**: text

```
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

### noisetime/ios/Flutter/flutter_export_environment.sh

**크기**: 580 bytes | **라인 수**: 14 | **타입**: text

```
#!/bin/sh
# This is a generated file; do not edit or check into version control.
export "FLUTTER_ROOT=/nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links"
export "FLUTTER_APPLICATION_PATH=/home/user/noisetime/noisetime"
export "COCOAPODS_PARALLEL_CODE_SIGN=true"
export "FLUTTER_TARGET=lib/main.dart"
export "FLUTTER_BUILD_DIR=build"
export "FLUTTER_BUILD_NAME=1.0.0"
export "FLUTTER_BUILD_NUMBER=1"
export "DART_OBFUSCATION=false"
export "TRACK_WIDGET_CREATION=true"
export "TREE_SHAKE_ICONS=false"
export "PACKAGE_CONFIG=.dart_tool/package_config.json"

```

### noisetime/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 2519 bytes | **라인 수**: 123 | **타입**: text

```
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json

**크기**: 391 bytes | **라인 수**: 24 | **타입**: text

```
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md

**크기**: 336 bytes | **라인 수**: 5 | **타입**: text

```
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
```

### noisetime/ios/Runner/AppDelegate.swift

**크기**: 404 bytes | **라인 수**: 14 | **타입**: text

```
import Flutter
import UIKit

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

```

### noisetime/ios/Runner/GeneratedPluginRegistrant.h

**크기**: 378 bytes | **라인 수**: 20 | **타입**: text

```
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GeneratedPluginRegistrant_h
#define GeneratedPluginRegistrant_h

#import <Flutter/Flutter.h>

NS_ASSUME_NONNULL_BEGIN

@interface GeneratedPluginRegistrant : NSObject
+ (void)registerWithRegistry:(NSObject<FlutterPluginRegistry>*)registry;
@end

NS_ASSUME_NONNULL_END
#endif /* GeneratedPluginRegistrant_h */

```

### noisetime/ios/Runner/GeneratedPluginRegistrant.m

**크기**: 1810 bytes | **라인 수**: 57 | **타입**: text

```
//
//  Generated file. Do not edit.
//

// clang-format off

#import "GeneratedPluginRegistrant.h"

#if __has_include(<audio_streamer/SwiftAudioStreamerPlugin.h>)
#import <audio_streamer/SwiftAudioStreamerPlugin.h>
#else
@import audio_streamer;
#endif

#if __has_include(<cloud_firestore/FLTFirebaseFirestorePlugin.h>)
#import <cloud_firestore/FLTFirebaseFirestorePlugin.h>
#else
@import cloud_firestore;
#endif

#if __has_include(<firebase_auth/FLTFirebaseAuthPlugin.h>)
#import <firebase_auth/FLTFirebaseAuthPlugin.h>
#else
@import firebase_auth;
#endif

#if __has_include(<firebase_core/FLTFirebaseCorePlugin.h>)
#import <firebase_core/FLTFirebaseCorePlugin.h>
#else
@import firebase_core;
#endif

#if __has_include(<google_sign_in_ios/FLTGoogleSignInPlugin.h>)
#import <google_sign_in_ios/FLTGoogleSignInPlugin.h>
#else
@import google_sign_in_ios;
#endif

#if __has_include(<permission_handler_apple/PermissionHandlerPlugin.h>)
#import <permission_handler_apple/PermissionHandlerPlugin.h>
#else
@import permission_handler_apple;
#endif

@implementation GeneratedPluginRegistrant

+ (void)registerWithRegistry:(NSObject<FlutterPluginRegistry>*)registry {
  [SwiftAudioStreamerPlugin registerWithRegistrar:[registry registrarForPlugin:@"SwiftAudioStreamerPlugin"]];
  [FLTFirebaseFirestorePlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseFirestorePlugin"]];
  [FLTFirebaseAuthPlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseAuthPlugin"]];
  [FLTFirebaseCorePlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseCorePlugin"]];
  [FLTGoogleSignInPlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTGoogleSignInPlugin"]];
  [PermissionHandlerPlugin registerWithRegistrar:[registry registrarForPlugin:@"PermissionHandlerPlugin"]];
}

@end

```

### noisetime/ios/Runner/Runner-Bridging-Header.h

**크기**: 38 bytes | **라인 수**: 2 | **타입**: text

```
#import "GeneratedPluginRegistrant.h"

```

### noisetime/ios/RunnerTests/RunnerTests.swift

**크기**: 285 bytes | **라인 수**: 13 | **타입**: text

```
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

```

### noisetime/lib/auth_screen.dart

**크기**: 2375 bytes | **라인 수**: 75 | **타입**: text

```
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';

class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  Future<void> _signUp() async {
    try {
      await FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );
    } catch (e) {
      debugPrint("SignUp Error: $e");
    }
  }

  Future<void> _signIn() async {
    try {
      await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );
    } catch (e) {
      debugPrint("SignIn Error: $e");
    }
  }

  Future<void> _signInWithGoogle() async {
    try {
      final googleUser = await GoogleSignIn().signIn();
      final googleAuth = await googleUser?.authentication;
      if (googleAuth == null) return;

      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );
      await FirebaseAuth.instance.signInWithCredential(credential);
    } catch (e) {
      debugPrint("Google SignIn Error: $e");
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("NoiseTime 로그인")),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(controller: _emailController, decoration: const InputDecoration(labelText: "이메일")),
            TextField(controller: _passwordController, decoration: const InputDecoration(labelText: "비밀번호"), obscureText: true),
            const SizedBox(height: 16),
            ElevatedButton(onPressed: _signUp, child: const Text("회원가입")),
            ElevatedButton(onPressed: _signIn, child: const Text("로그인")),
            const Divider(),
            ElevatedButton(onPressed: _signInWithGoogle, child: const Text("Google 로그인")),
          ],
        ),
      ),
    );
  }
}

```

### noisetime/lib/firebase_options.dart

**크기**: 2399 bytes | **라인 수**: 69 | **타입**: text

```
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAGPUbl4Ob6Argz-0jfFlRHZDXDBCtMhgI',
    appId: '1:130019319095:android:def30a9ce1dc05db1b0eb2',
    messagingSenderId: '130019319095',
    projectId: 'noisetime-youth',
    storageBucket: 'noisetime-youth.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCLFY2bFd1Cep99nDJiEMvpB5KAq6SqqLM',
    appId: '1:130019319095:ios:c5fdbba9e7dce87b1b0eb2',
    messagingSenderId: '130019319095',
    projectId: 'noisetime-youth',
    storageBucket: 'noisetime-youth.firebasestorage.app',
    iosBundleId: 'com.akzmft8282.project.noisetime',
  );
}

```

### noisetime/lib/main.dart

**크기**: 1079 bytes | **라인 수**: 36 | **타입**: text

```
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'firebase_options.dart';
import 'auth_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'NoiseTime',
      theme: ThemeData(primarySwatch: Colors.blue),
      home: StreamBuilder<User?>(
        stream: FirebaseAuth.instance.authStateChanges(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasData) {
            return const Scaffold(body: Center(child: Text("로그인 성공 ✅")));
          }
          return const AuthScreen();
        },
      ),
    );
  }
}

```

### noisetime/lib/noise_screen.dart

**크기**: 1091 bytes | **라인 수**: 47 | **타입**: text

```
import 'package:flutter/material.dart';
import 'noise_service.dart';
import 'firestore_service.dart';

class NoiseScreen extends StatefulWidget {
  const NoiseScreen({super.key});

  @override
  State<NoiseScreen> createState() => _NoiseScreenState();
}

class _NoiseScreenState extends State<NoiseScreen> {
  final _noiseService = NoiseService();
  double? _currentDb;

  @override
  void initState() {
    super.initState();
    _noiseService.startListening((dbValue) {
      setState(() {
        _currentDb = dbValue;
      });
      // 예시: Firestore에 저장
      saveNoiseSample(dbValue, "anon-uuid", "group-123");
    });
  }

  @override
  void dispose() {
    _noiseService.stopListening();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("소음 측정기")),
      body: Center(
        child: Text(
          _currentDb != null ? "현재 소음: ${_currentDb!.toStringAsFixed(1)} dB" : "측정 중...",
          style: const TextStyle(fontSize: 24),
        ),
      ),
    );
  }
}

```

### noisetime/lib/noise_service.dart

**크기**: 508 bytes | **라인 수**: 21 | **타입**: text

```
import 'package:noise_meter/noise_meter.dart';
import 'dart:async';

class NoiseService {
  final NoiseMeter _noiseMeter = NoiseMeter();
  StreamSubscription<NoiseReading>? _subscription;

  void startListening(Function(double dbValue) onData) {
    _subscription = _noiseMeter.noiseStream.listen((NoiseReading reading) {
      // 평균 dB 값 사용
      double db = reading.meanDecibel;
      onData(db);
    });
  }

  void stopListening() {
    _subscription?.cancel();
    _subscription = null;
  }
}

```

### noisetime/linux/flutter/CMakeLists.txt

**크기**: 2815 bytes | **라인 수**: 89 | **타입**: text

```
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)

```

### noisetime/linux/flutter/generated_plugin_registrant.h

**크기**: 303 bytes | **라인 수**: 16 | **타입**: text

```
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

```

### noisetime/linux/CMakeLists.txt

**크기**: 5431 bytes | **라인 수**: 146 | **타입**: text

```
# Project-level configuration.
cmake_minimum_required(VERSION 3.10)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "noisetime")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.example.noisetime")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Define the application target. To change its name, change BINARY_NAME above,
# not the value here, or `flutter run` will no longer work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

```

### noisetime/linux/my_application.h

**크기**: 388 bytes | **라인 수**: 19 | **타입**: text

```
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_

```

### noisetime/macos/Flutter/ephemeral/flutter_export_environment.sh

**크기**: 542 bytes | **라인 수**: 13 | **타입**: text

```
#!/bin/sh
# This is a generated file; do not edit or check into version control.
export "FLUTTER_ROOT=/nix/store/ksyk5yalwyxsyd964w32z77zv7cxl8bj-flutter-wrapped-3.22.0-sdk-links"
export "FLUTTER_APPLICATION_PATH=/home/user/noisetime/noisetime"
export "COCOAPODS_PARALLEL_CODE_SIGN=true"
export "FLUTTER_BUILD_DIR=build"
export "FLUTTER_BUILD_NAME=1.0.0"
export "FLUTTER_BUILD_NUMBER=1"
export "DART_OBFUSCATION=false"
export "TRACK_WIDGET_CREATION=true"
export "TREE_SHAKE_ICONS=false"
export "PACKAGE_CONFIG=.dart_tool/package_config.json"

```

### noisetime/macos/Flutter/GeneratedPluginRegistrant.swift

**크기**: 628 bytes | **라인 수**: 19 | **타입**: text

```
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import cloud_firestore
import firebase_auth
import firebase_core
import google_sign_in_ios

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  FLTFirebaseFirestorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseFirestorePlugin"))
  FLTFirebaseAuthPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseAuthPlugin"))
  FLTFirebaseCorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCorePlugin"))
  FLTGoogleSignInPlugin.register(with: registry.registrar(forPlugin: "FLTGoogleSignInPlugin"))
}

```

### noisetime/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 1291 bytes | **라인 수**: 69 | **타입**: text

```
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/macos/Runner/AppDelegate.swift

**크기**: 214 bytes | **라인 수**: 10 | **타입**: text

```
import Cocoa
import FlutterMacOS

@NSApplicationMain
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }
}

```

### noisetime/macos/Runner/MainFlutterWindow.swift

**크기**: 388 bytes | **라인 수**: 16 | **타입**: text

```
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

```

### noisetime/macos/RunnerTests/RunnerTests.swift

**크기**: 290 bytes | **라인 수**: 13 | **타입**: text

```
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

```

### noisetime/test/widget_test.dart

**크기**: 1060 bytes | **라인 수**: 31 | **타입**: text

```
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:noisetime/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```

### noisetime/web/index.html

**크기**: 1222 bytes | **라인 수**: 39 | **타입**: text

```
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="noisetime">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>noisetime</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

```

### noisetime/web/manifest.json

**크기**: 914 bytes | **라인 수**: 36 | **타입**: text

```
{
    "name": "noisetime",
    "short_name": "noisetime",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/DocumentSnapshotsStreamHandler.java

**크기**: 3034 bytes | **라인 수**: 80 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import static io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin.DEFAULT_ERROR_CODE;

import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.ListenSource;
import com.google.firebase.firestore.ListenerRegistration;
import com.google.firebase.firestore.MetadataChanges;
import com.google.firebase.firestore.SnapshotListenOptions;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import io.flutter.plugins.firebase.firestore.utils.ExceptionConverter;
import io.flutter.plugins.firebase.firestore.utils.PigeonParser;
import java.util.Map;

public class DocumentSnapshotsStreamHandler implements StreamHandler {

  ListenerRegistration listenerRegistration;
  FirebaseFirestore firestore;
  DocumentReference documentReference;
  MetadataChanges metadataChanges;

  DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior;
  ListenSource source;

  public DocumentSnapshotsStreamHandler(
      FirebaseFirestore firestore,
      DocumentReference documentReference,
      Boolean includeMetadataChanges,
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior,
      ListenSource source) {
    this.firestore = firestore;
    this.documentReference = documentReference;
    this.metadataChanges =
        includeMetadataChanges ? MetadataChanges.INCLUDE : MetadataChanges.EXCLUDE;
    this.serverTimestampBehavior = serverTimestampBehavior;
    this.source = source;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    SnapshotListenOptions.Builder optionsBuilder = new SnapshotListenOptions.Builder();
    optionsBuilder.setMetadataChanges(metadataChanges);
    optionsBuilder.setSource(source);

    listenerRegistration =
        documentReference.addSnapshotListener(
            optionsBuilder.build(),
            (documentSnapshot, exception) -> {
              if (exception != null) {
                Map<String, String> exceptionDetails = ExceptionConverter.createDetails(exception);
                events.error(DEFAULT_ERROR_CODE, exception.getMessage(), exceptionDetails);
                events.endOfStream();

                onCancel(null);
              } else {
                events.success(
                    PigeonParser.toPigeonDocumentSnapshot(documentSnapshot, serverTimestampBehavior)
                        .toList());
              }
            });
  }

  @Override
  public void onCancel(Object arguments) {
    if (listenerRegistration != null) {
      listenerRegistration.remove();
      listenerRegistration = null;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/LoadBundleStreamHandler.java

**크기**: 1619 bytes | **라인 수**: 50 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import static io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin.DEFAULT_ERROR_CODE;

import androidx.annotation.NonNull;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.LoadBundleTask;
import io.flutter.plugin.common.EventChannel;
import io.flutter.plugins.firebase.firestore.utils.ExceptionConverter;
import java.util.Map;

public class LoadBundleStreamHandler implements EventChannel.StreamHandler {

  public LoadBundleStreamHandler(FirebaseFirestore firestore, @NonNull byte[] bundle) {
    this.firestore = firestore;
    this.bundle = bundle;
  }

  private EventChannel.EventSink eventSink;

  private final FirebaseFirestore firestore;
  private final @NonNull byte[] bundle;

  @Override
  public void onListen(Object arguments, EventChannel.EventSink events) {
    eventSink = events;
    LoadBundleTask task = firestore.loadBundle(bundle);

    task.addOnProgressListener(events::success);

    task.addOnFailureListener(
        exception -> {
          Map<String, String> exceptionDetails = ExceptionConverter.createDetails(exception);
          events.error(DEFAULT_ERROR_CODE, exception.getMessage(), exceptionDetails);
          onCancel(null);
        });
  }

  @Override
  public void onCancel(Object arguments) {
    eventSink.endOfStream();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/OnTransactionResultListener.java

**크기**: 693 bytes | **라인 수**: 18 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import io.flutter.plugins.firebase.firestore.GeneratedAndroidFirebaseFirestore;
import java.util.List;

/** callback when a transaction result has been computed. */
public interface OnTransactionResultListener {
  void receiveTransactionResponse(
      GeneratedAndroidFirebaseFirestore.PigeonTransactionResult resultType,
      List<GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand> commands);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/QuerySnapshotsStreamHandler.java

**크기**: 3899 bytes | **라인 수**: 98 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import static io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin.DEFAULT_ERROR_CODE;

import com.google.firebase.firestore.DocumentChange;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.ListenSource;
import com.google.firebase.firestore.ListenerRegistration;
import com.google.firebase.firestore.MetadataChanges;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.SnapshotListenOptions;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import io.flutter.plugins.firebase.firestore.utils.ExceptionConverter;
import io.flutter.plugins.firebase.firestore.utils.PigeonParser;
import java.util.ArrayList;
import java.util.Map;

public class QuerySnapshotsStreamHandler implements StreamHandler {

  ListenerRegistration listenerRegistration;

  Query query;
  MetadataChanges metadataChanges;
  DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior;

  ListenSource source;

  public QuerySnapshotsStreamHandler(
      Query query,
      Boolean includeMetadataChanges,
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior,
      ListenSource source) {
    this.query = query;
    this.metadataChanges =
        includeMetadataChanges ? MetadataChanges.INCLUDE : MetadataChanges.EXCLUDE;
    this.serverTimestampBehavior = serverTimestampBehavior;
    this.source = source;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    SnapshotListenOptions.Builder optionsBuilder = new SnapshotListenOptions.Builder();
    optionsBuilder.setMetadataChanges(metadataChanges);
    optionsBuilder.setSource(source);

    listenerRegistration =
        query.addSnapshotListener(
            optionsBuilder.build(),
            (querySnapshot, exception) -> {
              if (exception != null) {
                Map<String, String> exceptionDetails = ExceptionConverter.createDetails(exception);
                events.error(DEFAULT_ERROR_CODE, exception.getMessage(), exceptionDetails);
                events.endOfStream();

                onCancel(null);
              } else {
                ArrayList<Object> toListResult = new ArrayList<Object>(3);
                ArrayList<Object> documents =
                    new ArrayList<Object>(querySnapshot.getDocuments().size());
                ArrayList<Object> documentChanges =
                    new ArrayList<Object>(querySnapshot.getDocumentChanges().size());
                for (DocumentSnapshot documentSnapshot : querySnapshot.getDocuments()) {
                  documents.add(
                      PigeonParser.toPigeonDocumentSnapshot(
                              documentSnapshot, serverTimestampBehavior)
                          .toList());
                }
                for (DocumentChange documentChange : querySnapshot.getDocumentChanges()) {
                  documentChanges.add(
                      PigeonParser.toPigeonDocumentChange(documentChange, serverTimestampBehavior)
                          .toList());
                }
                toListResult.add(documents);
                toListResult.add(documentChanges);
                toListResult.add(
                    PigeonParser.toPigeonSnapshotMetadata(querySnapshot.getMetadata()).toList());

                events.success(toListResult);
              }
            });
  }

  @Override
  public void onCancel(Object arguments) {
    if (listenerRegistration != null) {
      listenerRegistration.remove();
      listenerRegistration = null;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/SnapshotsInSyncStreamHandler.java

**크기**: 1186 bytes | **라인 수**: 38 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.ListenerRegistration;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;

public class SnapshotsInSyncStreamHandler implements StreamHandler {

  ListenerRegistration listenerRegistration;
  FirebaseFirestore firestore;

  public SnapshotsInSyncStreamHandler(FirebaseFirestore firestore) {
    this.firestore = firestore;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    Runnable snapshotsInSyncRunnable = () -> events.success(null);

    listenerRegistration = firestore.addSnapshotsInSyncListener(snapshotsInSyncRunnable);
  }

  @Override
  public void onCancel(Object arguments) {
    if (listenerRegistration != null) {
      listenerRegistration.remove();
      listenerRegistration = null;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/streamhandler/TransactionStreamHandler.java

**크기**: 6963 bytes | **라인 수**: 172 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.streamhandler;

import android.os.Handler;
import android.os.Looper;
import androidx.annotation.Nullable;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FieldPath;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.FirebaseFirestoreException;
import com.google.firebase.firestore.FirebaseFirestoreException.Code;
import com.google.firebase.firestore.SetOptions;
import com.google.firebase.firestore.Transaction;
import com.google.firebase.firestore.TransactionOptions;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestoreTransactionResult;
import io.flutter.plugins.firebase.firestore.GeneratedAndroidFirebaseFirestore;
import io.flutter.plugins.firebase.firestore.utils.ExceptionConverter;
import io.flutter.plugins.firebase.firestore.utils.PigeonParser;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class TransactionStreamHandler implements OnTransactionResultListener, StreamHandler {

  /** Callback when the transaction has been started. */
  public interface OnTransactionStartedListener {
    void onStarted(Transaction transaction);
  }

  final OnTransactionStartedListener onTransactionStartedListener;
  final FirebaseFirestore firestore;
  final String transactionId;
  final Long timeout;

  final Long maxAttempts;

  public TransactionStreamHandler(
      OnTransactionStartedListener onTransactionStartedListener,
      FirebaseFirestore firestore,
      String transactionId,
      Long timeout,
      Long maxAttempts) {
    this.onTransactionStartedListener = onTransactionStartedListener;
    this.firestore = firestore;
    this.transactionId = transactionId;
    this.timeout = timeout;
    this.maxAttempts = maxAttempts;
  }

  final Semaphore semaphore = new Semaphore(0);
  private GeneratedAndroidFirebaseFirestore.PigeonTransactionResult resultType;
  private List<GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand> commands;

  final Handler mainLooper = new Handler(Looper.getMainLooper());

  @Override
  public void onListen(Object arguments, EventSink events) {
    firestore
        .runTransaction(
            new TransactionOptions.Builder().setMaxAttempts(maxAttempts.intValue()).build(),
            transaction -> {
              onTransactionStartedListener.onStarted(transaction);

              Map<String, Object> attemptMap = new HashMap<>();
              attemptMap.put("appName", firestore.getApp().getName());

              mainLooper.post(() -> events.success(attemptMap));

              try {
                if (!semaphore.tryAcquire(timeout, TimeUnit.MILLISECONDS)) {
                  return FlutterFirebaseFirestoreTransactionResult.failed(
                      new FirebaseFirestoreException("timed out", Code.DEADLINE_EXCEEDED));
                }
              } catch (InterruptedException e) {
                return FlutterFirebaseFirestoreTransactionResult.failed(
                    new FirebaseFirestoreException("interrupted", Code.DEADLINE_EXCEEDED));
              }

              if (commands.isEmpty()) {
                return FlutterFirebaseFirestoreTransactionResult.complete();
              }

              if (resultType == GeneratedAndroidFirebaseFirestore.PigeonTransactionResult.FAILURE) {
                return FlutterFirebaseFirestoreTransactionResult.complete();
              }

              for (GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand command : commands) {
                DocumentReference documentReference = firestore.document(command.getPath());

                switch (command.getType()) {
                  case DELETE_TYPE:
                    transaction.delete(documentReference);
                    break;
                  case UPDATE:
                    transaction.update(
                        documentReference, Objects.requireNonNull(command.getData()));
                    break;
                  case SET:
                    {
                      GeneratedAndroidFirebaseFirestore.PigeonDocumentOption options =
                          Objects.requireNonNull(command.getOption());
                      SetOptions setOptions = null;

                      if (options.getMerge() != null && options.getMerge()) {
                        setOptions = SetOptions.merge();
                      } else if (options.getMergeFields() != null) {
                        List<List<String>> fieldList =
                            Objects.requireNonNull(options.getMergeFields());
                        List<FieldPath> fieldPathList = PigeonParser.parseFieldPath(fieldList);

                        setOptions = SetOptions.mergeFieldPaths(fieldPathList);
                      }

                      Map<String, Object> data = Objects.requireNonNull(command.getData());

                      if (setOptions == null) {
                        transaction.set(documentReference, data);
                      } else {
                        transaction.set(documentReference, data, setOptions);
                      }

                      break;
                    }
                }
              }
              return FlutterFirebaseFirestoreTransactionResult.complete();
            })
        .addOnCompleteListener(
            task -> {
              final HashMap<String, Object> map = new HashMap<>();
              if (task.getException() != null || task.getResult().exception != null) {
                final @Nullable Exception exception =
                    task.getException() != null ? task.getException() : task.getResult().exception;
                map.put("appName", firestore.getApp().getName());
                map.put("error", ExceptionConverter.createDetails(exception));
              } else if (task.getResult() != null) {
                map.put("complete", true);
              }

              mainLooper.post(
                  () -> {
                    events.success(map);
                    events.endOfStream();
                  });
            });
  }

  @Override
  public void onCancel(Object arguments) {
    semaphore.release();
  }

  @Override
  public void receiveTransactionResponse(
      GeneratedAndroidFirebaseFirestore.PigeonTransactionResult resultType,
      List<GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand> commands) {
    this.resultType = resultType;
    this.commands = commands;
    semaphore.release();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/utils/ExceptionConverter.java

**크기**: 2421 bytes | **라인 수**: 67 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.utils;

import static io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin.DEFAULT_ERROR_CODE;

import android.util.Log;
import com.google.firebase.firestore.FirebaseFirestoreException;
import io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestoreException;
import io.flutter.plugins.firebase.firestore.GeneratedAndroidFirebaseFirestore;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class ExceptionConverter {

  public static Map<String, String> createDetails(Exception exception) {
    Map<String, String> details = new HashMap<>();

    if (exception == null) {
      return details;
    }

    FlutterFirebaseFirestoreException firestoreException = null;

    if (exception instanceof FirebaseFirestoreException) {
      firestoreException =
          new FlutterFirebaseFirestoreException(
              (FirebaseFirestoreException) exception, exception.getCause());
    } else if (exception.getCause() != null
        && exception.getCause() instanceof FirebaseFirestoreException) {
      firestoreException =
          new FlutterFirebaseFirestoreException(
              (FirebaseFirestoreException) exception.getCause(),
              exception.getCause().getCause() != null
                  ? exception.getCause().getCause()
                  : exception.getCause());
    }

    if (firestoreException != null) {
      details.put("code", firestoreException.getCode());
      details.put("message", firestoreException.getMessage());
    }

    if (details.containsKey("code")
        && Objects.requireNonNull(details.get("code")).equals("unknown")) {
      Log.e("FLTFirebaseFirestore", "An unknown error occurred", exception);
    }

    return details;
  }

  public static void sendErrorToFlutter(
      GeneratedAndroidFirebaseFirestore.Result result, Exception exception) {
    Map<String, String> exceptionDetails = ExceptionConverter.createDetails(exception);
    result.error(
        new GeneratedAndroidFirebaseFirestore.FlutterError(
            DEFAULT_ERROR_CODE,
            exception != null ? exception.getMessage() : null,
            exceptionDetails));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/utils/PigeonParser.java

**크기**: 13930 bytes | **라인 수**: 336 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.utils;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.firebase.firestore.AggregateSource;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FieldPath;
import com.google.firebase.firestore.Filter;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.ListenSource;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.Source;
import io.flutter.plugins.firebase.firestore.GeneratedAndroidFirebaseFirestore;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class PigeonParser {

  public static Source parsePigeonSource(GeneratedAndroidFirebaseFirestore.Source source) {
    switch (source) {
      case CACHE:
        return Source.CACHE;
      case SERVER_AND_CACHE:
        return Source.DEFAULT;
      case SERVER:
        return Source.SERVER;
      default:
        throw new IllegalArgumentException("Unknown source: " + source);
    }
  }

  public static DocumentSnapshot.ServerTimestampBehavior parsePigeonServerTimestampBehavior(
      @Nullable GeneratedAndroidFirebaseFirestore.ServerTimestampBehavior serverTimestampBehavior) {
    if (serverTimestampBehavior == null) {
      return DocumentSnapshot.ServerTimestampBehavior.NONE;
    }
    switch (serverTimestampBehavior) {
      case NONE:
        return DocumentSnapshot.ServerTimestampBehavior.NONE;
      case ESTIMATE:
        return DocumentSnapshot.ServerTimestampBehavior.ESTIMATE;
      case PREVIOUS:
        return DocumentSnapshot.ServerTimestampBehavior.PREVIOUS;
      default:
        throw new IllegalArgumentException(
            "Unknown server timestamp behavior: " + serverTimestampBehavior);
    }
  }

  public static GeneratedAndroidFirebaseFirestore.PigeonQuerySnapshot toPigeonQuerySnapshot(
      com.google.firebase.firestore.QuerySnapshot querySnapshot,
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
    GeneratedAndroidFirebaseFirestore.PigeonQuerySnapshot.Builder pigeonQuerySnapshot =
        new GeneratedAndroidFirebaseFirestore.PigeonQuerySnapshot.Builder();
    pigeonQuerySnapshot.setMetadata(toPigeonSnapshotMetadata(querySnapshot.getMetadata()));
    pigeonQuerySnapshot.setDocumentChanges(
        toPigeonDocumentChanges(querySnapshot.getDocumentChanges(), serverTimestampBehavior));
    pigeonQuerySnapshot.setDocuments(
        toPigeonDocumentSnapshots(querySnapshot.getDocuments(), serverTimestampBehavior));
    return pigeonQuerySnapshot.build();
  }

  public static GeneratedAndroidFirebaseFirestore.PigeonSnapshotMetadata toPigeonSnapshotMetadata(
      com.google.firebase.firestore.SnapshotMetadata snapshotMetadata) {
    GeneratedAndroidFirebaseFirestore.PigeonSnapshotMetadata.Builder pigeonSnapshotMetadata =
        new GeneratedAndroidFirebaseFirestore.PigeonSnapshotMetadata.Builder();
    pigeonSnapshotMetadata.setHasPendingWrites(snapshotMetadata.hasPendingWrites());
    pigeonSnapshotMetadata.setIsFromCache(snapshotMetadata.isFromCache());
    return pigeonSnapshotMetadata.build();
  }

  public static List<GeneratedAndroidFirebaseFirestore.PigeonDocumentChange>
      toPigeonDocumentChanges(
          List<com.google.firebase.firestore.DocumentChange> documentChanges,
          DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
    List<GeneratedAndroidFirebaseFirestore.PigeonDocumentChange> pigeonDocumentChanges =
        new ArrayList<>(documentChanges.size());
    for (com.google.firebase.firestore.DocumentChange documentChange : documentChanges) {
      pigeonDocumentChanges.add(toPigeonDocumentChange(documentChange, serverTimestampBehavior));
    }
    return pigeonDocumentChanges;
  }

  public static GeneratedAndroidFirebaseFirestore.PigeonDocumentChange toPigeonDocumentChange(
      com.google.firebase.firestore.DocumentChange documentChange,
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
    GeneratedAndroidFirebaseFirestore.PigeonDocumentChange.Builder pigeonDocumentChange =
        new GeneratedAndroidFirebaseFirestore.PigeonDocumentChange.Builder();
    pigeonDocumentChange.setType(toPigeonDocumentChangeType(documentChange.getType()));
    pigeonDocumentChange.setOldIndex((long) documentChange.getOldIndex());
    pigeonDocumentChange.setNewIndex((long) documentChange.getNewIndex());
    pigeonDocumentChange.setDocument(
        toPigeonDocumentSnapshot(documentChange.getDocument(), serverTimestampBehavior));
    return pigeonDocumentChange.build();
  }

  public static GeneratedAndroidFirebaseFirestore.DocumentChangeType toPigeonDocumentChangeType(
      com.google.firebase.firestore.DocumentChange.Type type) {
    switch (type) {
      case ADDED:
        return GeneratedAndroidFirebaseFirestore.DocumentChangeType.ADDED;
      case MODIFIED:
        return GeneratedAndroidFirebaseFirestore.DocumentChangeType.MODIFIED;
      case REMOVED:
        return GeneratedAndroidFirebaseFirestore.DocumentChangeType.REMOVED;
      default:
        throw new IllegalArgumentException("Unknown change type: " + type);
    }
  }

  public static ListenSource parseListenSource(
      GeneratedAndroidFirebaseFirestore.ListenSource source) {
    switch (source) {
      case DEFAULT_SOURCE:
        return ListenSource.DEFAULT;
      case CACHE:
        return ListenSource.CACHE;
      default:
        throw new IllegalArgumentException("Unknown ListenSource value: " + source);
    }
  }

  public static GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot toPigeonDocumentSnapshot(
      com.google.firebase.firestore.DocumentSnapshot documentSnapshot,
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
    GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot.Builder pigeonDocumentSnapshot =
        new GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot.Builder();
    pigeonDocumentSnapshot.setMetadata(toPigeonSnapshotMetadata(documentSnapshot.getMetadata()));
    pigeonDocumentSnapshot.setData(documentSnapshot.getData(serverTimestampBehavior));
    pigeonDocumentSnapshot.setPath(documentSnapshot.getReference().getPath());
    return pigeonDocumentSnapshot.build();
  }

  public static List<GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot>
      toPigeonDocumentSnapshots(
          List<com.google.firebase.firestore.DocumentSnapshot> documentSnapshots,
          DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
    List<GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot> pigeonDocumentSnapshots =
        new ArrayList<>(documentSnapshots.size());
    for (com.google.firebase.firestore.DocumentSnapshot documentSnapshot : documentSnapshots) {
      pigeonDocumentSnapshots.add(
          toPigeonDocumentSnapshot(documentSnapshot, serverTimestampBehavior));
    }
    return pigeonDocumentSnapshots;
  }

  public static List<FieldPath> parseFieldPath(List<List<String>> fieldPaths) {
    List<FieldPath> paths = new ArrayList<>(fieldPaths.size());
    for (List<String> fieldPath : fieldPaths) {
      paths.add(FieldPath.of(fieldPath.toArray(new String[0])));
    }
    return paths;
  }

  public static Query parseQuery(
      FirebaseFirestore firestore,
      @NonNull String path,
      boolean isCollectionGroup,
      GeneratedAndroidFirebaseFirestore.PigeonQueryParameters parameters) {
    try {
      Query query;
      if (isCollectionGroup) {
        query = firestore.collectionGroup(path);
      } else {
        query = firestore.collection(path);
      }

      if (parameters == null) return query;

      boolean isFilterQuery = parameters.getFilters() != null;
      if (isFilterQuery) {
        Filter filter = filterFromJson(parameters.getFilters());
        query = query.where(filter);
      }

      List<List<Object>> whereConditions = Objects.requireNonNull(parameters.getWhere());

      for (List<Object> condition : whereConditions) {
        FieldPath fieldPath = (FieldPath) condition.get(0);
        String operator = (String) condition.get(1);
        Object value = condition.get(2);

        if ("==".equals(operator)) {
          query = query.whereEqualTo(fieldPath, value);
        } else if ("!=".equals(operator)) {
          query = query.whereNotEqualTo(fieldPath, value);
        } else if ("<".equals(operator)) {
          query = query.whereLessThan(fieldPath, value);
        } else if ("<=".equals(operator)) {
          query = query.whereLessThanOrEqualTo(fieldPath, value);
        } else if (">".equals(operator)) {
          query = query.whereGreaterThan(fieldPath, value);
        } else if (">=".equals(operator)) {
          query = query.whereGreaterThanOrEqualTo(fieldPath, value);
        } else if ("array-contains".equals(operator)) {
          query = query.whereArrayContains(fieldPath, value);
        } else if ("array-contains-any".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereArrayContainsAny(fieldPath, listValues);
        } else if ("in".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereIn(fieldPath, listValues);
        } else if ("not-in".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereNotIn(fieldPath, listValues);
        } else {
          Log.w(
              "FLTFirestoreMsgCodec",
              "An invalid query operator " + operator + " was received but not handled.");
        }
      }

      // "limit" filters
      Number limit = parameters.getLimit();
      if (limit != null) query = query.limit(limit.longValue());

      Number limitToLast = parameters.getLimitToLast();
      if (limitToLast != null) query = query.limitToLast(limitToLast.longValue());

      // "orderBy" filters
      List<List<Object>> orderBy = parameters.getOrderBy();
      if (orderBy == null) return query;

      for (List<Object> order : orderBy) {
        FieldPath fieldPath = (FieldPath) order.get(0);
        boolean descending = (boolean) order.get(1);

        Query.Direction direction =
            descending ? Query.Direction.DESCENDING : Query.Direction.ASCENDING;

        query = query.orderBy(fieldPath, direction);
      }

      // cursor queries
      List<Object> startAt = parameters.getStartAt();
      if (startAt != null) query = query.startAt(Objects.requireNonNull(startAt.toArray()));

      List<Object> startAfter = parameters.getStartAfter();
      if (startAfter != null)
        query = query.startAfter(Objects.requireNonNull(startAfter.toArray()));

      List<Object> endAt = parameters.getEndAt();
      if (endAt != null) query = query.endAt(Objects.requireNonNull(endAt.toArray()));

      List<Object> endBefore = parameters.getEndBefore();
      if (endBefore != null) query = query.endBefore(Objects.requireNonNull(endBefore.toArray()));

      return query;
    } catch (Exception exception) {
      Log.e(
          "FLTFirestoreMsgCodec",
          "An error occurred while parsing query arguments, this is most likely an error with this SDK.",
          exception);
      return null;
    }
  }

  private static Filter filterFromJson(Map<String, Object> map) {
    if (map.containsKey("fieldPath")) {
      // Deserialize a FilterQuery
      String op = (String) map.get("op");
      FieldPath fieldPath = (FieldPath) map.get("fieldPath");
      Object value = map.get("value");

      assert fieldPath != null;
      assert op != null;

      // All the operators from Firebase
      switch (op) {
        case "==":
          return Filter.equalTo(fieldPath, value);
        case "!=":
          return Filter.notEqualTo(fieldPath, value);
        case "<":
          return Filter.lessThan(fieldPath, value);
        case "<=":
          return Filter.lessThanOrEqualTo(fieldPath, value);
        case ">":
          return Filter.greaterThan(fieldPath, value);
        case ">=":
          return Filter.greaterThanOrEqualTo(fieldPath, value);
        case "array-contains":
          return Filter.arrayContains(fieldPath, value);
        case "array-contains-any":
          return Filter.arrayContainsAny(fieldPath, (List<? extends Object>) value);
        case "in":
          return Filter.inArray(fieldPath, (List<? extends Object>) value);
        case "not-in":
          return Filter.notInArray(fieldPath, (List<? extends Object>) value);
        default:
          throw new Error("Invalid operator");
      }
    }
    // Deserialize a FilterOperator
    String op = (String) map.get("op");
    @SuppressWarnings("unchecked")
    List<Map<String, Object>> queries = (List<Map<String, Object>>) map.get("queries");

    // Map queries recursively
    ArrayList<Filter> parsedFilters = new ArrayList<>();
    for (Map<String, Object> query : queries) {
      parsedFilters.add(filterFromJson(query));
    }

    if (op.equals("OR")) {
      return Filter.or(parsedFilters.toArray(new Filter[0]));
    } else if (op.equals("AND")) {
      return Filter.and(parsedFilters.toArray(new Filter[0]));
    }

    throw new Error("Invalid operator");
  }

  public static AggregateSource parseAggregateSource(
      GeneratedAndroidFirebaseFirestore.AggregateSource source) {
    switch (source) {
      case SERVER:
        return AggregateSource.SERVER;
      default:
        throw new IllegalArgumentException("Unknown AggregateSource value: " + source);
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/utils/ServerTimestampBehaviorConverter.java

**크기**: 987 bytes | **라인 수**: 29 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.firestore.utils;

import androidx.annotation.Nullable;
import com.google.firebase.firestore.DocumentSnapshot;

public class ServerTimestampBehaviorConverter {
  public static DocumentSnapshot.ServerTimestampBehavior toServerTimestampBehavior(
      @Nullable String serverTimestampBehavior) {
    if (serverTimestampBehavior == null) {
      return DocumentSnapshot.ServerTimestampBehavior.NONE;
    }
    switch (serverTimestampBehavior) {
      case "estimate":
        return DocumentSnapshot.ServerTimestampBehavior.ESTIMATE;
      case "previous":
        return DocumentSnapshot.ServerTimestampBehavior.PREVIOUS;
      case "none":
      default:
        return DocumentSnapshot.ServerTimestampBehavior.NONE;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestoreException.java

**크기**: 8622 bytes | **라인 수**: 224 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import com.google.firebase.firestore.FirebaseFirestoreException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FlutterFirebaseFirestoreException extends Exception {
  private static final String ERROR_ABORTED =
      "The operation was aborted, typically due to a concurrency issue like transaction aborts, etc.";
  private static final String ERROR_ALREADY_EXISTS =
      "Some document that we attempted to create already exists.";
  private static final String ERROR_CANCELLED =
      "The operation was cancelled (typically by the caller).";
  private static final String ERROR_DATA_LOSS = "Unrecoverable data loss or corruption.";
  private static final String ERROR_DEADLINE_EXCEEDED =
      "Deadline expired before operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire.";
  private static final String ERROR_FAILED_PRECONDITION =
      "Operation was rejected because the system is not in a state required for the operation's execution. If performing a query, ensure it has been indexed via the Firebase console.";
  private static final String ERROR_INTERNAL =
      "Internal errors. Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.";
  private static final String ERROR_INVALID_ARGUMENT =
      "Client specified an invalid argument. Note that this differs from failed-precondition. invalid-argument indicates arguments that are problematic regardless of the state of the system (e.g., an invalid field name).";
  private static final String ERROR_NOT_FOUND = "Some requested document was not found.";
  private static final String ERROR_OUT_OF_RANGE = "Operation was attempted past the valid range.";
  private static final String ERROR_PERMISSION_DENIED =
      "The caller does not have permission to execute the specified operation.";
  private static final String ERROR_RESOURCE_EXHAUSTED =
      "Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space.";
  private static final String ERROR_UNAUTHENTICATED =
      "The request does not have valid authentication credentials for the operation.";
  private static final String ERROR_UNAVAILABLE =
      "The service is currently unavailable. This is a most likely a transient condition and may be corrected by retrying with a backoff.";
  private static final String ERROR_UNIMPLEMENTED =
      "Operation is not implemented or not supported/enabled.";
  private static final String ERROR_UNKNOWN =
      "Operation is not implemented or not supported/enabled.";

  private final String code;
  private final String message;

  public FlutterFirebaseFirestoreException(
      FirebaseFirestoreException nativeException, Throwable cause) {
    super(nativeException != null ? nativeException.getMessage() : "", cause);

    String code = null;
    String message = null;

    if (cause != null && cause.getMessage() != null && cause.getMessage().contains(":")) {
      String causeMessage = cause.getMessage();
      Matcher matcher = Pattern.compile("([A-Z_]{3,25}):\\s(.*)").matcher(causeMessage);

      if (matcher.find()) {
        String foundCode = matcher.group(1).trim();
        String foundMessage = matcher.group(2).trim();
        switch (foundCode) {
          case "ABORTED":
            code = "aborted";
            message = ERROR_ABORTED;
            break;
          case "ALREADY_EXISTS":
            code = "already-exists";
            message = ERROR_ALREADY_EXISTS;
            break;
          case "CANCELLED":
            code = "cancelled";
            message = ERROR_CANCELLED;
            break;
          case "DATA_LOSS":
            code = "data-loss";
            message = ERROR_DATA_LOSS;
            break;
          case "DEADLINE_EXCEEDED":
            code = "deadline-exceeded";
            message = ERROR_DEADLINE_EXCEEDED;
            break;
          case "FAILED_PRECONDITION":
            code = "failed-precondition";
            if (foundMessage.contains("index")) {
              message = foundMessage;
            } else {
              message = ERROR_FAILED_PRECONDITION;
            }
            break;
          case "INTERNAL":
            code = "internal";
            message = ERROR_INTERNAL;
            break;
          case "INVALID_ARGUMENT":
            code = "invalid-argument";
            message = ERROR_INVALID_ARGUMENT;
            break;
          case "NOT_FOUND":
            code = "not-found";
            message = ERROR_NOT_FOUND;
            break;
          case "OUT_OF_RANGE":
            code = "out-of-range";
            message = ERROR_OUT_OF_RANGE;
            break;
          case "PERMISSION_DENIED":
            code = "permission-denied";
            message = ERROR_PERMISSION_DENIED;
            break;
          case "RESOURCE_EXHAUSTED":
            code = "resource-exhausted";
            message = ERROR_RESOURCE_EXHAUSTED;
            break;
          case "UNAUTHENTICATED":
            code = "unauthenticated";
            message = ERROR_UNAUTHENTICATED;
            break;
          case "UNAVAILABLE":
            code = "unavailable";
            message = ERROR_UNAVAILABLE;
            break;
          case "UNIMPLEMENTED":
            code = "unimplemented";
            message = ERROR_UNIMPLEMENTED;
            break;
          case "UNKNOWN":
            code = "unknown";
            message = ERROR_UNKNOWN;
            break;
        }
      }
    }

    if (code == null && nativeException != null) {
      switch (nativeException.getCode()) {
        case ABORTED:
          code = "aborted";
          message = ERROR_ABORTED;
          break;
        case ALREADY_EXISTS:
          code = "already-exists";
          message = ERROR_ALREADY_EXISTS;
          break;
        case CANCELLED:
          code = "cancelled";
          message = ERROR_CANCELLED;
          break;
        case DATA_LOSS:
          code = "data-loss";
          message = ERROR_DATA_LOSS;
          break;
        case DEADLINE_EXCEEDED:
          code = "deadline-exceeded";
          message = ERROR_DEADLINE_EXCEEDED;
          break;
        case FAILED_PRECONDITION:
          code = "failed-precondition";
          if (nativeException.getMessage() != null
                  && nativeException.getMessage().contains("query requires an index")
              || nativeException.getMessage().contains("ensure it has been indexed")) {
            message = nativeException.getMessage();
          } else {
            message = ERROR_FAILED_PRECONDITION;
          }
          break;
        case INTERNAL:
          code = "internal";
          message = ERROR_INTERNAL;
          break;
        case INVALID_ARGUMENT:
          code = "invalid-argument";
          message = ERROR_INVALID_ARGUMENT;
          break;
        case NOT_FOUND:
          code = "not-found";
          message = ERROR_NOT_FOUND;
          break;
        case OUT_OF_RANGE:
          code = "out-of-range";
          message = ERROR_OUT_OF_RANGE;
          break;
        case PERMISSION_DENIED:
          code = "permission-denied";
          message = ERROR_PERMISSION_DENIED;
          break;
        case RESOURCE_EXHAUSTED:
          code = "resource-exhausted";
          message = ERROR_RESOURCE_EXHAUSTED;
          break;
        case UNAUTHENTICATED:
          code = "unauthenticated";
          message = ERROR_UNAUTHENTICATED;
          break;
        case UNAVAILABLE:
          code = "unavailable";
          message = ERROR_UNAVAILABLE;
          break;
        case UNIMPLEMENTED:
          code = "unimplemented";
          message = ERROR_UNIMPLEMENTED;
          break;
        case UNKNOWN:
          code = "unknown";
          message = "Unknown error or an error from a different error domain.";
          break;
        default:
          // Even though UNKNOWN exists, this is a fallback
          code = "unknown";
          message = "An unknown error occurred";
      }
    }

    this.code = code;
    this.message = message;
  }

  public String getCode() {
    return code;
  }

  @Override
  public String getMessage() {
    return message;
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestoreExtension.java

**크기**: 699 bytes | **라인 수**: 26 | **타입**: text

```
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import com.google.firebase.firestore.FirebaseFirestore;

public class FlutterFirebaseFirestoreExtension {
  private final FirebaseFirestore instance;
  private final String databaseURL;

  public FlutterFirebaseFirestoreExtension(FirebaseFirestore instance, String databaseURL) {
    this.instance = instance;
    this.databaseURL = databaseURL;
  }

  public FirebaseFirestore getInstance() {
    return instance;
  }

  public String getDatabaseURL() {
    return databaseURL;
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestoreMessageCodec.java

**크기**: 22700 bytes | **라인 수**: 557 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import android.util.Log;
import com.google.firebase.FirebaseApp;
import com.google.firebase.Timestamp;
import com.google.firebase.firestore.Blob;
import com.google.firebase.firestore.DocumentChange;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FieldPath;
import com.google.firebase.firestore.FieldValue;
import com.google.firebase.firestore.Filter;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.FirebaseFirestoreSettings;
import com.google.firebase.firestore.GeoPoint;
import com.google.firebase.firestore.LoadBundleTaskProgress;
import com.google.firebase.firestore.MemoryCacheSettings;
import com.google.firebase.firestore.PersistentCacheSettings;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;
import com.google.firebase.firestore.SnapshotMetadata;
import com.google.firebase.firestore.VectorValue;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

class FlutterFirebaseFirestoreMessageCodec extends StandardMessageCodec {
  public static final FlutterFirebaseFirestoreMessageCodec INSTANCE =
      new FlutterFirebaseFirestoreMessageCodec();
  private static final byte DATA_TYPE_DATE_TIME = (byte) 180;
  private static final byte DATA_TYPE_GEO_POINT = (byte) 181;
  private static final byte DATA_TYPE_DOCUMENT_REFERENCE = (byte) 182;
  private static final byte DATA_TYPE_BLOB = (byte) 183;
  private static final byte DATA_TYPE_ARRAY_UNION = (byte) 184;
  private static final byte DATA_TYPE_ARRAY_REMOVE = (byte) 185;
  private static final byte DATA_TYPE_DELETE = (byte) 186;
  private static final byte DATA_TYPE_SERVER_TIMESTAMP = (byte) 187;
  private static final byte DATA_TYPE_TIMESTAMP = (byte) 188;
  private static final byte DATA_TYPE_INCREMENT_DOUBLE = (byte) 189;
  private static final byte DATA_TYPE_INCREMENT_INTEGER = (byte) 190;
  private static final byte DATA_TYPE_DOCUMENT_ID = (byte) 191;
  private static final byte DATA_TYPE_FIELD_PATH = (byte) 192;
  private static final byte DATA_TYPE_NAN = (byte) 193;
  private static final byte DATA_TYPE_INFINITY = (byte) 194;
  private static final byte DATA_TYPE_NEGATIVE_INFINITY = (byte) 195;
  private static final byte DATA_TYPE_FIRESTORE_INSTANCE = (byte) 196;
  private static final byte DATA_TYPE_FIRESTORE_QUERY = (byte) 197;
  private static final byte DATA_TYPE_FIRESTORE_SETTINGS = (byte) 198;
  private static final byte DATA_TYPE_VECTOR_VALUE = (byte) 199;

  @Override
  protected void writeValue(ByteArrayOutputStream stream, Object value) {
    if (value instanceof Date) {
      stream.write(DATA_TYPE_DATE_TIME);
      writeLong(stream, ((Date) value).getTime());
    } else if (value instanceof Timestamp) {
      stream.write(DATA_TYPE_TIMESTAMP);
      writeLong(stream, ((Timestamp) value).getSeconds());
      writeInt(stream, ((Timestamp) value).getNanoseconds());
    } else if (value instanceof GeoPoint) {
      stream.write(DATA_TYPE_GEO_POINT);
      writeAlignment(stream, 8);
      writeDouble(stream, ((GeoPoint) value).getLatitude());
      writeDouble(stream, ((GeoPoint) value).getLongitude());
    } else if (value instanceof VectorValue) {
      stream.write(DATA_TYPE_VECTOR_VALUE);
      writeValue(stream, ((VectorValue) value).toArray());
    } else if (value instanceof DocumentReference) {
      stream.write(DATA_TYPE_DOCUMENT_REFERENCE);
      FirebaseFirestore firestore = ((DocumentReference) value).getFirestore();
      String appName = firestore.getApp().getName();
      writeValue(stream, appName);
      writeValue(stream, ((DocumentReference) value).getPath());
      String databaseURL;
      // There is no way of getting database URL from Firebase android SDK API so we cache it ourselves
      synchronized (FlutterFirebaseFirestorePlugin.firestoreInstanceCache) {
        databaseURL =
            FlutterFirebaseFirestorePlugin.getCachedFirebaseFirestoreInstanceForKey(firestore)
                .getDatabaseURL();
      }
      writeValue(stream, databaseURL);
    } else if (value instanceof DocumentSnapshot) {
      writeDocumentSnapshot(stream, (DocumentSnapshot) value);
    } else if (value instanceof QuerySnapshot) {
      writeQuerySnapshot(stream, (QuerySnapshot) value);
    } else if (value instanceof DocumentChange) {
      writeDocumentChange(stream, (DocumentChange) value);
    } else if (value instanceof LoadBundleTaskProgress) {
      writeLoadBundleTaskProgress(stream, (LoadBundleTaskProgress) value);
    } else if (value instanceof SnapshotMetadata) {
      writeSnapshotMetadata(stream, (SnapshotMetadata) value);
    } else if (value instanceof Blob) {
      stream.write(DATA_TYPE_BLOB);
      writeBytes(stream, ((Blob) value).toBytes());
    } else if (value instanceof Double) {
      Double doubleValue = (Double) value;
      if (Double.isNaN(doubleValue)) {
        stream.write(DATA_TYPE_NAN);
      } else if (doubleValue.equals(Double.NEGATIVE_INFINITY)) {
        stream.write(DATA_TYPE_NEGATIVE_INFINITY);
      } else if (doubleValue.equals(Double.POSITIVE_INFINITY)) {
        stream.write(DATA_TYPE_INFINITY);
      } else {
        super.writeValue(stream, value);
      }
    } else {
      super.writeValue(stream, value);
    }
  }

  private void writeSnapshotMetadata(ByteArrayOutputStream stream, SnapshotMetadata value) {
    Map<String, Boolean> metadataMap = new HashMap<>();
    metadataMap.put("hasPendingWrites", value.hasPendingWrites());
    metadataMap.put("isFromCache", value.isFromCache());
    writeValue(stream, metadataMap);
  }

  private void writeDocumentChange(ByteArrayOutputStream stream, DocumentChange value) {
    Map<String, Object> changeMap = new HashMap<>();

    String type = null;
    switch (value.getType()) {
      case ADDED:
        type = "DocumentChangeType.added";
        break;
      case MODIFIED:
        type = "DocumentChangeType.modified";
        break;
      case REMOVED:
        type = "DocumentChangeType.removed";
        break;
    }

    changeMap.put("type", type);
    changeMap.put("data", value.getDocument().getData());
    changeMap.put("path", value.getDocument().getReference().getPath());
    changeMap.put("oldIndex", value.getOldIndex());
    changeMap.put("newIndex", value.getNewIndex());
    changeMap.put("metadata", value.getDocument().getMetadata());

    writeValue(stream, changeMap);
  }

  private void writeQuerySnapshot(ByteArrayOutputStream stream, QuerySnapshot value) {
    List<String> paths = new ArrayList<>();
    Map<String, Object> querySnapshotMap = new HashMap<>();
    List<Map<String, Object>> documents = new ArrayList<>();
    List<SnapshotMetadata> metadatas = new ArrayList<>();

    DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior =
        FlutterFirebaseFirestorePlugin.serverTimestampBehaviorHashMap.get(value.hashCode());

    for (DocumentSnapshot document : value.getDocuments()) {
      paths.add(document.getReference().getPath());
      if (serverTimestampBehavior != null) {
        documents.add(document.getData(serverTimestampBehavior));
      } else {
        documents.add(document.getData());
      }
      metadatas.add(document.getMetadata());
    }

    querySnapshotMap.put("paths", paths);
    querySnapshotMap.put("documents", documents);
    querySnapshotMap.put("metadatas", metadatas);
    querySnapshotMap.put("documentChanges", value.getDocumentChanges());
    querySnapshotMap.put("metadata", value.getMetadata());

    FlutterFirebaseFirestorePlugin.serverTimestampBehaviorHashMap.remove(value.hashCode());
    writeValue(stream, querySnapshotMap);
  }

  private void writeLoadBundleTaskProgress(
      ByteArrayOutputStream stream, LoadBundleTaskProgress snapshot) {
    Map<String, Object> snapshotMap = new HashMap<>();

    snapshotMap.put("bytesLoaded", snapshot.getBytesLoaded());
    snapshotMap.put("documentsLoaded", snapshot.getDocumentsLoaded());
    snapshotMap.put("totalBytes", snapshot.getTotalBytes());
    snapshotMap.put("totalDocuments", snapshot.getTotalDocuments());

    LoadBundleTaskProgress.TaskState taskState = snapshot.getTaskState();
    String convertedState = "running";

    switch (taskState) {
      case RUNNING:
        convertedState = "running";
        break;
      case SUCCESS:
        convertedState = "success";
        break;
      case ERROR:
        convertedState = "error";
        break;
    }

    snapshotMap.put("taskState", convertedState);

    writeValue(stream, snapshotMap);
  }

  @SuppressWarnings("ConstantConditions")
  private void writeDocumentSnapshot(ByteArrayOutputStream stream, DocumentSnapshot value) {
    Map<String, Object> snapshotMap = new HashMap<>();

    snapshotMap.put("path", value.getReference().getPath());

    if (value.exists()) {
      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior =
          FlutterFirebaseFirestorePlugin.serverTimestampBehaviorHashMap.get(value.hashCode());
      if (serverTimestampBehavior != null) {
        snapshotMap.put("data", value.getData(serverTimestampBehavior));
      } else {
        snapshotMap.put("data", value.getData());
      }
    } else {
      snapshotMap.put("data", null);
    }

    snapshotMap.put("metadata", value.getMetadata());

    FlutterFirebaseFirestorePlugin.serverTimestampBehaviorHashMap.remove(value.hashCode());
    writeValue(stream, snapshotMap);
  }

  @Override
  protected Object readValueOfType(byte type, ByteBuffer buffer) {
    switch (type) {
      case DATA_TYPE_DATE_TIME:
        return new Date(buffer.getLong());
      case DATA_TYPE_TIMESTAMP:
        return new Timestamp(buffer.getLong(), buffer.getInt());
      case DATA_TYPE_GEO_POINT:
        readAlignment(buffer, 8);
        return new GeoPoint(buffer.getDouble(), buffer.getDouble());
      case DATA_TYPE_VECTOR_VALUE:
        @SuppressWarnings("unchecked")
        final ArrayList<Double> arrayList = (ArrayList<Double>) readValue(buffer);
        double[] doubleArray = new double[arrayList.size()];
        for (int i = 0; i < arrayList.size(); i++) {
          doubleArray[i] = Objects.requireNonNull(arrayList.get(i), "Null value at index " + i);
        }
        return FieldValue.vector(doubleArray);
      case DATA_TYPE_DOCUMENT_REFERENCE:
        FirebaseFirestore firestore = (FirebaseFirestore) readValue(buffer);
        final String path = (String) readValue(buffer);
        return firestore.document(path);
      case DATA_TYPE_BLOB:
        final byte[] bytes = readBytes(buffer);
        return Blob.fromBytes(bytes);
      case DATA_TYPE_ARRAY_UNION:
        return FieldValue.arrayUnion(toArray(readValue(buffer)));
      case DATA_TYPE_ARRAY_REMOVE:
        return FieldValue.arrayRemove(toArray(readValue(buffer)));
      case DATA_TYPE_DELETE:
        return FieldValue.delete();
      case DATA_TYPE_SERVER_TIMESTAMP:
        return FieldValue.serverTimestamp();
      case DATA_TYPE_INCREMENT_INTEGER:
        final Number integerIncrementValue = (Number) readValue(buffer);
        return FieldValue.increment(integerIncrementValue.intValue());
      case DATA_TYPE_INCREMENT_DOUBLE:
        final Number doubleIncrementValue = (Number) readValue(buffer);
        return FieldValue.increment(doubleIncrementValue.doubleValue());
      case DATA_TYPE_DOCUMENT_ID:
        return FieldPath.documentId();
      case DATA_TYPE_FIRESTORE_INSTANCE:
        return readFirestoreInstance(buffer);
      case DATA_TYPE_FIRESTORE_QUERY:
        return readFirestoreQuery(buffer);
      case DATA_TYPE_FIRESTORE_SETTINGS:
        return readFirestoreSettings(buffer);
      case DATA_TYPE_NAN:
        return Double.NaN;
      case DATA_TYPE_INFINITY:
        return Double.POSITIVE_INFINITY;
      case DATA_TYPE_NEGATIVE_INFINITY:
        return Double.NEGATIVE_INFINITY;
      case DATA_TYPE_FIELD_PATH:
        final int size = readSize(buffer);
        final List<Object> list = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
          list.add(readValue(buffer));
        }
        return FieldPath.of((String[]) list.toArray(new String[0]));
      default:
        return super.readValueOfType(type, buffer);
    }
  }

  private FirebaseFirestore readFirestoreInstance(ByteBuffer buffer) {
    String appName = (String) readValue(buffer);
    String databaseURL = (String) readValue(buffer);
    FirebaseFirestoreSettings settings = (FirebaseFirestoreSettings) readValue(buffer);
    synchronized (FlutterFirebaseFirestorePlugin.firestoreInstanceCache) {
      FirebaseFirestore cachedFirestoreInstance =
          FlutterFirebaseFirestorePlugin.getFirestoreInstanceByNameAndDatabaseUrl(
              appName, databaseURL);
      if (cachedFirestoreInstance != null) {
        return cachedFirestoreInstance;
      }

      FirebaseApp app = FirebaseApp.getInstance(appName);
      FirebaseFirestore firestore = FirebaseFirestore.getInstance(app, databaseURL);
      firestore.setFirestoreSettings(settings);

      FlutterFirebaseFirestorePlugin.setCachedFirebaseFirestoreInstanceForKey(
          firestore, databaseURL);
      return firestore;
    }
  }

  private FirebaseFirestoreSettings readFirestoreSettings(ByteBuffer buffer) {
    @SuppressWarnings("unchecked")
    Map<String, Object> settingsMap = (Map<String, Object>) readValue(buffer);

    FirebaseFirestoreSettings.Builder settingsBuilder = new FirebaseFirestoreSettings.Builder();
    if (settingsMap.get("persistenceEnabled") != null) {
      Boolean persistenceEnabled = (Boolean) settingsMap.get("persistenceEnabled");

      if (Boolean.TRUE.equals(persistenceEnabled)) {
        PersistentCacheSettings.Builder persistenceSettings = PersistentCacheSettings.newBuilder();

        if (settingsMap.get("cacheSizeBytes") != null) {
          Long cacheSizeBytes = 104857600L;
          Object value = settingsMap.get("cacheSizeBytes");

          if (value instanceof Long) {
            cacheSizeBytes = (Long) value;
          } else if (value instanceof Integer) {
            cacheSizeBytes = Long.valueOf((Integer) value);
          }

          if (cacheSizeBytes == -1) {
            persistenceSettings.setSizeBytes(FirebaseFirestoreSettings.CACHE_SIZE_UNLIMITED);
          } else {
            persistenceSettings.setSizeBytes(cacheSizeBytes);
          }
        }

        settingsBuilder.setLocalCacheSettings(persistenceSettings.build());
      } else {
        settingsBuilder.setLocalCacheSettings(MemoryCacheSettings.newBuilder().build());
      }
    }

    if (settingsMap.get("host") != null) {
      settingsBuilder.setHost((String) Objects.requireNonNull(settingsMap.get("host")));
      // Only allow changing ssl if host is also specified.
      if (settingsMap.get("sslEnabled") != null) {
        settingsBuilder.setSslEnabled(
            (Boolean) Objects.requireNonNull(settingsMap.get("sslEnabled")));
      }
    }

    return settingsBuilder.build();
  }

  private Filter filterFromJson(Map<String, Object> map) {
    if (map.containsKey("fieldPath")) {
      // Deserialize a FilterQuery
      String op = (String) map.get("op");
      FieldPath fieldPath = (FieldPath) map.get("fieldPath");
      Object value = map.get("value");

      // All the operators from Firebase
      switch (op) {
        case "==":
          return Filter.equalTo(fieldPath, value);
        case "!=":
          return Filter.notEqualTo(fieldPath, value);
        case "<":
          return Filter.lessThan(fieldPath, value);
        case "<=":
          return Filter.lessThanOrEqualTo(fieldPath, value);
        case ">":
          return Filter.greaterThan(fieldPath, value);
        case ">=":
          return Filter.greaterThanOrEqualTo(fieldPath, value);
        case "array-contains":
          return Filter.arrayContains(fieldPath, value);
        case "array-contains-any":
          return Filter.arrayContainsAny(fieldPath, (List<? extends Object>) value);
        case "in":
          return Filter.inArray(fieldPath, (List<? extends Object>) value);
        case "not-in":
          return Filter.notInArray(fieldPath, (List<? extends Object>) value);
        default:
          throw new Error("Invalid operator");
      }
    }
    // Deserialize a FilterOperator
    String op = (String) map.get("op");
    @SuppressWarnings("unchecked")
    List<Map<String, Object>> queries = (List<Map<String, Object>>) map.get("queries");

    // Map queries recursively
    ArrayList<Filter> parsedFilters = new ArrayList<>();
    for (Map<String, Object> query : queries) {
      parsedFilters.add(filterFromJson(query));
    }

    if (op.equals("OR")) {
      return Filter.or(parsedFilters.toArray(new Filter[0]));
    } else if (op.equals("AND")) {
      return Filter.and(parsedFilters.toArray(new Filter[0]));
    }

    throw new Error("Invalid operator");
  }

  private Query readFirestoreQuery(ByteBuffer buffer) {
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> values = (Map<String, Object>) readValue(buffer);
      FirebaseFirestore firestore =
          (FirebaseFirestore) Objects.requireNonNull(values.get("firestore"));

      String path = (String) Objects.requireNonNull(values.get("path"));
      boolean isCollectionGroup = (boolean) values.get("isCollectionGroup");
      @SuppressWarnings("unchecked")
      Map<String, Object> parameters = (Map<String, Object>) values.get("parameters");

      Query query;
      if (isCollectionGroup) {
        query = firestore.collectionGroup(path);
      } else {
        query = firestore.collection(path);
      }

      if (parameters == null) return query;

      boolean isFilterQuery = parameters.containsKey("filters");
      if (isFilterQuery) {
        @SuppressWarnings("unchecked")
        Filter filter =
            filterFromJson((Map<String, Object>) Objects.requireNonNull(parameters.get("filters")));
        query = query.where(filter);
      }

      // "where" filters
      @SuppressWarnings("unchecked")
      List<List<Object>> filters =
          (List<List<Object>>) Objects.requireNonNull(parameters.get("where"));
      for (List<Object> condition : filters) {
        FieldPath fieldPath = (FieldPath) condition.get(0);
        String operator = (String) condition.get(1);
        Object value = condition.get(2);

        if ("==".equals(operator)) {
          query = query.whereEqualTo(fieldPath, value);
        } else if ("!=".equals(operator)) {
          query = query.whereNotEqualTo(fieldPath, value);
        } else if ("<".equals(operator)) {
          query = query.whereLessThan(fieldPath, value);
        } else if ("<=".equals(operator)) {
          query = query.whereLessThanOrEqualTo(fieldPath, value);
        } else if (">".equals(operator)) {
          query = query.whereGreaterThan(fieldPath, value);
        } else if (">=".equals(operator)) {
          query = query.whereGreaterThanOrEqualTo(fieldPath, value);
        } else if ("array-contains".equals(operator)) {
          query = query.whereArrayContains(fieldPath, value);
        } else if ("array-contains-any".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereArrayContainsAny(fieldPath, listValues);
        } else if ("in".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereIn(fieldPath, listValues);
        } else if ("not-in".equals(operator)) {
          @SuppressWarnings("unchecked")
          List<Object> listValues = (List<Object>) value;
          query = query.whereNotIn(fieldPath, listValues);
        } else {
          Log.w(
              "FLTFirestoreMsgCodec",
              "An invalid query operator " + operator + " was received but not handled.");
        }
      }

      // "limit" filters
      Number limit = (Number) parameters.get("limit");
      if (limit != null) query = query.limit(limit.longValue());

      Number limitToLast = (Number) parameters.get("limitToLast");
      if (limitToLast != null) query = query.limitToLast(limitToLast.longValue());

      // "orderBy" filters
      @SuppressWarnings("unchecked")
      List<List<Object>> orderBy = (List<List<Object>>) parameters.get("orderBy");
      if (orderBy == null) return query;

      for (List<Object> order : orderBy) {
        FieldPath fieldPath = (FieldPath) order.get(0);
        boolean descending = (boolean) order.get(1);

        Query.Direction direction =
            descending ? Query.Direction.DESCENDING : Query.Direction.ASCENDING;

        query = query.orderBy(fieldPath, direction);
      }

      // cursor queries
      @SuppressWarnings("unchecked")
      List<Object> startAt = (List<Object>) parameters.get("startAt");
      if (startAt != null) query = query.startAt(Objects.requireNonNull(startAt.toArray()));

      @SuppressWarnings("unchecked")
      List<Object> startAfter = (List<Object>) parameters.get("startAfter");
      if (startAfter != null)
        query = query.startAfter(Objects.requireNonNull(startAfter.toArray()));

      @SuppressWarnings("unchecked")
      List<Object> endAt = (List<Object>) parameters.get("endAt");
      if (endAt != null) query = query.endAt(Objects.requireNonNull(endAt.toArray()));

      @SuppressWarnings("unchecked")
      List<Object> endBefore = (List<Object>) parameters.get("endBefore");
      if (endBefore != null) query = query.endBefore(Objects.requireNonNull(endBefore.toArray()));

      return query;
    } catch (Exception exception) {
      Log.e(
          "FLTFirestoreMsgCodec",
          "An error occurred while parsing query arguments, this is most likely an error with this SDK.",
          exception);
      return null;
    }
  }

  private Object[] toArray(Object source) {
    if (source instanceof List) {
      return ((List<?>) source).toArray();
    }

    if (source == null) {
      return new ArrayList<>().toArray();
    }

    String sourceType = source.getClass().getCanonicalName();
    String message = "java.util.List was expected, unable to convert '%s' to an object array";
    throw new IllegalArgumentException(String.format(message, sourceType));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestorePlugin.java

**크기**: 39186 bytes | **라인 수**: 980 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import static com.google.firebase.firestore.AggregateField.average;
import static com.google.firebase.firestore.AggregateField.count;
import static com.google.firebase.firestore.AggregateField.sum;

import android.app.Activity;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.TaskCompletionSource;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.FirebaseApp;
import com.google.firebase.firestore.AggregateField;
import com.google.firebase.firestore.AggregateQuery;
import com.google.firebase.firestore.AggregateQuerySnapshot;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FieldPath;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.FirebaseFirestoreSettings;
import com.google.firebase.firestore.MemoryCacheSettings;
import com.google.firebase.firestore.PersistentCacheIndexManager;
import com.google.firebase.firestore.PersistentCacheSettings;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;
import com.google.firebase.firestore.SetOptions;
import com.google.firebase.firestore.Source;
import com.google.firebase.firestore.Transaction;
import com.google.firebase.firestore.WriteBatch;
import io.flutter.embedding.engine.plugins.FlutterPlugin;
import io.flutter.embedding.engine.plugins.activity.ActivityAware;
import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.EventChannel;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import io.flutter.plugin.common.StandardMethodCodec;
import io.flutter.plugins.firebase.core.FlutterFirebasePlugin;
import io.flutter.plugins.firebase.core.FlutterFirebasePluginRegistry;
import io.flutter.plugins.firebase.firestore.streamhandler.DocumentSnapshotsStreamHandler;
import io.flutter.plugins.firebase.firestore.streamhandler.LoadBundleStreamHandler;
import io.flutter.plugins.firebase.firestore.streamhandler.OnTransactionResultListener;
import io.flutter.plugins.firebase.firestore.streamhandler.QuerySnapshotsStreamHandler;
import io.flutter.plugins.firebase.firestore.streamhandler.SnapshotsInSyncStreamHandler;
import io.flutter.plugins.firebase.firestore.streamhandler.TransactionStreamHandler;
import io.flutter.plugins.firebase.firestore.utils.ExceptionConverter;
import io.flutter.plugins.firebase.firestore.utils.PigeonParser;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicReference;

public class FlutterFirebaseFirestorePlugin
    implements FlutterFirebasePlugin,
        FlutterPlugin,
        ActivityAware,
        GeneratedAndroidFirebaseFirestore.FirebaseFirestoreHostApi {
  protected static final HashMap<FirebaseFirestore, FlutterFirebaseFirestoreExtension>
      firestoreInstanceCache = new HashMap<>();
  public static final String TAG = "FlutterFirestorePlugin";
  public static final String DEFAULT_ERROR_CODE = "firebase_firestore";

  private static final String METHOD_CHANNEL_NAME = "plugins.flutter.io/firebase_firestore";

  final StandardMethodCodec MESSAGE_CODEC =
      new StandardMethodCodec(
          io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestoreMessageCodec.INSTANCE);

  private BinaryMessenger binaryMessenger;

  private final AtomicReference<Activity> activity = new AtomicReference<>(null);

  private final Map<String, Transaction> transactions = new HashMap<>();
  private final Map<String, EventChannel> eventChannels = new HashMap<>();
  private final Map<String, StreamHandler> streamHandlers = new HashMap<>();
  private final Map<String, OnTransactionResultListener> transactionHandlers = new HashMap<>();

  // Used in the decoder to know which ServerTimestampBehavior to use
  public static final Map<Integer, DocumentSnapshot.ServerTimestampBehavior>
      serverTimestampBehaviorHashMap = new HashMap<>();

  protected static FlutterFirebaseFirestoreExtension getCachedFirebaseFirestoreInstanceForKey(
      FirebaseFirestore firestore) {
    synchronized (firestoreInstanceCache) {
      return firestoreInstanceCache.get(firestore);
    }
  }

  protected static void setCachedFirebaseFirestoreInstanceForKey(
      FirebaseFirestore firestore, String databaseURL) {
    synchronized (firestoreInstanceCache) {
      FlutterFirebaseFirestoreExtension existingInstance = firestoreInstanceCache.get(firestore);
      if (existingInstance == null) {
        firestoreInstanceCache.put(
            firestore, new FlutterFirebaseFirestoreExtension(firestore, databaseURL));
      }
    }
  }

  protected static FirebaseFirestore getFirestoreInstanceByNameAndDatabaseUrl(
      String appName, String databaseURL) {
    synchronized (firestoreInstanceCache) {
      for (Map.Entry<FirebaseFirestore, FlutterFirebaseFirestoreExtension> entry :
          firestoreInstanceCache.entrySet()) {
        if (entry.getValue().getInstance().getApp().getName().equals(appName)
            && entry.getValue().getDatabaseURL().equals(databaseURL)) {
          return entry.getKey();
        }
      }
    }
    return null;
  }

  private static void destroyCachedFirebaseFirestoreInstanceForKey(FirebaseFirestore firestore) {
    synchronized (firestoreInstanceCache) {
      FlutterFirebaseFirestoreExtension existingInstance = firestoreInstanceCache.get(firestore);
      if (existingInstance != null) {
        firestoreInstanceCache.remove(firestore);
      }
    }
  }

  @Override
  public void onAttachedToEngine(@NonNull FlutterPluginBinding binding) {
    initInstance(binding.getBinaryMessenger());
  }

  @Override
  public void onDetachedFromEngine(@NonNull FlutterPluginBinding binding) {
    removeEventListeners();

    binaryMessenger = null;
  }

  @Override
  public void onAttachedToActivity(@NonNull ActivityPluginBinding activityPluginBinding) {
    attachToActivity(activityPluginBinding);
  }

  @Override
  public void onDetachedFromActivityForConfigChanges() {
    detachToActivity();
  }

  @Override
  public void onReattachedToActivityForConfigChanges(
      @NonNull ActivityPluginBinding activityPluginBinding) {
    attachToActivity(activityPluginBinding);
  }

  @Override
  public void onDetachedFromActivity() {
    detachToActivity();
  }

  private void attachToActivity(ActivityPluginBinding activityPluginBinding) {
    activity.set(activityPluginBinding.getActivity());
  }

  private void detachToActivity() {
    activity.set(null);
  }

  private void initInstance(BinaryMessenger messenger) {
    binaryMessenger = messenger;

    FlutterFirebasePluginRegistry.registerPlugin(METHOD_CHANNEL_NAME, this);

    GeneratedAndroidFirebaseFirestore.FirebaseFirestoreHostApi.setup(binaryMessenger, this);
  }

  @Override
  public Task<Map<String, Object>> getPluginConstantsForFirebaseApp(FirebaseApp firebaseApp) {
    TaskCompletionSource<Map<String, Object>> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  @Override
  public Task<Void> didReinitializeFirebaseCore() {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            // Context is ignored by API so we don't send it over even though annotated non-null.
            synchronized (firestoreInstanceCache) {
              for (Map.Entry<FirebaseFirestore, FlutterFirebaseFirestoreExtension> entry :
                  firestoreInstanceCache.entrySet()) {
                FirebaseFirestore firestore = entry.getKey();
                Tasks.await(firestore.terminate());
                FlutterFirebaseFirestorePlugin.destroyCachedFirebaseFirestoreInstanceForKey(
                    firestore);
              }
            }
            removeEventListeners();

            taskCompletionSource.setResult(null);

          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  /**
   * Registers a unique event channel based on a channel prefix.
   *
   * <p>Once registered, the plugin will take care of removing the stream handler and cleaning up,
   * if the engine is detached.
   *
   * <p>This function generates a random ID.
   *
   * @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
   *     "namespace/component" whereas the last / is added internally.
   * @param handler The handler object for responding to channel events and submitting data.
   * @return The generated identifier.
   * @see #registerEventChannel(String, String, StreamHandler)
   */
  private String registerEventChannel(String prefix, StreamHandler handler) {
    String identifier = UUID.randomUUID().toString().toLowerCase(Locale.US);
    return registerEventChannel(prefix, identifier, handler);
  }

  /**
   * Registers a unique event channel based on a channel prefix.
   *
   * <p>Once registered, the plugin will take care of removing the stream handler and cleaning up,
   * if the engine is detached.
   *
   * @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
   *     "namespace/component" whereas the last / is added internally.
   * @param identifier A identifier which will be appended to the prefix.
   * @param handler The handler object for responding to channel events and submitting data.
   * @return The passed identifier.
   */
  private String registerEventChannel(String prefix, String identifier, StreamHandler handler) {
    final String channelName = prefix + "/" + identifier;

    EventChannel channel = new EventChannel(binaryMessenger, channelName, MESSAGE_CODEC);
    channel.setStreamHandler(handler);
    eventChannels.put(identifier, channel);
    streamHandlers.put(identifier, handler);

    return identifier;
  }

  private void removeEventListeners() {
    synchronized (eventChannels) {
      for (String identifier : eventChannels.keySet()) {
        Objects.requireNonNull(eventChannels.get(identifier)).setStreamHandler(null);
      }
      eventChannels.clear();
    }

    synchronized (streamHandlers) {
      for (String identifier : streamHandlers.keySet()) {
        Objects.requireNonNull(streamHandlers.get(identifier)).onCancel(null);
      }
      streamHandlers.clear();
    }

    transactionHandlers.clear();
  }

  static FirebaseFirestoreSettings getSettingsFromPigeon(
      GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp pigeonApp) {
    FirebaseFirestoreSettings.Builder builder = new FirebaseFirestoreSettings.Builder();
    if (pigeonApp.getSettings().getHost() != null) {
      builder.setHost(pigeonApp.getSettings().getHost());
    }
    if (pigeonApp.getSettings().getSslEnabled() != null) {
      builder.setSslEnabled(pigeonApp.getSettings().getSslEnabled());
    }
    if (pigeonApp.getSettings().getPersistenceEnabled() != null) {
      if (pigeonApp.getSettings().getPersistenceEnabled()) {
        Long receivedCacheSizeBytes = pigeonApp.getSettings().getCacheSizeBytes();
        // This is the maximum amount of cache allowed:
        // https://firebase.google.com/docs/firestore/manage-data/enable-offline#configure_cache_size
        long cacheSizeBytes = 104857600L;
        if (receivedCacheSizeBytes != null && receivedCacheSizeBytes != -1) {
          cacheSizeBytes = receivedCacheSizeBytes;
        }
        builder.setLocalCacheSettings(
            PersistentCacheSettings.newBuilder().setSizeBytes(cacheSizeBytes).build());
      } else {
        builder.setLocalCacheSettings(MemoryCacheSettings.newBuilder().build());
      }
    }
    return builder.build();
  }

  public static FirebaseFirestore getFirestoreFromPigeon(
      GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp pigeonApp) {
    synchronized (FlutterFirebaseFirestorePlugin.firestoreInstanceCache) {
      FirebaseFirestore cachedFirestoreInstance =
          FlutterFirebaseFirestorePlugin.getFirestoreInstanceByNameAndDatabaseUrl(
              pigeonApp.getAppName(), pigeonApp.getDatabaseURL());
      if (cachedFirestoreInstance != null) {
        return cachedFirestoreInstance;
      }

      FirebaseApp app = FirebaseApp.getInstance(pigeonApp.getAppName());
      FirebaseFirestore firestore = FirebaseFirestore.getInstance(app, pigeonApp.getDatabaseURL());
      firestore.setFirestoreSettings(getSettingsFromPigeon(pigeonApp));

      FlutterFirebaseFirestorePlugin.setCachedFirebaseFirestoreInstanceForKey(
          firestore, pigeonApp.getDatabaseURL());
      return firestore;
    }
  }

  @Override
  public void loadBundle(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull byte[] bundle,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<String> result) {
    result.success(
        registerEventChannel(
            METHOD_CHANNEL_NAME + "/loadBundle",
            new LoadBundleStreamHandler(getFirestoreFromPigeon(app), bundle)));
  }

  @Override
  public void namedQueryGet(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String name,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonGetOptions options,
      @NonNull
          GeneratedAndroidFirebaseFirestore.Result<
                  GeneratedAndroidFirebaseFirestore.PigeonQuerySnapshot>
              result) {

    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Query query = Tasks.await(firestore.getNamedQuery(name));

            if (query == null) {
              result.error(
                  new NullPointerException(
                      "Named query has not been found. Please check it has been loaded properly via loadBundle()."));
              return;
            }

            final QuerySnapshot querySnapshot =
                Tasks.await(query.get(PigeonParser.parsePigeonSource(options.getSource())));

            result.success(
                PigeonParser.toPigeonQuerySnapshot(
                    querySnapshot,
                    PigeonParser.parsePigeonServerTimestampBehavior(
                        options.getServerTimestampBehavior())));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void clearPersistence(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.clearPersistence());
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void disableNetwork(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.disableNetwork());
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void enableNetwork(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.enableNetwork());
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void terminate(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.terminate());
            destroyCachedFirebaseFirestoreInstanceForKey(firestore);
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void waitForPendingWrites(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.waitForPendingWrites());
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  // Suppressed because we have already annotated the user facing Dart API as deprecated.
  @SuppressWarnings("deprecation")
  public void setIndexConfiguration(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String indexConfiguration,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            Tasks.await(firestore.setIndexConfiguration(indexConfiguration));

            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void persistenceCacheIndexManagerRequest(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.PersistenceCacheIndexManagerRequest request,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          PersistentCacheIndexManager indexManager =
              getFirestoreFromPigeon(app).getPersistentCacheIndexManager();
          if (indexManager != null) {
            switch (request) {
              case ENABLE_INDEX_AUTO_CREATION:
                indexManager.enableIndexAutoCreation();
                break;
              case DISABLE_INDEX_AUTO_CREATION:
                indexManager.disableIndexAutoCreation();
                break;
              case DELETE_ALL_INDEXES:
                indexManager.deleteAllIndexes();
                break;
            }
          } else {
            Log.d(TAG, "`PersistentCacheIndexManager` is not available.");
          }

          result.success(null);
        });
  }

  @Override
  public void setLoggingEnabled(
      @NonNull Boolean loggingEnabled,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore.setLoggingEnabled(loggingEnabled);

            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void snapshotsInSyncSetup(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<String> result) {
    FirebaseFirestore firestore = getFirestoreFromPigeon(app);

    result.success(
        registerEventChannel(
            METHOD_CHANNEL_NAME + "/snapshotsInSync", new SnapshotsInSyncStreamHandler(firestore)));
  }

  @Override
  public void transactionCreate(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull Long timeout,
      @NonNull Long maxAttempts,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<String> result) {
    FirebaseFirestore firestore = getFirestoreFromPigeon(app);

    final String transactionId = UUID.randomUUID().toString().toLowerCase(Locale.US);
    final TransactionStreamHandler handler =
        new TransactionStreamHandler(
            transaction -> transactions.put(transactionId, transaction),
            firestore,
            transactionId,
            timeout,
            maxAttempts);

    registerEventChannel(METHOD_CHANNEL_NAME + "/transaction", transactionId, handler);
    transactionHandlers.put(transactionId, handler);
    result.success(transactionId);
  }

  @Override
  public void transactionStoreResult(
      @NonNull String transactionId,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonTransactionResult resultType,
      @Nullable List<GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand> commands,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    Objects.requireNonNull(transactionHandlers.get(transactionId))
        .receiveTransactionResponse(resultType, commands);
    result.success(null);
  }

  @Override
  public void transactionGet(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String transactionId,
      @NonNull String path,
      @NonNull
          GeneratedAndroidFirebaseFirestore.Result<
                  GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot>
              result) {
    cachedThreadPool.execute(
        () -> {
          try {
            DocumentReference documentReference = getFirestoreFromPigeon(app).document(path);

            Transaction transaction = transactions.get(transactionId);

            if (transaction == null) {
              result.error(
                  new Exception(
                      "Transaction.getDocument(): No transaction handler exists for ID: "
                          + transactionId));
              return;
            }

            result.success(
                PigeonParser.toPigeonDocumentSnapshot(
                    transaction.get(documentReference),
                    DocumentSnapshot.ServerTimestampBehavior.NONE));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void documentReferenceSet(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.DocumentReferenceRequest request,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            DocumentReference documentReference =
                getFirestoreFromPigeon(app).document(request.getPath());

            Map<Object, Object> data = Objects.requireNonNull(request.getData());

            Task<Void> setTask;

            assert request.getOption() != null;
            if (request.getOption().getMerge() != null && request.getOption().getMerge()) {
              setTask = documentReference.set(data, SetOptions.merge());
            } else if (request.getOption().getMergeFields() != null) {
              List<List<String>> fieldList =
                  Objects.requireNonNull(request.getOption().getMergeFields());
              List<FieldPath> fieldPathList = PigeonParser.parseFieldPath(fieldList);
              setTask = documentReference.set(data, SetOptions.mergeFieldPaths(fieldPathList));
            } else {
              setTask = documentReference.set(data);
            }

            result.success(Tasks.await(setTask));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void documentReferenceUpdate(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.DocumentReferenceRequest request,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            DocumentReference documentReference =
                getFirestoreFromPigeon(app).document(request.getPath());
            Map<Object, Object> dataWithString = Objects.requireNonNull(request.getData());

            Map<FieldPath, Object> data = new HashMap<>();
            for (Object key : dataWithString.keySet()) {
              if (key instanceof String) {
                data.put(FieldPath.of((String) key), dataWithString.get(key));
              } else if (key instanceof FieldPath) {
                data.put((FieldPath) key, dataWithString.get(key));
              } else {
                throw new IllegalArgumentException(
                    "Invalid key type in update data. Supported types are String and FieldPath.");
              }
            }

            // Due to the signature of the function, I extract the first element of the map and
            // pass the rest of the map as an array of alternating keys and values.
            FieldPath firstFieldPath = data.keySet().iterator().next();
            Object firstObject = data.get(firstFieldPath);

            ArrayList<Object> flattenData = new ArrayList<>();
            for (FieldPath fieldPath : data.keySet()) {
              if (fieldPath.equals(firstFieldPath)) {
                continue;
              }
              flattenData.add(fieldPath);
              flattenData.add(data.get(fieldPath));
            }
            result.success(
                Tasks.await(
                    documentReference.update(firstFieldPath, firstObject, flattenData.toArray())));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void documentReferenceGet(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.DocumentReferenceRequest request,
      @NonNull
          GeneratedAndroidFirebaseFirestore.Result<
                  GeneratedAndroidFirebaseFirestore.PigeonDocumentSnapshot>
              result) {
    cachedThreadPool.execute(
        () -> {
          try {
            assert request.getSource() != null;
            Source source = PigeonParser.parsePigeonSource(request.getSource());
            DocumentReference documentReference =
                getFirestoreFromPigeon(app).document(request.getPath());

            final DocumentSnapshot documentSnapshot = Tasks.await(documentReference.get(source));

            assert request.getServerTimestampBehavior() != null;
            result.success(
                PigeonParser.toPigeonDocumentSnapshot(
                    documentSnapshot,
                    PigeonParser.parsePigeonServerTimestampBehavior(
                        request.getServerTimestampBehavior())));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void documentReferenceDelete(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.DocumentReferenceRequest request,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            DocumentReference documentReference =
                getFirestoreFromPigeon(app).document(request.getPath());

            result.success(Tasks.await(documentReference.delete()));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void queryGet(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String path,
      @NonNull Boolean isCollectionGroup,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonQueryParameters parameters,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonGetOptions options,
      @NonNull
          GeneratedAndroidFirebaseFirestore.Result<
                  GeneratedAndroidFirebaseFirestore.PigeonQuerySnapshot>
              result) {
    cachedThreadPool.execute(
        () -> {
          try {
            Source source = PigeonParser.parsePigeonSource(options.getSource());
            Query query =
                PigeonParser.parseQuery(
                    getFirestoreFromPigeon(app), path, isCollectionGroup, parameters);

            if (query == null) {
              result.error(
                  new GeneratedAndroidFirebaseFirestore.FlutterError(
                      "invalid_query",
                      "An error occurred while parsing query arguments, see native logs for more information. Please report this issue.",
                      null));
              return;
            }
            final QuerySnapshot querySnapshot = Tasks.await(query.get(source));

            result.success(
                PigeonParser.toPigeonQuerySnapshot(
                    querySnapshot,
                    PigeonParser.parsePigeonServerTimestampBehavior(
                        options.getServerTimestampBehavior())));
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void aggregateQuery(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String path,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonQueryParameters parameters,
      @NonNull GeneratedAndroidFirebaseFirestore.AggregateSource source,
      @NonNull List<GeneratedAndroidFirebaseFirestore.AggregateQuery> queries,
      @NonNull Boolean isCollectionGroup,
      @NonNull
          GeneratedAndroidFirebaseFirestore.Result<
                  List<GeneratedAndroidFirebaseFirestore.AggregateQueryResponse>>
              result) {
    Query query =
        PigeonParser.parseQuery(getFirestoreFromPigeon(app), path, isCollectionGroup, parameters);

    AggregateQuery aggregateQuery;
    ArrayList<AggregateField> aggregateFields = new ArrayList<>();

    for (GeneratedAndroidFirebaseFirestore.AggregateQuery queryRequest : queries) {
      switch (queryRequest.getType()) {
        case COUNT:
          aggregateFields.add(count());
          break;
        case SUM:
          assert queryRequest.getField() != null;
          aggregateFields.add(sum(queryRequest.getField()));
          break;
        case AVERAGE:
          assert queryRequest.getField() != null;
          aggregateFields.add(average(queryRequest.getField()));
          break;
      }
    }

    assert query != null;
    aggregateQuery =
        query.aggregate(
            aggregateFields.get(0),
            aggregateFields.subList(1, aggregateFields.size()).toArray(new AggregateField[0]));

    cachedThreadPool.execute(
        () -> {
          try {
            AggregateQuerySnapshot aggregateQuerySnapshot =
                Tasks.await(aggregateQuery.get(PigeonParser.parseAggregateSource(source)));

            ArrayList<GeneratedAndroidFirebaseFirestore.AggregateQueryResponse> aggregateResponse =
                new ArrayList<>();
            for (GeneratedAndroidFirebaseFirestore.AggregateQuery queryRequest : queries) {
              switch (queryRequest.getType()) {
                case COUNT:
                  GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder builder =
                      new GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder();
                  builder.setType(GeneratedAndroidFirebaseFirestore.AggregateType.COUNT);
                  builder.setValue((double) aggregateQuerySnapshot.getCount());

                  aggregateResponse.add(builder.build());
                  break;
                case SUM:
                  assert queryRequest.getField() != null;
                  GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder builderSum =
                      new GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder();
                  builderSum.setType(GeneratedAndroidFirebaseFirestore.AggregateType.SUM);
                  builderSum.setValue(
                      ((Number)
                              Objects.requireNonNull(
                                  aggregateQuerySnapshot.get(sum(queryRequest.getField()))))
                          .doubleValue());
                  builderSum.setField(queryRequest.getField());

                  aggregateResponse.add(builderSum.build());
                  break;
                case AVERAGE:
                  assert queryRequest.getField() != null;
                  GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder builderAverage =
                      new GeneratedAndroidFirebaseFirestore.AggregateQueryResponse.Builder();
                  builderAverage.setType(GeneratedAndroidFirebaseFirestore.AggregateType.AVERAGE);
                  builderAverage.setValue(
                      aggregateQuerySnapshot.get(average(queryRequest.getField())));
                  builderAverage.setField(queryRequest.getField());

                  aggregateResponse.add(builderAverage.build());
                  break;
              }
            }

            result.success(aggregateResponse);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void writeBatchCommit(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull List<GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand> writes,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<Void> result) {
    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseFirestore firestore = getFirestoreFromPigeon(app);
            WriteBatch batch = firestore.batch();

            for (GeneratedAndroidFirebaseFirestore.PigeonTransactionCommand write : writes) {
              GeneratedAndroidFirebaseFirestore.PigeonTransactionType type =
                  Objects.requireNonNull(write.getType());
              String path = Objects.requireNonNull(write.getPath());
              Map<String, Object> data = write.getData();

              DocumentReference documentReference = firestore.document(path);

              switch (type) {
                case DELETE_TYPE:
                  batch = batch.delete(documentReference);
                  break;
                case UPDATE:
                  batch = batch.update(documentReference, Objects.requireNonNull(data));
                  break;
                case SET:
                  GeneratedAndroidFirebaseFirestore.PigeonDocumentOption options =
                      Objects.requireNonNull(write.getOption());

                  if (options.getMerge() != null && options.getMerge()) {
                    batch =
                        batch.set(
                            documentReference, Objects.requireNonNull(data), SetOptions.merge());
                  } else if (options.getMergeFields() != null) {
                    List<FieldPath> fieldPathList =
                        PigeonParser.parseFieldPath(
                            Objects.requireNonNull(options.getMergeFields()));
                    batch =
                        batch.set(
                            documentReference,
                            Objects.requireNonNull(data),
                            SetOptions.mergeFieldPaths(fieldPathList));
                  } else {
                    batch = batch.set(documentReference, Objects.requireNonNull(data));
                  }
                  break;
              }
            }

            Tasks.await(batch.commit());
            result.success(null);
          } catch (Exception e) {
            ExceptionConverter.sendErrorToFlutter(result, e);
          }
        });
  }

  @Override
  public void querySnapshot(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull String path,
      @NonNull Boolean isCollectionGroup,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonQueryParameters parameters,
      @NonNull GeneratedAndroidFirebaseFirestore.PigeonGetOptions options,
      @NonNull Boolean includeMetadataChanges,
      @NonNull GeneratedAndroidFirebaseFirestore.ListenSource source,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<String> result) {
    Query query =
        PigeonParser.parseQuery(getFirestoreFromPigeon(app), path, isCollectionGroup, parameters);

    if (query == null) {
      result.error(
          new GeneratedAndroidFirebaseFirestore.FlutterError(
              "invalid_query",
              "An error occurred while parsing query arguments, see native logs for more information. Please report this issue.",
              null));
      return;
    }

    result.success(
        registerEventChannel(
            METHOD_CHANNEL_NAME + "/query",
            new QuerySnapshotsStreamHandler(
                query,
                includeMetadataChanges,
                PigeonParser.parsePigeonServerTimestampBehavior(
                    options.getServerTimestampBehavior()),
                PigeonParser.parseListenSource(source))));
  }

  @Override
  public void documentReferenceSnapshot(
      @NonNull GeneratedAndroidFirebaseFirestore.FirestorePigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseFirestore.DocumentReferenceRequest parameters,
      @NonNull Boolean includeMetadataChanges,
      @NonNull GeneratedAndroidFirebaseFirestore.ListenSource source,
      @NonNull GeneratedAndroidFirebaseFirestore.Result<String> result) {
    FirebaseFirestore firestore = getFirestoreFromPigeon(app);
    DocumentReference documentReference =
        getFirestoreFromPigeon(app).document(parameters.getPath());

    result.success(
        registerEventChannel(
            METHOD_CHANNEL_NAME + "/document",
            new DocumentSnapshotsStreamHandler(
                firestore,
                documentReference,
                includeMetadataChanges,
                PigeonParser.parsePigeonServerTimestampBehavior(
                    parameters.getServerTimestampBehavior()),
                PigeonParser.parseListenSource(source))));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestoreRegistrar.java

**크기**: 756 bytes | **라인 수**: 22 | **타입**: text

```
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import androidx.annotation.Keep;
import com.google.firebase.components.Component;
import com.google.firebase.components.ComponentRegistrar;
import com.google.firebase.platforminfo.LibraryVersionComponent;
import java.util.Collections;
import java.util.List;

@Keep
public class FlutterFirebaseFirestoreRegistrar implements ComponentRegistrar {
  @Override
  public List<Component<?>> getComponents() {
    return Collections.singletonList(
        LibraryVersionComponent.create(BuildConfig.LIBRARY_NAME, BuildConfig.LIBRARY_VERSION));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/FlutterFirebaseFirestoreTransactionResult.java

**크기**: 914 bytes | **라인 수**: 30 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.firestore;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

public class FlutterFirebaseFirestoreTransactionResult {

  public final @Nullable Exception exception;

  private FlutterFirebaseFirestoreTransactionResult(@NonNull Exception failureException) {
    exception = failureException;
  }

  private FlutterFirebaseFirestoreTransactionResult() {
    exception = null;
  }

  public static FlutterFirebaseFirestoreTransactionResult failed(@NonNull Exception exception) {
    return new FlutterFirebaseFirestoreTransactionResult(exception);
  }

  public static FlutterFirebaseFirestoreTransactionResult complete() {
    return new FlutterFirebaseFirestoreTransactionResult();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/java/io/flutter/plugins/firebase/firestore/GeneratedAndroidFirebaseFirestore.java

**크기**: 91807 bytes | **라인 수**: 2630 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package io.flutter.plugins.firebase.firestore;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class GeneratedAndroidFirebaseFirestore {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
          "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  /** An enumeration of document change types. */
  public enum DocumentChangeType {
    /** Indicates a new document was added to the set of documents matching the query. */
    ADDED(0),
    /** Indicates a document within the query was modified. */
    MODIFIED(1),
    /**
     * Indicates a document within the query was removed (either deleted or no longer matches the
     * query.
     */
    REMOVED(2);

    final int index;

    private DocumentChangeType(final int index) {
      this.index = index;
    }
  }

  /** An enumeration of firestore source types. */
  public enum Source {
    /**
     * Causes Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall back
     * to returning cached data if the server can't be reached.
     */
    SERVER_AND_CACHE(0),
    /**
     * Causes Firestore to avoid the cache, generating an error if the server cannot be reached.
     * Note that the cache will still be updated if the server request succeeds. Also note that
     * latency-compensation still takes effect, so any pending write operations will be visible in
     * the returned data (merged into the server-provided data).
     */
    SERVER(1),
    /**
     * Causes Firestore to immediately return a value from the cache, ignoring the server completely
     * (implying that the returned value may be stale with respect to the value on the server). If
     * there is no data in the cache to satisfy the `get` call, [DocumentReference.get] will throw a
     * [FirebaseException] and [Query.get] will return an empty [QuerySnapshotPlatform] with no
     * documents.
     */
    CACHE(2);

    final int index;

    private Source(final int index) {
      this.index = index;
    }
  }

  /**
   * The listener retrieves data and listens to updates from the local Firestore cache only. If the
   * cache is empty, an empty snapshot will be returned. Snapshot events will be triggered on cache
   * updates, like local mutations or load bundles.
   *
   * <p>Note that the data might be stale if the cache hasn't synchronized with recent server-side
   * changes.
   */
  public enum ListenSource {
    /**
     * The default behavior. The listener attempts to return initial snapshot from cache and
     * retrieve up-to-date snapshots from the Firestore server. Snapshot events will be triggered on
     * local mutations and server side updates.
     */
    DEFAULT_SOURCE(0),
    /**
     * The listener retrieves data and listens to updates from the local Firestore cache only. If
     * the cache is empty, an empty snapshot will be returned. Snapshot events will be triggered on
     * cache updates, like local mutations or load bundles.
     */
    CACHE(1);

    final int index;

    private ListenSource(final int index) {
      this.index = index;
    }
  }

  public enum ServerTimestampBehavior {
    /** Return null for [FieldValue.serverTimestamp()] values that have not yet */
    NONE(0),
    /**
     * Return local estimates for [FieldValue.serverTimestamp()] values that have not yet been set
     * to their final value.
     */
    ESTIMATE(1),
    /**
     * Return the previous value for [FieldValue.serverTimestamp()] values that have not yet been
     * set to their final value.
     */
    PREVIOUS(2);

    final int index;

    private ServerTimestampBehavior(final int index) {
      this.index = index;
    }
  }

  /** [AggregateSource] represents the source of data for an [AggregateQuery]. */
  public enum AggregateSource {
    /** Indicates that the data should be retrieved from the server. */
    SERVER(0);

    final int index;

    private AggregateSource(final int index) {
      this.index = index;
    }
  }

  /**
   * [PersistenceCacheIndexManagerRequest] represents the request types for the persistence cache
   * index manager.
   */
  public enum PersistenceCacheIndexManagerRequest {
    ENABLE_INDEX_AUTO_CREATION(0),
    DISABLE_INDEX_AUTO_CREATION(1),
    DELETE_ALL_INDEXES(2);

    final int index;

    private PersistenceCacheIndexManagerRequest(final int index) {
      this.index = index;
    }
  }

  public enum PigeonTransactionResult {
    SUCCESS(0),
    FAILURE(1);

    final int index;

    private PigeonTransactionResult(final int index) {
      this.index = index;
    }
  }

  public enum PigeonTransactionType {
    GET(0),
    UPDATE(1),
    SET(2),
    DELETE_TYPE(3);

    final int index;

    private PigeonTransactionType(final int index) {
      this.index = index;
    }
  }

  public enum AggregateType {
    COUNT(0),
    SUM(1),
    AVERAGE(2);

    final int index;

    private AggregateType(final int index) {
      this.index = index;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonFirebaseSettings {
    private @Nullable Boolean persistenceEnabled;

    public @Nullable Boolean getPersistenceEnabled() {
      return persistenceEnabled;
    }

    public void setPersistenceEnabled(@Nullable Boolean setterArg) {
      this.persistenceEnabled = setterArg;
    }

    private @Nullable String host;

    public @Nullable String getHost() {
      return host;
    }

    public void setHost(@Nullable String setterArg) {
      this.host = setterArg;
    }

    private @Nullable Boolean sslEnabled;

    public @Nullable Boolean getSslEnabled() {
      return sslEnabled;
    }

    public void setSslEnabled(@Nullable Boolean setterArg) {
      this.sslEnabled = setterArg;
    }

    private @Nullable Long cacheSizeBytes;

    public @Nullable Long getCacheSizeBytes() {
      return cacheSizeBytes;
    }

    public void setCacheSizeBytes(@Nullable Long setterArg) {
      this.cacheSizeBytes = setterArg;
    }

    private @NonNull Boolean ignoreUndefinedProperties;

    public @NonNull Boolean getIgnoreUndefinedProperties() {
      return ignoreUndefinedProperties;
    }

    public void setIgnoreUndefinedProperties(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"ignoreUndefinedProperties\" is null.");
      }
      this.ignoreUndefinedProperties = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonFirebaseSettings() {}

    public static final class Builder {

      private @Nullable Boolean persistenceEnabled;

      public @NonNull Builder setPersistenceEnabled(@Nullable Boolean setterArg) {
        this.persistenceEnabled = setterArg;
        return this;
      }

      private @Nullable String host;

      public @NonNull Builder setHost(@Nullable String setterArg) {
        this.host = setterArg;
        return this;
      }

      private @Nullable Boolean sslEnabled;

      public @NonNull Builder setSslEnabled(@Nullable Boolean setterArg) {
        this.sslEnabled = setterArg;
        return this;
      }

      private @Nullable Long cacheSizeBytes;

      public @NonNull Builder setCacheSizeBytes(@Nullable Long setterArg) {
        this.cacheSizeBytes = setterArg;
        return this;
      }

      private @Nullable Boolean ignoreUndefinedProperties;

      public @NonNull Builder setIgnoreUndefinedProperties(@NonNull Boolean setterArg) {
        this.ignoreUndefinedProperties = setterArg;
        return this;
      }

      public @NonNull PigeonFirebaseSettings build() {
        PigeonFirebaseSettings pigeonReturn = new PigeonFirebaseSettings();
        pigeonReturn.setPersistenceEnabled(persistenceEnabled);
        pigeonReturn.setHost(host);
        pigeonReturn.setSslEnabled(sslEnabled);
        pigeonReturn.setCacheSizeBytes(cacheSizeBytes);
        pigeonReturn.setIgnoreUndefinedProperties(ignoreUndefinedProperties);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(persistenceEnabled);
      toListResult.add(host);
      toListResult.add(sslEnabled);
      toListResult.add(cacheSizeBytes);
      toListResult.add(ignoreUndefinedProperties);
      return toListResult;
    }

    static @NonNull PigeonFirebaseSettings fromList(@NonNull ArrayList<Object> list) {
      PigeonFirebaseSettings pigeonResult = new PigeonFirebaseSettings();
      Object persistenceEnabled = list.get(0);
      pigeonResult.setPersistenceEnabled((Boolean) persistenceEnabled);
      Object host = list.get(1);
      pigeonResult.setHost((String) host);
      Object sslEnabled = list.get(2);
      pigeonResult.setSslEnabled((Boolean) sslEnabled);
      Object cacheSizeBytes = list.get(3);
      pigeonResult.setCacheSizeBytes(
          (cacheSizeBytes == null)
              ? null
              : ((cacheSizeBytes instanceof Integer)
                  ? (Integer) cacheSizeBytes
                  : (Long) cacheSizeBytes));
      Object ignoreUndefinedProperties = list.get(4);
      pigeonResult.setIgnoreUndefinedProperties((Boolean) ignoreUndefinedProperties);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class FirestorePigeonFirebaseApp {
    private @NonNull String appName;

    public @NonNull String getAppName() {
      return appName;
    }

    public void setAppName(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"appName\" is null.");
      }
      this.appName = setterArg;
    }

    private @NonNull PigeonFirebaseSettings settings;

    public @NonNull PigeonFirebaseSettings getSettings() {
      return settings;
    }

    public void setSettings(@NonNull PigeonFirebaseSettings setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"settings\" is null.");
      }
      this.settings = setterArg;
    }

    private @NonNull String databaseURL;

    public @NonNull String getDatabaseURL() {
      return databaseURL;
    }

    public void setDatabaseURL(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"databaseURL\" is null.");
      }
      this.databaseURL = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    FirestorePigeonFirebaseApp() {}

    public static final class Builder {

      private @Nullable String appName;

      public @NonNull Builder setAppName(@NonNull String setterArg) {
        this.appName = setterArg;
        return this;
      }

      private @Nullable PigeonFirebaseSettings settings;

      public @NonNull Builder setSettings(@NonNull PigeonFirebaseSettings setterArg) {
        this.settings = setterArg;
        return this;
      }

      private @Nullable String databaseURL;

      public @NonNull Builder setDatabaseURL(@NonNull String setterArg) {
        this.databaseURL = setterArg;
        return this;
      }

      public @NonNull FirestorePigeonFirebaseApp build() {
        FirestorePigeonFirebaseApp pigeonReturn = new FirestorePigeonFirebaseApp();
        pigeonReturn.setAppName(appName);
        pigeonReturn.setSettings(settings);
        pigeonReturn.setDatabaseURL(databaseURL);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(appName);
      toListResult.add((settings == null) ? null : settings.toList());
      toListResult.add(databaseURL);
      return toListResult;
    }

    static @NonNull FirestorePigeonFirebaseApp fromList(@NonNull ArrayList<Object> list) {
      FirestorePigeonFirebaseApp pigeonResult = new FirestorePigeonFirebaseApp();
      Object appName = list.get(0);
      pigeonResult.setAppName((String) appName);
      Object settings = list.get(1);
      pigeonResult.setSettings(
          (settings == null)
              ? null
              : PigeonFirebaseSettings.fromList((ArrayList<Object>) settings));
      Object databaseURL = list.get(2);
      pigeonResult.setDatabaseURL((String) databaseURL);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonSnapshotMetadata {
    private @NonNull Boolean hasPendingWrites;

    public @NonNull Boolean getHasPendingWrites() {
      return hasPendingWrites;
    }

    public void setHasPendingWrites(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"hasPendingWrites\" is null.");
      }
      this.hasPendingWrites = setterArg;
    }

    private @NonNull Boolean isFromCache;

    public @NonNull Boolean getIsFromCache() {
      return isFromCache;
    }

    public void setIsFromCache(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"isFromCache\" is null.");
      }
      this.isFromCache = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonSnapshotMetadata() {}

    public static final class Builder {

      private @Nullable Boolean hasPendingWrites;

      public @NonNull Builder setHasPendingWrites(@NonNull Boolean setterArg) {
        this.hasPendingWrites = setterArg;
        return this;
      }

      private @Nullable Boolean isFromCache;

      public @NonNull Builder setIsFromCache(@NonNull Boolean setterArg) {
        this.isFromCache = setterArg;
        return this;
      }

      public @NonNull PigeonSnapshotMetadata build() {
        PigeonSnapshotMetadata pigeonReturn = new PigeonSnapshotMetadata();
        pigeonReturn.setHasPendingWrites(hasPendingWrites);
        pigeonReturn.setIsFromCache(isFromCache);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(hasPendingWrites);
      toListResult.add(isFromCache);
      return toListResult;
    }

    static @NonNull PigeonSnapshotMetadata fromList(@NonNull ArrayList<Object> list) {
      PigeonSnapshotMetadata pigeonResult = new PigeonSnapshotMetadata();
      Object hasPendingWrites = list.get(0);
      pigeonResult.setHasPendingWrites((Boolean) hasPendingWrites);
      Object isFromCache = list.get(1);
      pigeonResult.setIsFromCache((Boolean) isFromCache);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonDocumentSnapshot {
    private @NonNull String path;

    public @NonNull String getPath() {
      return path;
    }

    public void setPath(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"path\" is null.");
      }
      this.path = setterArg;
    }

    private @Nullable Map<String, Object> data;

    public @Nullable Map<String, Object> getData() {
      return data;
    }

    public void setData(@Nullable Map<String, Object> setterArg) {
      this.data = setterArg;
    }

    private @NonNull PigeonSnapshotMetadata metadata;

    public @NonNull PigeonSnapshotMetadata getMetadata() {
      return metadata;
    }

    public void setMetadata(@NonNull PigeonSnapshotMetadata setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"metadata\" is null.");
      }
      this.metadata = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonDocumentSnapshot() {}

    public static final class Builder {

      private @Nullable String path;

      public @NonNull Builder setPath(@NonNull String setterArg) {
        this.path = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> data;

      public @NonNull Builder setData(@Nullable Map<String, Object> setterArg) {
        this.data = setterArg;
        return this;
      }

      private @Nullable PigeonSnapshotMetadata metadata;

      public @NonNull Builder setMetadata(@NonNull PigeonSnapshotMetadata setterArg) {
        this.metadata = setterArg;
        return this;
      }

      public @NonNull PigeonDocumentSnapshot build() {
        PigeonDocumentSnapshot pigeonReturn = new PigeonDocumentSnapshot();
        pigeonReturn.setPath(path);
        pigeonReturn.setData(data);
        pigeonReturn.setMetadata(metadata);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(path);
      toListResult.add(data);
      toListResult.add((metadata == null) ? null : metadata.toList());
      return toListResult;
    }

    static @NonNull PigeonDocumentSnapshot fromList(@NonNull ArrayList<Object> list) {
      PigeonDocumentSnapshot pigeonResult = new PigeonDocumentSnapshot();
      Object path = list.get(0);
      pigeonResult.setPath((String) path);
      Object data = list.get(1);
      pigeonResult.setData((Map<String, Object>) data);
      Object metadata = list.get(2);
      pigeonResult.setMetadata(
          (metadata == null)
              ? null
              : PigeonSnapshotMetadata.fromList((ArrayList<Object>) metadata));
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonDocumentChange {
    private @NonNull DocumentChangeType type;

    public @NonNull DocumentChangeType getType() {
      return type;
    }

    public void setType(@NonNull DocumentChangeType setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    private @NonNull PigeonDocumentSnapshot document;

    public @NonNull PigeonDocumentSnapshot getDocument() {
      return document;
    }

    public void setDocument(@NonNull PigeonDocumentSnapshot setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"document\" is null.");
      }
      this.document = setterArg;
    }

    private @NonNull Long oldIndex;

    public @NonNull Long getOldIndex() {
      return oldIndex;
    }

    public void setOldIndex(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"oldIndex\" is null.");
      }
      this.oldIndex = setterArg;
    }

    private @NonNull Long newIndex;

    public @NonNull Long getNewIndex() {
      return newIndex;
    }

    public void setNewIndex(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"newIndex\" is null.");
      }
      this.newIndex = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonDocumentChange() {}

    public static final class Builder {

      private @Nullable DocumentChangeType type;

      public @NonNull Builder setType(@NonNull DocumentChangeType setterArg) {
        this.type = setterArg;
        return this;
      }

      private @Nullable PigeonDocumentSnapshot document;

      public @NonNull Builder setDocument(@NonNull PigeonDocumentSnapshot setterArg) {
        this.document = setterArg;
        return this;
      }

      private @Nullable Long oldIndex;

      public @NonNull Builder setOldIndex(@NonNull Long setterArg) {
        this.oldIndex = setterArg;
        return this;
      }

      private @Nullable Long newIndex;

      public @NonNull Builder setNewIndex(@NonNull Long setterArg) {
        this.newIndex = setterArg;
        return this;
      }

      public @NonNull PigeonDocumentChange build() {
        PigeonDocumentChange pigeonReturn = new PigeonDocumentChange();
        pigeonReturn.setType(type);
        pigeonReturn.setDocument(document);
        pigeonReturn.setOldIndex(oldIndex);
        pigeonReturn.setNewIndex(newIndex);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(type == null ? null : type.index);
      toListResult.add((document == null) ? null : document.toList());
      toListResult.add(oldIndex);
      toListResult.add(newIndex);
      return toListResult;
    }

    static @NonNull PigeonDocumentChange fromList(@NonNull ArrayList<Object> list) {
      PigeonDocumentChange pigeonResult = new PigeonDocumentChange();
      Object type = list.get(0);
      pigeonResult.setType(DocumentChangeType.values()[(int) type]);
      Object document = list.get(1);
      pigeonResult.setDocument(
          (document == null)
              ? null
              : PigeonDocumentSnapshot.fromList((ArrayList<Object>) document));
      Object oldIndex = list.get(2);
      pigeonResult.setOldIndex(
          (oldIndex == null)
              ? null
              : ((oldIndex instanceof Integer) ? (Integer) oldIndex : (Long) oldIndex));
      Object newIndex = list.get(3);
      pigeonResult.setNewIndex(
          (newIndex == null)
              ? null
              : ((newIndex instanceof Integer) ? (Integer) newIndex : (Long) newIndex));
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonQuerySnapshot {
    private @NonNull List<PigeonDocumentSnapshot> documents;

    public @NonNull List<PigeonDocumentSnapshot> getDocuments() {
      return documents;
    }

    public void setDocuments(@NonNull List<PigeonDocumentSnapshot> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"documents\" is null.");
      }
      this.documents = setterArg;
    }

    private @NonNull List<PigeonDocumentChange> documentChanges;

    public @NonNull List<PigeonDocumentChange> getDocumentChanges() {
      return documentChanges;
    }

    public void setDocumentChanges(@NonNull List<PigeonDocumentChange> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"documentChanges\" is null.");
      }
      this.documentChanges = setterArg;
    }

    private @NonNull PigeonSnapshotMetadata metadata;

    public @NonNull PigeonSnapshotMetadata getMetadata() {
      return metadata;
    }

    public void setMetadata(@NonNull PigeonSnapshotMetadata setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"metadata\" is null.");
      }
      this.metadata = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonQuerySnapshot() {}

    public static final class Builder {

      private @Nullable List<PigeonDocumentSnapshot> documents;

      public @NonNull Builder setDocuments(@NonNull List<PigeonDocumentSnapshot> setterArg) {
        this.documents = setterArg;
        return this;
      }

      private @Nullable List<PigeonDocumentChange> documentChanges;

      public @NonNull Builder setDocumentChanges(@NonNull List<PigeonDocumentChange> setterArg) {
        this.documentChanges = setterArg;
        return this;
      }

      private @Nullable PigeonSnapshotMetadata metadata;

      public @NonNull Builder setMetadata(@NonNull PigeonSnapshotMetadata setterArg) {
        this.metadata = setterArg;
        return this;
      }

      public @NonNull PigeonQuerySnapshot build() {
        PigeonQuerySnapshot pigeonReturn = new PigeonQuerySnapshot();
        pigeonReturn.setDocuments(documents);
        pigeonReturn.setDocumentChanges(documentChanges);
        pigeonReturn.setMetadata(metadata);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(documents);
      toListResult.add(documentChanges);
      toListResult.add((metadata == null) ? null : metadata.toList());
      return toListResult;
    }

    static @NonNull PigeonQuerySnapshot fromList(@NonNull ArrayList<Object> list) {
      PigeonQuerySnapshot pigeonResult = new PigeonQuerySnapshot();
      Object documents = list.get(0);
      pigeonResult.setDocuments((List<PigeonDocumentSnapshot>) documents);
      Object documentChanges = list.get(1);
      pigeonResult.setDocumentChanges((List<PigeonDocumentChange>) documentChanges);
      Object metadata = list.get(2);
      pigeonResult.setMetadata(
          (metadata == null)
              ? null
              : PigeonSnapshotMetadata.fromList((ArrayList<Object>) metadata));
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonGetOptions {
    private @NonNull Source source;

    public @NonNull Source getSource() {
      return source;
    }

    public void setSource(@NonNull Source setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"source\" is null.");
      }
      this.source = setterArg;
    }

    private @NonNull ServerTimestampBehavior serverTimestampBehavior;

    public @NonNull ServerTimestampBehavior getServerTimestampBehavior() {
      return serverTimestampBehavior;
    }

    public void setServerTimestampBehavior(@NonNull ServerTimestampBehavior setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"serverTimestampBehavior\" is null.");
      }
      this.serverTimestampBehavior = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonGetOptions() {}

    public static final class Builder {

      private @Nullable Source source;

      public @NonNull Builder setSource(@NonNull Source setterArg) {
        this.source = setterArg;
        return this;
      }

      private @Nullable ServerTimestampBehavior serverTimestampBehavior;

      public @NonNull Builder setServerTimestampBehavior(
          @NonNull ServerTimestampBehavior setterArg) {
        this.serverTimestampBehavior = setterArg;
        return this;
      }

      public @NonNull PigeonGetOptions build() {
        PigeonGetOptions pigeonReturn = new PigeonGetOptions();
        pigeonReturn.setSource(source);
        pigeonReturn.setServerTimestampBehavior(serverTimestampBehavior);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(source == null ? null : source.index);
      toListResult.add(serverTimestampBehavior == null ? null : serverTimestampBehavior.index);
      return toListResult;
    }

    static @NonNull PigeonGetOptions fromList(@NonNull ArrayList<Object> list) {
      PigeonGetOptions pigeonResult = new PigeonGetOptions();
      Object source = list.get(0);
      pigeonResult.setSource(Source.values()[(int) source]);
      Object serverTimestampBehavior = list.get(1);
      pigeonResult.setServerTimestampBehavior(
          ServerTimestampBehavior.values()[(int) serverTimestampBehavior]);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonDocumentOption {
    private @Nullable Boolean merge;

    public @Nullable Boolean getMerge() {
      return merge;
    }

    public void setMerge(@Nullable Boolean setterArg) {
      this.merge = setterArg;
    }

    private @Nullable List<List<String>> mergeFields;

    public @Nullable List<List<String>> getMergeFields() {
      return mergeFields;
    }

    public void setMergeFields(@Nullable List<List<String>> setterArg) {
      this.mergeFields = setterArg;
    }

    public static final class Builder {

      private @Nullable Boolean merge;

      public @NonNull Builder setMerge(@Nullable Boolean setterArg) {
        this.merge = setterArg;
        return this;
      }

      private @Nullable List<List<String>> mergeFields;

      public @NonNull Builder setMergeFields(@Nullable List<List<String>> setterArg) {
        this.mergeFields = setterArg;
        return this;
      }

      public @NonNull PigeonDocumentOption build() {
        PigeonDocumentOption pigeonReturn = new PigeonDocumentOption();
        pigeonReturn.setMerge(merge);
        pigeonReturn.setMergeFields(mergeFields);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(merge);
      toListResult.add(mergeFields);
      return toListResult;
    }

    static @NonNull PigeonDocumentOption fromList(@NonNull ArrayList<Object> list) {
      PigeonDocumentOption pigeonResult = new PigeonDocumentOption();
      Object merge = list.get(0);
      pigeonResult.setMerge((Boolean) merge);
      Object mergeFields = list.get(1);
      pigeonResult.setMergeFields((List<List<String>>) mergeFields);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonTransactionCommand {
    private @NonNull PigeonTransactionType type;

    public @NonNull PigeonTransactionType getType() {
      return type;
    }

    public void setType(@NonNull PigeonTransactionType setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    private @NonNull String path;

    public @NonNull String getPath() {
      return path;
    }

    public void setPath(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"path\" is null.");
      }
      this.path = setterArg;
    }

    private @Nullable Map<String, Object> data;

    public @Nullable Map<String, Object> getData() {
      return data;
    }

    public void setData(@Nullable Map<String, Object> setterArg) {
      this.data = setterArg;
    }

    private @Nullable PigeonDocumentOption option;

    public @Nullable PigeonDocumentOption getOption() {
      return option;
    }

    public void setOption(@Nullable PigeonDocumentOption setterArg) {
      this.option = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonTransactionCommand() {}

    public static final class Builder {

      private @Nullable PigeonTransactionType type;

      public @NonNull Builder setType(@NonNull PigeonTransactionType setterArg) {
        this.type = setterArg;
        return this;
      }

      private @Nullable String path;

      public @NonNull Builder setPath(@NonNull String setterArg) {
        this.path = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> data;

      public @NonNull Builder setData(@Nullable Map<String, Object> setterArg) {
        this.data = setterArg;
        return this;
      }

      private @Nullable PigeonDocumentOption option;

      public @NonNull Builder setOption(@Nullable PigeonDocumentOption setterArg) {
        this.option = setterArg;
        return this;
      }

      public @NonNull PigeonTransactionCommand build() {
        PigeonTransactionCommand pigeonReturn = new PigeonTransactionCommand();
        pigeonReturn.setType(type);
        pigeonReturn.setPath(path);
        pigeonReturn.setData(data);
        pigeonReturn.setOption(option);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(type == null ? null : type.index);
      toListResult.add(path);
      toListResult.add(data);
      toListResult.add((option == null) ? null : option.toList());
      return toListResult;
    }

    static @NonNull PigeonTransactionCommand fromList(@NonNull ArrayList<Object> list) {
      PigeonTransactionCommand pigeonResult = new PigeonTransactionCommand();
      Object type = list.get(0);
      pigeonResult.setType(PigeonTransactionType.values()[(int) type]);
      Object path = list.get(1);
      pigeonResult.setPath((String) path);
      Object data = list.get(2);
      pigeonResult.setData((Map<String, Object>) data);
      Object option = list.get(3);
      pigeonResult.setOption(
          (option == null) ? null : PigeonDocumentOption.fromList((ArrayList<Object>) option));
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class DocumentReferenceRequest {
    private @NonNull String path;

    public @NonNull String getPath() {
      return path;
    }

    public void setPath(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"path\" is null.");
      }
      this.path = setterArg;
    }

    private @Nullable Map<Object, Object> data;

    public @Nullable Map<Object, Object> getData() {
      return data;
    }

    public void setData(@Nullable Map<Object, Object> setterArg) {
      this.data = setterArg;
    }

    private @Nullable PigeonDocumentOption option;

    public @Nullable PigeonDocumentOption getOption() {
      return option;
    }

    public void setOption(@Nullable PigeonDocumentOption setterArg) {
      this.option = setterArg;
    }

    private @Nullable Source source;

    public @Nullable Source getSource() {
      return source;
    }

    public void setSource(@Nullable Source setterArg) {
      this.source = setterArg;
    }

    private @Nullable ServerTimestampBehavior serverTimestampBehavior;

    public @Nullable ServerTimestampBehavior getServerTimestampBehavior() {
      return serverTimestampBehavior;
    }

    public void setServerTimestampBehavior(@Nullable ServerTimestampBehavior setterArg) {
      this.serverTimestampBehavior = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    DocumentReferenceRequest() {}

    public static final class Builder {

      private @Nullable String path;

      public @NonNull Builder setPath(@NonNull String setterArg) {
        this.path = setterArg;
        return this;
      }

      private @Nullable Map<Object, Object> data;

      public @NonNull Builder setData(@Nullable Map<Object, Object> setterArg) {
        this.data = setterArg;
        return this;
      }

      private @Nullable PigeonDocumentOption option;

      public @NonNull Builder setOption(@Nullable PigeonDocumentOption setterArg) {
        this.option = setterArg;
        return this;
      }

      private @Nullable Source source;

      public @NonNull Builder setSource(@Nullable Source setterArg) {
        this.source = setterArg;
        return this;
      }

      private @Nullable ServerTimestampBehavior serverTimestampBehavior;

      public @NonNull Builder setServerTimestampBehavior(
          @Nullable ServerTimestampBehavior setterArg) {
        this.serverTimestampBehavior = setterArg;
        return this;
      }

      public @NonNull DocumentReferenceRequest build() {
        DocumentReferenceRequest pigeonReturn = new DocumentReferenceRequest();
        pigeonReturn.setPath(path);
        pigeonReturn.setData(data);
        pigeonReturn.setOption(option);
        pigeonReturn.setSource(source);
        pigeonReturn.setServerTimestampBehavior(serverTimestampBehavior);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(path);
      toListResult.add(data);
      toListResult.add((option == null) ? null : option.toList());
      toListResult.add(source == null ? null : source.index);
      toListResult.add(serverTimestampBehavior == null ? null : serverTimestampBehavior.index);
      return toListResult;
    }

    static @NonNull DocumentReferenceRequest fromList(@NonNull ArrayList<Object> list) {
      DocumentReferenceRequest pigeonResult = new DocumentReferenceRequest();
      Object path = list.get(0);
      pigeonResult.setPath((String) path);
      Object data = list.get(1);
      pigeonResult.setData((Map<Object, Object>) data);
      Object option = list.get(2);
      pigeonResult.setOption(
          (option == null) ? null : PigeonDocumentOption.fromList((ArrayList<Object>) option));
      Object source = list.get(3);
      pigeonResult.setSource(source == null ? null : Source.values()[(int) source]);
      Object serverTimestampBehavior = list.get(4);
      pigeonResult.setServerTimestampBehavior(
          serverTimestampBehavior == null
              ? null
              : ServerTimestampBehavior.values()[(int) serverTimestampBehavior]);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonQueryParameters {
    private @Nullable List<List<Object>> where;

    public @Nullable List<List<Object>> getWhere() {
      return where;
    }

    public void setWhere(@Nullable List<List<Object>> setterArg) {
      this.where = setterArg;
    }

    private @Nullable List<List<Object>> orderBy;

    public @Nullable List<List<Object>> getOrderBy() {
      return orderBy;
    }

    public void setOrderBy(@Nullable List<List<Object>> setterArg) {
      this.orderBy = setterArg;
    }

    private @Nullable Long limit;

    public @Nullable Long getLimit() {
      return limit;
    }

    public void setLimit(@Nullable Long setterArg) {
      this.limit = setterArg;
    }

    private @Nullable Long limitToLast;

    public @Nullable Long getLimitToLast() {
      return limitToLast;
    }

    public void setLimitToLast(@Nullable Long setterArg) {
      this.limitToLast = setterArg;
    }

    private @Nullable List<Object> startAt;

    public @Nullable List<Object> getStartAt() {
      return startAt;
    }

    public void setStartAt(@Nullable List<Object> setterArg) {
      this.startAt = setterArg;
    }

    private @Nullable List<Object> startAfter;

    public @Nullable List<Object> getStartAfter() {
      return startAfter;
    }

    public void setStartAfter(@Nullable List<Object> setterArg) {
      this.startAfter = setterArg;
    }

    private @Nullable List<Object> endAt;

    public @Nullable List<Object> getEndAt() {
      return endAt;
    }

    public void setEndAt(@Nullable List<Object> setterArg) {
      this.endAt = setterArg;
    }

    private @Nullable List<Object> endBefore;

    public @Nullable List<Object> getEndBefore() {
      return endBefore;
    }

    public void setEndBefore(@Nullable List<Object> setterArg) {
      this.endBefore = setterArg;
    }

    private @Nullable Map<String, Object> filters;

    public @Nullable Map<String, Object> getFilters() {
      return filters;
    }

    public void setFilters(@Nullable Map<String, Object> setterArg) {
      this.filters = setterArg;
    }

    public static final class Builder {

      private @Nullable List<List<Object>> where;

      public @NonNull Builder setWhere(@Nullable List<List<Object>> setterArg) {
        this.where = setterArg;
        return this;
      }

      private @Nullable List<List<Object>> orderBy;

      public @NonNull Builder setOrderBy(@Nullable List<List<Object>> setterArg) {
        this.orderBy = setterArg;
        return this;
      }

      private @Nullable Long limit;

      public @NonNull Builder setLimit(@Nullable Long setterArg) {
        this.limit = setterArg;
        return this;
      }

      private @Nullable Long limitToLast;

      public @NonNull Builder setLimitToLast(@Nullable Long setterArg) {
        this.limitToLast = setterArg;
        return this;
      }

      private @Nullable List<Object> startAt;

      public @NonNull Builder setStartAt(@Nullable List<Object> setterArg) {
        this.startAt = setterArg;
        return this;
      }

      private @Nullable List<Object> startAfter;

      public @NonNull Builder setStartAfter(@Nullable List<Object> setterArg) {
        this.startAfter = setterArg;
        return this;
      }

      private @Nullable List<Object> endAt;

      public @NonNull Builder setEndAt(@Nullable List<Object> setterArg) {
        this.endAt = setterArg;
        return this;
      }

      private @Nullable List<Object> endBefore;

      public @NonNull Builder setEndBefore(@Nullable List<Object> setterArg) {
        this.endBefore = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> filters;

      public @NonNull Builder setFilters(@Nullable Map<String, Object> setterArg) {
        this.filters = setterArg;
        return this;
      }

      public @NonNull PigeonQueryParameters build() {
        PigeonQueryParameters pigeonReturn = new PigeonQueryParameters();
        pigeonReturn.setWhere(where);
        pigeonReturn.setOrderBy(orderBy);
        pigeonReturn.setLimit(limit);
        pigeonReturn.setLimitToLast(limitToLast);
        pigeonReturn.setStartAt(startAt);
        pigeonReturn.setStartAfter(startAfter);
        pigeonReturn.setEndAt(endAt);
        pigeonReturn.setEndBefore(endBefore);
        pigeonReturn.setFilters(filters);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(9);
      toListResult.add(where);
      toListResult.add(orderBy);
      toListResult.add(limit);
      toListResult.add(limitToLast);
      toListResult.add(startAt);
      toListResult.add(startAfter);
      toListResult.add(endAt);
      toListResult.add(endBefore);
      toListResult.add(filters);
      return toListResult;
    }

    static @NonNull PigeonQueryParameters fromList(@NonNull ArrayList<Object> list) {
      PigeonQueryParameters pigeonResult = new PigeonQueryParameters();
      Object where = list.get(0);
      pigeonResult.setWhere((List<List<Object>>) where);
      Object orderBy = list.get(1);
      pigeonResult.setOrderBy((List<List<Object>>) orderBy);
      Object limit = list.get(2);
      pigeonResult.setLimit(
          (limit == null) ? null : ((limit instanceof Integer) ? (Integer) limit : (Long) limit));
      Object limitToLast = list.get(3);
      pigeonResult.setLimitToLast(
          (limitToLast == null)
              ? null
              : ((limitToLast instanceof Integer) ? (Integer) limitToLast : (Long) limitToLast));
      Object startAt = list.get(4);
      pigeonResult.setStartAt((List<Object>) startAt);
      Object startAfter = list.get(5);
      pigeonResult.setStartAfter((List<Object>) startAfter);
      Object endAt = list.get(6);
      pigeonResult.setEndAt((List<Object>) endAt);
      Object endBefore = list.get(7);
      pigeonResult.setEndBefore((List<Object>) endBefore);
      Object filters = list.get(8);
      pigeonResult.setFilters((Map<String, Object>) filters);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class AggregateQuery {
    private @NonNull AggregateType type;

    public @NonNull AggregateType getType() {
      return type;
    }

    public void setType(@NonNull AggregateType setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    private @Nullable String field;

    public @Nullable String getField() {
      return field;
    }

    public void setField(@Nullable String setterArg) {
      this.field = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    AggregateQuery() {}

    public static final class Builder {

      private @Nullable AggregateType type;

      public @NonNull Builder setType(@NonNull AggregateType setterArg) {
        this.type = setterArg;
        return this;
      }

      private @Nullable String field;

      public @NonNull Builder setField(@Nullable String setterArg) {
        this.field = setterArg;
        return this;
      }

      public @NonNull AggregateQuery build() {
        AggregateQuery pigeonReturn = new AggregateQuery();
        pigeonReturn.setType(type);
        pigeonReturn.setField(field);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(type == null ? null : type.index);
      toListResult.add(field);
      return toListResult;
    }

    static @NonNull AggregateQuery fromList(@NonNull ArrayList<Object> list) {
      AggregateQuery pigeonResult = new AggregateQuery();
      Object type = list.get(0);
      pigeonResult.setType(AggregateType.values()[(int) type]);
      Object field = list.get(1);
      pigeonResult.setField((String) field);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class AggregateQueryResponse {
    private @NonNull AggregateType type;

    public @NonNull AggregateType getType() {
      return type;
    }

    public void setType(@NonNull AggregateType setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    private @Nullable String field;

    public @Nullable String getField() {
      return field;
    }

    public void setField(@Nullable String setterArg) {
      this.field = setterArg;
    }

    private @Nullable Double value;

    public @Nullable Double getValue() {
      return value;
    }

    public void setValue(@Nullable Double setterArg) {
      this.value = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    AggregateQueryResponse() {}

    public static final class Builder {

      private @Nullable AggregateType type;

      public @NonNull Builder setType(@NonNull AggregateType setterArg) {
        this.type = setterArg;
        return this;
      }

      private @Nullable String field;

      public @NonNull Builder setField(@Nullable String setterArg) {
        this.field = setterArg;
        return this;
      }

      private @Nullable Double value;

      public @NonNull Builder setValue(@Nullable Double setterArg) {
        this.value = setterArg;
        return this;
      }

      public @NonNull AggregateQueryResponse build() {
        AggregateQueryResponse pigeonReturn = new AggregateQueryResponse();
        pigeonReturn.setType(type);
        pigeonReturn.setField(field);
        pigeonReturn.setValue(value);
        return pigeonReturn;
      }
    }

    @NonNull
    public ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(type == null ? null : type.index);
      toListResult.add(field);
      toListResult.add(value);
      return toListResult;
    }

    static @NonNull AggregateQueryResponse fromList(@NonNull ArrayList<Object> list) {
      AggregateQueryResponse pigeonResult = new AggregateQueryResponse();
      Object type = list.get(0);
      pigeonResult.setType(AggregateType.values()[(int) type]);
      Object field = list.get(1);
      pigeonResult.setField((String) field);
      Object value = list.get(2);
      pigeonResult.setValue((Double) value);
      return pigeonResult;
    }
  }

  public interface Result<T> {
    @SuppressWarnings("UnknownNullness")
    void success(T result);

    void error(@NonNull Throwable error);
  }

  private static class FirebaseFirestoreHostApiCodec extends FlutterFirebaseFirestoreMessageCodec {
    public static final FirebaseFirestoreHostApiCodec INSTANCE =
        new FirebaseFirestoreHostApiCodec();

    private FirebaseFirestoreHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AggregateQuery.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return AggregateQueryResponse.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return DocumentReferenceRequest.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return FirestorePigeonFirebaseApp.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return PigeonDocumentChange.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return PigeonDocumentOption.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return PigeonDocumentSnapshot.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return PigeonFirebaseSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return PigeonGetOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return PigeonQueryParameters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return PigeonQuerySnapshot.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return PigeonSnapshotMetadata.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return PigeonTransactionCommand.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AggregateQuery) {
        stream.write(128);
        writeValue(stream, ((AggregateQuery) value).toList());
      } else if (value instanceof AggregateQueryResponse) {
        stream.write(129);
        writeValue(stream, ((AggregateQueryResponse) value).toList());
      } else if (value instanceof DocumentReferenceRequest) {
        stream.write(130);
        writeValue(stream, ((DocumentReferenceRequest) value).toList());
      } else if (value instanceof FirestorePigeonFirebaseApp) {
        stream.write(131);
        writeValue(stream, ((FirestorePigeonFirebaseApp) value).toList());
      } else if (value instanceof PigeonDocumentChange) {
        stream.write(132);
        writeValue(stream, ((PigeonDocumentChange) value).toList());
      } else if (value instanceof PigeonDocumentOption) {
        stream.write(133);
        writeValue(stream, ((PigeonDocumentOption) value).toList());
      } else if (value instanceof PigeonDocumentSnapshot) {
        stream.write(134);
        writeValue(stream, ((PigeonDocumentSnapshot) value).toList());
      } else if (value instanceof PigeonFirebaseSettings) {
        stream.write(135);
        writeValue(stream, ((PigeonFirebaseSettings) value).toList());
      } else if (value instanceof PigeonGetOptions) {
        stream.write(136);
        writeValue(stream, ((PigeonGetOptions) value).toList());
      } else if (value instanceof PigeonQueryParameters) {
        stream.write(137);
        writeValue(stream, ((PigeonQueryParameters) value).toList());
      } else if (value instanceof PigeonQuerySnapshot) {
        stream.write(138);
        writeValue(stream, ((PigeonQuerySnapshot) value).toList());
      } else if (value instanceof PigeonSnapshotMetadata) {
        stream.write(139);
        writeValue(stream, ((PigeonSnapshotMetadata) value).toList());
      } else if (value instanceof PigeonTransactionCommand) {
        stream.write(140);
        writeValue(stream, ((PigeonTransactionCommand) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface FirebaseFirestoreHostApi {

    void loadBundle(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull byte[] bundle,
        @NonNull Result<String> result);

    void namedQueryGet(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String name,
        @NonNull PigeonGetOptions options,
        @NonNull Result<PigeonQuerySnapshot> result);

    void clearPersistence(@NonNull FirestorePigeonFirebaseApp app, @NonNull Result<Void> result);

    void disableNetwork(@NonNull FirestorePigeonFirebaseApp app, @NonNull Result<Void> result);

    void enableNetwork(@NonNull FirestorePigeonFirebaseApp app, @NonNull Result<Void> result);

    void terminate(@NonNull FirestorePigeonFirebaseApp app, @NonNull Result<Void> result);

    void waitForPendingWrites(
        @NonNull FirestorePigeonFirebaseApp app, @NonNull Result<Void> result);

    void setIndexConfiguration(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String indexConfiguration,
        @NonNull Result<Void> result);

    void setLoggingEnabled(@NonNull Boolean loggingEnabled, @NonNull Result<Void> result);

    void snapshotsInSyncSetup(
        @NonNull FirestorePigeonFirebaseApp app, @NonNull Result<String> result);

    void transactionCreate(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull Long timeout,
        @NonNull Long maxAttempts,
        @NonNull Result<String> result);

    void transactionStoreResult(
        @NonNull String transactionId,
        @NonNull PigeonTransactionResult resultType,
        @Nullable List<PigeonTransactionCommand> commands,
        @NonNull Result<Void> result);

    void transactionGet(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String transactionId,
        @NonNull String path,
        @NonNull Result<PigeonDocumentSnapshot> result);

    void documentReferenceSet(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull DocumentReferenceRequest request,
        @NonNull Result<Void> result);

    void documentReferenceUpdate(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull DocumentReferenceRequest request,
        @NonNull Result<Void> result);

    void documentReferenceGet(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull DocumentReferenceRequest request,
        @NonNull Result<PigeonDocumentSnapshot> result);

    void documentReferenceDelete(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull DocumentReferenceRequest request,
        @NonNull Result<Void> result);

    void queryGet(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String path,
        @NonNull Boolean isCollectionGroup,
        @NonNull PigeonQueryParameters parameters,
        @NonNull PigeonGetOptions options,
        @NonNull Result<PigeonQuerySnapshot> result);

    void aggregateQuery(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String path,
        @NonNull PigeonQueryParameters parameters,
        @NonNull AggregateSource source,
        @NonNull List<AggregateQuery> queries,
        @NonNull Boolean isCollectionGroup,
        @NonNull Result<List<AggregateQueryResponse>> result);

    void writeBatchCommit(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull List<PigeonTransactionCommand> writes,
        @NonNull Result<Void> result);

    void querySnapshot(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull String path,
        @NonNull Boolean isCollectionGroup,
        @NonNull PigeonQueryParameters parameters,
        @NonNull PigeonGetOptions options,
        @NonNull Boolean includeMetadataChanges,
        @NonNull ListenSource source,
        @NonNull Result<String> result);

    void documentReferenceSnapshot(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull DocumentReferenceRequest parameters,
        @NonNull Boolean includeMetadataChanges,
        @NonNull ListenSource source,
        @NonNull Result<String> result);

    void persistenceCacheIndexManagerRequest(
        @NonNull FirestorePigeonFirebaseApp app,
        @NonNull PersistenceCacheIndexManagerRequest request,
        @NonNull Result<Void> result);

    /** The codec used by FirebaseFirestoreHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return FirebaseFirestoreHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `FirebaseFirestoreHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setup(
        @NonNull BinaryMessenger binaryMessenger, @Nullable FirebaseFirestoreHostApi api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.loadBundle",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                byte[] bundleArg = (byte[]) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.loadBundle(appArg, bundleArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.namedQueryGet",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String nameArg = (String) args.get(1);
                PigeonGetOptions optionsArg = (PigeonGetOptions) args.get(2);
                Result<PigeonQuerySnapshot> resultCallback =
                    new Result<PigeonQuerySnapshot>() {
                      public void success(PigeonQuerySnapshot result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.namedQueryGet(appArg, nameArg, optionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.clearPersistence",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.clearPersistence(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.disableNetwork",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.disableNetwork(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.enableNetwork",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.enableNetwork(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.terminate",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.terminate(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.waitForPendingWrites",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.waitForPendingWrites(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.setIndexConfiguration",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String indexConfigurationArg = (String) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIndexConfiguration(appArg, indexConfigurationArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.setLoggingEnabled",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean loggingEnabledArg = (Boolean) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setLoggingEnabled(loggingEnabledArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.snapshotsInSyncSetup",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.snapshotsInSyncSetup(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.transactionCreate",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                Number timeoutArg = (Number) args.get(1);
                Number maxAttemptsArg = (Number) args.get(2);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.transactionCreate(
                    appArg,
                    (timeoutArg == null) ? null : timeoutArg.longValue(),
                    (maxAttemptsArg == null) ? null : maxAttemptsArg.longValue(),
                    resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.transactionStoreResult",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String transactionIdArg = (String) args.get(0);
                PigeonTransactionResult resultTypeArg =
                    PigeonTransactionResult.values()[(int) args.get(1)];
                List<PigeonTransactionCommand> commandsArg =
                    (List<PigeonTransactionCommand>) args.get(2);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.transactionStoreResult(
                    transactionIdArg, resultTypeArg, commandsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.transactionGet",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String transactionIdArg = (String) args.get(1);
                String pathArg = (String) args.get(2);
                Result<PigeonDocumentSnapshot> resultCallback =
                    new Result<PigeonDocumentSnapshot>() {
                      public void success(PigeonDocumentSnapshot result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.transactionGet(appArg, transactionIdArg, pathArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.documentReferenceSet",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                DocumentReferenceRequest requestArg = (DocumentReferenceRequest) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.documentReferenceSet(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.documentReferenceUpdate",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                DocumentReferenceRequest requestArg = (DocumentReferenceRequest) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.documentReferenceUpdate(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.documentReferenceGet",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                DocumentReferenceRequest requestArg = (DocumentReferenceRequest) args.get(1);
                Result<PigeonDocumentSnapshot> resultCallback =
                    new Result<PigeonDocumentSnapshot>() {
                      public void success(PigeonDocumentSnapshot result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.documentReferenceGet(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.documentReferenceDelete",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                DocumentReferenceRequest requestArg = (DocumentReferenceRequest) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.documentReferenceDelete(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.queryGet",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String pathArg = (String) args.get(1);
                Boolean isCollectionGroupArg = (Boolean) args.get(2);
                PigeonQueryParameters parametersArg = (PigeonQueryParameters) args.get(3);
                PigeonGetOptions optionsArg = (PigeonGetOptions) args.get(4);
                Result<PigeonQuerySnapshot> resultCallback =
                    new Result<PigeonQuerySnapshot>() {
                      public void success(PigeonQuerySnapshot result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.queryGet(
                    appArg,
                    pathArg,
                    isCollectionGroupArg,
                    parametersArg,
                    optionsArg,
                    resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.aggregateQuery",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String pathArg = (String) args.get(1);
                PigeonQueryParameters parametersArg = (PigeonQueryParameters) args.get(2);
                AggregateSource sourceArg = AggregateSource.values()[(int) args.get(3)];
                List<AggregateQuery> queriesArg = (List<AggregateQuery>) args.get(4);
                Boolean isCollectionGroupArg = (Boolean) args.get(5);
                Result<List<AggregateQueryResponse>> resultCallback =
                    new Result<List<AggregateQueryResponse>>() {
                      public void success(List<AggregateQueryResponse> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.aggregateQuery(
                    appArg,
                    pathArg,
                    parametersArg,
                    sourceArg,
                    queriesArg,
                    isCollectionGroupArg,
                    resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.writeBatchCommit",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                List<PigeonTransactionCommand> writesArg =
                    (List<PigeonTransactionCommand>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.writeBatchCommit(appArg, writesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.querySnapshot",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                String pathArg = (String) args.get(1);
                Boolean isCollectionGroupArg = (Boolean) args.get(2);
                PigeonQueryParameters parametersArg = (PigeonQueryParameters) args.get(3);
                PigeonGetOptions optionsArg = (PigeonGetOptions) args.get(4);
                Boolean includeMetadataChangesArg = (Boolean) args.get(5);
                ListenSource sourceArg = ListenSource.values()[(int) args.get(6)];
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.querySnapshot(
                    appArg,
                    pathArg,
                    isCollectionGroupArg,
                    parametersArg,
                    optionsArg,
                    includeMetadataChangesArg,
                    sourceArg,
                    resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.documentReferenceSnapshot",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                DocumentReferenceRequest parametersArg = (DocumentReferenceRequest) args.get(1);
                Boolean includeMetadataChangesArg = (Boolean) args.get(2);
                ListenSource sourceArg = ListenSource.values()[(int) args.get(3)];
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.documentReferenceSnapshot(
                    appArg, parametersArg, includeMetadataChangesArg, sourceArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.cloud_firestore_platform_interface.FirebaseFirestoreHostApi.persistenceCacheIndexManagerRequest",
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FirestorePigeonFirebaseApp appArg = (FirestorePigeonFirebaseApp) args.get(0);
                PersistenceCacheIndexManagerRequest requestArg =
                    PersistenceCacheIndexManagerRequest.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.persistenceCacheIndexManagerRequest(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/android/src/main/AndroidManifest.xml

**크기**: 511 bytes | **라인 수**: 10 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="io.flutter.plugins.firebase.firestore">
    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data android:name="com.google.firebase.components:io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestoreRegistrar"
                       android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/dartpad/lib/main.dart

**크기**: 12241 bytes | **라인 수**: 432 | **타입**: text

```
// ignore_for_file: prefer_const_constructors_in_immutables,unnecessary_const,library_private_types_in_public_api,avoid_print
// Copyright 2021, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: defaultFirebaseOptions);
  runApp(FirestoreExampleApp());
}

/// A reference to the list of movies.
/// We are using `withConverter` to ensure that interactions with the collection
/// are type-safe.
final moviesRef = FirebaseFirestore.instance
    .collection('firestore-example-app')
    .withConverter<Movie>(
      fromFirestore: (snapshots, _) => Movie.fromJson(snapshots.data()!),
      toFirestore: (movie, _) => movie.toJson(),
    );

/// The different ways that we can filter/sort movies.
enum MovieQuery {
  year,
  likesAsc,
  likesDesc,
  score,
  sciFi,
  fantasy,
}

extension on Query<Movie> {
  /// Create a firebase query from a [MovieQuery]
  Query<Movie> queryBy(MovieQuery query) {
    return switch (query) {
      MovieQuery.fantasy => where('genre', arrayContainsAny: ['Fantasy']),
      MovieQuery.sciFi => where('genre', arrayContainsAny: ['Sci-Fi']),
      MovieQuery.likesAsc ||
      MovieQuery.likesDesc =>
        orderBy('likes', descending: query == MovieQuery.likesDesc),
      MovieQuery.year => orderBy('year', descending: true),
      MovieQuery.score => orderBy('score', descending: true)
    };
  }
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class FirestoreExampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firestore Example App',
      theme: ThemeData.dark(),
      home: const Scaffold(
        body: Center(child: FilmList()),
      ),
    );
  }
}

/// Holds all example app films
class FilmList extends StatefulWidget {
  const FilmList({Key? key}) : super(key: key);

  @override
  _FilmListState createState() => _FilmListState();
}

class _FilmListState extends State<FilmList> {
  MovieQuery query = MovieQuery.year;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Firestore Example: Movies'),

            // This is a example use for 'snapshots in sync'.
            // The view reflects the time of the last Firestore sync; which happens any time a field is updated.
            StreamBuilder(
              stream: FirebaseFirestore.instance.snapshotsInSync(),
              builder: (context, _) {
                return Text(
                  'Latest Snapshot: ${DateTime.now()}',
                  style: Theme.of(context).textTheme.bodySmall,
                );
              },
            ),
          ],
        ),
        actions: <Widget>[
          PopupMenuButton<MovieQuery>(
            onSelected: (value) => setState(() => query = value),
            icon: const Icon(Icons.sort),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: MovieQuery.year,
                  child: Text('Sort by Year'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.score,
                  child: Text('Sort by Score'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesAsc,
                  child: Text('Sort by Likes ascending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesDesc,
                  child: Text('Sort by Likes descending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.fantasy,
                  child: Text('Filter genre Fantasy'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.sciFi,
                  child: Text('Filter genre Sci-Fi'),
                ),
              ];
            },
          ),
          PopupMenuButton<String>(
            onSelected: (_) => _resetLikes(),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: 'reset_likes',
                  child: Text('Reset like counts (WriteBatch)'),
                ),
              ];
            },
          ),
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Movie>>(
        stream: moviesRef.queryBy(query).snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text(snapshot.error.toString()),
            );
          }

          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final data = snapshot.requireData;

          return ListView.builder(
            itemCount: data.size,
            itemBuilder: (context, index) {
              return _MovieItem(
                data.docs[index].data(),
                data.docs[index].reference,
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _resetLikes() async {
    final movies = await moviesRef.get();
    WriteBatch batch = FirebaseFirestore.instance.batch();

    for (final movie in movies.docs) {
      batch.update(movie.reference, {'likes': 0});
    }
    await batch.commit();
  }
}

/// A single movie row.
class _MovieItem extends StatelessWidget {
  _MovieItem(this.movie, this.reference);

  final Movie movie;
  final DocumentReference<Movie> reference;

  /// Returns the movie poster.
  Widget get poster {
    return SizedBox(
      width: 100,
      child: Image.network(movie.poster),
    );
  }

  /// Returns movie details.
  Widget get details {
    return Padding(
      padding: const EdgeInsets.only(left: 8, right: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          title,
          metadata,
          genres,
          Likes(
            reference: reference,
            currentLikes: movie.likes,
          ),
        ],
      ),
    );
  }

  /// Return the movie title.
  Widget get title {
    return Text(
      '${movie.title} (${movie.year})',
      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
    );
  }

  /// Returns metadata about the movie.
  Widget get metadata {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(right: 8),
            child: Text('Rated: ${movie.rated}'),
          ),
          Text('Runtime: ${movie.runtime}'),
        ],
      ),
    );
  }

  /// Returns a list of genre movie tags.
  List<Widget> get genreItems {
    return [
      for (final genre in movie.genre)
        Padding(
          padding: const EdgeInsets.only(right: 2),
          child: Chip(
            backgroundColor: Colors.lightBlue,
            label: Text(
              genre,
              style: const TextStyle(color: Colors.white),
            ),
          ),
        ),
    ];
  }

  /// Returns all genres.
  Widget get genres {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Wrap(
        children: genreItems,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4, top: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          poster,
          Flexible(child: details),
        ],
      ),
    );
  }
}

/// Displays and manages the movie 'like' count.
class Likes extends StatefulWidget {
  /// Constructs a new [Likes] instance with a given [DocumentReference] and
  /// current like count.
  Likes({
    Key? key,
    required this.reference,
    required this.currentLikes,
  }) : super(key: key);

  /// The reference relating to the counter.
  final DocumentReference<Movie> reference;

  /// The number of current likes (before manipulation).
  final int currentLikes;

  @override
  _LikesState createState() => _LikesState();
}

class _LikesState extends State<Likes> {
  /// A local cache of the current likes, used to immediately render the updated
  /// likes count after an update, even while the request isn't completed yet.
  late int _likes = widget.currentLikes;

  Future<void> _onLike() async {
    final currentLikes = _likes;

    // Increment the 'like' count straight away to show feedback to the user.
    setState(() {
      _likes = currentLikes + 1;
    });

    try {
      // Update the likes using a transaction.
      // We use a transaction because multiple users could update the likes count
      // simultaneously. As such, our likes count may be different from the likes
      // count on the server.
      int newLikes = await FirebaseFirestore.instance
          .runTransaction<int>((transaction) async {
        DocumentSnapshot<Movie> movie =
            await transaction.get<Movie>(widget.reference);

        if (!movie.exists) {
          throw Exception('Document does not exist!');
        }

        int updatedLikes = movie.data()!.likes + 1;
        transaction.update(widget.reference, {'likes': updatedLikes});
        return updatedLikes;
      });

      // Update with the real count once the transaction has completed.
      setState(() => _likes = newLikes);
    } catch (e, s) {
      print(s);
      print('Failed to update likes for document! $e');

      // If the transaction fails, revert back to the old count
      setState(() => _likes = currentLikes);
    }
  }

  @override
  void didUpdateWidget(Likes oldWidget) {
    super.didUpdateWidget(oldWidget);
    // The likes on the server changed, so we need to update our local cache to
    // keep things in sync. Otherwise if another user updates the likes,
    // we won't see the update.
    if (widget.currentLikes != oldWidget.currentLikes) {
      _likes = widget.currentLikes;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          iconSize: 20,
          onPressed: _onLike,
          icon: const Icon(Icons.favorite),
        ),
        Text('$_likes likes'),
      ],
    );
  }
}

@immutable
class Movie {
  Movie({
    required this.genre,
    required this.likes,
    required this.poster,
    required this.rated,
    required this.runtime,
    required this.title,
    required this.year,
  });

  Movie.fromJson(Map<String, Object?> json)
      : this(
          genre: (json['genre']! as List).cast<String>(),
          likes: json['likes']! as int,
          poster: json['poster']! as String,
          rated: json['rated']! as String,
          runtime: json['runtime']! as String,
          title: json['title']! as String,
          year: json['year']! as int,
        );

  final String poster;
  final int likes;
  final String title;
  final int year;
  final String runtime;
  final String rated;
  final List<String> genre;

  Map<String, Object?> toJson() {
    return {
      'genre': genre,
      'likes': likes,
      'poster': poster,
      'rated': rated,
      'runtime': runtime,
      'title': title,
      'year': year,
    };
  }
}

const defaultFirebaseOptions = const FirebaseOptions(
  apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
  appId: '1:406099696497:web:87e25e51afe982cd3574d0',
  messagingSenderId: '406099696497',
  projectId: 'flutterfire-e2e-tests',
  authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
  databaseURL:
      'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
  storageBucket: 'flutterfire-e2e-tests.appspot.com',
  measurementId: 'G-JN95N1JV2E',
);

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/dartpad/dartpad_metadata.yaml

**크기**: 75 bytes | **라인 수**: 5 | **타입**: text

```
name: Cloud Firestore Example
mode: flutter
files:
  - name: lib/main.dart

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/debug/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/kotlin/io/flutter/plugins/firebase/firestore/example/MainActivity.kt

**크기**: 146 bytes | **라인 수**: 6 | **타입**: text

```
package io.flutter.plugins.firebase.firestore.example

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/res/drawable/launch_background.xml

**크기**: 434 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/res/drawable-v21/launch_background.xml

**크기**: 438 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/res/values/styles.xml

**크기**: 996 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/res/values-night/styles.xml

**크기**: 995 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/main/AndroidManifest.xml

**크기**: 2195 bytes | **라인 수**: 46 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/src/profile/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/android/app/google-services.json

**크기**: 19376 bytes | **라인 수**: 615 | **타입**: text

```
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.database.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/collection_reference_e2e.dart

**크기**: 6876 bytes | **라인 수**: 212 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runCollectionReferenceTests() {
  group('$CollectionReference', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (DocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test('add() adds a document', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('collection-reference-add');
      var rand = Random();
      var randNum = rand.nextInt(999999);
      DocumentReference<Map<String, dynamic>> doc = await collection.add({
        'value': randNum,
      });
      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      expect(randNum, equals(snapshot.data()!['value']));
    });

    test(
      'snapshots() can be reused',
      () async {
        final foo = await initializeTest('foo');

        final snapshot = foo.snapshots();
        final snapshot2 = foo.snapshots();

        expect(
          await snapshot.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', []),
        );
        expect(
          await snapshot2.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', []),
        );

        await foo.add({'value': 42});

        expect(
          await snapshot.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', [
            isA<QueryDocumentSnapshot>()
                .having((e) => e.data(), 'data', {'value': 42}),
          ]),
        );
        expect(
          await snapshot2.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', [
            isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          ]),
        );
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );

    group(
      'withConverter',
      () {
        test(
          'add/snapshot',
          () async {
            final foo = await initializeTest('foo');
            final fooConverter = foo.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            final fooSnapshot = foo.snapshots();
            final fooConverterSnapshot = fooConverter.snapshots();

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot<Map<String, dynamic>>>()
                    .having((e) => e.docs, 'docs', []),
              ),
            );
            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', []),
              ),
            );

            final newDocument = await fooConverter.add(42);

            await expectLater(
              newDocument.get(),
              completion(
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ),
            );

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot>().having((e) => e.docs, 'docs', [
                  isA<QueryDocumentSnapshot>()
                      .having((e) => e.data(), 'data', {'value': 42}),
                ]),
              ),
            );
            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<QueryDocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await foo.add({'value': 21});

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                        .having((e) => e.data(), 'data', {'value': 42}),
                    isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                        .having((e) => e.data(), 'data', {'value': 21}),
                  ]),
                ),
              ),
            );

            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<QueryDocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<QueryDocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ]),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'returning null from `fromFirestore` should not throw a null check error',
          () async {
            final foo = await initializeTest('foo');
            await foo.add({'value': 42});
            final fooConverter = foo.withConverter(
              fromFirestore: (_, __) => null,
              toFirestore: (_, __) => {}, // unused
            );

            final fooConverterSnapshot = fooConverter.snapshots();

            await expectLater(
              fooConverterSnapshot,
              emits(
                // ignore: prefer_void_to_null
                isA<QuerySnapshot<Null>>().having((e) => e.docs, 'docs', [
                  // ignore: prefer_void_to_null
                  isA<QueryDocumentSnapshot<Null>>()
                      .having((e) => e.data(), 'data', null),
                ]),
              ),
            );
          },
        );
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/document_change_e2e.dart

**크기**: 7253 bytes | **라인 수**: 203 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runDocumentChangeTests() {
  group('$DocumentChange', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');

      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (DocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test(
      'can add/update values to null in the document',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('null-test');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', false),
          ),
        );

        await doc1.set(<String, Object?>{
          'key': null,
          'key2': 42,
        });

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', true)
                .having((q) => q.data(), 'data()', <String, Object?>{
              'key': null,
              'key2': 42,
            }),
          ),
        );

        await doc1.set({
          'key': null,
          'key2': null,
        });

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', true)
                .having((q) => q.data(), 'data()', <String, Object?>{
              'key': null,
              'key2': null,
            }),
          ),
        );
      },
      timeout: const Timeout.factor(8),
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );

    test(
      'returns the correct metadata when adding and removing',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('add-remove-document');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');

        // Set something in the database
        await doc1.set({'name': 'doc1'});

        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        int call = 0;

        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(1));
                expect(snapshot.docChanges.length, equals(1));
                expect(snapshot.docChanges[0], isA<DocumentChange>());
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.newIndex, equals(0));
                expect(change.oldIndex, equals(-1));
                expect(change.type, equals(DocumentChangeType.added));
                expect(change.doc.data()!['name'], equals('doc1'));
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(0));
                expect(snapshot.docChanges.length, equals(1));
                expect(snapshot.docChanges[0], isA<DocumentChange>());
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.newIndex, equals(-1));
                expect(change.oldIndex, equals(0));
                expect(change.type, equals(DocumentChangeType.removed));
                expect(change.doc.data()!['name'], equals('doc1'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 2,
            reason: 'Stream should only have been called twice.',
          ),
        );

        await Future.delayed(
          const Duration(seconds: 1),
        ); // Ensure listener fires
        await doc1.delete();

        await subscription.cancel();
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );

    test(
      'returns the correct metadata when modifying',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('add-modify-document');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');
        DocumentReference<Map<String, dynamic>> doc2 = collection.doc('doc2');
        DocumentReference<Map<String, dynamic>> doc3 = collection.doc('doc3');

        await doc1.set({'value': 1});
        await doc2.set({'value': 2});
        await doc3.set({'value': 3});
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.orderBy('value').snapshots();

        int call = 0;
        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(3));
                expect(snapshot.docChanges.length, equals(3));
                snapshot.docChanges.asMap().forEach(
                    (int index, DocumentChange<Map<String, dynamic>> change) {
                  expect(change.oldIndex, equals(-1));
                  expect(change.newIndex, equals(index));
                  expect(change.type, equals(DocumentChangeType.added));
                  expect(change.doc.data()!['value'], equals(index + 1));
                });
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(3));
                expect(snapshot.docChanges.length, equals(1));
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.oldIndex, equals(0));
                expect(change.newIndex, equals(2));
                expect(change.type, equals(DocumentChangeType.modified));
                expect(change.doc.id, equals('doc1'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 2,
            reason: 'Stream should only have been called twice.',
          ),
        );

        await Future.delayed(
          const Duration(seconds: 1),
        ); // Ensure listener fires
        await doc1.update({'value': 4});

        await subscription.cancel();
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/document_reference_e2e.dart

**크기**: 21553 bytes | **라인 수**: 634 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runDocumentReferenceTests() {
  group('$DocumentReference', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    group(
      'DocumentReference.snapshots()',
      () {
        test('returns a [Stream]', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          expect(stream, isA<Stream<DocumentSnapshot<Map<String, dynamic>>>>());
        });

        test('can be reused', () async {
          final foo = await initializeTest('foo');

          final snapshot = foo.snapshots();
          final snapshot2 = foo.snapshots();

          expect(
            await snapshot.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.exists, 'exists', false),
          );
          expect(
            await snapshot2.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.exists, 'exists', false),
          );

          await foo.set({'value': 42});

          expect(
            await snapshot.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          );
          expect(
            await snapshot2.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          );
        });

        test('listens to a single response', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isFalse);
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to a single response from cache', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots(source: ListenSource.cache);
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isFalse);
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to a document from cache', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot-cache');
          await document.set({'foo': 'bar'});
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots(source: ListenSource.cache);
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isTrue);
                expect(snapshot.data(), equals({'foo': 'bar'}));
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to multiple documents', () async {
          DocumentReference<Map<String, dynamic>> doc1 =
              await initializeTest('document-snapshot-1');
          DocumentReference<Map<String, dynamic>> doc2 =
              await initializeTest('document-snapshot-2');

          await doc1.set({'test': 'value1'});
          await doc2.set({'test': 'value2'});

          final value1 = doc1.snapshots().first.then((s) => s.data()!['test']);
          final value2 = doc2.snapshots().first.then((s) => s.data()!['test']);

          await expectLater(value1, completion('value1'));
          await expectLater(value2, completion('value2'));
        });

        test('listens to a multiple changes response', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot-multiple');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          int call = 0;

          StreamSubscription subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                call++;
                if (call == 1) {
                  expect(snapshot.exists, isFalse);
                } else if (call == 2) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['bar'], equals('baz'));
                } else if (call == 3) {
                  expect(snapshot.exists, isFalse);
                } else if (call == 4) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['foo'], equals('bar'));
                } else if (call == 5) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['foo'], equals('baz'));
                } else {
                  fail('Should not have been called');
                }
              },
              count: 5,
              reason: 'Stream should only have been called five times.',
            ),
          );

          await Future.delayed(
            const Duration(seconds: 1),
          ); // allow stream to return a noop-doc
          await document.set({'bar': 'baz'});
          await document.delete();
          await document.set({'foo': 'bar'});
          await document.update({'foo': 'baz'});

          await subscription.cancel();
          await Future.delayed(
            const Duration(seconds: 1),
          );
        });

        test('listeners throws a [FirebaseException]', () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();

          try {
            await stream.first;
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }

          fail('Should have thrown a [FirebaseException]');
        });
      },
    );

    group('DocumentReference.delete()', () {
      test('delete() deletes a document', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-delete');
        await document.set({
          'foo': 'bar',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.exists, isTrue);
        await document.delete();
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.exists, isFalse);
      });

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.delete();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
        //This will fail on web until this is resolved: https://github.com/dart-lang/sdk/issues/52572
        skip: kIsWeb,
      );
    });

    group('DocumentReference.get()', () {
      test('gets a document from server', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-get-server');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot =
            await document.get(const GetOptions(source: Source.server));
        expect(snapshot.data(), {'foo': 'bar'});
        expect(snapshot.metadata.isFromCache, isFalse);
      });

      test(
        'gets a document from cache',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-get-cache');
          await document.set({'foo': 'bar'});
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await document.get(const GetOptions(source: Source.cache));
          expect(snapshot.data(), equals({'foo': 'bar'}));
          expect(snapshot.metadata.isFromCache, isTrue);
        },
        skip: kIsWeb,
      );

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.get();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );
    });

    group('DocumentReference.set()', () {
      test('sets data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-set');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document.set({'bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'bar': 'baz'}));
      });

      test('set() merges data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-set-merge');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document
            .set({'foo': 'ben', 'bar': 'baz'}, SetOptions(merge: true));
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'foo': 'ben', 'bar': 'baz'}));
      });

      test(
        'set() merges fields',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-set-merge-fields');
          Map<String, dynamic> initialData = {
            'foo': 'bar',
            'bar': 123,
            'baz': '456',
          };
          Map<String, dynamic> dataToSet = {
            'foo': 'should-not-merge',
            'bar': 456,
            'baz': 'foo',
          };
          await document.set(initialData);
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await document.get();
          expect(snapshot.data(), equals(initialData));
          await document.set(
            dataToSet,
            SetOptions(
              mergeFields: [
                'bar',
                FieldPath(const ['baz']),
              ],
            ),
          );
          DocumentSnapshot<Map<String, dynamic>> snapshot2 =
              await document.get();
          expect(
            snapshot2.data(),
            equals({'foo': 'bar', 'bar': 456, 'baz': 'foo'}),
          );
        },
      );

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.set({'foo': 'bar'});
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );

      test('set and return all possible datatypes', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-types');

        await document.set({
          'string': 'foo bar',
          'number_32': 123,
          // Equivalent of `Number.MAX_SAFE_INTEGER` in JS, can't go higher than this.
          'number_64': 9007199254740991,
          'bool_true': true,
          'bool_false': false,
          'map': {
            'foo': 'bar',
            'bar': {'baz': 'ben'},
          },
          'list': [
            1,
            '2',
            true,
            false,
            {'foo': 'bar'},
          ],
          'null': null,
          'timestamp': Timestamp.now(),
          'geopoint': const GeoPoint(1, 2),
          'vectorValue': const VectorValue([1, 2, 3]),
          'reference': firestore.doc('foo/bar'),
          'nan': double.nan,
          'infinity': double.infinity,
          'negative_infinity': double.negativeInfinity,
        });

        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        Map<String, dynamic> data = snapshot.data()!;

        expect(data['string'], equals('foo bar'));
        expect(data['number_32'], equals(123));
        expect(data['number_64'], equals(9007199254740991));
        expect(data['bool_true'], isTrue);
        expect(data['bool_false'], isFalse);
        expect(
          data['map'],
          equals(<String, dynamic>{
            'foo': 'bar',
            'bar': {'baz': 'ben'},
          }),
        );
        expect(
          data['list'],
          equals([
            1,
            '2',
            true,
            false,
            {'foo': 'bar'},
          ]),
        );
        expect(data['null'], equals(null));
        expect(data['timestamp'], isA<Timestamp>());
        expect(data['geopoint'], isA<GeoPoint>());
        expect((data['geopoint'] as GeoPoint).latitude, equals(1));
        expect((data['geopoint'] as GeoPoint).longitude, equals(2));
        expect(data['vectorValue'], isA<VectorValue>());
        expect(
          (data['vectorValue'] as VectorValue).toArray(),
          equals([1, 2, 3]),
        );
        expect(data['reference'], isA<DocumentReference>());
        expect((data['reference'] as DocumentReference).id, equals('bar'));
        expect(data['nan'].isNaN, equals(true));
        expect(data['infinity'], equals(double.infinity));
        expect(data['negative_infinity'], equals(double.negativeInfinity));
      });
    });

    group('DocumentReference.update()', () {
      test('updates data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document.update({'bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'foo': 'bar', 'bar': 'baz'}));
      });

      test('updates nested data using dots', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({
          'foo': {'bar': 'baz'},
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({
            'foo': {'bar': 'baz'},
          }),
        );

        await document.update({'foo.bar': 'toto'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({
            'foo': {'bar': 'toto'},
          }),
        );
      });

      test('updates nested data using FieldPath', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({
          'foo': {'bar': 'baz'},
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({
            'foo': {'bar': 'baz'},
          }),
        );

        await document.update({
          FieldPath(const ['foo', 'bar']): 'toto',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({
            'foo': {'bar': 'toto'},
          }),
        );
      });

      test('updates nested data containing a dot using FieldPath', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({'foo.bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({'foo.bar': 'baz'}),
        );

        await document.update({
          FieldPath(const ['foo.bar']): 'toto',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({'foo.bar': 'toto'}),
        );
      });

      test(
        'throws if document does not exist',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-update-not-exists');
          try {
            await document.update({'foo': 'bar'});
            fail('Should have thrown');
          } catch (e) {
            expect(
              e,
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'not-found'),
            );
          }
        },
      );
    });

    group('withConverter', () {
      test(
        'set/snapshot/get',
        () async {
          final foo = await initializeTest('foo');
          final fooConverter = foo.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          final fooSnapshot = foo.snapshots();
          final fooConverterSnapshot = fooConverter.snapshots();

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', null),
            ),
          );
          await expectLater(
            fooConverterSnapshot,
            emits(
              isA<DocumentSnapshot<int>>()
                  .having((e) => e.data(), 'data', null),
            ),
          );

          await fooConverter.set(42);

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', {'value': 42}),
            ),
          );
          await expectLater(
            fooConverterSnapshot,
            emits(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ),
          );
          await expectLater(
            fooConverter.get(),
            completion(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ),
          );

          await foo.set({'value': 21});

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', {'value': 21}),
            ),
          );

          await expectLater(
            fooConverter.get(),
            completion(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/e2e_test.dart

**크기**: 2124 bytes | **라인 수**: 72 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'collection_reference_e2e.dart';
import 'document_change_e2e.dart';
import 'document_reference_e2e.dart';
import 'field_value_e2e.dart';
import 'firebase_options.dart';
import 'geo_point_e2e.dart';
import 'instance_e2e.dart';
import 'load_bundle_e2e.dart';
import 'query_e2e.dart';
import 'second_database.dart';
import 'settings_e2e.dart';
import 'snapshot_metadata_e2e.dart';
import 'timestamp_e2e.dart';
import 'transaction_e2e.dart';
import 'vector_value_e2e.dart';
import 'web_snapshot_listeners.dart';
import 'write_batch_e2e.dart';

bool kUseFirestoreEmulator = true;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('cloud_firestore', () {
    setUpAll(() async {
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
      // Web by default doesn't have persistence enabled
      FirebaseFirestore.instance.settings = const Settings(
        persistenceEnabled: true,
      );

      if (kUseFirestoreEmulator) {
        FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);
      }
    });

    runInstanceTests();

    runCollectionReferenceTests();
    runDocumentChangeTests();
    runDocumentReferenceTests();
    runFieldValueTests();
    runGeoPointTests();
    runVectorValueTests();
    runQueryTests();
    runSnapshotMetadataTests();
    runTimestampTests();
    runTransactionTests();
    runWriteBatchTests();
    runLoadBundleTests();
    runWebSnapshotListenersTests();
    if (defaultTargetPlatform != TargetPlatform.windows) {
      runSecondDatabaseTests();
    }
    if (kIsWeb) {
      runSettingsTest();
    }
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/field_value_e2e.dart

**크기**: 9326 bytes | **라인 수**: 241 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runFieldValueTests() {
  group('$FieldValue', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    group('FieldValue.increment()', () {
      test('increments a number if it exists', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-exists');
        await doc.set({'foo': 2});
        await doc.update({'foo': FieldValue.increment(1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(3));
        // Expect it to be a int
        expect(snapshot.data()!['foo'], isA<int>());
      });

      test('increments a big number if it exists', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-exists');
        await doc.set({'foo': 0});
        await doc.update({'foo': FieldValue.increment(2148000000)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(2148000000));
      });

      test('decrements a number', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-decrement-exists');
        await doc.set({'foo': 2});
        await doc.update({'foo': FieldValue.increment(-1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(1));
      });

      test('sets an increment if it does not exist', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-not-exists');
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.exists, isFalse);
        await doc.set({'foo': FieldValue.increment(1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc.get();
        expect(snapshot2.data()!['foo'], equals(1));
      });
    });

    group('FieldValue.serverTimestamp()', () {
      test('sets a new server time value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-server-timestamp-new');
        await doc.set({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], isA<Timestamp>());
      });

      test('updates a server time value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-server-timestamp-update');
        await doc.set({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        Timestamp serverTime1 = snapshot.data()!['foo'];
        expect(serverTime1, isA<Timestamp>());
        await Future.delayed(const Duration(milliseconds: 100));
        await doc.update({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc.get();
        Timestamp serverTime2 = snapshot2.data()!['foo'];
        expect(serverTime2, isA<Timestamp>());
        expect(
          serverTime2.microsecondsSinceEpoch >
              serverTime1.microsecondsSinceEpoch,
          isTrue,
        );
      });
    });

    group('FieldValue.delete()', () {
      test('removes a value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-delete');
        await doc.set({'foo': 'bar', 'bar': 'baz'});
        await doc.update({'bar': FieldValue.delete()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data(), equals(<String, dynamic>{'foo': 'bar'}));
      });
    });

    group('FieldValue.arrayUnion()', () {
      test('updates an existing array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-update-array');
        await doc.set({
          'foo': [1, 2],
        });
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([1, 2, 3, 4]));
      });

      test('updates an array if current value is not an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-replace');
        await doc.set({'foo': 'bar'});
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      test('sets an array if current value is not an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-replace');
        await doc.set({'foo': 'bar'});
        await doc.set({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });
    });

    group('FieldValue.arrayRemove()', () {
      test('removes items in an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-existing');
        await doc.set({
          'foo': [1, 2, 3, 4],
        });
        await doc.update({
          'foo': FieldValue.arrayRemove([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([1, 2]));
      });

      test('removes & updates an array if existing item is not an array',
          () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-replace');
        await doc.set({'foo': 'bar'});
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      test('removes & sets an array if existing item is not an array',
          () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-replace');
        await doc.set({'foo': 'bar'});
        await doc.set({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      // ignore: todo
      // TODO(salakar): test is currently failing on CI but unable to reproduce locally
      test(
        'updates with nested types',
        () async {
          DocumentReference<Map<String, dynamic>> doc =
              await initializeTest('field-value-nested-types');

          DocumentReference<Map<String, dynamic>> ref =
              FirebaseFirestore.instance.doc('foo/bar');

          await doc.set({
            'foo': [1],
          });
          await doc.update({
            'foo': FieldValue.arrayUnion([2, ref]),
          });
          DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
          expect(snapshot.data()!['foo'], equals([1, 2, ref]));
        },
        skip: true,
      );

      test('query should restore nested Timestamp', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('nested-timestamp');
        await Future.wait([
          doc.set({
            'nested': {
              'timestamp': Timestamp.fromDate(DateTime(2020)),
            },
            'timestamp': Timestamp.fromDate(DateTime(2020)),
          }),
        ]);

        final snapshot = await doc.get();

        expect(snapshot.data()!['timestamp'], isA<Timestamp>());
        expect(snapshot.data()!['nested']['timestamp'], isA<Timestamp>());
      });

      test('query should restore nested Timestamp in List', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('nested-timestamp');
        await doc.set({
          'timestamp': Timestamp.fromDate(DateTime.now()),
          'logs': [
            {
              'createdAt': Timestamp.fromDate(DateTime.now()),
            },
          ],
        });

        final snapshot = await doc.get();

        expect(snapshot.data()!['timestamp'], isA<Timestamp>());
        expect(snapshot.data()!['logs'][0]['createdAt'], isA<Timestamp>());
      });
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/firebase_options.dart

**크기**: 3655 bytes | **라인 수**: 93 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      TargetPlatform.linux => throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        ),
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:175ea7a64b2faf5e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/firebase_options_secondary.dart

**크기**: 2854 bytes | **라인 수**: 76 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options_secondary.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyAFh7c37C6MyAVwRJylz7EwvzZSECqmcus',
    appId: '1:866672724757:web:3a0fad9cba4848ea19f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    authDomain: 'flutterfire-e2e-tests-2.firebaseapp.com',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAMoRmAcD_NW0DVoO40ThJO1zDF2vDB7Rs',
    appId: '1:866672724757:android:d069b410181b65cf19f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDfWh055gUcnS6_Gqd_Jjwy7boVm5_E8oI',
    appId: '1:866672724757:ios:142139d84dda4ed419f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
    iosClientId:
        '866672724757-rncbdu3qrn0j423e1tfk2jg7jdvrhd8i.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestoreExample',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDfWh055gUcnS6_Gqd_Jjwy7boVm5_E8oI',
    appId: '1:866672724757:ios:3e35357fc677cc5719f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
    iosClientId:
        '866672724757-fup6o8riklmmc7mbo3b1jolbeadbb84m.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/geo_point_e2e.dart

**크기**: 1771 bytes | **라인 수**: 55 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runGeoPointTests() {
  group('$GeoPoint', () {
    late FirebaseFirestore /*?*/ firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $GeoPoint & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point');

      await doc.set({'foo': const GeoPoint(10, -10)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      GeoPoint geopoint = snapshot.data()!['foo'];
      expect(geopoint, isA<GeoPoint>());
      expect(geopoint.latitude, equals(10));
      expect(geopoint.longitude, equals(-10));
    });

    test('updates a $GeoPoint & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point-update');

      await doc.set({'foo': const GeoPoint(10, -10)});

      await doc.update({'foo': const GeoPoint(-10, 10)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      GeoPoint geopoint = snapshot.data()!['foo'];
      expect(geopoint, isA<GeoPoint>());
      expect(geopoint.latitude, equals(-10));
      expect(geopoint.longitude, equals(10));
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/instance_e2e.dart

**크기**: 11901 bytes | **라인 수**: 347 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runInstanceTests() {
  group(
    '$FirebaseFirestore.instance',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      test(
        'snapshotsInSync()',
        () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/insync');

          // Ensure deleted
          await documentReference.delete();

          StreamController controller = StreamController();
          StreamSubscription insync;
          StreamSubscription snapshots;

          int inSyncCount = 0;

          insync = firestore.snapshotsInSync().listen((_) {
            controller.add('insync=$inSyncCount');
            inSyncCount++;
          });

          snapshots = documentReference.snapshots().listen((ds) {
            controller.add('snapshot-exists=${ds.exists}');
          });

          // Allow the snapshots to trigger...
          await Future.delayed(const Duration(seconds: 1));

          await documentReference.set({'foo': 'bar'});

          await expectLater(
            controller.stream,
            emitsInOrder([
              'insync=0', // No other snapshots
              'snapshot-exists=false',
              'insync=1',
              'snapshot-exists=true',
              'insync=2',
            ]),
          );

          await controller.close();
          await insync.cancel();
          await snapshots.cancel();
        },
        skip: kIsWeb,
      );

      test(
        'enableNetwork()',
        () async {
          // Write some data while online
          await firestore.enableNetwork();
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/enable-network');
          await documentReference.set({'foo': 'bar'});

          // Disable the network
          await firestore.disableNetwork();

          StreamController controller = StreamController();

          // Set some data while offline
          // ignore: unawaited_futures
          documentReference.set({'foo': 'baz'}).then((_) async {
            // Only when back online will this trigger
            controller.add(true);
          });

          // Go back online
          await firestore.enableNetwork();

          await expectLater(controller.stream, emits(true));
          await controller.close();
        },
        skip: kIsWeb,
      );

      test(
        'disableNetwork()',
        () async {
          // Write some data while online
          await firestore.enableNetwork();
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/disable-network');
          await documentReference.set({'foo': 'bar'});

          // Disable the network
          await firestore.disableNetwork();

          // Get data from cache
          DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
              await documentReference.get();
          expect(documentSnapshot.metadata.isFromCache, isTrue);
          expect(documentSnapshot.data()!['foo'], equals('bar'));

          // Go back online once test complete
          await firestore.enableNetwork();
        },
        skip: kIsWeb,
      );

      test(
        'waitForPendingWrites()',
        () async {
          await firestore.waitForPendingWrites();
        },
        skip: kIsWeb,
      );

      test(
        'terminate() / clearPersistence()',
        () async {
          // Since the firestore instance has already been used,
          // calling `clearPersistence` will throw a native error.
          // We first check it does throw as expected, then terminate
          // the instance, and then check whether clearing succeeds.
          try {
            await firestore.clearPersistence();
            fail('Should have thrown');
          } on FirebaseException catch (e) {
            expect(e.code, equals('failed-precondition'));
          } catch (e) {
            fail('$e');
          }

          await firestore.terminate();
          await firestore.clearPersistence();
        },
        skip: kIsWeb || defaultTargetPlatform == TargetPlatform.windows,
      );

      test(
        'setIndexConfigurationFromJSON()',
        () async {
          final json = jsonEncode({
            'indexes': [
              {
                'collectionGroup': 'posts',
                'queryScope': 'COLLECTION',
                'fields': [
                  {'fieldPath': 'author', 'arrayConfig': 'CONTAINS'},
                  {'fieldPath': 'timestamp', 'order': 'DESCENDING'},
                ],
              }
            ],
            'fieldOverrides': [
              {
                'collectionGroup': 'posts',
                'fieldPath': 'myBigMapField',
                'indexes': [],
              }
            ],
          });

          await firestore.setIndexConfigurationFromJSON(json);
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );

      test('setLoggingEnabled should resolve without issue', () async {
        await FirebaseFirestore.setLoggingEnabled(true);
        await FirebaseFirestore.setLoggingEnabled(false);
      });

      test(
          'Settings() - `persistenceEnabled` & `cacheSizeBytes` with acceptable number',
          () async {
        FirebaseFirestore.instance.settings =
            const Settings(persistenceEnabled: true, cacheSizeBytes: 10000000);
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });

      test(
          'Settings() - `persistenceEnabled` & `cacheSizeBytes` with `Settings.CACHE_SIZE_UNLIMITED`',
          () async {
        FirebaseFirestore.instance.settings = const Settings(
          persistenceEnabled: true,
          cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
        );
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });

      test('Settings() - `persistenceEnabled` & without `cacheSizeBytes`',
          () async {
        FirebaseFirestore.instance.settings =
            const Settings(persistenceEnabled: true);
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });
      test(
        '`PersistenceCacheIndexManager` with default persistence settings for each platform',
        () async {
          if (defaultTargetPlatform == TargetPlatform.windows) {
            try {
              // Windows does not have `PersistenceCacheIndexManager` support
              FirebaseFirestore.instance.persistentCacheIndexManager();
            } catch (e) {
              expect(e, isInstanceOf<UnimplementedError>());
            }
          } else {
            if (kIsWeb) {
              // persistence is disabled by default on web
              final firestore = FirebaseFirestore.instanceFor(
                app: Firebase.app(),
                // Use different firestore instance to test behavior
                databaseId: 'default-web',
              );
              PersistentCacheIndexManager? indexManager =
                  firestore.persistentCacheIndexManager();
              expect(indexManager, isNull);
            } else {
              final firestore = FirebaseFirestore.instanceFor(
                app: Firebase.app(),
                // Use different firestore instance to test behavior
                databaseId: 'default-other-platform-test',
              );
              // macOS, android, iOS have persistence enabled by default
              PersistentCacheIndexManager? indexManager =
                  firestore.persistentCacheIndexManager();
              await indexManager!.enableIndexAutoCreation();
              await indexManager.disableIndexAutoCreation();
              await indexManager.deleteAllIndexes();
            }
          }
        },
      );

      test(
        '`PersistenceCacheIndexManager` with persistence enabled for each platform',
        () async {
          if (kIsWeb) {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-enabled',
            );
            // persistence is disabled by default so we enable it
            firestore.settings = const Settings(persistenceEnabled: true);

            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();

            await indexManager!.enableIndexAutoCreation();
            await indexManager.disableIndexAutoCreation();
            await indexManager.deleteAllIndexes();

            final firestore2 = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-disabled-2',
            );

            // Enable persistence using settings instead of deprecated enablePersistence()
            firestore2.settings = const Settings(persistenceEnabled: true);

            PersistentCacheIndexManager? indexManager2 =
                firestore2.persistentCacheIndexManager();

            await indexManager2!.enableIndexAutoCreation();
            await indexManager2.disableIndexAutoCreation();
            await indexManager2.deleteAllIndexes();
          } else {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'other-platform-enabled',
            );
            firestore.settings = const Settings(persistenceEnabled: true);
            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();
            await indexManager!.enableIndexAutoCreation();
            await indexManager.disableIndexAutoCreation();
            await indexManager.deleteAllIndexes();
          }
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );

      test(
        '`PersistenceCacheIndexManager` with persistence disabled for each platform',
        () async {
          if (kIsWeb) {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-disabled-1',
            );
            // persistence is disabled by default so we enable it
            firestore.settings = const Settings(persistenceEnabled: false);

            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();

            expect(indexManager, isNull);
          } else {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'other-platform-disabled',
            );
            // macOS, android, iOS have persistence enabled by default so we disable it
            firestore.settings = const Settings(persistenceEnabled: false);
            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();
            expect(indexManager, isNull);
          }
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    },
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/load_bundle_e2e.dart

**크기**: 8440 bytes | **라인 수**: 253 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;

void runLoadBundleTests() {
  group('$DocumentReference', () {
    late FirebaseFirestore firestore;

    Future<Uint8List> loadBundleSetup(int number) async {
      // endpoint serves a bundle with 3 documents each containing
      // a 'number' property that increments in value 1-3.
      final url =
          Uri.https('api.rnfirebase.io', '/firestore/e2e-tests/bundle-$number');
      final response = await http.get(url);
      String string = response.body;
      return Uint8List.fromList(string.codeUnits);
    }

    setUp(() async {
      firestore = FirebaseFirestore.instance;
    });

    group('FirebaseFirestore.loadBundle()', () {
      test('loadBundle()', () async {
        const int number = 1;
        const String collection = 'firestore-bundle-tests-$number';
        Uint8List buffer = await loadBundleSetup(number);
        LoadBundleTask task = firestore.loadBundle(buffer);

        // ensure the bundle has been completely cached
        await task.stream.last;

        QuerySnapshot<Map<String, Object?>> snapshot = await firestore
            .collection(collection)
            .get(const GetOptions(source: Source.cache));

        expect(
          snapshot.docs.map((document) => document['number']),
          everyElement(anyOf(1, 2, 3)),
        );
      });

      test(
        'loadBundle(): LoadBundleTaskProgress stream snapshots',
        () async {
          Uint8List buffer = await loadBundleSetup(2);
          LoadBundleTask task = firestore.loadBundle(buffer);

          final list = await task.stream.toList();

          expect(
            list.map((e) => e.totalDocuments),
            everyElement(isNonNegative),
          );
          expect(list.map((e) => e.bytesLoaded), everyElement(isNonNegative));
          expect(
            list.map((e) => e.documentsLoaded),
            everyElement(isNonNegative),
          );
          expect(list.map((e) => e.totalBytes), everyElement(isNonNegative));
          expect(list, everyElement(isInstanceOf<LoadBundleTaskSnapshot>()));

          LoadBundleTaskSnapshot lastSnapshot = list.removeLast();
          expect(lastSnapshot.taskState, LoadBundleTaskState.success);

          expect(
            list.map((e) => e.taskState),
            everyElement(LoadBundleTaskState.running),
          );
        },
        // Working locally but is failing on CI
        skip: kIsWeb,
      );

      test(
        'loadBundle(): error handling for malformed bundle',
        () async {
          final url = Uri.https(
            'api.rnfirebase.io',
            '/firestore/e2e-tests/malformed-bundle',
          );
          final response = await http.get(url);
          String string = response.body;
          Uint8List buffer = Uint8List.fromList(string.codeUnits);

          LoadBundleTask task = firestore.loadBundle(buffer);

          await expectLater(
            task.stream.last,
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'load-bundle-error'),
            ),
          );
        },
      );

      test(
        'loadBundle(): pause and resume stream',
        () async {
          Uint8List buffer = await loadBundleSetup(3);
          LoadBundleTask task = firestore.loadBundle(buffer);
          // Illustrates the pause() & resume() function.
          // A single stream will stop sending events once the listener is unsubscribed

          // Will listen & pause after first event received
          await expectLater(
            task.stream,
            emits(
              isA<LoadBundleTaskSnapshot>().having(
                (ts) => ts.taskState,
                'taskState',
                LoadBundleTaskState.running,
              ),
            ),
          );

          await Future.delayed(const Duration(milliseconds: 1));

          // Will resume & pause after second event received
          await expectLater(
            task.stream,
            emits(
              isA<LoadBundleTaskSnapshot>().having(
                (ts) => ts.taskState,
                'taskState',
                anyOf(LoadBundleTaskState.running, LoadBundleTaskState.success),
              ),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });

    group('FirebaseFirestore.namedQueryGet()', () {
      test(
        'namedQueryGet() successful',
        () async {
          const int number = 4;
          Uint8List buffer = await loadBundleSetup(number);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          // namedQuery 'named-bundle-test' which returns a QuerySnaphot of the same 3 documents
          // with 'number' property
          QuerySnapshot<Map<String, Object?>> snapshot =
              await firestore.namedQueryGet(
            'named-bundle-test-$number',
            options: const GetOptions(source: Source.cache),
          );

          expect(
            snapshot.docs.map((document) => document['number']),
            everyElement(anyOf(1, 2, 3)),
          );
        },
        skip: kIsWeb,
      );

      test(
        'namedQueryGet() error',
        () async {
          Uint8List buffer = await loadBundleSetup(4);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          await expectLater(
            firestore.namedQueryGet(
              'wrong-name',
              options: const GetOptions(source: Source.cache),
            ),
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'non-existent-named-query'),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });

    group('FirebaeFirestore.namedQueryWithConverterGet()', () {
      test('namedQueryWithConverterGet() successful', () async {
        const int number = 4;
        Uint8List buffer = await loadBundleSetup(number);
        LoadBundleTask task = firestore.loadBundle(buffer);

        // ensure the bundle has been completely cached
        await task.stream.last;

        // namedQuery 'named-bundle-test' which returns a QuerySnaphot of the same 3 documents
        // with 'number' property
        QuerySnapshot<ConverterPlaceholder> snapshot =
            await firestore.namedQueryWithConverterGet<ConverterPlaceholder>(
          'named-bundle-test-$number',
          options: const GetOptions(source: Source.cache),
          fromFirestore: ConverterPlaceholder.new,
          toFirestore: (value, options) => value.toFirestore(),
        );

        expect(
          snapshot.docs.map((document) => document['number']),
          everyElement(anyOf(1, 2, 3)),
        );
      });

      test(
        'namedQueryWithConverterGet() error',
        () async {
          Uint8List buffer = await loadBundleSetup(4);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          await expectLater(
            firestore.namedQueryWithConverterGet<ConverterPlaceholder>(
              'wrong-name',
              options: const GetOptions(source: Source.cache),
              fromFirestore: ConverterPlaceholder.new,
              toFirestore: (value, options) => value.toFirestore(),
            ),
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'non-existent-named-query'),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });
  });
}

class ConverterPlaceholder {
  ConverterPlaceholder(this.firestore, this.getOptions);

  final DocumentSnapshot<Map<String, Object?>> firestore;
  final SnapshotOptions? getOptions;

  Map<String, Object?> toFirestore() => firestore.data()!;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/query_e2e.dart

**크기**: 133473 bytes | **라인 수**: 4073 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runQueryTests() {
  group('$Query', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    group('equality', () {
      // testing == override using e2e tests as it is dependent on the platform
      test('handles deeply compares query parameters', () async {
        final movies = firestore.collection('/movies');
        final starWarsComments =
            firestore.collection('/movies/star-wars/comments');

        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          movies.where('genre', arrayContains: ['Flutter']),
        );
        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          isNot(movies.where('genre', arrayContains: ['React'])),
        );
        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          isNot(starWarsComments.where('genre', arrayContains: ['Flutter'])),
        );
      });

      test('differentiate queries from a different app instance', () async {
        final fooApp = await Firebase.initializeApp(
          name: 'foo',
          options: Firebase.app().options,
        );

        expect(
          FirebaseFirestore.instanceFor(app: fooApp)
              .collection('movies')
              .limit(42),
          FirebaseFirestore.instanceFor(app: fooApp)
              .collection('movies')
              .limit(42),
        );

        expect(
          FirebaseFirestore.instance.collection('movies').limit(42),
          isNot(
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
          ),
        );
      });

      test('differentiate collection group', () async {
        expect(
          firestore.collectionGroup('comments').limit(42),
          firestore.collectionGroup('comments').limit(42),
        );
        expect(
          firestore.collectionGroup('comments').limit(42),
          isNot(firestore.collection('comments').limit(42)),
        );
      });
    });

    /**
     * collectionGroup
     */
    group('collectionGroup()', () {
      test('returns a data via a sub-collection', () async {
        CollectionReference<Map<String, dynamic>> collection =
            firestore.collection('flutter-tests/collection-group/group-test');
        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

        await Future.forEach(snapshot.docs,
            (DocumentSnapshot documentSnapshot) {
          return documentSnapshot.reference.delete();
        });

        await collection.doc('doc1').set({'foo': 1});
        await collection.doc('doc2').set({'foo': 2});

        QuerySnapshot<Map<String, dynamic>> groupSnapshot = await firestore
            .collectionGroup('group-test')
            .orderBy('foo', descending: true)
            .get();
        expect(groupSnapshot.size, equals(2));
        expect(groupSnapshot.docs[0].data()['foo'], equals(2));
        expect(groupSnapshot.docs[1].data()['foo'], equals(1));
      });

      test(
          'should respond with a FirebaseException, the query requires an index',
          () async {
        try {
          await FirebaseFirestore.instance
              .collectionGroup('collection-group')
              .where('number', isGreaterThan: 1, isLessThan: 3)
              .where('foo', isEqualTo: 'bar')
              .get();
        } catch (error) {
          expect(
            (error as FirebaseException).code,
            equals('failed-precondition'),
          );
          expect(
            error.message,
            'The query requires an index',
          );
        }
      });
    });

    /**
     * get
     */
    group('Query.get()', () {
      test('returns a [QuerySnapshot]', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get();
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test('uses [GetOptions] cache', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs =
            await collection.get(const GetOptions(source: Source.cache));
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        expect(qs.metadata.isFromCache, isTrue);
      });

      test('uses [GetOptions] server', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs =
            await collection.get(const GetOptions(source: Source.server));
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        expect(qs.metadata.isFromCache, isFalse);
      });

      test('uses [GetOptions] serverTimestampBehavior previous', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
          const GetOptions(
            serverTimestampBehavior: ServerTimestampBehavior.previous,
          ),
        );
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test('uses [GetOptions] serverTimestampBehavior estimate', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
          const GetOptions(
            serverTimestampBehavior: ServerTimestampBehavior.estimate,
          ),
        );
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test(
        'throws a [FirebaseException]',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              firestore.collection('not-allowed');

          try {
            await collection.get();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );

      test(
        'should respond with a FirebaseException, the query requires an index',
        () async {
          try {
            await FirebaseFirestore.instance
                .collection('flutter-tests')
                .where('number', isGreaterThan: 1, isLessThan: 3)
                .where('foo', isEqualTo: 'bar')
                .get();
          } catch (error) {
            expect(
              (error as FirebaseException).code,
              equals('failed-precondition'),
            );
            expect(
              error.message,
              'The query requires an index',
            );
          }
        },
      );
    });

    /**
     * snapshots
     */
    group('Query.snapshots()', () {
      test('returns a [Stream]', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        expect(stream, isA<Stream<QuerySnapshot<Map<String, dynamic>>>>());
      });

      test('listens to a single response', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get-single');
        await collection.add({'foo': 'bar'});
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

        subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              expect(snapshot.docs.length, equals(1));
              expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
              QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                  snapshot.docs[0];
              expect(documentSnapshot.data()['foo'], equals('bar'));
            },
            reason: 'Stream should only have been called once.',
          ),
        );
        addTearDown(() async {
          await subscription?.cancel();
        });
      });

      test(
        'listens to a single response from cache with QuerySnapshot',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-single-cache');
          await collection.add({'foo': 'bar'});
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots(source: ListenSource.cache);
          StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

          subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.docs.length, equals(1));
                expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              },
              reason: 'Stream should only have been called once.',
            ),
          );
          addTearDown(() async {
            await subscription?.cancel();
          });
        },
        // Failing on CI but works locally
        skip: kIsWeb,
      );

      test('listens to multiple queries', () async {
        CollectionReference<Map<String, dynamic>> collection1 =
            await initializeTest('document-snapshot-1');
        CollectionReference<Map<String, dynamic>> collection2 =
            await initializeTest('document-snapshot-2');

        await collection1.add({'test': 'value1'});
        await collection2.add({'test': 'value2'});

        final value1 = collection1
            .snapshots()
            .first
            .then((s) => s.docs.first.data()['test']);
        final value2 = collection2
            .snapshots()
            .first
            .then((s) => s.docs.first.data()['test']);

        await expectLater(value1, completion('value1'));
        await expectLater(value2, completion('value2'));
      });

      test('listens to a multiple changes response', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get-multiple');
        await collection.add({'foo': 'bar'});

        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        int call = 0;

        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(1));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc1');
                expect(documentSnapshot.data()['bar'], equals('baz'));
              } else if (call == 3) {
                expect(snapshot.docs.length, equals(1));
                expect(
                  snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty,
                  isTrue,
                );
              } else if (call == 4) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                expect(documentSnapshot.data()['foo'], equals('bar'));
              } else if (call == 5) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                expect(documentSnapshot.data()['foo'], equals('baz'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 5,
            reason: 'Stream should only have been called five times.',
          ),
        );

        await Future.delayed(const Duration(milliseconds: 500));
        await collection.doc('doc1').set({'bar': 'baz'});
        await collection.doc('doc1').delete();
        await collection.doc('doc2').set({'foo': 'bar'});
        await collection.doc('doc2').update({'foo': 'baz'});

        await subscription.cancel();
      });

      test(
        'listeners throws a [FirebaseException] with Query',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              firestore.collection('not-allowed');
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();

          try {
            await stream.first;
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals(
                'permission-denied',
              ),
            );
            return;
          }

          fail('Should have thrown a [FirebaseException]');
        },
      );
    });

    /**
     * End At
     */

    group('Query.endAt{Document}()', () {
      test('ends at string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends at string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endAt({2}).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends at field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .endAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy(FieldPath(const ['foo'])).endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('endAtDocument() ends at a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .endAtDocument(endAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('endAtDocument() ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.endAtDocument(endAtSnapshot).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });
    });

    /**
     * Start At
     */

    group('Query.startAt{Document}()', () {
      test('starts at string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts at string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAt({2}).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts at field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .startAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('startAtDocument() starts at a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .startAtDocument(startAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));
      });

      test('startAtDocument() starts at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.startAtDocument(startAtSnapshot).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc4'));
      });
    });

    /**
     * End Before
     */

    group('Query.endBefore{Document}()', () {
      test('ends before string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endBefore([1]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends before string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endBefore({1}).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends before field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .endBefore([1]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('endbeforeDocument() ends before a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc1').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .endBeforeDocument(endAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('endBeforeDocument() ends before a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc4').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.endBeforeDocument(endAtSnapshot).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });
    });

    /**
     * Start after
     */
    group('Query.startAfter{Document}()', () {
      test('starts after string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAfter([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAfter([1]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts after field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .startAfter([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .startAfter([1]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('startAfterDocument() starts after a document field value',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot startAfterSnapshot =
            await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .startAfterDocument(startAfterSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));
      });

      test('startAfterDocument() starts after a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.startAfterDocument(startAtSnapshot).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc4'));
      });

      testWidgets(
        'throws exception without orderBy() on field used for inequality query',
        (_) async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfterDocument-inequality-field-throw');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 10},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 10},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 10},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          Query inequalityQuery =
              collection.where('bar.value', isGreaterThan: 5);

          await expectLater(
            inequalityQuery.startAfterDocument(startAtSnapshot).get(),
            throwsA(
              isA<FirebaseException>().having(
                (e) => e.message,
                'message',
                contains(
                  'Client specified an invalid argument',
                ),
              ),
            ),
          );
        },
        // firebase-js-sdk does not require an orderBy() field to be set for this to work
        skip: kIsWeb,
      );

      testWidgets(
        'throws exception without correct orderBy("wrong-field") field used for inequality query',
        (_) async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'startAfterDocument-wrong-inequality-field-throw',
          );
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc2').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
            collection.doc('doc3').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
            collection.doc('doc4').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          Query inequalityQuery =
              collection.where('bar.value', isGreaterThan: 5);
          await expectLater(
            inequalityQuery
                .orderBy('wrong-field')
                .startAfterDocument(startAtSnapshot)
                .get(),
            throwsA(
              isA<FirebaseException>().having(
                (e) => e.message,
                'message',
                contains(
                  'Client specified an invalid argument',
                ),
              ),
            ),
          );
        },
        // firebase-js-sdk does not require an orderBy() field to be set for this to work
        skip: kIsWeb,
      );

      testWidgets(
          'Successful request when using orderBy() with same field used on inequality query',
          (_) async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfterDocument-correct-inequality-field');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': 2,
          }),
          collection.doc('doc2').set({
            'bar': 10,
          }),
          collection.doc('doc3').set({
            'bar': 11,
          }),
          collection.doc('doc4').set({
            'bar': 12,
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
        Query inequalityQuery = collection.where('bar', isGreaterThan: 5);

        final result = await inequalityQuery
            .orderBy('bar')
            .startAfterDocument(startAtSnapshot)
            .get();

        expect(result.size, equals(2));
        expect(result.docs[0].id, equals('doc3'));
        expect(result.docs[1].id, equals('doc4'));
      });
    });

    /**
     * Start & End
     */

    group('Query.startAt/endAt', () {
      test('starts at & ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAt([2]).endAt([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts at & ends before a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAt([2]).endBefore([4]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts after & ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAfter([1]).endAt([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts a document and ends before document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-document');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
        DocumentSnapshot endBeforeSnapshot = await collection.doc('doc4').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .startAtDocument(startAtSnapshot)
            .endBeforeDocument(endBeforeSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });
    });

    /**
     * Limit
     */

    group('Query.limit{toLast}()', () {
      test('limits documents', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limit');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.limit(2).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo', descending: true).limit(2).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc3'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('limits to last documents', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limitToLast');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').limitToLast(2).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy('foo', descending: true)
            .limitToLast(2)
            .get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc1'));
      });
    });

    /**
     * Order
     */
    group('Query.orderBy()', () {
      test('allows ordering by documentId', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-document-id');

        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 1,
          }),
          collection.doc('doc3').set({
            'foo': 1,
          }),
          collection.doc('doc4').set({
            'bar': 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').orderBy(FieldPath.documentId).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });

      test('orders async by default', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-asc');

        await Future.wait([
          collection.doc('doc1').set({
            'foo': 3,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc1'));
      });

      test('orders descending', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-desc');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo', descending: true).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc1'));
      });
    });

    /**
     * Where filters
     */

    group('Query.where()', () {
      test('returns documents when querying for properties that are not null',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('not-null');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 'bar',
          }),
          collection.doc('doc2').set({
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'foo': null,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNull: false).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('returns documents when querying properties that are equal to null',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('not-null');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 'bar',
          }),
          collection.doc('doc2').set({
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'foo': null,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNull: true).get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].id, equals('doc3'));
      });

      test('returns with equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isEqualTo: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals(rand));
        });
      });

      test('returns with not equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNotEqualTo: rand).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals(rand + 1));
        });
      });

      test('returns with greater than checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-greater-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand - 1,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
          collection.doc('doc4').set({
            'foo': rand + 2,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isGreaterThan: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] > rand, isTrue);
        });
      });

      test('returns with greater than or equal to checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-greater-than-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand - 1,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
          collection.doc('doc4').set({
            'foo': rand + 2,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isGreaterThanOrEqualTo: rand).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] >= rand, isTrue);
        });
      });

      test('returns with less than checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-less-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': -rand + 1,
          }),
          collection.doc('doc2').set({
            'foo': -rand + 2,
          }),
          collection.doc('doc3').set({
            'foo': rand,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isLessThan: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] < rand, isTrue);
        });
      });

      test('returns with less than equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-less-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': -rand + 1,
          }),
          collection.doc('doc2').set({
            'foo': -rand + 2,
          }),
          collection.doc('doc3').set({
            'foo': rand,
          }),
          collection.doc('doc4').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isLessThanOrEqualTo: rand).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] <= rand, isTrue);
        });
      });

      test('returns with array-contains filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': [1, '2', rand],
          }),
          collection.doc('doc2').set({
            'foo': [1, '2', '$rand'],
          }),
          collection.doc('doc3').set({
            'foo': [1, '2', '$rand'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', arrayContains: '$rand').get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals([1, '2', '$rand']));
        });
      });

      test('returns with in filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereIn: ['Ready to Ship', 'Ordered']).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with in filter using Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in-iterable');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where(
              'status',
              // To force the list to be an iterable
              whereIn: ['Ready to Ship', 'Ordered'].map((e) => e),
            )
            .get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with in filter using Set', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereIn: {'Ready to Ship', 'Ordered'}).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with not-in filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereNotIn: ['Ready to Ship', 'Ordered']).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Incomplete', isTrue);
        });
      });

      test('returns with not-in filter with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereNotIn: {'Ready to Ship', 'Ordered'}).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Incomplete', isTrue);
        });
      });

      test('returns with array-contains-any filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains-any');

        await Future.wait([
          collection.doc('doc1').set({
            'category': ['Appliances', 'Housewares', 'Cooking'],
          }),
          collection.doc('doc2').set({
            'category': ['Appliances', 'Electronics', 'Nursery'],
          }),
          collection.doc('doc3').set({
            'category': ['Audio/Video', 'Electronics'],
          }),
          collection.doc('doc4').set({
            'category': ['Beauty'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
          'category',
          arrayContainsAny: ['Appliances', 'Electronics'],
        ).get();

        // 2nd record should only be returned once
        expect(snapshot.docs.length, equals(3));
      });

      test('returns with array-contains-any filter using Set', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains-any');

        await Future.wait([
          collection.doc('doc1').set({
            'category': ['Appliances', 'Housewares', 'Cooking'],
          }),
          collection.doc('doc2').set({
            'category': ['Appliances', 'Electronics', 'Nursery'],
          }),
          collection.doc('doc3').set({
            'category': ['Audio/Video', 'Electronics'],
          }),
          collection.doc('doc4').set({
            'category': ['Beauty'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
          'category',
          arrayContainsAny: {'Appliances', 'Electronics'},
        ).get();

        // 2nd record should only be returned once
        expect(snapshot.docs.length, equals(3));
      });

      // When documents have a key with a '.' in them, only a [FieldPath]
      // can access the value, rather than a raw string
      test('returns where FieldPath', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-field-path');

        FieldPath fieldPath = FieldPath(const ['nested', 'foo.bar@gmail.com']);

        await Future.wait([
          collection.doc('doc1').set({
            'nested': {
              'foo.bar@gmail.com': true,
            },
          }),
          collection.doc('doc2').set({
            'nested': {
              'foo.bar@gmail.com': true,
            },
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'nested': {
              'foo.bar@gmail.com': false,
            },
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where(fieldPath, isEqualTo: true).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].get(fieldPath), isTrue);
        expect(snapshot.docs[1].get(fieldPath), isTrue);
        expect(snapshot.docs[1].get('foo'), equals('bar'));
      });

      test('returns results using FieldPath.documentId', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-field-path-document-id');

        DocumentReference<Map<String, dynamic>> docRef = await collection.add({
          'foo': 'bar',
        });

        // Add secondary document for sanity check
        await collection.add({
          'bar': 'baz',
        });

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where(FieldPath.documentId, isEqualTo: docRef.id)
            .get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].get('foo'), equals('bar'));
      });

      test('returns an encoded DocumentReference', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-document-reference');

        DocumentReference<Map<String, dynamic>> ref =
            FirebaseFirestore.instance.doc('foo/bar');

        await Future.wait([
          collection.add({
            'foo': ref,
          }),
          collection.add({
            'foo': FirebaseFirestore.instance.doc('bar/baz'),
          }),
          collection.add({
            'foo': 'foo/bar',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('foo', isEqualTo: FirebaseFirestore.instance.doc('foo/bar'))
            .get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].get('foo'), equals(ref));
      });
    });

    group('Query.where() with Filter class', () {
      test(
          'returns documents with `DocumentReference` as an argument in `isEqualTo`',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('doc-ref-arg-isequal-to');
        final ref = FirebaseFirestore.instance.doc('foo/bar');
        final ref2 = FirebaseFirestore.instance.doc('foo/foo');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'title': 'Book A',
            'ref': FirebaseFirestore.instance.doc('foo/bar'),
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'title': 'Book B',
            'ref': FirebaseFirestore.instance.doc('foo/bar'),
          }),
          collection.doc('doc3').set({
            'genre': 'fantasy',
            'title': 'Book C',
            'ref': ref2,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter('ref', isEqualTo: ref),
                ),
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter(
                    'ref',
                    isEqualTo: ref2,
                  ),
                ),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('Book C'));
        expect(results.docs[1].data()['title'], equals('Book B'));
        expect(results.docs[2].data()['title'], equals('Book A'));
      });

      test(
          'returns documents with `DocumentReference` as an argument in `arrayContains`',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('doc-ref-arg-array-contains');
        final ref = FirebaseFirestore.instance.doc('foo/bar');
        final ref2 = FirebaseFirestore.instance.doc('foo/foo');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'title': 'Book A',
            'ref': [ref],
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'title': 'Book B',
            'ref': [ref],
          }),
          collection.doc('doc3').set({
            'genre': 'adventure',
            'title': 'Book C',
            'ref': [ref2],
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter('ref', arrayContains: ref),
                ),
                Filter.and(
                  Filter('genre', isEqualTo: 'adventure'),
                  Filter(
                    'ref',
                    arrayContains: ref2,
                  ),
                ),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('Book C'));
        expect(results.docs[1].data()['title'], equals('Book B'));
        expect(results.docs[2].data()['title'], equals('Book A'));
      });

      test('returns documents with OR filter for arrayContainsAny', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-array-contains-any');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'title': 'Book A',
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'title': 'Book B',
          }),
          collection.doc('doc3').set({
            'genre': ['mystery', 'thriller'],
            'title': 'Book C',
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter('genre', arrayContainsAny: ['fantasy']),
                Filter('genre', arrayContainsAny: ['sci-fi']),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('Book B'));
        expect(results.docs[1].data()['title'], equals('Book A'));
      });

      test('returns documents with AND filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-and');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
        ]);

        final results = await collection
            .where(
              Filter.and(
                Filter('genre', arrayContains: 'sci-fi'),
                Filter('rating', isGreaterThanOrEqualTo: 4.0),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[0].data()['rating'], equals(4.2));
        expect(results.docs[0].data()['genre'], equals(['sci-fi', 'action']));
      });

      test('returns documents with OR filter and a previous condition',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-and');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'rating': 4.5,
            'year': 1970,
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'rating': 3.8,
            'year': 1980,
          }),
          collection.doc('doc3').set({
            'genre': 'sci-fi',
            'rating': 4.2,
            'year': 1980,
          }),
        ]);

        final results = await collection
            .where('genre', isEqualTo: 'fantasy')
            .where(
              Filter.or(
                Filter('year', isEqualTo: 1980),
                Filter('rating', isGreaterThanOrEqualTo: 4.0),
              ),
            )
            .orderBy('rating')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[0].data()['rating'], equals(3.8));
        expect(results.docs[1].id, equals('doc1'));
        expect(results.docs[1].data()['rating'], equals(4.5));
      });

      test('returns documents with nested OR and AND filters', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-nested');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
          collection.doc('doc4').set({
            'genre': ['mystery', 'action'],
            'rating': 4.7,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', arrayContains: 'sci-fi'),
                  Filter('rating', isGreaterThanOrEqualTo: 4.0),
                ),
                Filter.and(
                  Filter('genre', arrayContains: 'mystery'),
                  Filter('rating', isGreaterThanOrEqualTo: 4.5),
                ),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc4'));
        expect(results.docs[0].data()['rating'], equals(4.7));
        expect(
          results.docs[0].data()['genre'],
          equals(['mystery', 'action']),
        );
        expect(results.docs[1].id, equals('doc3'));
        expect(results.docs[1].data()['rating'], equals(4.2));
        expect(results.docs[1].data()['genre'], equals(['sci-fi', 'action']));
      });

      test('allow FieldPathType for Filter queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('filter-path-type');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
          collection.doc('doc4').set({
            'genre': ['mystery', 'action'],
            'rating': 4.7,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter(FieldPath.documentId, isEqualTo: 'doc1'),
                  Filter('rating', isEqualTo: 4.5),
                ),
                Filter.and(
                  Filter(FieldPath.documentId, isEqualTo: 'doc2'),
                  Filter('rating', isEqualTo: 3.8),
                ),
              ),
            )
            .orderBy(FieldPath.documentId, descending: false)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[0].data()['rating'], equals(4.5));

        expect(results.docs[1].id, equals('doc2'));
        expect(results.docs[1].data()['rating'], equals(3.8));
      });

      test('allow multiple conjunctive queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-conjunctive-queries');

        final matchMap = {
          'rating1': 3.8,
          'year1': 1970,
          'runtime1': 90,
          'director1': 'Director2',
          'producer1': 'Producer2',
          'budget1': 20000000,
          'boxOffice1': 50000000,
          'actor1': 'Actor2',
          'language1': 'English',
          'award1': 'Award2',
          'genre1': ['sci-fi', 'thriller'],
          'country1': 'USA',
          'released1': true,
          'screenplay1': 'Screenplay2',
          'cinematography1': 'Cinematography2',
          'music1': 'Music2',
          'rating2': 4.2,
          'year2': 1982,
          'runtime2': 60,
          'director2': 'Director3',
          'producer2': 'Producer3',
          'budget2': 30000000,
          'boxOffice2': 60000000,
          'actor2': 'Actor3',
          'language2': 'Korean',
          'award2': 'Award3',
          'genre2': ['sci-fi', 'action'],
          'country2': 'South Korea',
          'released2': false,
          'screenplay2': 'Screenplay3',
        };

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
            'director': 'Director1',
            'producer': 'Producer1',
            'budget': 10000000,
            'boxOffice': 25000000,
            'actor': 'Actor1',
            'language': 'English',
            'award': 'Award1',
          }),
          collection.doc('doc2').set(matchMap),
          collection.doc('doc3').set(matchMap),
        ]);

        final results = await collection
            .where(
              Filter.and(
                Filter('rating1', isEqualTo: 3.8),
                Filter('year1', isEqualTo: 1970),
                Filter('runtime1', isEqualTo: 90),
                Filter('director1', isEqualTo: 'Director2'),
                Filter('producer1', isEqualTo: 'Producer2'),
                Filter('budget1', isEqualTo: 20000000),
                Filter('boxOffice1', isEqualTo: 50000000),
                Filter('actor1', isEqualTo: 'Actor2'),
                Filter('language1', isEqualTo: 'English'),
                Filter('award1', isEqualTo: 'Award2'),
                Filter('genre1', arrayContainsAny: ['sci-fi']),
                Filter('country1', isEqualTo: 'USA'),
                Filter('released1', isEqualTo: true),
                Filter('screenplay1', isEqualTo: 'Screenplay2'),
                Filter('cinematography1', isEqualTo: 'Cinematography2'),
                Filter('music1', isEqualTo: 'Music2'),
                Filter('rating2', isEqualTo: 4.2),
                Filter('year2', isEqualTo: 1982),
                Filter('runtime2', isEqualTo: 60),
                Filter('director2', isEqualTo: 'Director3'),
                Filter('producer2', isEqualTo: 'Producer3'),
                Filter('budget2', isEqualTo: 30000000),
                Filter('boxOffice2', isEqualTo: 60000000),
                Filter('actor2', isEqualTo: 'Actor3'),
                Filter('language2', isEqualTo: 'Korean'),
                Filter('award2', isEqualTo: 'Award3'),
                Filter('genre2', isEqualTo: ['sci-fi', 'action']),
                Filter('country2', isEqualTo: 'South Korea'),
                Filter('released2', isEqualTo: false),
                Filter('screenplay2', isEqualTo: 'Screenplay3'),
              ),
            )
            .orderBy('rating1', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test(
        'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple conjunctive queries',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'array-contain-not-equal-conjunctive-queries',
          );

          await Future.wait([
            collection.doc('doc1').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc2').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc3').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'foo',
            }),
          ]);

          final results = await collection
              .where(
                Filter.and(
                  Filter('genre', arrayContainsAny: ['sci-fi']),
                  Filter('screenplay2', isNotEqualTo: 'foo'),
                ),
              )
              .orderBy('screenplay2', descending: true)
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc1'));
        },
      );

      test('allow multiple disjunctive queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-queries');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
            'director': 'Director1',
            'producer': 'Producer1',
            'country': 'USA',
            'budget': 10000000,
            'boxOffice': 25000000,
            'actor': 'Actor1',
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
            'year': 1970,
            'runtime': 90,
            'released': true,
            'country': 'Wales',
            'director': 'Director2',
            'producer': 'Producer2',
            'budget': 20000000,
            'boxOffice': 50000000,
            'actor': 'Actor2',
            'language': 'English',
            'award': 'Award2',
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 4.2,
            'year': 1982,
            'runtime': 60,
            'released': false,
            'country': 'Wales',
            'director': 'Director3',
            'producer': 'Producer3',
            'budget': 30000000,
            'boxOffice': 60000000,
            'actor': 'Actor3',
            'language': 'Korean',
            'award': 'Award3',
          }),
          collection.doc('doc4').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 4.7,
            'year': 1990,
            'runtime': 120,
            'released': true,
            'country': 'Wales',
            'director': 'Director4',
            'producer': 'Producer4',
            'budget': 40000000,
            'boxOffice': 80000000,
            'actor': 'Actor4',
            'language': 'Welsh',
            'award': 'Award4',
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter('rating', isEqualTo: 3.8),
                Filter('year', isEqualTo: 1970),
                Filter('runtime', isEqualTo: 90),
                Filter('director', isEqualTo: 'Director2'),
                Filter('country', isEqualTo: 'Wales'),
                Filter('budget', isEqualTo: 20000000),
                Filter('boxOffice', isEqualTo: 50000000),
                Filter('genre', arrayContainsAny: ['sci-fi']),
                Filter('actor', isEqualTo: 'Actor2'),
                Filter('language', isEqualTo: 'English'),
                Filter('award', isEqualTo: 'Award2'),
                Filter('screenWriter', isEqualTo: 'ScreenWriter2'),
                Filter('editor', isEqualTo: 'Editor2'),
                Filter('cinematographer', isEqualTo: 'Cinematographer2'),
                Filter('releaseCountry', isEqualTo: 'Country2'),
                Filter('distributor', isEqualTo: 'Distributor2'),
                Filter('ratingSystem', isEqualTo: 'RatingSystem2'),
                Filter('soundtrackComposer', isEqualTo: 'Composer2'),
                Filter('visualEffectsCompany', isEqualTo: 'EffectsCompany2'),
                Filter('productionCompany', isEqualTo: 'ProductionCompany2'),
                Filter('filmFormat', isEqualTo: 'FilmFormat2'),
                Filter('aspectRatio', isEqualTo: 'AspectRatio2'),
                Filter('colorProcess', isEqualTo: 'ColorProcess2'),
                Filter('soundProcess', isEqualTo: 'SoundProcess2'),
                Filter('numberOfTheaters', isEqualTo: 2000),
                Filter('openingWeekendRevenue', isEqualTo: 10000000),
                Filter('totalDomesticRevenue', isEqualTo: 60000000),
                Filter('totalWorldwideRevenue', isEqualTo: 200000000),
                Filter('estimatedProfit', isEqualTo: 140000000),
                Filter('mainCharacter', isEqualTo: 'MainCharacter2'),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].id, equals('doc4'));
        expect(results.docs[0].data()['rating'], equals(4.7));
        expect(
          results.docs[0].data()['genre'],
          equals(['sci-fi', 'thriller']),
        );
        expect(results.docs[1].id, equals('doc3'));
        expect(results.docs[1].data()['rating'], equals(4.2));
        expect(results.docs[1].data()['genre'], equals(['sci-fi', 'thriller']));
        expect(results.docs[2].id, equals('doc2'));
        expect(results.docs[2].data()['rating'], equals(3.8));
        expect(results.docs[2].data()['genre'], equals(['sci-fi', 'thriller']));
      });

      test(
        'Can combine  `arrayContainsAny` & `isNotEqualTo` in disjunctive queries',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'array-contain-not-equal-disjunctive-queries',
          );

          await Future.wait([
            collection.doc('doc1').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc2').set({
              'genre': ['fantasy', 'sci-fi'],
              'mainCharacter': 'MainCharacter2',
            }),
            collection.doc('doc3').set({
              'genre': ['fantasy', 'something else'],
              'mainCharacter': 'foo',
            }),
            collection.doc('doc4').set({
              'genre': ['fantasy', 'something else'],
              'mainCharacter': 'MainCharacter2',
            }),
          ]);

          final results = await collection
              .where(
                Filter.or(
                  Filter('genre', arrayContainsAny: ['sci-fi']),
                  Filter('mainCharacter', isNotEqualTo: 'MainCharacter2'),
                ),
              )
              .orderBy('mainCharacter', descending: true)
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc3'));
          expect(results.docs[1].id, equals('doc2'));
        },
      );

      test(
          'allow multiple disjunctive queries for "arrayContainsAny" using ".where() API"',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-where');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['Not', 'Here'],
            'number': 1,
          }),
          collection.doc('doc2').set({
            'genre': ['Animation', 'Another'],
            'number': 2,
          }),
          collection.doc('doc3').set({
            'genre': ['Adventure', 'Another'],
            'number': 3,
          }),
        ]);
        final genres = [
          'Action',
          'Adventure',
          'Animation',
          'Biography',
          'Comedy',
          'Crime',
          'Drama',
          'Documentary',
          'Family',
          'Fantasy',
          'Film-Noir',
          'History',
          'Horror',
          'Music',
          'Musical',
          'Mystery',
          'Romance',
          'Sci-Fi',
          'Sport',
          'Thriller',
          'War',
          'Western',
          'Epic',
          'Tragedy',
          'Satire',
          'Romantic Comedy',
          'Black Comedy',
          'Paranormal',
          'Non-fiction',
          'Realism',
        ];

        final results = await collection
            .where(
              'genre',
              arrayContainsAny: genres,
            )
            .orderBy('number')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test(
          'allow multiple disjunctive queries for "whereIn" using ".where() API"',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-where');

        await Future.wait([
          collection.doc('doc1').set({'genre': 'Not this', 'number': 1}),
          collection.doc('doc2').set({'genre': 'Animation', 'number': 2}),
          collection.doc('doc3').set({'genre': 'Adventure', 'number': 3}),
        ]);
        final genres = [
          'Action',
          'Adventure',
          'Animation',
          'Biography',
          'Comedy',
          'Crime',
          'Drama',
          'Documentary',
          'Family',
          'Fantasy',
          'Film-Noir',
          'History',
          'Horror',
          'Music',
          'Musical',
          'Mystery',
          'Romance',
          'Sci-Fi',
          'Sport',
          'Thriller',
          'War',
          'Western',
          'Epic',
          'Tragedy',
          'Satire',
          'Romantic Comedy',
          'Black Comedy',
          'Paranormal',
          'Non-fiction',
          'Realism',
        ];

        final results = await collection
            .where(
              'genre',
              whereIn: genres,
            )
            .orderBy('number')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('"whereIn" query combined with "arrayContainsAny"', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontainsany-in-combined');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
            'prop': 'foo',
          }),
          collection.doc('doc2').set({
            'value': [2, 4, 5],
            'prop': 'bar',
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
            'prop': 'basalt',
          }),
        ]);

        final results = await collection
            .where(
              'value',
              arrayContainsAny: [1, 7],
            )
            .where(
              'prop',
              whereIn: ['foo', 'basalt'],
            )
            .orderBy('prop')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[1].id, equals('doc1'));
      });

      test('isEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 5}),
          collection.doc('doc3').set({'value': 7}),
        ]);

        final results = await collection
            .where(
              Filter('value', isEqualTo: 5),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('isNotEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isnotequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 5}),
          collection.doc('doc3').set({'value': 7}),
        ]);

        final results = await collection
            .where(
              Filter('value', isNotEqualTo: 5),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc3'));
      });

      test('isLessThan filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-islessthan');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isLessThan: 7),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc1'));
      });

      test('isLessThanOrEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-islessthanequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isLessThanOrEqualTo: 7),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('isGreaterThan filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isgreaterthan');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isGreaterThan: 5),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('isGreaterThanOrEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isgreaterthanequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isGreaterThanOrEqualTo: 7),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('arrayContains filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontains');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
          }),
          collection.doc('doc2').set({
            'value': [1, 4, 5],
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
          }),
        ]);

        final results = await collection
            .where(
              Filter('value', arrayContains: 1),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('arrayContainsAny filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontainsany');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
          }),
          collection.doc('doc2').set({
            'value': [1, 4, 5],
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
          }),
        ]);

        final results = await collection
            .where(
              Filter('value', arrayContainsAny: [1, 7]),
            )
            .get();

        expect(results.docs.length, equals(3));
      });

      test('whereIn filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-wherein');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': 'B'}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', whereIn: ['A', 'C']),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('whereNotIn filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-wherenotin');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': 'B'}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', whereNotIn: ['A', 'C']),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc2'));
      });

      test('isNull filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isnull');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': null}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', isNull: true),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc2'));
      });

      test('endAt filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endat-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endAt([3]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('endBefore filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endbefore-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // endBefore
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endBefore([4]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('endBeforeDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endbeforedocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc4').get();

        // endBeforeDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endBeforeDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('limit filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limit-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // limit
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .limit(2)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('limitToLast filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limittolast-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // limitToLast
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .limitToLast(2)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('D'));
        expect(results.docs[1].data()['title'], equals('E'));
      });

      test('orderBy filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('orderby-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // orderBy
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: true)
            .get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('E'));
        expect(results.docs[1].data()['title'], equals('D'));
        expect(results.docs[2].data()['title'], equals('C'));
        expect(results.docs[3].data()['title'], equals('B'));
      });

      test('startAfter filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startafter-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // startAfter
        results = await collection
            .where(Filter('value', isGreaterThan: 3))
            .orderBy('value', descending: false)
            .startAfter([2]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('D'));
        expect(results.docs[1].data()['title'], equals('E'));
      });

      test('startAfterDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startafterdocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc2').get();

// startAfterDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAfterDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('C'));
        expect(results.docs[1].data()['title'], equals('D'));
        expect(results.docs[2].data()['title'], equals('E'));
      });

      test('startAt filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startat-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

// startAt
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAt([2]).get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
        expect(results.docs[2].data()['title'], equals('D'));
        expect(results.docs[3].data()['title'], equals('E'));
      });

      test('startAtDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startatdocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc2').get();

// startAtDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAtDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
        expect(results.docs[2].data()['title'], equals('D'));
        expect(results.docs[3].data()['title'], equals('E'));
      });
    });

    group('withConverter', () {
      test(
        'from a query instead of collection',
        () async {
          final collection = await initializeTest('foo');

          final query = collection //
              .where('value', isGreaterThan: 0)
              .withConverter<int>(
                fromFirestore: (snapshots, _) =>
                    snapshots.data()!['value']! as int,
                toFirestore: (value, _) => {'value': value},
              );

          await collection.add({'value': 42});
          await collection.add({'value': -1});

          final snapshot = query.snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await collection.add({'value': 21});

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals(
                  [
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ],
                ),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'from a Filter query instead of collection',
        () async {
          final collection = await initializeTest('foo');

          final query = collection
              .where(Filter('value', isGreaterThan: 0))
              .withConverter<int>(
                fromFirestore: (snapshots, _) =>
                    snapshots.data()!['value']! as int,
                toFirestore: (value, _) => {'value': value},
              );

          await collection.add({'value': 42});
          await collection.add({'value': -1});

          final snapshot = query.snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await collection.add({'value': 21});

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals(
                  [
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ],
                ),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'snapshots',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(-1);

          final snapshot =
              converted.where('value', isGreaterThan: 0).snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await converted.add(21);

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals([
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 21),
                ]),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'get',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(-1);

          expect(
            await converted
                .where('value', isGreaterThan: 0)
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'orderBy',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted.orderBy('value').get().then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'limit',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted.orderBy('value').limit(1).get().then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'limitToLast',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted
                .orderBy('value')
                .limitToLast(1)
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test('endAt', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted.orderBy('value').endAt([2]).get().then((d) => d.docs),
          [
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
          ],
        );
      });

      test('endAt with Iterable', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted.orderBy('value').endAt({2}).get().then((d) => d.docs),
          [
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
          ],
        );
      });

      test(
        'endAtDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAtDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test('endBefore', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted
              .orderBy('value')
              .endBefore([2])
              .get()
              .then((d) => d.docs),
          [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
        );
      });

      test('endBefore with Iterable', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted
              .orderBy('value')
              .endBefore({2})
              .get()
              .then((d) => d.docs),
          [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
        );
      });

      test(
        'endBeforeDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBeforeDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAt',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAt([2])
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAt with Iterable',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAt({2})
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAtDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAtDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfter',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfter([2])
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfter with Iterable',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfter({2})
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfterDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfterDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );
    });

    group('Aggregate Queries', () {
      test(
        'count()',
        () async {
          final collection = await initializeTest('count');

          await Future.wait([
            collection.add({'foo': 'bar'}),
            collection.add({'bar': 'baz'}),
          ]);

          AggregateQuery query = collection.count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            2,
          );
        },
      );

      test(
        'count() with query',
        () async {
          final collection = await initializeTest('count');

          await Future.wait([
            collection.add({'foo': 'bar'}),
            collection.add({'foo': 'baz'}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 'bar').count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            1,
          );
        },
      );

      test(
        'sum()',
        () async {
          final collection = await initializeTest('sum');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query = collection.aggregate(sum('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getSum('foo'),
            3,
          );
        },
      );

      test(
        'sum() with query',
        () async {
          final collection = await initializeTest('sum');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 1).aggregate(sum('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getSum('foo'),
            1,
          );
        },
      );

      test(
        'average()',
        () async {
          final collection = await initializeTest('avg');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query = collection.aggregate(average('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getAverage('foo'),
            1.5,
          );
        },
      );

      test(
        'average() with query',
        () async {
          final collection = await initializeTest('avg');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 1).aggregate(average('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getAverage('foo'),
            1,
          );
        },
      );

      test(
        'chaining aggregate queries',
        () async {
          final collection = await initializeTest('chaining');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.aggregate(count(), sum('foo'), average('foo'));
          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            2,
          );

          expect(
            snapshot.getSum('foo'),
            3,
          );

          expect(
            snapshot.getAverage('foo'),
            1.5,
          );
        },
      );

      test('chaining multiples aggregate queries', () async {
        final collection = await initializeTest('chaining');

        await Future.wait([
          collection.add({'foo': 1}),
          collection.add({'foo': 2}),
        ]);

        AggregateQuery query = collection
            .where('foo', isEqualTo: 1)
            .aggregate(count(), sum('foo'), average('foo'));

        AggregateQuerySnapshot snapshot = await query.get();

        expect(
          snapshot.count,
          1,
        );

        expect(
          snapshot.getSum('foo'),
          1,
        );

        expect(
          snapshot.getAverage('foo'),
          1,
        );
      });

      test(
        'count() with collectionGroup',
        () async {
          const subCollection = 'aggregate-group-count';
          final doc1 = FirebaseFirestore.instance
              .collection('flutter-tests')
              .doc('agg1');
          final doc2 = FirebaseFirestore.instance
              .collection('flutter-tests')
              .doc('agg2');
          await Future.wait([
            doc1.set({'foo': 'bar'}),
            doc2.set({'foo': 'baz'}),
          ]);

          final collection = doc1.collection(subCollection);
          final collection2 = doc2.collection(subCollection);

          await Future.wait([
            // 6 sub-documents
            collection.doc('agg1').set({'foo': 'bar'}),
            collection.doc('agg2').set({'foo': 'bar'}),
            collection.doc('agg3').set({'foo': 'bar'}),
            collection2.doc('agg4').set({'foo': 'bar'}),
            collection2.doc('agg5').set({'foo': 'bar'}),
            collection2.doc('agg6').set({'foo': 'bar'}),
          ]);

          AggregateQuery query =
              FirebaseFirestore.instance.collectionGroup(subCollection).count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            6,
          );
        },
      );

      test('count(), average() & sum() on empty collection', () async {
        final collection = await initializeTest('empty-collection');

        final snapshot = await collection
            .aggregate(count(), sum('foo'), average('foo'))
            .get();
        expect(snapshot.count, 0);
        expect(snapshot.getSum('foo'), 0);
        expect(snapshot.getAverage('foo'), null);
      });
    });

    group('startAfterDocument', () {
      test('startAfterDocument() accept DocumentReference in query parameters',
          () async {
        final collection = await initializeTest('start-after-document');

        final doc1 = collection.doc('1');
        final doc2 = collection.doc('2');
        final doc3 = collection.doc('3');
        final doc4 = collection.doc('4');
        await doc1.set({'ref': doc1});
        await doc2.set({'ref': doc2});
        await doc3.set({'ref': doc3});
        await doc4.set({'ref': null});

        final q = collection
            .where('ref', isNull: false)
            .orderBy('ref')
            .startAfterDocument(await doc1.get());

        final res = await q.get();
        expect(res.docs.map((e) => e.reference), [doc2, doc3]);
      });
    });

    group('WhereIn Filter', () {
      test('Multiple whereIn filters should not trigger an assertion',
          () async {
        try {
          final collection = await initializeTest('multipe-whereIn-clause');

          Map<String, String> data = {};

          for (int i = 1; i <= 10; i++) {
            data['field$i'] = 'value$i';
          }

          await collection.doc().set(data);

          Query<Map<String, dynamic>> query = collection;
          data.forEach((field, values) {
            query = query.where(field, whereIn: [values]);
          });

          await query.get();
        } on AssertionError catch (e) {
          fail('Test failed due to AssertionError: $e');
        }
      });

      test(
          'Multiple whereIn filters exceeding DNF 30 clause limit should trigger an assertion',
          () async {
        try {
          final collection = await initializeTest('multipe-whereIn-clause');

          await collection.doc().set({'genre': 'fiction'});
          await collection.doc().set({'author': 'Author A'});

          // DNF for this query = 36 (6 genres * 6 authors) exceeding the 30 clause limit
          await collection.where(
            'genre',
            whereIn: [
              'fiction',
              'non-fiction',
              'fantasy',
              'science-fiction',
              'mystery',
              'thriller',
            ],
          ).where(
            'author',
            whereIn: [
              'Author A',
              'Author B',
              'Author C',
              'Author D',
              'Author E',
              'Author F',
            ],
          ).get();
        } catch (error) {
          expect(error, isA<FirebaseException>());
        }
      });
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/second_database.dart

**크기**: 103544 bytes | **라인 수**: 3007 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
import 'dart:async';
import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

// ignore: do_not_use_environment
const bool skipTestsOnCI = bool.fromEnvironment('CI');

String getCurrentPlatform() {
  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    return 'android';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
    return 'ios';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.macOS) {
    return 'macos';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.windows) {
    return 'windows';
  } else if (kIsWeb) {
    return 'web';
  } else {
    return 'unknown';
  }
}

void runSecondDatabaseTests() {
  group(
    'Second Database',
    () {
      late FirebaseFirestore firestore;
      String collectionForSecondDatabase = 'flutterfire-2';

      setUpAll(() async {
        firestore = FirebaseFirestore.instanceFor(
          app: Firebase.app(),
          databaseId: 'flutterfire-2',
        );

        firestore.useFirestoreEmulator('localhost', 8080);
      });

      Future<CollectionReference<Map<String, dynamic>>> initializeTest(
        String id,
      ) async {
        // Pushed rules which only allow database "flutterfire-2" to have "flutterfire-2" collection writes

        CollectionReference<Map<String, dynamic>> collection =
            firestore.collection(
          '$collectionForSecondDatabase/${getCurrentPlatform()}/$id',
        );
        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

        List<Future> deleteFutures = snapshot.docs.map((documentSnapshot) {
          return documentSnapshot.reference.delete();
        }).toList();

        await Future.wait(deleteFutures);
        return collection;
      }

      group(
          'queries for default database are banned for this collection: "$collectionForSecondDatabase"',
          () {
        test('barred query', () async {
          final defaultFirestore = FirebaseFirestore.instance;
          try {
            await defaultFirestore
                .collection(collectionForSecondDatabase)
                .add({'foo': 'bar'});
            fail('Should have thrown a [FirebaseException]');
          } catch (e) {
            expect(e, isA<FirebaseException>());
            expect((e as FirebaseException).code, equals('permission-denied'));
          }
        });
      });

      group('equality', () {
        // testing == override using e2e tests as it is dependent on the platform
        test('handles deeply compares query parameters', () async {
          final movies = firestore.collection('/movies');
          final starWarsComments =
              firestore.collection('/movies/star-wars/comments');

          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            movies.where('genre', arrayContains: ['Flutter']),
          );
          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            isNot(movies.where('genre', arrayContains: ['React'])),
          );
          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            isNot(starWarsComments.where('genre', arrayContains: ['Flutter'])),
          );
        });

        test('differentiate queries from a different app instance', () async {
          final fooApp = await Firebase.initializeApp(
            name: 'foo',
            options: Firebase.app().options,
          );

          expect(
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
          );

          expect(
            firestore.collection('movies').limit(42),
            isNot(
              FirebaseFirestore.instanceFor(app: fooApp)
                  .collection('movies')
                  .limit(42),
            ),
          );
        });

        test('differentiate collection group', () async {
          expect(
            firestore.collectionGroup('comments').limit(42),
            firestore.collectionGroup('comments').limit(42),
          );
          expect(
            firestore.collectionGroup('comments').limit(42),
            isNot(firestore.collection('comments').limit(42)),
          );
        });
      });
      /**
       * get
       */
      group('Query.get()', () {
        test('returns a [QuerySnapshot]', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get();
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test('uses [GetOptions] cache', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs =
              await collection.get(const GetOptions(source: Source.cache));
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
          expect(qs.metadata.isFromCache, isTrue);
        });

        test('uses [GetOptions] server', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs =
              await collection.get(const GetOptions(source: Source.server));
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
          expect(qs.metadata.isFromCache, isFalse);
        });

        test('uses [GetOptions] serverTimestampBehavior previous', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
            const GetOptions(
              serverTimestampBehavior: ServerTimestampBehavior.previous,
            ),
          );
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test('uses [GetOptions] serverTimestampBehavior estimate', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
            const GetOptions(
              serverTimestampBehavior: ServerTimestampBehavior.estimate,
            ),
          );
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test(
          'throws a [FirebaseException]',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                firestore.collection('not-allowed');

            try {
              await collection.get();
            } catch (error) {
              expect(error, isA<FirebaseException>());
              expect(
                (error as FirebaseException).code,
                equals('permission-denied'),
              );
              return;
            }
            fail('Should have thrown a [FirebaseException]');
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );
      });

      /**
       * snapshots
       */
      group('Query.snapshots()', () {
        test('returns a [Stream]', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();
          expect(stream, isA<Stream<QuerySnapshot<Map<String, dynamic>>>>());
        });

        test('listens to a single response', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-single');
          await collection.add({'foo': 'bar'});
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();

          StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

          subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.docs.length, equals(1));

                expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to multiple queries', () async {
          CollectionReference<Map<String, dynamic>> collection1 =
              await initializeTest('document-snapshot-1');
          CollectionReference<Map<String, dynamic>> collection2 =
              await initializeTest('document-snapshot-2');

          await collection1.add({'test': 'value1'});
          await collection2.add({'test': 'value2'});

          final value1 = collection1
              .snapshots()
              .first
              .then((s) => s.docs.first.data()['test']);
          final value2 = collection2
              .snapshots()
              .first
              .then((s) => s.docs.first.data()['test']);

          await expectLater(value1, completion('value1'));
          await expectLater(value2, completion('value2'));
        });

        test('listens to a multiple changes response', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-multiple');
          await collection.add({'foo': 'bar'});

          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();
          int call = 0;

          StreamSubscription subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                call++;
                if (call == 1) {
                  expect(snapshot.docs.length, equals(1));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs[0];
                  expect(documentSnapshot.data()['foo'], equals('bar'));
                } else if (call == 2) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc1');
                  expect(documentSnapshot.data()['bar'], equals('baz'));
                } else if (call == 3) {
                  expect(snapshot.docs.length, equals(1));
                  expect(
                    snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty,
                    isTrue,
                  );
                } else if (call == 4) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                  expect(documentSnapshot.data()['foo'], equals('bar'));
                } else if (call == 5) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                  expect(documentSnapshot.data()['foo'], equals('baz'));
                } else {
                  fail('Should not have been called');
                }
              },
              count: 5,
              reason: 'Stream should only have been called five times.',
            ),
          );

          await Future.delayed(const Duration(milliseconds: 500));
          await collection.doc('doc1').set({'bar': 'baz'});
          await collection.doc('doc1').delete();
          await collection.doc('doc2').set({'foo': 'bar'});
          await collection.doc('doc2').update({'foo': 'baz'});

          await subscription.cancel();
        });

        test(
          'listeners throws a [FirebaseException]',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                firestore.collection('not-allowed');
            Stream<QuerySnapshot<Map<String, dynamic>>> stream =
                collection.snapshots();

            try {
              await stream.first;
            } catch (error) {
              expect(error, isA<FirebaseException>());
              expect(
                (error as FirebaseException).code,
                equals(
                  'permission-denied',
                ),
              );
              return;
            }

            fail('Should have thrown a [FirebaseException]');
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );
      });

      /**
       * End At
       */

      group('Query.endAt{Document}()', () {
        test('ends at string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends at string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endAt({2}).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends at field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .endAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('endAtDocument() ends at a document field value', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .endAtDocument(endAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test('endAtDocument() ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.endAtDocument(endAtSnapshot).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });
      });

      /**
       * Start At
       */

      group('Query.startAt{Document}()', () {
        test('starts at string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts at string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAt({2}).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts at field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .startAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('startAtDocument() starts at a document field value', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .startAtDocument(startAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));
        });

        test('startAtDocument() starts at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.startAtDocument(startAtSnapshot).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc4'));
        });
      });

      /**
       * End Before
       */

      group('Query.endBefore{Document}()', () {
        test('ends before string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endBefore([1]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends before string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endBefore({1}).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends before field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .endBefore([1]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('endbeforeDocument() ends before a document field value',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc1').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .endBeforeDocument(endAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test('endBeforeDocument() ends before a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc4').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.endBeforeDocument(endAtSnapshot).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });
      });

      /**
       * Start after
       */
      group('Query.startAfter{Document}()', () {
        test('starts after string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAfter([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAfter([1]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts after field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .startAfter([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .startAfter([1]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('startAfterDocument() starts after a document field value',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot startAfterSnapshot =
              await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .startAfterDocument(startAfterSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));
        });

        test('startAfterDocument() starts after a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.startAfterDocument(startAtSnapshot).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc4'));
        });
      });

      /**
       * Start & End
       */

      group('Query.startAt/endAt', () {
        test('starts at & ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAt([2]).endAt([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts at & ends before a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAt([2]).endBefore([4]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts after & ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAfter([1]).endAt([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts a document and ends before document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-document');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          DocumentSnapshot endBeforeSnapshot =
              await collection.doc('doc4').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .startAtDocument(startAtSnapshot)
              .endBeforeDocument(endBeforeSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });
      });

      /**
       * Limit
       */

      group('Query.limit{toLast}()', () {
        test('limits documents', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limit');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.limit(2).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo', descending: true).limit(2).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc3'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('limits to last documents', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limitToLast');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').limitToLast(2).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy('foo', descending: true)
              .limitToLast(2)
              .get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc1'));
        });
      });

      /**
       * Order
       */
      group('Query.orderBy()', () {
        test('allows ordering by documentId', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-document-id');

          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 1,
            }),
            collection.doc('doc3').set({
              'foo': 1,
            }),
            collection.doc('doc4').set({
              'bar': 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('foo')
              .orderBy(FieldPath.documentId)
              .get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });

        test('orders async by default', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-asc');

          await Future.wait([
            collection.doc('doc1').set({
              'foo': 3,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc1'));
        });

        test('orders descending', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-desc');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo', descending: true).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc1'));
        });
      });

      /**
       * Where filters
       */

      group('Query.where()', () {
        test('returns documents when querying for properties that are not null',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('not-null');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 'bar',
            }),
            collection.doc('doc2').set({
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'foo': null,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNull: false).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test(
            'returns documents when querying properties that are equal to null',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('not-null');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 'bar',
            }),
            collection.doc('doc2').set({
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'foo': null,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNull: true).get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].id, equals('doc3'));
        });

        test('returns with equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isEqualTo: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals(rand));
          });
        });

        test('returns with not equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNotEqualTo: rand).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals(rand + 1));
          });
        });

        test('returns with greater than checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-greater-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand - 1,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
            collection.doc('doc4').set({
              'foo': rand + 2,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isGreaterThan: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] > rand, isTrue);
          });
        });

        test('returns with greater than or equal to checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-greater-than-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand - 1,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
            collection.doc('doc4').set({
              'foo': rand + 2,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isGreaterThanOrEqualTo: rand).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] >= rand, isTrue);
          });
        });

        test('returns with less than checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-less-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': -rand + 1,
            }),
            collection.doc('doc2').set({
              'foo': -rand + 2,
            }),
            collection.doc('doc3').set({
              'foo': rand,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isLessThan: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] < rand, isTrue);
          });
        });

        test('returns with less than equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-less-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': -rand + 1,
            }),
            collection.doc('doc2').set({
              'foo': -rand + 2,
            }),
            collection.doc('doc3').set({
              'foo': rand,
            }),
            collection.doc('doc4').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isLessThanOrEqualTo: rand).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] <= rand, isTrue);
          });
        });

        test('returns with array-contains filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': [1, '2', rand],
            }),
            collection.doc('doc2').set({
              'foo': [1, '2', '$rand'],
            }),
            collection.doc('doc3').set({
              'foo': [1, '2', '$rand'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', arrayContains: '$rand').get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals([1, '2', '$rand']));
          });
        });

        test('returns with in filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereIn: ['Ready to Ship', 'Ordered']).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with in filter using Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in-iterable');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where(
                'status',
                // To force the list to be an iterable
                whereIn: ['Ready to Ship', 'Ordered'].map((e) => e),
              )
              .get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with in filter using Set', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereIn: {'Ready to Ship', 'Ordered'}).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with not-in filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereNotIn: ['Ready to Ship', 'Ordered']).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Incomplete', isTrue);
          });
        });

        test('returns with not-in filter with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereNotIn: {'Ready to Ship', 'Ordered'}).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Incomplete', isTrue);
          });
        });

        test('returns with array-contains-any filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains-any');

          await Future.wait([
            collection.doc('doc1').set({
              'category': ['Appliances', 'Housewares', 'Cooking'],
            }),
            collection.doc('doc2').set({
              'category': ['Appliances', 'Electronics', 'Nursery'],
            }),
            collection.doc('doc3').set({
              'category': ['Audio/Video', 'Electronics'],
            }),
            collection.doc('doc4').set({
              'category': ['Beauty'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
            'category',
            arrayContainsAny: ['Appliances', 'Electronics'],
          ).get();

          // 2nd record should only be returned once
          expect(snapshot.docs.length, equals(3));
        });

        test('returns with array-contains-any filter using Set', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains-any');

          await Future.wait([
            collection.doc('doc1').set({
              'category': ['Appliances', 'Housewares', 'Cooking'],
            }),
            collection.doc('doc2').set({
              'category': ['Appliances', 'Electronics', 'Nursery'],
            }),
            collection.doc('doc3').set({
              'category': ['Audio/Video', 'Electronics'],
            }),
            collection.doc('doc4').set({
              'category': ['Beauty'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
            'category',
            arrayContainsAny: {'Appliances', 'Electronics'},
          ).get();

          // 2nd record should only be returned once
          expect(snapshot.docs.length, equals(3));
        });

        // When documents have a key with a '.' in them, only a [FieldPath]
        // can access the value, rather than a raw string
        test('returns where FieldPath', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-field-path');

          FieldPath fieldPath =
              FieldPath(const ['nested', 'foo.bar@gmail.com']);

          await Future.wait([
            collection.doc('doc1').set({
              'nested': {
                'foo.bar@gmail.com': true,
              },
            }),
            collection.doc('doc2').set({
              'nested': {
                'foo.bar@gmail.com': true,
              },
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'nested': {
                'foo.bar@gmail.com': false,
              },
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where(fieldPath, isEqualTo: true).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].get(fieldPath), isTrue);
          expect(snapshot.docs[1].get(fieldPath), isTrue);
          expect(snapshot.docs[1].get('foo'), equals('bar'));
        });

        test('returns results using FieldPath.documentId', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-field-path-document-id');

          DocumentReference<Map<String, dynamic>> docRef =
              await collection.add({
            'foo': 'bar',
          });

          // Add secondary document for sanity check
          await collection.add({
            'bar': 'baz',
          });

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where(FieldPath.documentId, isEqualTo: docRef.id)
              .get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].get('foo'), equals('bar'));
        });

        test('returns an encoded DocumentReference', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-document-reference');

          DocumentReference<Map<String, dynamic>> ref =
              firestore.doc('foo/bar');

          await Future.wait([
            collection.add({
              'foo': ref,
            }),
            collection.add({
              'foo': firestore.doc('bar/baz'),
            }),
            collection.add({
              'foo': 'foo/bar',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('foo', isEqualTo: firestore.doc('foo/bar'))
              .get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].get('foo'), equals(ref));
        });
      });

      group('Query.where() with Filter class', () {
        test(
          'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple disjunctive queries',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                await initializeTest('multiple-disjunctive-queries');

            await Future.wait([
              collection.add({
                'genre': 'sci-fi',
                'mainCharacter': 'Tim',
                'rating': 1,
              }),
              collection.add({
                'mainCharacter': 'MainCharacter2',
                'genre': 'action',
                'rating': 1,
              }),
              collection.add({
                'mainCharacter': 'MainCharacter2',
                'genre': 'action',
                'rating': 1,
              }),
            ]);
            final result = await collection
                .where(
                  Filter.or(
                    Filter('genre', arrayContainsAny: ['sci-fi']),
                    Filter('mainCharacter', isNotEqualTo: 'MainCharacter2'),
                  ),
                )
                .orderBy('rating', descending: true)
                .get();

            expect(result.docs.length, equals(1));
            expect(result.docs[0].data()['genre'], equals('sci-fi'));
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );

        test(
          'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple conjunctive queries',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                await initializeTest(
              'array-contain-not-equal-conjunctive-queries',
            );

            await Future.wait([
              collection.doc('doc1').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'bar',
              }),
              collection.doc('doc2').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'bar',
              }),
              collection.doc('doc3').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'foo',
              }),
            ]);

            final results = await collection
                .where(
                  Filter.and(
                    Filter('genre', arrayContainsAny: ['sci-fi']),
                    Filter('screenplay2', isNotEqualTo: 'foo'),
                  ),
                )
                .orderBy('screenplay2', descending: true)
                .get();

            expect(results.docs.length, equals(2));
            expect(results.docs[0].id, equals('doc2'));
            expect(results.docs[1].id, equals('doc1'));
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );

        test('isEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 5}),
            collection.doc('doc3').set({'value': 7}),
          ]);

          final results = await collection
              .where(
                Filter('value', isEqualTo: 5),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('isNotEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isnotequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 5}),
            collection.doc('doc3').set({'value': 7}),
          ]);

          final results = await collection
              .where(
                Filter('value', isNotEqualTo: 5),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc3'));
        });

        test('isLessThan filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-islessthan');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isLessThan: 7),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc1'));
        });

        test('isLessThanOrEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-islessthanequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isLessThanOrEqualTo: 7),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('isGreaterThan filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isgreaterthan');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isGreaterThan: 5),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('isGreaterThanOrEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isgreaterthanequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isGreaterThanOrEqualTo: 7),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('arrayContains filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-arraycontains');
          await Future.wait([
            collection.doc('doc1').set({
              'value': [1, 2, 3],
            }),
            collection.doc('doc2').set({
              'value': [1, 4, 5],
            }),
            collection.doc('doc3').set({
              'value': [6, 7, 8],
            }),
          ]);

          final results = await collection
              .where(
                Filter('value', arrayContains: 1),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('arrayContainsAny filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-arraycontainsany');
          await Future.wait([
            collection.doc('doc1').set({
              'value': [1, 2, 3],
            }),
            collection.doc('doc2').set({
              'value': [1, 4, 5],
            }),
            collection.doc('doc3').set({
              'value': [6, 7, 8],
            }),
          ]);

          final results = await collection
              .where(
                Filter('value', arrayContainsAny: [1, 7]),
              )
              .get();

          expect(results.docs.length, equals(3));
        });

        test('whereIn filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-wherein');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': 'B'}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', whereIn: ['A', 'C']),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('whereNotIn filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-wherenotin');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': 'B'}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', whereNotIn: ['A', 'C']),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc2'));
        });

        test('isNull filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isnull');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': null}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', isNull: true),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc2'));
        });

        test('endAt filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endat-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endAt([3]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('endBefore filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endbefore-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // endBefore
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endBefore([4]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('endBeforeDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endbeforedocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc4').get();

          // endBeforeDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endBeforeDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('limit filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limit-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // limit
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .limit(2)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('limitToLast filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limittolast-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // limitToLast
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .limitToLast(2)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('D'));
          expect(results.docs[1].data()['title'], equals('E'));
        });

        test('orderBy filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('orderby-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // orderBy
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: true)
              .get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('E'));
          expect(results.docs[1].data()['title'], equals('D'));
          expect(results.docs[2].data()['title'], equals('C'));
          expect(results.docs[3].data()['title'], equals('B'));
        });

        test('startAfter filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startafter-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // startAfter
          results = await collection
              .where(Filter('value', isGreaterThan: 3))
              .orderBy('value', descending: false)
              .startAfter([2]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('D'));
          expect(results.docs[1].data()['title'], equals('E'));
        });

        test('startAfterDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startafterdocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc2').get();

// startAfterDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAfterDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(3));
          expect(results.docs[0].data()['title'], equals('C'));
          expect(results.docs[1].data()['title'], equals('D'));
          expect(results.docs[2].data()['title'], equals('E'));
        });

        test('startAt filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startat-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

// startAt
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAt([2]).get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
          expect(results.docs[2].data()['title'], equals('D'));
          expect(results.docs[3].data()['title'], equals('E'));
        });

        test('startAtDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startatdocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc2').get();

// startAtDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAtDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
          expect(results.docs[2].data()['title'], equals('D'));
          expect(results.docs[3].data()['title'], equals('E'));
        });
      });

      group('withConverter', () {
        test(
          'from a query instead of collection',
          () async {
            final collection = await initializeTest('foo');

            final query = collection //
                .where('value', isGreaterThan: 0)
                .withConverter<int>(
                  fromFirestore: (snapshots, _) =>
                      snapshots.data()!['value']! as int,
                  toFirestore: (value, _) => {'value': value},
                );

            await collection.add({'value': 42});
            await collection.add({'value': -1});

            final snapshot = query.snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await collection.add({'value': 21});

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals(
                    [
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 42),
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 21),
                    ],
                  ),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'from a Filter query instead of collection',
          () async {
            final collection = await initializeTest('foo');

            final query = collection //
                .where(Filter('value', isGreaterThan: 0))
                .withConverter<int>(
                  fromFirestore: (snapshots, _) =>
                      snapshots.data()!['value']! as int,
                  toFirestore: (value, _) => {'value': value},
                );

            await collection.add({'value': 42});
            await collection.add({'value': -1});

            final snapshot = query.snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await collection.add({'value': 21});

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals(
                    [
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 42),
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 21),
                    ],
                  ),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'snapshots',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(-1);

            final snapshot =
                converted.where('value', isGreaterThan: 0).snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await converted.add(21);

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ]),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'get',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(-1);

            expect(
              await converted
                  .where('value', isGreaterThan: 0)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'orderBy',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted.orderBy('value').get().then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 21),
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'limit',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted
                  .orderBy('value')
                  .limit(1)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 21),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'limitToLast',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted
                  .orderBy('value')
                  .limitToLast(1)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test('endAt', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAt([2])
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        });

        test('endAt with Iterable', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAt({2})
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        });

        test(
          'endAtDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .endAtDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test('endBefore', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBefore([2])
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        });

        test('endBefore with Iterable', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBefore({2})
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        });

        test(
          'endBeforeDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .endBeforeDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAt',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAt([2])
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAt with Iterable',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAt({2})
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAtDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAtDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfter',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfter([2])
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfter with Iterable',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfter({2})
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfterDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfterDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'count()',
          () async {
            final collection = await initializeTest('count');

            await Future.wait([
              collection.add({'foo': 'bar'}),
              collection.add({'bar': 'baz'}),
            ]);

            AggregateQuery query = collection.count();

            AggregateQuerySnapshot snapshot = await query.get();

            expect(
              snapshot.count,
              2,
            );
          },
        );

        test(
          'count() with query',
          () async {
            final collection = await initializeTest('count');

            await Future.wait([
              collection.add({'foo': 'bar'}),
              collection.add({'foo': 'baz'}),
            ]);

            AggregateQuery query =
                collection.where('foo', isEqualTo: 'bar').count();

            AggregateQuerySnapshot snapshot = await query.get();

            expect(
              snapshot.count,
              1,
            );
          },
        );
      });

      group('startAfterDocument', () {
        test(
            'startAfterDocument() accept DocumentReference in query parameters',
            () async {
          final collection = await initializeTest('start-after-document');

          final doc1 = collection.doc('1');
          final doc2 = collection.doc('2');
          final doc3 = collection.doc('3');
          final doc4 = collection.doc('4');
          await doc1.set({'ref': doc1});
          await doc2.set({'ref': doc2});
          await doc3.set({'ref': doc3});
          await doc4.set({'ref': null});

          final q = collection
              .where('ref', isNull: false)
              .orderBy('ref')
              .startAfterDocument(await doc1.get());

          final res = await q.get();
          expect(res.docs.map((e) => e.reference), [doc2, doc3]);
        });
      });
    },
    // Skipped on CI for web as the data is live and it clashes with other tests running in CI
    skip: kIsWeb && skipTestsOnCI,
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/settings_e2e.dart

**크기**: 1387 bytes | **라인 수**: 46 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runSettingsTest() {
  group(
    '$Settings',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<Settings> initializeTest() async {
        Settings firestoreSettings = const Settings(
          persistenceEnabled: false,
          webExperimentalForceLongPolling: true,
          webExperimentalAutoDetectLongPolling: true,
          webExperimentalLongPollingOptions: WebExperimentalLongPollingOptions(
            timeoutDuration: Duration(seconds: 15),
          ),
        );

        return firestore.settings = firestoreSettings;
      }

      test('checks if long polling settings were applied', () async {
        Settings settings = await initializeTest();

        expect(settings.webExperimentalForceLongPolling, true);

        expect(settings.webExperimentalAutoDetectLongPolling, true);

        expect(
          settings.webExperimentalLongPollingOptions,
          settings.webExperimentalLongPollingOptions,
        );
      });
    },
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/snapshot_metadata_e2e.dart

**크기**: 1535 bytes | **라인 수**: 45 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runSnapshotMetadataTests() {
  group(
    '$SnapshotMetadata',
    () {
      late FirebaseFirestore /*?*/ firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<CollectionReference> initializeTest(String id) async {
        CollectionReference collection =
            firestore.collection('flutter-tests/$id/query-tests');
        QuerySnapshot snapshot = await collection.get();
        await Future.forEach(snapshot.docs,
            (DocumentSnapshot documentSnapshot) {
          return documentSnapshot.reference.delete();
        });
        return collection;
      }

      test('a snapshot returns the correct [isFromCache] value', () async {
        CollectionReference collection =
            await initializeTest('snapshot-metadata-is-from-cache');
        QuerySnapshot qs =
            await collection.get(const GetOptions(source: Source.cache));
        expect(qs.metadata.isFromCache, isTrue);

        QuerySnapshot qs2 =
            await collection.get(const GetOptions(source: Source.server));
        expect(qs2.metadata.isFromCache, isFalse);
      });
    },
    skip: kIsWeb,
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/timestamp_e2e.dart

**크기**: 2476 bytes | **라인 수**: 75 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runTimestampTests() {
  group('$Timestamp', () {
    late FirebaseFirestore /*?*/ firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $Timestamp & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('timestamp');
      DateTime date = DateTime.utc(3000);

      await doc.set({'foo': Timestamp.fromDate(date)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp timestamp = snapshot.data()!['foo'];
      expect(timestamp, isA<Timestamp>());
      expect(
        timestamp.millisecondsSinceEpoch,
        equals(date.millisecondsSinceEpoch),
      );
    });

    test('updates a $Timestamp & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point-update');
      DateTime date = DateTime.utc(3000, 01, 02);

      await doc.set({'foo': DateTime.utc(3000)});
      await doc.update({'foo': date});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp timestamp = snapshot.data()!['foo'];
      expect(timestamp, isA<Timestamp>());
      expect(
        timestamp.millisecondsSinceEpoch,
        equals(date.millisecondsSinceEpoch),
      );
    });

    test('set pre-1970 $Timestamp and return', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('timestamp');
      final date = DateTime(1969, 06, 22, 0, 0, 0, 123);
      final localTimestamp = Timestamp.fromDate(date);

      await doc.set({'foo': localTimestamp});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp retievedTimestamp = snapshot.data()!['foo'];
      expect(retievedTimestamp, isA<Timestamp>());
      expect(
        retievedTimestamp,
        equals(localTimestamp),
      );
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/transaction_e2e.dart

**크기**: 16942 bytes | **라인 수**: 490 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runTransactionTests() {
  group(
    '$Transaction',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<DocumentReference<Map<String, dynamic>>> initializeTest(
        String path,
      ) async {
        String prefixedPath = 'flutter-tests/$path';
        await firestore.doc(prefixedPath).delete();
        return firestore.doc(prefixedPath);
      }

      test('works with withConverter', () async {
        DocumentReference<Map<String, dynamic>> rawDoc =
            await initializeTest('with-converter-batch');

        DocumentReference<int> doc = rawDoc.withConverter(
          fromFirestore: (snapshot, options) {
            return snapshot.data()!['value'] as int;
          },
          toFirestore: (value, options) => {'value': value},
        );

        await doc.set(42);

        expect(
          await firestore.runTransaction<int?>((transaction) async {
            final snapshot = await transaction.get<int>(doc);
            return snapshot.data();
          }),
          42,
        );

        await firestore.runTransaction((transaction) async {
          transaction.set(doc, 21);
        });

        expect(await doc.get().then((s) => s.data()), 21);

        await firestore.runTransaction((transaction) async {
          transaction.update(doc, {'value': 0});
        });

        expect(await doc.get().then((s) => s.data()), 0);
      });

      test('should resolve with user value', () async {
        int randomValue = Random().nextInt(9999);
        int response = await firestore
            .runTransaction<int>((Transaction transaction) async {
          return randomValue;
        });
        expect(response, equals(randomValue));
      });

      test('should abort if thrown and not continue', () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            await initializeTest('transaction-abort');

        await documentReference.set({'foo': 'bar'});

        try {
          await firestore.runTransaction((Transaction transaction) async {
            transaction.set(documentReference, {
              'foo': 'baz',
            });
            throw 'Stop';
          });
          // ignore: dead_code
          fail('Should have thrown');
        } catch (e) {
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.data()!['foo'], equals('bar'));
        }
      });

      test(
        'should not collide if number of maxAttempts is enough',
        () async {
          DocumentReference<Map<String, dynamic>> doc1 =
              await initializeTest('transaction-maxAttempts-1');

          await doc1.set({'test': 0});

          await Future.wait([
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 2,
            ),
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 2,
            ),
          ]);

          DocumentSnapshot<Map<String, dynamic>> snapshot1 = await doc1.get();
          expect(snapshot1.data()!['test'], equals(2));
        },
        retry: 2,
      );

      test('should collide if number of maxAttempts is too low', () async {
        DocumentReference<Map<String, dynamic>> doc1 =
            await initializeTest('transaction-maxAttempts-2');

        await doc1.set({'test': 0});

        await expectLater(
          Future.wait([
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 1,
            ),
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 1,
            ),
          ]),
          throwsA(
            isA<FirebaseException>()
                .having((e) => e.code, 'code', 'failed-precondition'),
          ),
        );
      });

      test('runs multiple transactions in parallel', () async {
        DocumentReference<Map<String, dynamic>> doc1 =
            await initializeTest('transaction-multi-1');
        DocumentReference<Map<String, dynamic>> doc2 =
            await initializeTest('transaction-multi-2');

        await doc1.set({'test': 'value1'});
        await doc2.set({'test': 'value2'});

        await Future.wait([
          firestore.runTransaction((Transaction transaction) async {
            transaction.set(doc1, {
              'test': 'value3',
            });
          }),
          firestore.runTransaction((Transaction transaction) async {
            transaction.set(doc2, {
              'test': 'value4',
            });
          }),
        ]);

        DocumentSnapshot<Map<String, dynamic>> snapshot1 = await doc1.get();
        expect(snapshot1.data()!['test'], equals('value3'));
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc2.get();
        expect(snapshot2.data()!['test'], equals('value4'));
      });

      test('should abort if timeout is exceeded', () async {
        await expectLater(
          firestore.runTransaction(
            (Transaction transaction) =>
                Future.delayed(const Duration(seconds: 2)),
            timeout: const Duration(seconds: 1),
          ),
          throwsA(
            isA<FirebaseException>()
                .having((e) => e.code, 'code', 'deadline-exceeded'),
          ),
        );
      });

      test('should throw with exception', () async {
        try {
          await firestore.runTransaction((Transaction transaction) async {
            throw StateError('foo');
          });
          // ignore: dead_code
          fail('Transaction should not have resolved');
        } on StateError catch (e) {
          expect(e.message, equals('foo'));
          return;
        } catch (e) {
          fail('Transaction threw invalid exeption');
        }
      });

      test('should throw a native error, and convert to a [FirebaseException]',
          () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            firestore.doc('not-allowed/document');

        try {
          await firestore.runTransaction((Transaction transaction) async {
            transaction.set(documentReference, {'foo': 'bar'});
          });
          fail('Transaction should not have resolved');
        } on FirebaseException catch (e) {
          expect(e.code, equals('permission-denied'));
          return;
        } catch (e) {
          fail('Transaction threw invalid exception');
        }
      });

      group('Transaction.get()', () {
        test('should throw if get is called after a command', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/foo');

          expect(
            () => firestore.runTransaction((Transaction transaction) async {
              await transaction.get(documentReference);
              transaction.set(documentReference, {'foo': 'bar'});
              await transaction.get(documentReference);
            }),
            throwsAssertionError,
          );
        });

        test(
            'should throw a native error, and convert to a [FirebaseException]',
            () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('not-allowed/document');

          try {
            await firestore.runTransaction((Transaction transaction) async {
              await transaction.get(documentReference);
            });
            fail('Transaction should not have resolved');
          } on FirebaseException catch (e) {
            expect(e.code, equals('permission-denied'));
            return;
          } catch (e) {
            fail('Transaction threw invalid exception');
          }
        });

        // ignore: todo
        // TODO(Salakar): Test seems to fail sometimes. Will look at in a future PR.
        // test('support returning any value, e.g. a [DocumentSnapshot]', () async {
        //   DocumentReference<Map<String, dynamic>> documentReference =
        //       await initializeTest('transaction-get');

        //   DocumentSnapshot<Map<String, dynamic>> snapshot =
        //       await firestore.runTransaction((Transaction transaction) async {
        //     DocumentSnapshot<Map<String, dynamic>> returned = await transaction.get(documentReference);
        //     // required:
        //     transaction.set(documentReference, {'foo': 'bar'});
        //     return returned;
        //   });

        //   expect(snapshot, isA<DocumentSnapshot>());
        //   expect(snapshot.reference.path, equals(documentReference.path));
        // }, skip: kUseFirestoreEmulator);
      });

      group('Transaction.delete()', () {
        test('should delete a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-delete');

          await documentReference.set({'foo': 'bar'});

          await firestore.runTransaction((Transaction transaction) async {
            transaction.delete(documentReference);
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isFalse);
        });
      });

      group('Transaction.update()', () {
        test('should update a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-update');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.update(documentReference, {
              'bar': documentSnapshot.data()!['bar'] + 1,
            });
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(snapshot.data()!['bar'], equals(2));
          expect(snapshot.data()!['foo'], equals('bar'));
        });
      });

      group('Transaction.set()', () {
        test('sets a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(documentReference, {
              'bar': documentSnapshot.data()!['bar'] + 1,
            });
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(
            snapshot.data(),
            equals(<String, dynamic>{'bar': 2}),
          );
        });

        test('merges a document with set', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set-merge');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(
              documentReference,
              {'bar': documentSnapshot.data()!['bar'] + 1},
              SetOptions(merge: true),
            );
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(snapshot.data()!['bar'], equals(2));
          expect(snapshot.data()!['foo'], equals('bar'));
        });

        test('merges fields a document with set', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set-merge-fields');

          await documentReference.set({'foo': 'bar', 'bar': 1, 'baz': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(
              documentReference,
              {
                'bar': documentSnapshot.data()!['bar'] + 1,
                'baz': 'ben',
              },
              SetOptions(mergeFields: ['bar']),
            );
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(
            snapshot.data(),
            equals(<String, dynamic>{'foo': 'bar', 'bar': 2, 'baz': 1}),
          );
        });
      });

      test('runs all commands in a single transaction', () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            await initializeTest('transaction-all');

        DocumentReference<Map<String, dynamic>> documentReference2 =
            firestore.doc('flutter-tests/delete');

        await documentReference2.set({'foo': 'bar'});
        await documentReference.set({'foo': 1});

        String result = await firestore
            .runTransaction<String>((Transaction transaction) async {
          DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
              await transaction.get(documentReference);

          transaction.set(documentReference, {
            'foo': documentSnapshot.data()!['foo'] + 1,
          });

          transaction.update(documentReference, {'bar': 'baz'});

          transaction.delete(documentReference2);

          return 'done';
        });

        expect(result, equals('done'));

        DocumentSnapshot<Map<String, dynamic>> snapshot =
            await documentReference.get();
        expect(snapshot.exists, isTrue);
        expect(
          snapshot.data(),
          equals(<String, dynamic>{'foo': 2, 'bar': 'baz'}),
        );

        DocumentSnapshot<Map<String, dynamic>> snapshot2 =
            await documentReference2.get();
        expect(snapshot2.exists, isFalse);
      });

      // TODO(Lyokone): adding auth make some tests fails in macOS
      // test(
      //     'should not fail to complete transaction if user is authenticated',
      //     () async {
      //   DocumentReference<Map<String, dynamic>> doc1 =
      //       await initializeTest('transaction-authentified-1');

      //   try {
      //     await FirebaseAuth.instance.createUserWithEmailAndPassword(
      //       email: 'firestore@mail.com',
      //       password: 'this-is-a-password',
      //     );
      //   } catch (e) {
      //     await FirebaseAuth.instance.signInWithEmailAndPassword(
      //       email: 'firestore@mail.com',
      //       password: 'this-is-a-password',
      //     );
      //   }

      //   await doc1.set({'test': 0});

      //   final value = await firestore.runTransaction(
      //     (Transaction transaction) async {
      //       final value = await transaction.get(doc1);
      //       final newValue = value['test'] + 1;
      //       transaction.set(doc1, {
      //         'test': newValue,
      //       });

      //       return newValue;
      //     },
      //     maxAttempts: 1,
      //   );

      //   expect(value, equals(1));

      //   await FirebaseAuth.instance.signOut();
      // });
    },
    skip: kIsWeb,
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/vector_value_e2e.dart

**크기**: 5410 bytes | **라인 수**: 173 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runVectorValueTests() {
  group('$VectorValue', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $VectorValue & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value');

      await doc.set({
        'foo': const VectorValue([10.0, -10.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([10.0, -10.0]));
    });

    test('updates a $VectorValue & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-update');

      await doc.set({
        'foo': const VectorValue([10.0, -10.0]),
      });

      await doc.update({
        'foo': const VectorValue([-10.0, 10.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([-10.0, 10.0]));
    });

    test('handles empty vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-empty');

      try {
        await doc.set({
          'foo': const VectorValue([]),
        });
        fail('Should have thrown an exception');
      } catch (e) {
        expect(e, isA<FirebaseException>());
        expect(
          (e as FirebaseException).code.contains('invalid-argument'),
          isTrue,
        );
      }
    });

    test('handles single dimension vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-single');

      await doc.set({
        'foo': const VectorValue([42.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([42.0]));
    });

    test('handles maximum dimensions vector', () async {
      List<double> maxDimensions = List.filled(2048, 1);
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-max-dimensions');

      await doc.set({
        'foo': VectorValue(maxDimensions),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals(maxDimensions));
    });

    test('handles maximum dimensions + 1 vector', () async {
      List<double> maxPlusOneDimensions = List.filled(2049, 1);
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-max-plus-one');

      try {
        await doc.set({
          'foo': VectorValue(maxPlusOneDimensions),
        });

        fail('Should have thrown an exception');
      } catch (e) {
        expect(e, isA<FirebaseException>());
        expect(
          (e as FirebaseException).code.contains('invalid-argument'),
          isTrue,
        );
      }
    });

    test('handles very large values in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-large-values');

      await doc.set({
        'foo': const VectorValue([1e10, -1e10]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([1e10, -1e10]));
    });

    test('handles floats in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-floats');

      await doc.set({
        'foo': const VectorValue([3.14, 2.718]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([3.14, 2.718]));
    });

    test('handles negative values in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-negative');

      await doc.set({
        'foo': const VectorValue([-42.0, -100.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([-42.0, -100.0]));
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/web_snapshot_listeners.dart

**크기**: 5668 bytes | **라인 수**: 195 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

// Run only on web for demonstrating snapshot listener clean up in debug mode does not clean up the listeners incorrectly.
// See: https://github.com/firebase/flutterfire/issues/13019
void runWebSnapshotListenersTests() {
  group('Web snapshot listeners', () {
    late FirebaseFirestore firestore;
    late CollectionReference<Map<String, dynamic>> collection;
    late DocumentReference<Map<String, dynamic>> document;
    late DocumentReference<Map<String, dynamic>> document2;
    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
      collection = firestore
          .collection('flutter-tests/web-snapshot-listeners/query-tests');
      document = collection.doc('doc1');
      document2 = collection.doc('doc1');

      await Future.wait([
        document.set({'foo': 1}),
        collection.add({'foo': 2}),
        collection.add({'foo': 3}),
      ]);
    });

    test(
      'document snapshot listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        document.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );

    test(
      'document snapshot listeners with different doc refs in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        Completer<bool> completer4 = Completer<bool>();
        document.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        document2.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        document2.snapshots().listen((snapshot) {
          if (completer4.isCompleted) {
            return;
          }
          completer4.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;
        final four = await completer4.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
        expect(four, true);
      },
      skip: !kIsWeb,
    );

    test(
      'query snapshot listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        collection.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        collection.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        collection.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });
        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );

    test(
      'snapshot in sync listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        firestore.snapshotsInSync().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        firestore.snapshotsInSync().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        firestore.snapshotsInSync().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/integration_test/write_batch_e2e.dart

**크기**: 4264 bytes | **라인 수**: 134 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runWriteBatchTests() {
  group('$WriteBatch', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs, (
        DocumentSnapshot<Map<String, dynamic>> documentSnapshot,
      ) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test('works with withConverter', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('with-converter-batch');
      WriteBatch batch = firestore.batch();

      DocumentReference<int> doc = collection.doc('doc1').withConverter(
            fromFirestore: (snapshot, options) {
              return snapshot.data()!['value'] as int;
            },
            toFirestore: (value, options) => {'value': value},
          );

      var snapshot = await doc.get();

      expect(snapshot.exists, false);

      batch.set<int>(doc, 42);

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, true);
      expect(snapshot.data(), 42);

      batch = firestore.batch();
      batch.update(doc, {'value': 21});

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, true);
      expect(snapshot.data(), 21);

      batch = firestore.batch();
      batch.delete(doc);

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, false);
    });

    test('performs batch operations', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('write-batch-ops');
      WriteBatch batch = firestore.batch();

      DocumentReference<Map<String, dynamic>> doc1 =
          collection.doc('doc1'); // delete
      DocumentReference<Map<String, dynamic>> doc2 =
          collection.doc('doc2'); // set
      DocumentReference<Map<String, dynamic>> doc3 =
          collection.doc('doc3'); // update
      DocumentReference<Map<String, dynamic>> doc4 =
          collection.doc('doc4'); // update w/ merge
      DocumentReference<Map<String, dynamic>> doc5 =
          collection.doc('doc5'); // update w/ mergeFields

      await Future.wait([
        doc1.set({'foo': 'bar'}),
        doc2.set({'foo': 'bar'}),
        doc3.set({'foo': 'bar', 'bar': 'baz'}),
        doc4.set({'foo': 'bar'}),
        doc5.set({'foo': 'bar', 'bar': 'baz'}),
      ]);

      batch.delete(doc1);
      batch.set(doc2, <String, dynamic>{'bar': 'baz'});
      batch.update(doc3, <String, dynamic>{'bar': 'ben'});
      batch.set(doc4, <String, dynamic>{'bar': 'ben'}, SetOptions(merge: true));

      batch.set(
        doc5,
        <String, dynamic>{'bar': 'ben'},
        SetOptions(mergeFields: ['bar']),
      );

      await batch.commit();

      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      expect(snapshot.docs.length, equals(4));
      expect(snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty, isTrue);
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc2').data(),
        equals(<String, dynamic>{'bar': 'baz'}),
      );
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc3').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc4').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );

      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc5').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 2519 bytes | **라인 수**: 123 | **타입**: text

```
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json

**크기**: 391 bytes | **라인 수**: 24 | **타입**: text

```
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md

**크기**: 336 bytes | **라인 수**: 5 | **타입**: text

```
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/Runner/AppDelegate.swift

**크기**: 391 bytes | **라인 수**: 14 | **타입**: text

```
import UIKit
import Flutter

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/Runner/Runner-Bridging-Header.h

**크기**: 38 bytes | **라인 수**: 2 | **타입**: text

```
#import "GeneratedPluginRegistrant.h"

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/ios/firebase_app_id_file.json

**크기**: 275 bytes | **라인 수**: 7 | **타입**: text

```
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:0670bc5fe8574a9c3574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/lib/firebase_options.dart

**크기**: 3655 bytes | **라인 수**: 93 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      TargetPlatform.linux => throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        ),
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:175ea7a64b2faf5e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/lib/main.dart

**크기**: 16215 bytes | **라인 수**: 549 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

import 'firebase_options.dart';

/// Requires that a Firestore emulator is running locally.
/// See https://firebase.google.com/docs/firestore/quickstart#optional_prototype_and_test_with
bool shouldUseFirestoreEmulator = true;

Future<Uint8List> loadBundleSetup(int number) async {
  // endpoint serves a bundle with 3 documents each containing
  // a 'number' property that increments in value 1-3.
  final url =
      Uri.https('api.rnfirebase.io', '/firestore/e2e-tests/bundle-$number');
  final response = await http.get(url);
  String string = response.body;
  return Uint8List.fromList(string.codeUnits);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  FirebaseFirestore.instance.settings = const Settings(
    persistenceEnabled: true,
  );
  if (shouldUseFirestoreEmulator) {
    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);
  }

  runApp(FirestoreExampleApp());
}

/// A reference to the list of movies.
/// We are using `withConverter` to ensure that interactions with the collection
/// are type-safe.
final moviesRef = FirebaseFirestore.instance
    .collection('firestore-example-app')
    .withConverter<Movie>(
      fromFirestore: (snapshots, _) => Movie.fromJson(snapshots.data()!),
      toFirestore: (movie, _) => movie.toJson(),
    );

/// The different ways that we can filter/sort movies.
enum MovieQuery {
  year,
  likesAsc,
  likesDesc,
  rated,
  sciFi,
  fantasy,
}

extension on Query<Movie> {
  /// Create a firebase query from a [MovieQuery]
  Query<Movie> queryBy(MovieQuery query) {
    return switch (query) {
      MovieQuery.fantasy => where('genre', arrayContainsAny: ['fantasy']),
      MovieQuery.sciFi => where('genre', arrayContainsAny: ['sci-fi']),
      MovieQuery.likesAsc ||
      MovieQuery.likesDesc =>
        orderBy('likes', descending: query == MovieQuery.likesDesc),
      MovieQuery.year => orderBy('year', descending: true),
      MovieQuery.rated => orderBy('rated', descending: true)
    };
  }
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class FirestoreExampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firestore Example App',
      theme: ThemeData.dark(),
      home: const Scaffold(
        body: Center(child: FilmList()),
      ),
    );
  }
}

/// Holds all example app films
class FilmList extends StatefulWidget {
  const FilmList({Key? key}) : super(key: key);

  @override
  _FilmListState createState() => _FilmListState();
}

class _FilmListState extends State<FilmList> {
  MovieQuery query = MovieQuery.year;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Firestore Example: Movies'),

            // This is a example use for 'snapshots in sync'.
            // The view reflects the time of the last Firestore sync; which happens any time a field is updated.
            StreamBuilder(
              stream: FirebaseFirestore.instance.snapshotsInSync(),
              builder: (context, _) {
                return Text(
                  'Latest Snapshot: ${DateTime.now()}',
                  style: Theme.of(context).textTheme.bodySmall,
                );
              },
            ),
          ],
        ),
        actions: <Widget>[
          PopupMenuButton<MovieQuery>(
            onSelected: (value) => setState(() => query = value),
            icon: const Icon(Icons.sort),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: MovieQuery.year,
                  child: Text('Sort by Year'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.rated,
                  child: Text('Sort by Rated'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesAsc,
                  child: Text('Sort by Likes ascending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesDesc,
                  child: Text('Sort by Likes descending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.fantasy,
                  child: Text('Filter genre fantasy'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.sciFi,
                  child: Text('Filter genre sci-fi'),
                ),
              ];
            },
          ),
          PopupMenuButton<String>(
            onSelected: (value) async {
              switch (value) {
                case 'reset_likes':
                  return _resetLikes();
                case 'aggregate':
                  // Count the number of movies
                  final _count = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .count()
                      .get();

                  print('Count: ${_count.count}');

                  // Average the number of likes
                  final _average = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(average('likes'))
                      .get();

                  print('Average: ${_average.getAverage('likes')}');

                  // Sum the number of likes
                  final _sum = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(sum('likes'))
                      .get();

                  print('Sum: ${_sum.getSum('likes')}');

                  // In one query
                  final _all = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(
                        average('likes'),
                        sum('likes'),
                        count(),
                      )
                      .get();

                  print('Average: ${_all.getAverage('likes')} '
                      'Sum: ${_all.getSum('likes')} '
                      'Count: ${_all.count}');

                  return;
                case 'load_bundle':
                  Uint8List buffer = await loadBundleSetup(2);
                  LoadBundleTask task =
                      FirebaseFirestore.instance.loadBundle(buffer);

                  final list = await task.stream.toList();

                  print(
                    list.map((e) => e.totalDocuments),
                  );
                  print(
                    list.map((e) => e.bytesLoaded),
                  );
                  print(
                    list.map((e) => e.documentsLoaded),
                  );
                  print(
                    list.map((e) => e.totalBytes),
                  );
                  print(
                    list,
                  );

                  LoadBundleTaskSnapshot lastSnapshot = list.removeLast();
                  print(lastSnapshot.taskState);

                  print(
                    list.map((e) => e.taskState),
                  );
                  return;
                case 'vectorValue':
                  const vectorValue = VectorValue([1.0, 2.0, 3.0]);
                  final vectorValueDoc = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .add({'vectorValue': vectorValue});

                  final snapshot = await vectorValueDoc.get();
                  print(snapshot.data());
                  return;
                default:
                  return;
              }
            },
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: 'reset_likes',
                  child: Text('Reset like counts (WriteBatch)'),
                ),
                const PopupMenuItem(
                  value: 'aggregate',
                  child: Text('Get aggregate data'),
                ),
                const PopupMenuItem(
                  value: 'load_bundle',
                  child: Text('Load bundle'),
                ),
                const PopupMenuItem(
                  value: 'vectorValue',
                  child: Text('Test Vector Value'),
                ),
              ];
            },
          ),
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Movie>>(
        stream: moviesRef.queryBy(query).snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text(snapshot.error.toString()),
            );
          }

          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final data = snapshot.requireData;

          return ListView.builder(
            itemCount: data.size,
            itemBuilder: (context, index) {
              return _MovieItem(
                data.docs[index].data(),
                data.docs[index].reference,
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _resetLikes() async {
    final movies = await moviesRef.get(
      const GetOptions(
        serverTimestampBehavior: ServerTimestampBehavior.previous,
      ),
    );

    WriteBatch batch = FirebaseFirestore.instance.batch();

    for (final movie in movies.docs) {
      batch.update(movie.reference, {'likes': 0});
    }
    await batch.commit();
  }
}

/// A single movie row.
class _MovieItem extends StatelessWidget {
  _MovieItem(this.movie, this.reference);

  final Movie movie;
  final DocumentReference<Movie> reference;

  /// Returns the movie poster.
  Widget get poster {
    return SizedBox(
      width: 100,
      child: Image.network(movie.poster),
    );
  }

  /// Returns movie details.
  Widget get details {
    return Padding(
      padding: const EdgeInsets.only(left: 8, right: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          title,
          metadata,
          genres,
          Likes(
            reference: reference,
            currentLikes: movie.likes,
          ),
        ],
      ),
    );
  }

  /// Return the movie title.
  Widget get title {
    return Text(
      '${movie.title} (${movie.year})',
      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
    );
  }

  /// Returns metadata about the movie.
  Widget get metadata {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(right: 8),
            child: Text('Rated: ${movie.rated}'),
          ),
          Text('Runtime: ${movie.runtime}'),
        ],
      ),
    );
  }

  /// Returns a list of genre movie tags.
  List<Widget> get genreItems {
    return [
      for (final genre in movie.genre)
        Padding(
          padding: const EdgeInsets.only(right: 2),
          child: Chip(
            backgroundColor: Colors.lightBlue,
            label: Text(
              genre,
              style: const TextStyle(color: Colors.white),
            ),
          ),
        ),
    ];
  }

  /// Returns all genres.
  Widget get genres {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Wrap(
        children: genreItems,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4, top: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          poster,
          Flexible(child: details),
        ],
      ),
    );
  }
}

/// Displays and manages the movie 'like' count.
class Likes extends StatefulWidget {
  /// Constructs a new [Likes] instance with a given [DocumentReference] and
  /// current like count.
  Likes({
    Key? key,
    required this.reference,
    required this.currentLikes,
  }) : super(key: key);

  /// The reference relating to the counter.
  final DocumentReference<Movie> reference;

  /// The number of current likes (before manipulation).
  final int currentLikes;

  @override
  _LikesState createState() => _LikesState();
}

class _LikesState extends State<Likes> {
  /// A local cache of the current likes, used to immediately render the updated
  /// likes count after an update, even while the request isn't completed yet.
  late int _likes = widget.currentLikes;

  Future<void> _onLike() async {
    final currentLikes = _likes;

    // Increment the 'like' count straight away to show feedback to the user.
    setState(() {
      _likes = currentLikes + 1;
    });

    try {
      // Update the likes using a transaction.
      // We use a transaction because multiple users could update the likes count
      // simultaneously. As such, our likes count may be different from the likes
      // count on the server.
      int newLikes = await FirebaseFirestore.instance
          .runTransaction<int>((transaction) async {
        DocumentSnapshot<Movie> movie =
            await transaction.get<Movie>(widget.reference);

        if (!movie.exists) {
          throw Exception('Document does not exist!');
        }

        int updatedLikes = movie.data()!.likes + 1;
        transaction.update(widget.reference, {'likes': updatedLikes});
        return updatedLikes;
      });

      // Update with the real count once the transaction has completed.
      setState(() => _likes = newLikes);
    } catch (e, s) {
      print(s);
      print('Failed to update likes for document! $e');

      // If the transaction fails, revert back to the old count
      setState(() => _likes = currentLikes);
    }
  }

  @override
  void didUpdateWidget(Likes oldWidget) {
    super.didUpdateWidget(oldWidget);
    // The likes on the server changed, so we need to update our local cache to
    // keep things in sync. Otherwise if another user updates the likes,
    // we won't see the update.
    if (widget.currentLikes != oldWidget.currentLikes) {
      _likes = widget.currentLikes;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          iconSize: 20,
          onPressed: _onLike,
          icon: const Icon(Icons.favorite),
        ),
        Text('$_likes likes'),
      ],
    );
  }
}

@immutable
class Movie {
  Movie({
    required this.genre,
    required this.likes,
    required this.poster,
    required this.rated,
    required this.runtime,
    required this.title,
    required this.year,
  });

  Movie.fromJson(Map<String, Object?> json)
      : this(
          genre: (json['genre']! as List).cast<String>(),
          likes: json['likes']! as int,
          poster: json['poster']! as String,
          rated: json['rated']! as String,
          runtime: json['runtime']! as String,
          title: json['title']! as String,
          year: json['year']! as int,
        );

  final String poster;
  final int likes;
  final String title;
  final int year;
  final String runtime;
  final String rated;
  final List<String> genre;

  Map<String, Object?> toJson() {
    return {
      'genre': genre,
      'likes': likes,
      'poster': poster,
      'rated': rated,
      'runtime': runtime,
      'title': title,
      'year': year,
    };
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 1291 bytes | **라인 수**: 69 | **타입**: text

```
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/macos/Runner/AppDelegate.swift

**크기**: 201 bytes | **라인 수**: 10 | **타입**: text

```
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/macos/Runner/MainFlutterWindow.swift

**크기**: 388 bytes | **라인 수**: 16 | **타입**: text

```
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/macos/RunnerTests/RunnerTests.swift

**크기**: 505 bytes | **라인 수**: 15 | **타입**: text

```
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {
  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/macos/firebase_app_id_file.json

**크기**: 275 bytes | **라인 수**: 7 | **타입**: text

```
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:0670bc5fe8574a9c3574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/test_driver/integration_test.dart

**크기**: 326 bytes | **라인 수**: 8 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/web/index.html

**크기**: 1218 bytes | **라인 수**: 39 | **타입**: text

```
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>example</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/web/manifest.json

**크기**: 930 bytes | **라인 수**: 36 | **타입**: text

```
{
    "name": "Firestore Example",
    "short_name": "Firestore Example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/web/wasm_index.html

**크기**: 235 bytes | **라인 수**: 14 | **타입**: text

```
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <title>Flutter web app</title>
  <script src="flutter.js"></script>
</head>
<body>
  <script>
    {{flutter_build_config}}
    _flutter.loader.load();
  </script>
</body>
</html>
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/flutter/CMakeLists.txt

**크기**: 3742 bytes | **라인 수**: 110 | **타입**: text

```
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/CMakeLists.txt

**크기**: 1796 bytes | **라인 수**: 41 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/flutter_window.cpp

**크기**: 2333 bytes | **라인 수**: 74 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() { this->Show(); });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/flutter_window.h

**크기**: 1152 bytes | **라인 수**: 40 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/main.cpp

**크기**: 1487 bytes | **라인 수**: 47 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t* command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments = GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"cloud_firestore_example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/resource.h

**크기**: 604 bytes | **라인 수**: 23 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON 101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE 102
#define _APS_NEXT_COMMAND_VALUE 40001
#define _APS_NEXT_CONTROL_VALUE 1001
#define _APS_NEXT_SYMED_VALUE 101
#endif
#endif

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/utils.cpp

**크기**: 2030 bytes | **라인 수**: 70 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE* unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length =
      ::WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, -1,
                            nullptr, 0, nullptr, nullptr) -
      1;  // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length <= 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, input_length,
      utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/utils.h

**크기**: 896 bytes | **라인 수**: 26 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/win32_window.cpp

**크기**: 8585 bytes | **라인 수**: 285 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See:
/// https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
    L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] =
    L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() { ++g_active_window_count; }

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title, const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() { return ShowWindow(window_handle_, SW_SHOWNORMAL); }

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window, UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd, UINT const message, WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() { return window_handle_; }

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result =
      RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                  kGetPreferredBrightnessRegValue, RRF_RT_REG_DWORD, nullptr,
                  &light_mode, &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/runner/win32_window.h

**크기**: 3679 bytes | **라인 수**: 107 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window, UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window, UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/windows/CMakeLists.txt

**크기**: 3931 bytes | **라인 수**: 102 | **타입**: text

```
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(cloud_firestore_example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "cloud_firestore_example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/README.md

**크기**: 182 bytes | **라인 수**: 9 | **타입**: text

```
# firestore_example

Demonstrates how to use the firestore plugin.

## Getting Started

For help getting started with Flutter, view our online
[documentation](https://flutter.dev/).

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/analysis_options.yaml

**크기**: 327 bytes | **라인 수**: 10 | **타입**: text

```
# Copyright 2021 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# in the LICENSE file.

include: ../../../../analysis_options.yaml
linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/firebase.json

**크기**: 191 bytes | **라인 수**: 1 | **타입**: text

```
{"flutter":{"platforms":{"android":{"default":{"projectId":"flutterfire-e2e-tests","appId":"1:406099696497:android:175ea7a64b2faf5e3574d0","fileOutput":"android/app/google-services.json"}}}}}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/example/pubspec.yaml

**크기**: 363 bytes | **라인 수**: 22 | **타입**: text

```
name: cloud_firestore_example
description: Demonstrates how to use the firestore plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  cloud_firestore: ^6.0.2
  firebase_core: ^4.1.1
  flutter:
    sdk: flutter
  http: ^1.0.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h

**크기**: 1214 bytes | **라인 수**: 38 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTDocumentSnapshotStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FIRDocumentReference *reference;
@property(nonatomic, assign) BOOL includeMetadataChanges;
@property(nonatomic, assign) FIRListenSource source;
@property(nonatomic, assign) FIRServerTimestampBehavior serverTimestampBehavior;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                        reference:(FIRDocumentReference *)reference
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h

**크기**: 567 bytes | **라인 수**: 16 | **타입**: text

```
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <FirebaseFirestore/FirebaseFirestore.h>
#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreExtension : NSObject

@property(nonatomic, strong, readonly) FIRFirestore *instance;
@property(nonatomic, strong, readonly) NSString *databaseURL;

- (instancetype)initWithFirestoreInstance:(FIRFirestore *)instance
                              databaseURL:(NSString *)databaseURL;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h

**크기**: 471 bytes | **라인 수**: 18 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreReader : FlutterStandardReader
- (id)readValueOfType:(UInt8)type;
+ (dispatch_queue_t)getFirestoreQueue;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h

**크기**: 2655 bytes | **라인 수**: 67 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#import <Foundation/Foundation.h>
#import "FLTFirebaseFirestoreExtension.h"

typedef NS_ENUM(UInt8, FirestoreDataType) {
  FirestoreDataTypeDateTime = 180,
  FirestoreDataTypeGeoPoint = 181,
  FirestoreDataTypeDocumentReference = 182,
  FirestoreDataTypeBlob = 183,
  FirestoreDataTypeArrayUnion = 184,
  FirestoreDataTypeArrayRemove = 185,
  FirestoreDataTypeDelete = 186,
  FirestoreDataTypeServerTimestamp = 187,
  FirestoreDataTypeTimestamp = 188,
  FirestoreDataTypeIncrementDouble = 189,
  FirestoreDataTypeIncrementInteger = 190,
  FirestoreDataTypeDocumentId = 191,
  FirestoreDataTypeFieldPath = 192,
  FirestoreDataTypeNaN = 193,
  FirestoreDataTypeInfinity = 194,
  FirestoreDataTypeNegativeInfinity = 195,
  FirestoreDataTypeFirestoreInstance = 196,
  FirestoreDataTypeFirestoreQuery = 197,
  FirestoreDataTypeFirestoreSettings = 198,
  FirestoreDataTypeVectorValue = 199,
};

@interface FLTFirebaseFirestoreReaderWriter : FlutterStandardReaderWriter
- (FlutterStandardWriter *_Nonnull)writerWithData:(NSMutableData *_Nullable)data;
- (FlutterStandardReader *_Nonnull)readerWithData:(NSData *_Nullable)data;
@end

@interface FLTFirebaseFirestoreUtils : NSObject
+ (FIRFirestoreSource)FIRFirestoreSourceFromArguments:(NSDictionary *_Nonnull)arguments;
+ (NSArray *_Nonnull)ErrorCodeAndMessageFromNSError:(NSError *_Nonnull)error;
+ (FLTFirebaseFirestoreExtension *_Nullable)
    getCachedFIRFirestoreInstanceForAppName:(NSString *_Nonnull)appName
                                databaseURL:(NSString *_Nonnull)url;
+ (void)setCachedFIRFirestoreInstance:(FIRFirestore *_Nonnull)firestore
                           forAppName:(NSString *_Nonnull)appName
                          databaseURL:(NSString *_Nonnull)url;
+ (void)destroyCachedInstanceForFirestore:(NSString *_Nonnull)appName
                              databaseURL:(NSString *_Nonnull)databaseURL;
+ (FIRFirestore *_Nullable)getFirestoreInstanceByName:(NSString *_Nonnull)appName
                                          databaseURL:(NSString *_Nonnull)databaseURL;
+ (void)cleanupFirestoreInstances:(void (^_Nullable)(void))completion;
+ (NSUInteger)count;
+ (FLTFirebaseFirestoreExtension *_Nullable)getCachedInstanceForFirestore:
    (FIRFirestore *_Nonnull)firestore;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h

**크기**: 427 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreWriter : FlutterStandardWriter
- (void)writeValue:(id)value;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h

**크기**: 968 bytes | **라인 수**: 41 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

//
//  FLTLoadBundleStreamHandler.h
//  Pods
//
//  Created by Russell Wheatley on 05/05/2021.
//
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTLoadBundleStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FlutterStandardTypedData *bundle;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                           bundle:(FlutterStandardTypedData *)bundle;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h

**크기**: 1072 bytes | **라인 수**: 32 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTQuerySnapshotStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FIRQuery *query;
@property(nonatomic, assign) BOOL includeMetadataChanges;
@property(nonatomic, assign) FIRListenSource source;
@property(nonatomic, assign) FIRServerTimestampBehavior serverTimestampBehavior;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                            query:(FIRQuery *)query
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h

**크기**: 577 bytes | **라인 수**: 24 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTSnapshotsInSyncStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTTransactionStreamHandler.h

**크기**: 1384 bytes | **라인 수**: 43 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#if __has_include(<cloud_firestore/FirestoreMessages.g.h>)
#import <cloud_firestore/FirestoreMessages.g.h>
#else
#import "../Public/FirestoreMessages.g.h"
#endif
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTTransactionStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) NSNumber *timeout;
@property(nonatomic, strong) NSNumber *maxAttempts;

- (instancetype)initWithId:(NSString *)transactionId
                 firestore:(FIRFirestore *)firestore
                   timeout:(nonnull NSNumber *)timeout
               maxAttempts:(nonnull NSNumber *)maxAttempts
                   started:(void (^)(FIRTransaction *))startedListener
                     ended:(void (^)(void))endedListener;
- (void)receiveTransactionResponse:(PigeonTransactionResult)resultType
                          commands:(NSArray<PigeonTransactionCommand *> *)commands;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FirestorePigeonParser.h

**크기**: 2428 bytes | **라인 수**: 59 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#import <Foundation/Foundation.h>
#if __has_include(<cloud_firestore/FirestoreMessages.g.h>)
#import <cloud_firestore/FirestoreMessages.g.h>
#else
#import "../Public/FirestoreMessages.g.h"
#endif
@interface FirestorePigeonParser : NSObject

+ (FIRFilter *_Nonnull)filterFromJson:(NSDictionary<NSString *, id> *_Nullable)map;

+ (FIRQuery *_Nonnull)parseQueryWithParameters:(nonnull PigeonQueryParameters *)parameters
                                     firestore:(nonnull FIRFirestore *)firestore
                                          path:(nonnull NSString *)path
                             isCollectionGroup:(Boolean)isCollectionGroup;

+ (FIRFirestoreSource)parseSource:(Source)source;

+ (NSArray<FIRFieldPath *> *_Nonnull)parseFieldPath:
    (NSArray<NSArray<NSString *> *> *_Nonnull)fieldPaths;

+ (FIRServerTimestampBehavior)parseServerTimestampBehavior:
    (ServerTimestampBehavior)serverTimestampBehavior;

+ (FIRListenSource)parseListenSource:(ListenSource)source;

+ (PigeonSnapshotMetadata *_Nonnull)toPigeonSnapshotMetadata:
    (FIRSnapshotMetadata *_Nonnull)snapshotMetadata;

+ (PigeonDocumentSnapshot *_Nonnull)
    toPigeonDocumentSnapshot:(FIRDocumentSnapshot *_Nonnull)documentSnapshot
     serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior;

+ (DocumentChangeType)toPigeonDocumentChangeType:(FIRDocumentChangeType)documentChangeType;

+ (PigeonDocumentChange *_Nonnull)toPigeonDocumentChange:(FIRDocumentChange *_Nonnull)documentChange
                                 serverTimestampBehavior:
                                     (FIRServerTimestampBehavior)serverTimestampBehavior;

+ (NSArray<PigeonDocumentChange *> *_Nonnull)
    toPigeonDocumentChanges:(NSArray<FIRDocumentChange *> *_Nonnull)documentChanges
    serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior;

+ (PigeonQuerySnapshot *_Nonnull)toPigeonQuerySnapshot:(FIRQuerySnapshot *_Nonnull)querySnaphot
                               serverTimestampBehavior:
                                   (FIRServerTimestampBehavior)serverTimestampBehavior;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h

**크기**: 411 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import "FirestoreMessages.g.h"

@interface PigeonDocumentSnapshot (Map)
- (NSDictionary *)toList;
@end

@interface PigeonDocumentChange (Map)
- (NSDictionary *)toList;
@end

@interface PigeonSnapshotMetadata (Map)
- (NSDictionary *)toList;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h

**크기**: 701 bytes | **라인 수**: 24 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>
#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "FirestoreMessages.g.h"

@interface FLTFirebaseFirestorePlugin
    : FLTFirebasePlugin <FlutterPlugin, FLTFirebasePlugin, FirebaseFirestoreHostApi>
+ (NSMutableDictionary<NSNumber *, NSString *> *)serverTimestampMap;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/FirestoreMessages.g.h

**크기**: 20917 bytes | **라인 수**: 425 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

/// An enumeration of document change types.
typedef NS_ENUM(NSUInteger, DocumentChangeType) {
  /// Indicates a new document was added to the set of documents matching the
  /// query.
  DocumentChangeTypeAdded = 0,
  /// Indicates a document within the query was modified.
  DocumentChangeTypeModified = 1,
  /// Indicates a document within the query was removed (either deleted or no
  /// longer matches the query.
  DocumentChangeTypeRemoved = 2,
};

/// Wrapper for DocumentChangeType to allow for nullability.
@interface DocumentChangeTypeBox : NSObject
@property(nonatomic, assign) DocumentChangeType value;
- (instancetype)initWithValue:(DocumentChangeType)value;
@end

/// An enumeration of firestore source types.
typedef NS_ENUM(NSUInteger, Source) {
  /// Causes Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall back
  /// to
  /// returning cached data if the server can't be reached.
  SourceServerAndCache = 0,
  /// Causes Firestore to avoid the cache, generating an error if the server cannot be reached. Note
  /// that the cache will still be updated if the server request succeeds. Also note that
  /// latency-compensation still takes effect, so any pending write operations will be visible in
  /// the
  /// returned data (merged into the server-provided data).
  SourceServer = 1,
  /// Causes Firestore to immediately return a value from the cache, ignoring the server completely
  /// (implying that the returned value may be stale with respect to the value on the server). If
  /// there is no data in the cache to satisfy the `get` call,
  /// [DocumentReference.get] will throw a [FirebaseException] and
  /// [Query.get] will return an empty [QuerySnapshotPlatform] with no documents.
  SourceCache = 2,
};

/// Wrapper for Source to allow for nullability.
@interface SourceBox : NSObject
@property(nonatomic, assign) Source value;
- (instancetype)initWithValue:(Source)value;
@end

/// The listener retrieves data and listens to updates from the local Firestore cache only.
/// If the cache is empty, an empty snapshot will be returned.
/// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
///
/// Note that the data might be stale if the cache hasn't synchronized with recent server-side
/// changes.
typedef NS_ENUM(NSUInteger, ListenSource) {
  /// The default behavior. The listener attempts to return initial snapshot from cache and retrieve
  /// up-to-date snapshots from the Firestore server.
  /// Snapshot events will be triggered on local mutations and server side updates.
  ListenSourceDefaultSource = 0,
  /// The listener retrieves data and listens to updates from the local Firestore cache only.
  /// If the cache is empty, an empty snapshot will be returned.
  /// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
  ListenSourceCache = 1,
};

/// Wrapper for ListenSource to allow for nullability.
@interface ListenSourceBox : NSObject
@property(nonatomic, assign) ListenSource value;
- (instancetype)initWithValue:(ListenSource)value;
@end

typedef NS_ENUM(NSUInteger, ServerTimestampBehavior) {
  /// Return null for [FieldValue.serverTimestamp()] values that have not yet
  ServerTimestampBehaviorNone = 0,
  /// Return local estimates for [FieldValue.serverTimestamp()] values that have not yet been set to
  /// their final value.
  ServerTimestampBehaviorEstimate = 1,
  /// Return the previous value for [FieldValue.serverTimestamp()] values that have not yet been set
  /// to their final value.
  ServerTimestampBehaviorPrevious = 2,
};

/// Wrapper for ServerTimestampBehavior to allow for nullability.
@interface ServerTimestampBehaviorBox : NSObject
@property(nonatomic, assign) ServerTimestampBehavior value;
- (instancetype)initWithValue:(ServerTimestampBehavior)value;
@end

/// [AggregateSource] represents the source of data for an [AggregateQuery].
typedef NS_ENUM(NSUInteger, AggregateSource) {
  /// Indicates that the data should be retrieved from the server.
  AggregateSourceServer = 0,
};

/// Wrapper for AggregateSource to allow for nullability.
@interface AggregateSourceBox : NSObject
@property(nonatomic, assign) AggregateSource value;
- (instancetype)initWithValue:(AggregateSource)value;
@end

/// [PersistenceCacheIndexManagerRequest] represents the request types for the persistence cache
/// index manager.
typedef NS_ENUM(NSUInteger, PersistenceCacheIndexManagerRequest) {
  PersistenceCacheIndexManagerRequestEnableIndexAutoCreation = 0,
  PersistenceCacheIndexManagerRequestDisableIndexAutoCreation = 1,
  PersistenceCacheIndexManagerRequestDeleteAllIndexes = 2,
};

/// Wrapper for PersistenceCacheIndexManagerRequest to allow for nullability.
@interface PersistenceCacheIndexManagerRequestBox : NSObject
@property(nonatomic, assign) PersistenceCacheIndexManagerRequest value;
- (instancetype)initWithValue:(PersistenceCacheIndexManagerRequest)value;
@end

typedef NS_ENUM(NSUInteger, PigeonTransactionResult) {
  PigeonTransactionResultSuccess = 0,
  PigeonTransactionResultFailure = 1,
};

/// Wrapper for PigeonTransactionResult to allow for nullability.
@interface PigeonTransactionResultBox : NSObject
@property(nonatomic, assign) PigeonTransactionResult value;
- (instancetype)initWithValue:(PigeonTransactionResult)value;
@end

typedef NS_ENUM(NSUInteger, PigeonTransactionType) {
  PigeonTransactionTypeGet = 0,
  PigeonTransactionTypeUpdate = 1,
  PigeonTransactionTypeSet = 2,
  PigeonTransactionTypeDeleteType = 3,
};

/// Wrapper for PigeonTransactionType to allow for nullability.
@interface PigeonTransactionTypeBox : NSObject
@property(nonatomic, assign) PigeonTransactionType value;
- (instancetype)initWithValue:(PigeonTransactionType)value;
@end

typedef NS_ENUM(NSUInteger, AggregateType) {
  AggregateTypeCount = 0,
  AggregateTypeSum = 1,
  AggregateTypeAverage = 2,
};

/// Wrapper for AggregateType to allow for nullability.
@interface AggregateTypeBox : NSObject
@property(nonatomic, assign) AggregateType value;
- (instancetype)initWithValue:(AggregateType)value;
@end

@class PigeonFirebaseSettings;
@class FirestorePigeonFirebaseApp;
@class PigeonSnapshotMetadata;
@class PigeonDocumentSnapshot;
@class PigeonDocumentChange;
@class PigeonQuerySnapshot;
@class PigeonGetOptions;
@class PigeonDocumentOption;
@class PigeonTransactionCommand;
@class DocumentReferenceRequest;
@class PigeonQueryParameters;
@class AggregateQuery;
@class AggregateQueryResponse;

@interface PigeonFirebaseSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPersistenceEnabled:(nullable NSNumber *)persistenceEnabled
                                      host:(nullable NSString *)host
                                sslEnabled:(nullable NSNumber *)sslEnabled
                            cacheSizeBytes:(nullable NSNumber *)cacheSizeBytes
                 ignoreUndefinedProperties:(NSNumber *)ignoreUndefinedProperties;
@property(nonatomic, strong, nullable) NSNumber *persistenceEnabled;
@property(nonatomic, copy, nullable) NSString *host;
@property(nonatomic, strong, nullable) NSNumber *sslEnabled;
@property(nonatomic, strong, nullable) NSNumber *cacheSizeBytes;
@property(nonatomic, strong) NSNumber *ignoreUndefinedProperties;
@end

@interface FirestorePigeonFirebaseApp : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppName:(NSString *)appName
                       settings:(PigeonFirebaseSettings *)settings
                    databaseURL:(NSString *)databaseURL;
@property(nonatomic, copy) NSString *appName;
@property(nonatomic, strong) PigeonFirebaseSettings *settings;
@property(nonatomic, copy) NSString *databaseURL;
@end

@interface PigeonSnapshotMetadata : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithHasPendingWrites:(NSNumber *)hasPendingWrites
                             isFromCache:(NSNumber *)isFromCache;
@property(nonatomic, strong) NSNumber *hasPendingWrites;
@property(nonatomic, strong) NSNumber *isFromCache;
@end

@interface PigeonDocumentSnapshot : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                    metadata:(PigeonSnapshotMetadata *)metadata;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *data;
@property(nonatomic, strong) PigeonSnapshotMetadata *metadata;
@end

@interface PigeonDocumentChange : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(DocumentChangeType)type
                    document:(PigeonDocumentSnapshot *)document
                    oldIndex:(NSNumber *)oldIndex
                    newIndex:(NSNumber *)newIndex;
@property(nonatomic, assign) DocumentChangeType type;
@property(nonatomic, strong) PigeonDocumentSnapshot *document;
@property(nonatomic, strong) NSNumber *oldIndex;
@property(nonatomic, strong) NSNumber *index;
@end

@interface PigeonQuerySnapshot : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDocuments:(NSArray<PigeonDocumentSnapshot *> *)documents
                  documentChanges:(NSArray<PigeonDocumentChange *> *)documentChanges
                         metadata:(PigeonSnapshotMetadata *)metadata;
@property(nonatomic, strong) NSArray<PigeonDocumentSnapshot *> *documents;
@property(nonatomic, strong) NSArray<PigeonDocumentChange *> *documentChanges;
@property(nonatomic, strong) PigeonSnapshotMetadata *metadata;
@end

@interface PigeonGetOptions : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithSource:(Source)source
       serverTimestampBehavior:(ServerTimestampBehavior)serverTimestampBehavior;
@property(nonatomic, assign) Source source;
@property(nonatomic, assign) ServerTimestampBehavior serverTimestampBehavior;
@end

@interface PigeonDocumentOption : NSObject
+ (instancetype)makeWithMerge:(nullable NSNumber *)merge
                  mergeFields:(nullable NSArray<NSArray<NSString *> *> *)mergeFields;
@property(nonatomic, strong, nullable) NSNumber *merge;
@property(nonatomic, strong, nullable) NSArray<NSArray<NSString *> *> *mergeFields;
@end

@interface PigeonTransactionCommand : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(PigeonTransactionType)type
                        path:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                      option:(nullable PigeonDocumentOption *)option;
@property(nonatomic, assign) PigeonTransactionType type;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *data;
@property(nonatomic, strong, nullable) PigeonDocumentOption *option;
@end

@interface DocumentReferenceRequest : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<id, id> *)data
                      option:(nullable PigeonDocumentOption *)option
                      source:(nullable SourceBox *)source
     serverTimestampBehavior:(nullable ServerTimestampBehaviorBox *)serverTimestampBehavior;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<id, id> *data;
@property(nonatomic, strong, nullable) PigeonDocumentOption *option;
@property(nonatomic, strong, nullable) SourceBox *source;
@property(nonatomic, strong, nullable) ServerTimestampBehaviorBox *serverTimestampBehavior;
@end

@interface PigeonQueryParameters : NSObject
+ (instancetype)makeWithWhere:(nullable NSArray<NSArray<id> *> *)where
                      orderBy:(nullable NSArray<NSArray<id> *> *)orderBy
                        limit:(nullable NSNumber *)limit
                  limitToLast:(nullable NSNumber *)limitToLast
                      startAt:(nullable NSArray<id> *)startAt
                   startAfter:(nullable NSArray<id> *)startAfter
                        endAt:(nullable NSArray<id> *)endAt
                    endBefore:(nullable NSArray<id> *)endBefore
                      filters:(nullable NSDictionary<NSString *, id> *)filters;
@property(nonatomic, strong, nullable) NSArray<NSArray<id> *> *where;
@property(nonatomic, strong, nullable) NSArray<NSArray<id> *> *orderBy;
@property(nonatomic, strong, nullable) NSNumber *limit;
@property(nonatomic, strong, nullable) NSNumber *limitToLast;
@property(nonatomic, strong, nullable) NSArray<id> *startAt;
@property(nonatomic, strong, nullable) NSArray<id> *startAfter;
@property(nonatomic, strong, nullable) NSArray<id> *endAt;
@property(nonatomic, strong, nullable) NSArray<id> *endBefore;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *filters;
@end

@interface AggregateQuery : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(AggregateType)type field:(nullable NSString *)field;
@property(nonatomic, assign) AggregateType type;
@property(nonatomic, copy, nullable) NSString *field;
@end

@interface AggregateQueryResponse : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(AggregateType)type
                       field:(nullable NSString *)field
                       value:(nullable NSNumber *)value;
@property(nonatomic, assign) AggregateType type;
@property(nonatomic, copy, nullable) NSString *field;
@property(nonatomic, strong, nullable) NSNumber *value;
@end

/// The codec used by FirebaseFirestoreHostApi.
NSObject<FlutterMessageCodec> *FirebaseFirestoreHostApiGetCodec(void);

@protocol FirebaseFirestoreHostApi
- (void)loadBundleApp:(FirestorePigeonFirebaseApp *)app
               bundle:(FlutterStandardTypedData *)bundle
           completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)namedQueryGetApp:(FirestorePigeonFirebaseApp *)app
                    name:(NSString *)name
                 options:(PigeonGetOptions *)options
              completion:
                  (void (^)(PigeonQuerySnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)clearPersistenceApp:(FirestorePigeonFirebaseApp *)app
                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)disableNetworkApp:(FirestorePigeonFirebaseApp *)app
               completion:(void (^)(FlutterError *_Nullable))completion;
- (void)enableNetworkApp:(FirestorePigeonFirebaseApp *)app
              completion:(void (^)(FlutterError *_Nullable))completion;
- (void)terminateApp:(FirestorePigeonFirebaseApp *)app
          completion:(void (^)(FlutterError *_Nullable))completion;
- (void)waitForPendingWritesApp:(FirestorePigeonFirebaseApp *)app
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setIndexConfigurationApp:(FirestorePigeonFirebaseApp *)app
              indexConfiguration:(NSString *)indexConfiguration
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setLoggingEnabledLoggingEnabled:(NSNumber *)loggingEnabled
                             completion:(void (^)(FlutterError *_Nullable))completion;
- (void)snapshotsInSyncSetupApp:(FirestorePigeonFirebaseApp *)app
                     completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)transactionCreateApp:(FirestorePigeonFirebaseApp *)app
                     timeout:(NSNumber *)timeout
                 maxAttempts:(NSNumber *)maxAttempts
                  completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)transactionStoreResultTransactionId:(NSString *)transactionId
                                 resultType:(PigeonTransactionResult)resultType
                                   commands:(nullable NSArray<PigeonTransactionCommand *> *)commands
                                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)transactionGetApp:(FirestorePigeonFirebaseApp *)app
            transactionId:(NSString *)transactionId
                     path:(NSString *)path
               completion:
                   (void (^)(PigeonDocumentSnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)documentReferenceSetApp:(FirestorePigeonFirebaseApp *)app
                        request:(DocumentReferenceRequest *)request
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)documentReferenceUpdateApp:(FirestorePigeonFirebaseApp *)app
                           request:(DocumentReferenceRequest *)request
                        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)documentReferenceGetApp:(FirestorePigeonFirebaseApp *)app
                        request:(DocumentReferenceRequest *)request
                     completion:(void (^)(PigeonDocumentSnapshot *_Nullable,
                                          FlutterError *_Nullable))completion;
- (void)documentReferenceDeleteApp:(FirestorePigeonFirebaseApp *)app
                           request:(DocumentReferenceRequest *)request
                        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)queryGetApp:(FirestorePigeonFirebaseApp *)app
                 path:(NSString *)path
    isCollectionGroup:(NSNumber *)isCollectionGroup
           parameters:(PigeonQueryParameters *)parameters
              options:(PigeonGetOptions *)options
           completion:(void (^)(PigeonQuerySnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)aggregateQueryApp:(FirestorePigeonFirebaseApp *)app
                     path:(NSString *)path
               parameters:(PigeonQueryParameters *)parameters
                   source:(AggregateSource)source
                  queries:(NSArray<AggregateQuery *> *)queries
        isCollectionGroup:(NSNumber *)isCollectionGroup
               completion:(void (^)(NSArray<AggregateQueryResponse *> *_Nullable,
                                    FlutterError *_Nullable))completion;
- (void)writeBatchCommitApp:(FirestorePigeonFirebaseApp *)app
                     writes:(NSArray<PigeonTransactionCommand *> *)writes
                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)querySnapshotApp:(FirestorePigeonFirebaseApp *)app
                      path:(NSString *)path
         isCollectionGroup:(NSNumber *)isCollectionGroup
                parameters:(PigeonQueryParameters *)parameters
                   options:(PigeonGetOptions *)options
    includeMetadataChanges:(NSNumber *)includeMetadataChanges
                    source:(ListenSource)source
                completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)documentReferenceSnapshotApp:(FirestorePigeonFirebaseApp *)app
                          parameters:(DocumentReferenceRequest *)parameters
              includeMetadataChanges:(NSNumber *)includeMetadataChanges
                              source:(ListenSource)source
                          completion:
                              (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)persistenceCacheIndexManagerRequestApp:(FirestorePigeonFirebaseApp *)app
                                       request:(PersistenceCacheIndexManagerRequest)request
                                    completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void FirebaseFirestoreHostApiSetup(id<FlutterBinaryMessenger> binaryMessenger,
                                          NSObject<FirebaseFirestoreHostApi> *_Nullable api);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTDocumentSnapshotStreamHandler.m

**크기**: 3186 bytes | **라인 수**: 83 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h"

@interface FLTDocumentSnapshotStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTDocumentSnapshotStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore
                                reference:(nonnull FIRDocumentReference *)reference
                   includeMetadataChanges:(BOOL)includeMetadataChanges
                  serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                                   source:(FIRListenSource)source {
  self = [super init];
  if (self) {
    self.firestore = firestore;
    self.reference = reference;
    self.includeMetadataChanges = includeMetadataChanges;
    self.serverTimestampBehavior = serverTimestampBehavior;
    self.source = source;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  id listener = ^(FIRDocumentSnapshot *snapshot, NSError *_Nullable error) {
    if (error) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
      NSString *code = codeAndMessage[0];
      NSString *message = codeAndMessage[1];
      NSDictionary *details = @{
        @"code" : code,
        @"message" : message,
      };
      dispatch_async(dispatch_get_main_queue(), ^{
        events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                     message:message
                                             optionalDetails:details
                                          andOptionalNSError:error]);
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        events(
            [[FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                     serverTimestampBehavior:self.serverTimestampBehavior] toList]);
      });
    }
  };

  FIRSnapshotListenOptions *options = [[FIRSnapshotListenOptions alloc] init];
  FIRSnapshotListenOptions *optionsWithSourceAndMetadata = [[options
      optionsWithIncludeMetadataChanges:_includeMetadataChanges] optionsWithSource:_source];

  self.listenerRegistration =
      [_reference addSnapshotListenerWithOptions:optionsWithSourceAndMetadata listener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreExtension.m

**크기**: 760 bytes | **라인 수**: 28 | **타입**: text

```
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseFirestore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h"

@interface FLTFirebaseFirestoreExtension ()

@property(nonatomic, strong, readwrite) FIRFirestore *instance;
@property(nonatomic, strong, readwrite) NSString *databaseURL;

@end

@implementation FLTFirebaseFirestoreExtension

- (instancetype)initWithFirestoreInstance:(FIRFirestore *)firestore
                              databaseURL:(NSString *)databaseURL {
  self = [super init];
  if (self) {
    _instance = firestore;
    _databaseURL = [databaseURL copy];
  }
  return self;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestorePlugin.m

**크기**: 39160 bytes | **라인 수**: 879 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import <TargetConditionals.h>
#import "FirebaseFirestoreInternal/FIRPersistentCacheIndexManager.h"
#import "include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h"
#import "include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h"
#import "include/cloud_firestore/Private/FLTTransactionStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h"

NSString *const kFLTFirebaseFirestoreChannelName = @"plugins.flutter.io/firebase_firestore";
NSString *const kFLTFirebaseFirestoreQuerySnapshotEventChannelName =
    @"plugins.flutter.io/firebase_firestore/query";
NSString *const kFLTFirebaseFirestoreDocumentSnapshotEventChannelName =
    @"plugins.flutter.io/firebase_firestore/document";
NSString *const kFLTFirebaseFirestoreSnapshotsInSyncEventChannelName =
    @"plugins.flutter.io/firebase_firestore/snapshotsInSync";
NSString *const kFLTFirebaseFirestoreTransactionChannelName =
    @"plugins.flutter.io/firebase_firestore/transaction";
NSString *const kFLTFirebaseFirestoreLoadBundleChannelName =
    @"plugins.flutter.io/firebase_firestore/loadBundle";

@interface FLTFirebaseFirestorePlugin ()
@property(nonatomic, retain) NSMutableDictionary *transactions;

/// Registers a unique event channel based on a channel prefix.
///
/// Once registered, the plugin will take care of removing the stream handler and cleaning up,
/// if the engine is detached.
///
/// This function generates a random ID.
///
/// @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
///     "namespace/component" whereas the last / is added internally.
/// @param handler The handler object for responding to channel events and submitting data.
/// @return The generated identifier.
/// @see #registerEventChannel(String, String, StreamHandler)
- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler;

/// Registers a unique event channel based on a channel prefix.
///
/// Once registered, the plugin will take care of removing the stream handler and cleaning up,
/// if the engine is detached.
///
/// @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
/// "namespace/component" whereas the last / is added internally.
/// @param identifier A identifier which will be appended to the prefix.
/// @param handler The handler object for responding to channel events and submitting data.
/// @return The passed identifier.
/// @see #registerEventChannel(String, String, StreamHandler)
- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                                  identifier:(NSString *)identifier
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler;
@end

static NSCache<NSNumber *, NSString *> *_serverTimestampMap;

@implementation FLTFirebaseFirestorePlugin {
  NSMutableDictionary<NSString *, FlutterEventChannel *> *_eventChannels;
  NSMutableDictionary<NSString *, NSObject<FlutterStreamHandler> *> *_streamHandlers;
  NSMutableDictionary<NSString *, FLTTransactionStreamHandler *> *_transactionHandlers;
  NSObject<FlutterBinaryMessenger> *_binaryMessenger;
}

FlutterStandardMethodCodec *_codec;

+ (NSCache<NSNumber *, NSString *> *)serverTimestampMap {
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    _serverTimestampMap = [NSCache<NSNumber *, NSString *> new];
  });
  return _serverTimestampMap;
}

+ (void)initialize {
  _codec =
      [FlutterStandardMethodCodec codecWithReaderWriter:[FLTFirebaseFirestoreReaderWriter new]];
}

#pragma mark - FlutterPlugin

// Returns a singleton instance of the Firebase Firestore plugin.
//+ (instancetype)sharedInstance {
//  static dispatch_once_t onceToken;
//  static FLTFirebaseFirestorePlugin *instance;
//
//  dispatch_once(&onceToken, ^{
//    instance = [[FLTFirebaseFirestorePlugin alloc] init];
//    // Register with the Flutter Firebase plugin registry.
//    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:instance];
//  });
//
//  return instance;
//}

- (instancetype)init:(NSObject<FlutterBinaryMessenger> *)messenger {
  self = [super init];
  if (self) {
    _binaryMessenger = messenger;
    _transactions = [NSMutableDictionary<NSNumber *, FIRTransaction *> dictionary];
    _eventChannels = [NSMutableDictionary dictionary];
    _streamHandlers = [NSMutableDictionary dictionary];
    _transactionHandlers = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FLTFirebaseFirestorePlugin *instance =
      [[FLTFirebaseFirestorePlugin alloc] init:[registrar messenger]];

#if TARGET_OS_OSX
// TODO(Salakar): Publish does not exist on MacOS version of FlutterPluginRegistrar.
#else
  [registrar publish:instance];
#endif
  FirebaseFirestoreHostApiSetup(registrar.messenger, instance);
}

- (void)cleanupEventListeners {
  for (FlutterEventChannel *channel in self->_eventChannels.allValues) {
    [channel setStreamHandler:nil];
  }
  [self->_eventChannels removeAllObjects];
  for (NSObject<FlutterStreamHandler> *handler in self->_streamHandlers.allValues) {
    [handler onCancelWithArguments:nil];
  }
  [self->_streamHandlers removeAllObjects];

  @synchronized(self->_transactions) {
    [self->_transactions removeAllObjects];
  }
}

- (void)cleanupFirestoreInstances:(void (^)(void))completion {
  if ([FLTFirebaseFirestoreUtils count] > 0) {
    [FLTFirebaseFirestoreUtils cleanupFirestoreInstances:completion];
  } else {
    if (completion != nil) completion();
  }
}

- (void)detachFromEngineForRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  [self cleanupEventListeners];
}

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^)(void))completion {
  [self cleanupEventListeners];
  [self cleanupFirestoreInstances:completion];
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *)firebase_app {
  return @{};
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  return kFLTFirebaseFirestoreChannelName;
}

#pragma mark - Firestore API

- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler {
  return [self registerEventChannelWithPrefix:prefix
                                   identifier:[[[NSUUID UUID] UUIDString] lowercaseString]
                                streamHandler:handler];
}

- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                                  identifier:(NSString *)identifier
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler {
  NSString *channelName = [NSString stringWithFormat:@"%@/%@", prefix, identifier];

  FlutterEventChannel *channel = [[FlutterEventChannel alloc] initWithName:channelName
                                                           binaryMessenger:_binaryMessenger
                                                                     codec:_codec];

  [channel setStreamHandler:handler];
  [_eventChannels setObject:channel forKey:identifier];
  [_streamHandlers setObject:handler forKey:identifier];

  return identifier;
}

- (FIRFirestore *_Nullable)getFIRFirestoreFromAppNameFromPigeon:
    (FirestorePigeonFirebaseApp *)pigeonApp {
  @synchronized(self) {
    NSString *appNameDart = pigeonApp.appName;
    NSString *databaseUrl = pigeonApp.databaseURL;

    FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:appNameDart];

    if ([FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                  databaseURL:databaseUrl] != nil) {
      return [FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                       databaseURL:databaseUrl];
    }

    FIRFirestoreSettings *settings = [[FIRFirestoreSettings alloc] init];
    if (pigeonApp.settings.persistenceEnabled != nil) {
      bool persistEnabled = [pigeonApp.settings.persistenceEnabled boolValue];

      // We default to the maximum amount of cache allowed.
      NSNumber *size = @(kFIRFirestoreCacheSizeUnlimited);

      if (pigeonApp.settings.cacheSizeBytes) {
        NSNumber *cacheSizeBytes = pigeonApp.settings.cacheSizeBytes;
        if ([cacheSizeBytes intValue] != -1) {
          size = cacheSizeBytes;
        }
      }

      if (persistEnabled) {
        settings.cacheSettings = [[FIRPersistentCacheSettings alloc] initWithSizeBytes:size];
      } else {
        settings.cacheSettings = [[FIRMemoryCacheSettings alloc]
            initWithGarbageCollectorSettings:[[FIRMemoryLRUGCSettings alloc] init]];
      }
    }

    if (pigeonApp.settings.host != nil) {
      settings.host = pigeonApp.settings.host;
      // Only allow changing ssl if host is also specified.
      if (pigeonApp.settings.sslEnabled != nil) {
        settings.sslEnabled = [pigeonApp.settings.sslEnabled boolValue];
      }
    }

    settings.dispatchQueue = [FLTFirebaseFirestoreReader getFirestoreQueue];

    FIRFirestore *firestore = [FIRFirestore firestoreForApp:app database:databaseUrl];
    firestore.settings = settings;

    [FLTFirebaseFirestoreUtils setCachedFIRFirestoreInstance:firestore
                                                  forAppName:app.name
                                                 databaseURL:databaseUrl];
    return firestore;
  }
}

- (FlutterError *)convertToFlutterError:(NSError *)error {
  NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
  NSString *_Nullable code = codeAndMessage[0];
  NSString *_Nullable message = codeAndMessage[1];
  NSDictionary *_Nullable details = @{
    @"code" : code,
    @"message" : message,
  };

  return [FlutterError errorWithCode:code message:message details:details];
}

- (void)clearPersistenceApp:(nonnull FirestorePigeonFirebaseApp *)app
                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore clearPersistenceWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)disableNetworkApp:(nonnull FirestorePigeonFirebaseApp *)app
               completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore disableNetworkWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)documentReferenceDeleteApp:(nonnull FirestorePigeonFirebaseApp *)app
                           request:(nonnull DocumentReferenceRequest *)request
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  [document deleteDocumentWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)terminate:(id)arguments withMethodCallResult:(FLTFirebaseMethodCallResult *)result {
  FIRFirestore *firestore = arguments[@"firestore"];
  [firestore terminateWithCompletion:^(NSError *error) {
    if (error != nil) {
      result.error(nil, nil, nil, error);
    } else {
      FLTFirebaseFirestoreExtension *firestoreExtension =
          [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
      [FLTFirebaseFirestoreUtils destroyCachedInstanceForFirestore:firestore.app.name
                                                       databaseURL:firestoreExtension.databaseURL];
      result.success(nil);
    }
  }];
}

- (void)documentReferenceGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                        request:(nonnull DocumentReferenceRequest *)request
                     completion:(nonnull void (^)(PigeonDocumentSnapshot *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];
  FIRFirestoreSource source = [FirestorePigeonParser parseSource:request.source.value];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:request.serverTimestampBehavior.value];

  id completionGet = ^(FIRDocumentSnapshot *_Nullable snapshot, NSError *_Nullable error) {
    if (error != nil) {
      completion(nil, [self convertToFlutterError:error]);
    } else {
      completion([FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                         serverTimestampBehavior:serverTimestampBehavior],
                 nil);
    }
  };

  [document getDocumentWithSource:source completion:completionGet];
}

- (void)documentReferenceSetApp:(nonnull FirestorePigeonFirebaseApp *)app
                        request:(nonnull DocumentReferenceRequest *)request
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  id data = request.data;
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  void (^completionBlock)(NSError *) = ^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  };

  if ([request.option.merge isEqual:@YES]) {
    [document setData:data merge:YES completion:completionBlock];
  } else if (request.option.mergeFields) {
    [document setData:data
          mergeFields:[FirestorePigeonParser parseFieldPath:request.option.mergeFields]
           completion:completionBlock];
  } else {
    [document setData:data completion:completionBlock];
  }
}

- (void)documentReferenceSnapshotApp:(nonnull FirestorePigeonFirebaseApp *)app
                          parameters:(nonnull DocumentReferenceRequest *)parameters
              includeMetadataChanges:(nonnull NSNumber *)includeMetadataChanges
                              source:(ListenSource)source
                          completion:(nonnull void (^)(NSString *_Nullable,
                                                       FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:parameters.path];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:parameters.serverTimestampBehavior.value];
  FIRListenSource listenSource = [FirestorePigeonParser parseListenSource:source];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreDocumentSnapshotEventChannelName
                             streamHandler:[[FLTDocumentSnapshotStreamHandler alloc]
                                                     initWithFirestore:firestore
                                                             reference:document
                                                includeMetadataChanges:includeMetadataChanges
                                                                           .boolValue
                                               serverTimestampBehavior:serverTimestampBehavior
                                                                source:listenSource]],
      nil);
}

- (void)documentReferenceUpdateApp:(nonnull FirestorePigeonFirebaseApp *)app
                           request:(nonnull DocumentReferenceRequest *)request
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  id data = request.data;
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  [document updateData:data
            completion:^(NSError *error) {
              if (error != nil) {
                completion([self convertToFlutterError:error]);
              } else {
                completion(nil);
              }
            }];
}

- (void)enableNetworkApp:(nonnull FirestorePigeonFirebaseApp *)app
              completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore enableNetworkWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)loadBundleApp:(nonnull FirestorePigeonFirebaseApp *)app
               bundle:(nonnull FlutterStandardTypedData *)bundle
           completion:(nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  completion([self registerEventChannelWithPrefix:kFLTFirebaseFirestoreLoadBundleChannelName
                                    streamHandler:[[FLTLoadBundleStreamHandler alloc]
                                                      initWithFirestore:firestore
                                                                 bundle:bundle]],
             nil);
}

- (void)namedQueryGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                    name:(nonnull NSString *)name
                 options:(nonnull PigeonGetOptions *)options
              completion:(nonnull void (^)(PigeonQuerySnapshot *_Nullable,
                                           FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  FIRFirestoreSource source = [FirestorePigeonParser parseSource:options.source];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];

  [firestore
      getQueryNamed:name
         completion:^(FIRQuery *_Nullable query) {
           if (query == nil) {
             completion(nil,
                        [FlutterError errorWithCode:@"non-existent-named-query"
                                            message:@"Named query has not been found. Please check "
                                                    @"it has been loaded properly via loadBundle()."
                                            details:nil]);

             return;
           }
           [query getDocumentsWithSource:source
                              completion:^(FIRQuerySnapshot *_Nullable snapshot,
                                           NSError *_Nullable error) {
                                if (error != nil) {
                                  completion(nil, [self convertToFlutterError:error]);
                                } else {
                                  completion([FirestorePigeonParser
                                                   toPigeonQuerySnapshot:snapshot
                                                 serverTimestampBehavior:serverTimestampBehavior],
                                             nil);
                                }
                              }];
         }];
}

- (void)queryGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                 path:(nonnull NSString *)path
    isCollectionGroup:(nonnull NSNumber *)isCollectionGroup
           parameters:(nonnull PigeonQueryParameters *)parameters
              options:(nonnull PigeonGetOptions *)options
           completion:(nonnull void (^)(PigeonQuerySnapshot *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  FIRFirestoreSource source = [FirestorePigeonParser parseSource:options.source];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];

  [query getDocumentsWithSource:source
                     completion:^(FIRQuerySnapshot *_Nullable snapshot, NSError *_Nullable error) {
                       if (error != nil) {
                         completion(nil, [self convertToFlutterError:error]);
                       } else {
                         completion(
                             [FirestorePigeonParser toPigeonQuerySnapshot:snapshot
                                                  serverTimestampBehavior:serverTimestampBehavior],
                             nil);
                       }
                     }];
}

- (void)querySnapshotApp:(nonnull FirestorePigeonFirebaseApp *)app
                      path:(nonnull NSString *)path
         isCollectionGroup:(nonnull NSNumber *)isCollectionGroup
                parameters:(nonnull PigeonQueryParameters *)parameters
                   options:(nonnull PigeonGetOptions *)options
    includeMetadataChanges:(nonnull NSNumber *)includeMetadataChanges
                    source:(ListenSource)source
                completion:
                    (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];
  FIRListenSource listenSource = [FirestorePigeonParser parseListenSource:source];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreQuerySnapshotEventChannelName
                             streamHandler:[[FLTQuerySnapshotStreamHandler alloc]
                                                     initWithFirestore:firestore
                                                                 query:query
                                                includeMetadataChanges:includeMetadataChanges
                                                                           .boolValue
                                               serverTimestampBehavior:serverTimestampBehavior
                                                                source:listenSource]],
      nil);
}

- (void)setIndexConfigurationApp:(nonnull FirestorePigeonFirebaseApp *)app
              indexConfiguration:(nonnull NSString *)indexConfiguration
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  [firestore setIndexConfigurationFromJSON:indexConfiguration
                                completion:^(NSError *_Nullable error) {
                                  if (error != nil) {
                                    completion([self convertToFlutterError:error]);
                                  } else {
                                    completion(nil);
                                  }
                                }];
}

- (void)persistenceCacheIndexManagerRequestApp:(FirestorePigeonFirebaseApp *)app
                                       request:(PersistenceCacheIndexManagerRequest)request
                                    completion:(void (^)(FlutterError *_Nullable))completion {
  FIRPersistentCacheIndexManager *persistentCacheIndexManager =
      [self getFIRFirestoreFromAppNameFromPigeon:app].persistentCacheIndexManager;

  if (persistentCacheIndexManager) {
    switch (request) {
      case PersistenceCacheIndexManagerRequestEnableIndexAutoCreation:
        [persistentCacheIndexManager enableIndexAutoCreation];
        break;
      case PersistenceCacheIndexManagerRequestDisableIndexAutoCreation:
        [persistentCacheIndexManager disableIndexAutoCreation];
        break;
      case PersistenceCacheIndexManagerRequestDeleteAllIndexes:
        [persistentCacheIndexManager deleteAllIndexes];
        break;
    }
  } else {
    // Put because `persistentCacheIndexManager` is a nullable property
    NSLog(@"FLTFirebaseFirestore: `PersistentCacheIndexManager` is not available.");
  }
  completion(nil);
}

- (void)setLoggingEnabledLoggingEnabled:(nonnull NSNumber *)loggingEnabled
                             completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  [FIRFirestore enableLogging:[loggingEnabled boolValue]];
  completion(nil);
}

- (void)terminateApp:(nonnull FirestorePigeonFirebaseApp *)app
          completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore terminateWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      FLTFirebaseFirestoreExtension *firestoreExtension =
          [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
      [FLTFirebaseFirestoreUtils destroyCachedInstanceForFirestore:firestore.app.name
                                                       databaseURL:firestoreExtension.databaseURL];
      completion(nil);
    }
  }];
}

- (void)transactionGetApp:(nonnull FirestorePigeonFirebaseApp *)app
            transactionId:(nonnull NSString *)transactionId
                     path:(nonnull NSString *)path
               completion:(nonnull void (^)(PigeonDocumentSnapshot *_Nullable,
                                            FlutterError *_Nullable))completion {
  // Dispatching to main thread allow us to ensure that the auth token are fetched in time
  // for the transaction
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
    FIRDocumentReference *document = [firestore documentWithPath:path];

    FIRTransaction *transaction = self->_transactions[transactionId];

    if (transaction == nil) {
      completion(
          nil,
          [FlutterError
              errorWithCode:@"missing-transaction"
                    message:@"An error occurred while getting the native transaction. "
                            @"It could be caused by a timeout in a preceding transaction operation."
                    details:nil]);
      return;
    }

    NSError *error = nil;
    FIRDocumentSnapshot *snapshot = [transaction getDocument:document error:&error];

    if (error != nil) {
      completion(nil, [self convertToFlutterError:error]);
    } else if (snapshot != nil) {
      completion([FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                         serverTimestampBehavior:FIRServerTimestampBehaviorNone],
                 nil);
    } else {
      completion(nil, nil);
    }
  });
}

- (void)transactionStoreResultTransactionId:(nonnull NSString *)transactionId
                                 resultType:(PigeonTransactionResult)resultType
                                   commands:(nullable NSArray<PigeonTransactionCommand *> *)commands
                                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  [_transactionHandlers[transactionId] receiveTransactionResponse:resultType commands:commands];

  completion(nil);
}

- (void)waitForPendingWritesApp:(nonnull FirestorePigeonFirebaseApp *)app
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore waitForPendingWritesWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)writeBatchCommitApp:(nonnull FirestorePigeonFirebaseApp *)app
                     writes:(nonnull NSArray<PigeonTransactionCommand *> *)writes
                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRWriteBatch *batch = [firestore batch];

  for (PigeonTransactionCommand *write in writes) {
    PigeonTransactionType type = write.type;
    NSString *path = write.path;
    FIRDocumentReference *reference = [firestore documentWithPath:path];

    switch (type) {
      case PigeonTransactionTypeGet:
        break;
      case PigeonTransactionTypeDeleteType:
        [batch deleteDocument:reference];
        break;
      case PigeonTransactionTypeUpdate:
        [batch updateData:write.data forDocument:reference];
        break;
      case PigeonTransactionTypeSet:
        if ([write.option.merge isEqual:@YES]) {
          [batch setData:write.data forDocument:reference merge:YES];
        } else if (write.option.mergeFields) {
          [batch setData:write.data
              forDocument:reference
              mergeFields:[FirestorePigeonParser parseFieldPath:write.option.mergeFields]];
        } else {
          [batch setData:write.data forDocument:reference];
        }
        break;
    }
  }

  [batch commitWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)snapshotsInSyncSetupApp:(nonnull FirestorePigeonFirebaseApp *)app
                     completion:(nonnull void (^)(NSString *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreSnapshotsInSyncEventChannelName
                             streamHandler:[[FLTSnapshotsInSyncStreamHandler alloc]
                                               initWithFirestore:firestore]],
      nil);
}

- (void)transactionCreateApp:(nonnull FirestorePigeonFirebaseApp *)app
                     timeout:(nonnull NSNumber *)timeout
                 maxAttempts:(nonnull NSNumber *)maxAttempts
                  completion:
                      (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  NSString *transactionId = [[[NSUUID UUID] UUIDString] lowercaseString];

  FLTTransactionStreamHandler *handler =
      [[FLTTransactionStreamHandler alloc] initWithId:transactionId
          firestore:firestore
          timeout:timeout
          maxAttempts:maxAttempts
          started:^(FIRTransaction *_Nonnull transaction) {
            self->_transactions[transactionId] = transaction;
          }
          ended:^{
            self->_transactions[transactionId] = nil;
          }];

  _transactionHandlers[transactionId] = handler;

  completion([self registerEventChannelWithPrefix:kFLTFirebaseFirestoreTransactionChannelName
                                       identifier:transactionId
                                    streamHandler:handler],
             nil);
}

- (void)aggregateQueryApp:(nonnull FirestorePigeonFirebaseApp *)app
                     path:(nonnull NSString *)path
               parameters:(nonnull PigeonQueryParameters *)parameters
                   source:(AggregateSource)source
                  queries:(nonnull NSArray<AggregateQuery *> *)queries
        isCollectionGroup:(NSNumber *)isCollectionGroup
               completion:(nonnull void (^)(NSArray<AggregateQueryResponse *> *_Nullable,
                                            FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  NSMutableArray<FIRAggregateField *> *aggregateFields =
      [[NSMutableArray<FIRAggregateField *> alloc] init];

  for (AggregateQuery *queryRequest in queries) {
    switch ([queryRequest type]) {
      case AggregateTypeCount:
        [aggregateFields addObject:[FIRAggregateField aggregateFieldForCount]];
        break;
      case AggregateTypeSum:
        [aggregateFields
            addObject:[FIRAggregateField aggregateFieldForSumOfField:[queryRequest field]]];
        break;
      case AggregateTypeAverage:
        [aggregateFields
            addObject:[FIRAggregateField aggregateFieldForAverageOfField:[queryRequest field]]];
        break;
      default:
        // Handle the default case
        break;
    }
  }

  FIRAggregateQuery *aggregateQuery = [query aggregate:aggregateFields];

  [aggregateQuery
      aggregationWithSource:FIRAggregateSourceServer
                 completion:^(FIRAggregateQuerySnapshot *_Nullable snapshot,
                              NSError *_Nullable error) {
                   if (error != nil) {
                     completion(nil, [self convertToFlutterError:error]);
                     return;
                   }
                   NSMutableArray<AggregateQueryResponse *> *aggregateResponses =
                       [[NSMutableArray alloc] init];

                   for (AggregateQuery *queryRequest in queries) {
                     switch (queryRequest.type) {
                       case AggregateTypeCount: {
                         double doubleValue = [snapshot.count doubleValue];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeCount
                                                  field:nil
                                                  value:[NSNumber numberWithDouble:doubleValue]]];
                         break;
                       }
                       case AggregateTypeSum: {
                         NSNumber *value = [snapshot
                             valueForAggregateField:[FIRAggregateField
                                                        aggregateFieldForSumOfField:[queryRequest
                                                                                        field]]];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeSum
                                                  field:queryRequest.field
                                                  // This passes either a double (wrapped in
                                                  // NSNumber) or null value
                                                  value:value != ((id)[NSNull null])
                                                            ? [NSNumber
                                                                  numberWithDouble:[value
                                                                                       doubleValue]]
                                                            : value]];
                         break;
                       }
                       case AggregateTypeAverage: {
                         NSNumber *value = [snapshot
                             valueForAggregateField:
                                 [FIRAggregateField
                                     aggregateFieldForAverageOfField:[queryRequest field]]];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeAverage
                                                  field:queryRequest.field
                                                  // This passes either a double (wrapped in
                                                  // NSNumber) or null value
                                                  value:value != ((id)[NSNull null])
                                                            ? [NSNumber
                                                                  numberWithDouble:[value
                                                                                       doubleValue]]
                                                            : value]];
                         break;
                       }
                     }
                   }

                   completion(aggregateResponses, nil);
                 }];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreReader.m

**크기**: 12564 bytes | **라인 수**: 319 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"

@implementation FLTFirebaseFirestoreReader

- (id)readValueOfType:(UInt8)type {
  switch (type) {
    case FirestoreDataTypeDateTime: {
      SInt64 value;
      [self readBytes:&value length:8];
      return [NSDate dateWithTimeIntervalSince1970:(value / 1000.0)];
    }
    case FirestoreDataTypeTimestamp: {
      SInt64 seconds;
      int nanoseconds;
      [self readBytes:&seconds length:8];
      [self readBytes:&nanoseconds length:4];
      return [[FIRTimestamp alloc] initWithSeconds:seconds nanoseconds:nanoseconds];
    }
    case FirestoreDataTypeGeoPoint: {
      Float64 latitude;
      Float64 longitude;
      [self readAlignment:8];
      [self readBytes:&latitude length:8];
      [self readBytes:&longitude length:8];
      return [[FIRGeoPoint alloc] initWithLatitude:latitude longitude:longitude];
    }
    case FirestoreDataTypeVectorValue: {
      return [[FIRVectorValue alloc] initWithArray:[self readValue]];
    }
    case FirestoreDataTypeDocumentReference: {
      FIRFirestore *firestore = [self readValue];
      NSString *documentPath = [self readValue];
      return [firestore documentWithPath:documentPath];
    }
    case FirestoreDataTypeFieldPath: {
      UInt32 length = [self readSize];
      NSMutableArray *array = [NSMutableArray arrayWithCapacity:length];
      for (UInt32 i = 0; i < length; i++) {
        id value = [self readValue];
        [array addObject:(value == nil ? [NSNull null] : value)];
      }
      return [[FIRFieldPath alloc] initWithFields:array];
    }
    case FirestoreDataTypeBlob:
      return [self readData:[self readSize]];
    case FirestoreDataTypeArrayUnion:
      return [FIRFieldValue fieldValueForArrayUnion:[self readValue]];
    case FirestoreDataTypeArrayRemove:
      return [FIRFieldValue fieldValueForArrayRemove:[self readValue]];
    case FirestoreDataTypeDelete:
      return [FIRFieldValue fieldValueForDelete];
    case FirestoreDataTypeServerTimestamp:
      return [FIRFieldValue fieldValueForServerTimestamp];
    case FirestoreDataTypeIncrementDouble:
      return
          [FIRFieldValue fieldValueForDoubleIncrement:((NSNumber *)[self readValue]).doubleValue];
    case FirestoreDataTypeIncrementInteger:
      return [FIRFieldValue fieldValueForIntegerIncrement:((NSNumber *)[self readValue]).intValue];
    case FirestoreDataTypeDocumentId:
      return [FIRFieldPath documentID];
    case FirestoreDataTypeFirestoreInstance:
      return [self FIRFirestore];
    case FirestoreDataTypeFirestoreQuery:
      return [self FIRQuery];
    case FirestoreDataTypeFirestoreSettings:
      return [self FIRFirestoreSettings];
    case FirestoreDataTypeNaN:
      return @(NAN);
    case FirestoreDataTypeInfinity:
      return @(INFINITY);
    case FirestoreDataTypeNegativeInfinity:
      return @(-INFINITY);
    default:
      return [super readValueOfType:type];
  }
}

+ (dispatch_queue_t)getFirestoreQueue {
  static dispatch_queue_t firestoreQueue;
  static dispatch_once_t once;
  dispatch_once(&once, ^{
    firestoreQueue = dispatch_queue_create("dev.flutter.firebase.firestore", DISPATCH_QUEUE_SERIAL);
  });
  return firestoreQueue;
}

- (FIRFirestoreSettings *)FIRFirestoreSettings {
  NSDictionary *values = [self readValue];
  FIRFirestoreSettings *settings = [[FIRFirestoreSettings alloc] init];

  if (![values[@"persistenceEnabled"] isEqual:[NSNull null]]) {
    bool persistEnabled = [((NSNumber *)values[@"persistenceEnabled"]) boolValue];

    // We default to the maximum amount of cache allowed.
    NSNumber *size = @(kFIRFirestoreCacheSizeUnlimited);

    if (![values[@"cacheSizeBytes"] isEqual:[NSNull null]]) {
      NSNumber *cacheSizeBytes = ((NSNumber *)values[@"cacheSizeBytes"]);
      if ([cacheSizeBytes intValue] != -1) {
        size = cacheSizeBytes;
      }
    }

    if (persistEnabled) {
      settings.cacheSettings = [[FIRPersistentCacheSettings alloc] initWithSizeBytes:size];
    } else {
      settings.cacheSettings = [[FIRMemoryCacheSettings alloc]
          initWithGarbageCollectorSettings:[[FIRMemoryLRUGCSettings alloc] init]];
    }
  }

  if (![values[@"host"] isEqual:[NSNull null]]) {
    settings.host = (NSString *)values[@"host"];
    // Only allow changing ssl if host is also specified.
    if (![values[@"sslEnabled"] isEqual:[NSNull null]]) {
      settings.sslEnabled = [((NSNumber *)values[@"sslEnabled"]) boolValue];
    }
  }

  settings.dispatchQueue = [FLTFirebaseFirestoreReader getFirestoreQueue];

  return settings;
}

- (FIRFilter *)filterFromJson:(NSDictionary<NSString *, id> *)map {
  if (map[@"fieldPath"]) {
    // Deserialize a FilterQuery
    NSString *op = map[@"op"];
    FIRFieldPath *fieldPath = map[@"fieldPath"];
    id value = map[@"value"];

    // All the operators from Firebase
    if ([op isEqualToString:@"=="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isEqualTo:value];
    } else if ([op isEqualToString:@"!="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isNotEqualTo:value];
    } else if ([op isEqualToString:@"<"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThan:value];
    } else if ([op isEqualToString:@"<="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
    } else if ([op isEqualToString:@">"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThan:value];
    } else if ([op isEqualToString:@">="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
    } else if ([op isEqualToString:@"array-contains"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContains:value];
    } else if ([op isEqualToString:@"array-contains-any"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContainsAny:value];
    } else if ([op isEqualToString:@"in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath in:value];
    } else if ([op isEqualToString:@"not-in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath notIn:value];
    } else {
      @throw [NSException exceptionWithName:@"InvalidOperator"
                                     reason:@"Invalid operator"
                                   userInfo:nil];
    }
  }
  // Deserialize a FilterOperator
  NSString *op = map[@"op"];
  NSArray<NSDictionary<NSString *, id> *> *queries = map[@"queries"];

  // Map queries recursively
  NSMutableArray<FIRFilter *> *parsedFilters = [NSMutableArray array];
  for (NSDictionary<NSString *, id> *query in queries) {
    [parsedFilters addObject:[self filterFromJson:query]];
  }

  if ([op isEqualToString:@"OR"]) {
    return [FIRFilter orFilterWithFilters:parsedFilters];
  } else if ([op isEqualToString:@"AND"]) {
    return [FIRFilter andFilterWithFilters:parsedFilters];
  }

  @throw [NSException exceptionWithName:@"InvalidOperator" reason:@"Invalid operator" userInfo:nil];
}

- (FIRQuery *)FIRQuery {
  @try {
    FIRQuery *query;
    NSDictionary *values = [self readValue];
    FIRFirestore *firestore = values[@"firestore"];

    NSDictionary *parameters = values[@"parameters"];
    NSArray *whereConditions = parameters[@"where"];
    BOOL isCollectionGroup = ((NSNumber *)values[@"isCollectionGroup"]).boolValue;

    if (isCollectionGroup) {
      query = [firestore collectionGroupWithID:values[@"path"]];
    } else {
      query = (FIRQuery *)[firestore collectionWithPath:values[@"path"]];
    }

    BOOL isFilterQuery = [parameters objectForKey:@"filters"] != nil;
    if (isFilterQuery) {
      FIRFilter *filter =
          [self filterFromJson:(NSDictionary<NSString *, id> *)parameters[@"filters"]];
      query = [query queryWhereFilter:filter];
    }

    // Filters
    for (id item in whereConditions) {
      NSArray *condition = item;
      FIRFieldPath *fieldPath = (FIRFieldPath *)condition[0];
      NSString *operator= condition[1];
      id value = condition[2];
      if ([operator isEqualToString:@"=="]) {
        query = [query queryWhereFieldPath:fieldPath isEqualTo:value];
      } else if ([operator isEqualToString:@"!="]) {
        query = [query queryWhereFieldPath:fieldPath isNotEqualTo:value];
      } else if ([operator isEqualToString:@"<"]) {
        query = [query queryWhereFieldPath:fieldPath isLessThan:value];
      } else if ([operator isEqualToString:@"<="]) {
        query = [query queryWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
      } else if ([operator isEqualToString:@">"]) {
        query = [query queryWhereFieldPath:fieldPath isGreaterThan:value];
      } else if ([operator isEqualToString:@">="]) {
        query = [query queryWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
      } else if ([operator isEqualToString:@"array-contains"]) {
        query = [query queryWhereFieldPath:fieldPath arrayContains:value];
      } else if ([operator isEqualToString:@"array-contains-any"]) {
        query = [query queryWhereFieldPath:fieldPath arrayContainsAny:value];
      } else if ([operator isEqualToString:@"in"]) {
        query = [query queryWhereFieldPath:fieldPath in:value];
      } else if ([operator isEqualToString:@"not-in"]) {
        query = [query queryWhereFieldPath:fieldPath notIn:value];
      } else {
        NSLog(@"FLTFirebaseFirestore: An invalid query operator %@ was received but not handled.",
              operator);
      }
    }

    // Limit
    id limit = parameters[@"limit"];
    if (![limit isEqual:[NSNull null]]) {
      query = [query queryLimitedTo:((NSNumber *)limit).intValue];
    }

    // Limit To Last
    id limitToLast = parameters[@"limitToLast"];
    if (![limitToLast isEqual:[NSNull null]]) {
      query = [query queryLimitedToLast:((NSNumber *)limitToLast).intValue];
    }

    // Ordering
    NSArray *orderBy = parameters[@"orderBy"];
    if ([orderBy isEqual:[NSNull null]]) {
      // We return early if no ordering set as cursor queries below require at least one orderBy set
      return query;
    }

    for (NSArray *orderByParameters in orderBy) {
      FIRFieldPath *fieldPath = (FIRFieldPath *)orderByParameters[0];
      NSNumber *descending = orderByParameters[1];
      query = [query queryOrderedByFieldPath:fieldPath descending:[descending boolValue]];
    }

    // Start At
    id startAt = parameters[@"startAt"];
    if (![startAt isEqual:[NSNull null]]) query = [query queryStartingAtValues:(NSArray *)startAt];
    // Start After
    id startAfter = parameters[@"startAfter"];
    if (![startAfter isEqual:[NSNull null]])
      query = [query queryStartingAfterValues:(NSArray *)startAfter];
    // End At
    id endAt = parameters[@"endAt"];
    if (![endAt isEqual:[NSNull null]]) query = [query queryEndingAtValues:(NSArray *)endAt];
    // End Before
    id endBefore = parameters[@"endBefore"];
    if (![endBefore isEqual:[NSNull null]])
      query = [query queryEndingBeforeValues:(NSArray *)endBefore];

    return query;
  } @catch (NSException *exception) {
    NSLog(@"An error occurred while parsing query arguments, this is most likely an error with "
          @"this SDK. %@",
          [exception callStackSymbols]);
    return nil;
  }
}

- (FIRFirestore *)FIRFirestore {
  @synchronized(self) {
    NSString *appNameDart = [self readValue];
    NSString *databaseUrl = [self readValue];
    FIRFirestoreSettings *settings = [self readValue];
    FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:appNameDart];

    if ([FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                  databaseURL:databaseUrl] != nil) {
      return [FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                       databaseURL:databaseUrl];
    }

    FIRFirestore *firestore = [FIRFirestore firestoreForApp:app database:databaseUrl];
    firestore.settings = settings;

    [FLTFirebaseFirestoreUtils setCachedFIRFirestoreInstance:firestore
                                                  forAppName:app.name
                                                 databaseURL:databaseUrl];
    return firestore;
  }
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreUtils.m

**크기**: 9574 bytes | **라인 수**: 253 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h"

@implementation FLTFirebaseFirestoreReaderWriter
- (FlutterStandardWriter *_Nonnull)writerWithData:(NSMutableData *)data {
  return [[FLTFirebaseFirestoreWriter alloc] initWithData:data];
}
- (FlutterStandardReader *_Nonnull)readerWithData:(NSData *)data {
  return [[FLTFirebaseFirestoreReader alloc] initWithData:data];
}
@end

NSMutableDictionary<NSString *, FLTFirebaseFirestoreExtension *> *firestoreInstanceCache;

@implementation FLTFirebaseFirestoreUtils

+ (NSString *)generateKeyForAppName:(NSString *)appName andDatabaseURL:(NSString *)databaseURL {
  return [NSString stringWithFormat:@"%@|%@", appName, databaseURL];
}

+ (FLTFirebaseFirestoreExtension *_Nullable)
    getCachedFIRFirestoreInstanceForAppName:(NSString *_Nonnull)appName
                                databaseURL:(NSString *_Nonnull)url {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
      return nil;
    } else {
      NSString *key = [self generateKeyForAppName:appName andDatabaseURL:url];
      return firestoreInstanceCache[key];
    }
  }
}

+ (void)setCachedFIRFirestoreInstance:(FIRFirestore *_Nonnull)firestore
                           forAppName:(NSString *_Nonnull)appName
                          databaseURL:(NSString *_Nonnull)url {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
    }
    NSString *key = [self generateKeyForAppName:appName andDatabaseURL:url];
    firestoreInstanceCache[key] =
        [[FLTFirebaseFirestoreExtension alloc] initWithFirestoreInstance:firestore databaseURL:url];
  }
}

+ (void)destroyCachedInstanceForFirestore:(NSString *_Nonnull)appName
                              databaseURL:(NSString *_Nonnull)databaseURL {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache != nil) {
      NSString *key = [self generateKeyForAppName:appName andDatabaseURL:databaseURL];
      FLTFirebaseFirestoreExtension *extension = firestoreInstanceCache[key];

      if (extension != nil) {
        [firestoreInstanceCache removeObjectForKey:key];
      }
    }
  }
}

+ (FIRFirestore *)getFirestoreInstanceByName:(NSString *)appName
                                 databaseURL:(NSString *)databaseURL {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
    }
    NSString *key = [self generateKeyForAppName:appName andDatabaseURL:databaseURL];
    FLTFirebaseFirestoreExtension *extension = firestoreInstanceCache[key];

    if (extension != nil) {
      return extension.instance;
    }

    return nil;
  }
}

+ (NSUInteger)count {
  return [firestoreInstanceCache count];
}

// Require this method when we don't have access to the "databaseURL"
+ (FLTFirebaseFirestoreExtension *_Nullable)getCachedInstanceForFirestore:
    (FIRFirestore *_Nonnull)firestore {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache != nil) {
      NSEnumerator *enumerator = [firestoreInstanceCache keyEnumerator];
      NSString *key;

      while ((key = [enumerator nextObject])) {
        FLTFirebaseFirestoreExtension *value = firestoreInstanceCache[key];

        if (value.instance == firestore) {
          return value;
        }
      }
    }
    @throw [NSException exceptionWithName:@"NoCachedInstance"
                                   reason:@"No cached instance of Firestore"
                                 userInfo:nil];
  }
}

+ (void)cleanupFirestoreInstances:(void (^)(void))completion {
  __block int instancesTerminated = 0;
  NSUInteger numberOfInstances = [firestoreInstanceCache count];
  void (^firestoreTerminateInstanceCompletion)(NSError *) = ^void(NSError *error) {
    instancesTerminated++;
    if (instancesTerminated == numberOfInstances && completion != nil) {
      completion();
    }
  };

  if (numberOfInstances > 0) {
    for (NSString *key in firestoreInstanceCache) {
      FLTFirebaseFirestoreExtension *firestoreExtension = firestoreInstanceCache[key];
      FIRFirestore *firestore = firestoreExtension.instance;

      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        [firestore terminateWithCompletion:^(NSError *error) {
          [FLTFirebaseFirestoreUtils
              destroyCachedInstanceForFirestore:firestore.app.name
                                    databaseURL:firestoreExtension.databaseURL];
          firestoreTerminateInstanceCompletion(error);
        }];
      });
    }
  }
}

+ (FIRFirestoreSource)FIRFirestoreSourceFromArguments:(NSDictionary *)arguments {
  NSString *source = arguments[@"source"];
  if ([@"server" isEqualToString:source]) {
    return FIRFirestoreSourceServer;
  }

  if ([@"cache" isEqualToString:source]) {
    return FIRFirestoreSourceCache;
  }

  return FIRFirestoreSourceDefault;
}

+ (NSArray *)ErrorCodeAndMessageFromNSError:(NSError *)error {
  NSString *code = @"unknown";

  if (error == nil) {
    return @[ code, @"An unknown error has occurred." ];
  }

  NSString *message;

  switch (error.code) {
    case FIRFirestoreErrorCodeAborted:
      code = @"aborted";
      message = @"The operation was aborted, typically due to a concurrency issue like transaction "
                @"aborts, etc.";
      break;
    case FIRFirestoreErrorCodeAlreadyExists:
      code = @"already-exists";
      message = @"Some document that we attempted to create already exists.";
      break;
    case FIRFirestoreErrorCodeCancelled:
      code = @"cancelled";
      message = @"The operation was cancelled (typically by the caller).";
      break;
    case FIRFirestoreErrorCodeDataLoss:
      code = @"data-loss";
      message = @"Unrecoverable data loss or corruption.";
      break;
    case FIRFirestoreErrorCodeDeadlineExceeded:
      code = @"deadline-exceeded";
      message = @"Deadline expired before operation could complete. For operations that change the "
                @"state of the system, this error may be returned even if the operation has "
                @"completed successfully. For example, a successful response from a server could "
                @"have been delayed long enough for the deadline to expire.";
      break;
    case FIRFirestoreErrorCodeFailedPrecondition:
      code = @"failed-precondition";
      if ([error.localizedDescription containsString:@"index"]) {
        message = error.localizedDescription;
      } else {
        message = @"Operation was rejected because the system is not in a state required for the "
                  @"operation's execution. If performing a query, ensure it has been indexed via "
                  @"the Firebase console.";
      }
      break;
    case FIRFirestoreErrorCodeInternal:
      code = @"internal";
      message = @"Internal errors. Means some invariants expected by underlying system has been "
                @"broken. If you see one of these errors, something is very broken.";
      break;
    case FIRFirestoreErrorCodeInvalidArgument:
      code = @"invalid-argument";
      message = @"Client specified an invalid argument. Note that this differs from "
                @"failed-precondition. invalid-argument indicates arguments that are problematic "
                @"regardless of the state of the system (e.g., an invalid field name).";
      break;
    case FIRFirestoreErrorCodeNotFound:
      code = @"not-found";
      message = @"Some requested document was not found.";
      break;
    case FIRFirestoreErrorCodeOutOfRange:
      code = @"out-of-range";
      message = @"Operation was attempted past the valid range.";
      break;
    case FIRFirestoreErrorCodePermissionDenied:
      code = @"permission-denied";
      message = @"The caller does not have permission to execute the specified operation.";
      break;
    case FIRFirestoreErrorCodeResourceExhausted:
      code = @"resource-exhausted";
      message = @"Some resource has been exhausted, perhaps a per-user quota, or perhaps the "
                @"entire file system is out of space.";
      break;
    case FIRFirestoreErrorCodeUnauthenticated:
      code = @"unauthenticated";
      message = @"The request does not have valid authentication credentials for the operation.";
      break;
    case FIRFirestoreErrorCodeUnavailable:
      code = @"unavailable";
      message = @"The service is currently unavailable. This is a most likely a transient "
                @"condition and may be corrected by retrying with a backoff.";
      break;
    case FIRFirestoreErrorCodeUnimplemented:
      code = @"unimplemented";
      message = @"Operation is not implemented or not supported/enabled.";
      break;
    case FIRFirestoreErrorCodeUnknown:
      code = @"unknown";
      message = @"Unknown error or an error from a different error domain.";
      break;
    default:
      code = @"unknown";
      message = @"An unknown error occurred.";
      break;
  }

  return @[ code, message ];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreWriter.m

**크기**: 8368 bytes | **라인 수**: 242 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h"

@implementation FLTFirebaseFirestoreWriter : FlutterStandardWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[NSDate class]]) {
    [self writeByte:FirestoreDataTypeDateTime];
    NSDate *date = value;
    NSTimeInterval time = date.timeIntervalSince1970;
    SInt64 ms = (SInt64)(time * 1000.0);
    [self writeBytes:&ms length:8];
  } else if ([value isKindOfClass:[FIRTimestamp class]]) {
    FIRTimestamp *timestamp = value;
    SInt64 seconds = timestamp.seconds;
    int nanoseconds = timestamp.nanoseconds;
    [self writeByte:FirestoreDataTypeTimestamp];
    [self writeBytes:(UInt8 *)&seconds length:8];
    [self writeBytes:(UInt8 *)&nanoseconds length:4];
  } else if ([value isKindOfClass:[FIRGeoPoint class]]) {
    FIRGeoPoint *geoPoint = value;
    Float64 latitude = geoPoint.latitude;
    Float64 longitude = geoPoint.longitude;
    [self writeByte:FirestoreDataTypeGeoPoint];
    [self writeAlignment:8];
    [self writeBytes:(UInt8 *)&latitude length:8];
    [self writeBytes:(UInt8 *)&longitude length:8];
  } else if ([value isKindOfClass:[FIRVectorValue class]]) {
    FIRVectorValue *vector = value;
    [self writeByte:FirestoreDataTypeVectorValue];
    [self writeValue:vector.array];
  } else if ([value isKindOfClass:[FIRDocumentReference class]]) {
    FIRDocumentReference *document = value;
    NSString *documentPath = [document path];
    NSString *appName = [FLTFirebasePlugin firebaseAppNameFromIosName:document.firestore.app.name];
    [self writeByte:FirestoreDataTypeDocumentReference];
    [self writeValue:appName];
    [self writeValue:documentPath];

    FIRFirestore *firestore = document.firestore;

    FLTFirebaseFirestoreExtension *extension =
        [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
    [self writeValue:extension.databaseURL];

  } else if ([value isKindOfClass:[FIRDocumentSnapshot class]]) {
    [super writeValue:[self FIRDocumentSnapshot:value]];
  } else if ([value isKindOfClass:[FIRLoadBundleTaskProgress class]]) {
    [super writeValue:[self FIRLoadBundleTaskProgress:value]];
  } else if ([value isKindOfClass:[FIRQuerySnapshot class]]) {
    [super writeValue:[self FIRQuerySnapshot:value]];
  } else if ([value isKindOfClass:[FIRDocumentChange class]]) {
    [super writeValue:[self FIRDocumentChange:value]];
  } else if ([value isKindOfClass:[FIRSnapshotMetadata class]]) {
    [super writeValue:[self FIRSnapshotMetadata:value]];
  } else if ([value isKindOfClass:[NSNumber class]]) {
    NSNumber *number = (NSNumber *)value;

    // Infinity
    if ([number isEqual:@(INFINITY)]) {
      [self writeByte:FirestoreDataTypeInfinity];
      return;
    }

    // -Infinity
    if ([number isEqual:@(-INFINITY)]) {
      [self writeByte:FirestoreDataTypeNegativeInfinity];
      return;
    }

    // NaN
    if ([[value description].lowercaseString isEqual:@"nan"]) {
      [self writeByte:FirestoreDataTypeNaN];
      return;
    }

    [super writeValue:value];
  } else if ([value isKindOfClass:[NSData class]]) {
    NSData *blob = value;
    [self writeByte:FirestoreDataTypeBlob];
    [self writeSize:(UInt32)blob.length];
    [self writeData:blob];
  } else {
    [super writeValue:value];
  }
}

- (NSDictionary *)FIRSnapshotMetadata:(FIRSnapshotMetadata *)snapshotMetadata {
  return @{
    @"hasPendingWrites" : @(snapshotMetadata.hasPendingWrites),
    @"isFromCache" : @(snapshotMetadata.isFromCache),
  };
}

- (NSDictionary *)FIRDocumentChange:(FIRDocumentChange *)documentChange {
  NSString *type;

  switch (documentChange.type) {
    case FIRDocumentChangeTypeAdded:
      type = @"DocumentChangeType.added";
      break;
    case FIRDocumentChangeTypeModified:
      type = @"DocumentChangeType.modified";
      break;
    case FIRDocumentChangeTypeRemoved:
      type = @"DocumentChangeType.removed";
      break;
  }

  NSNumber *oldIndex;
  NSNumber *newIndex;

  // Note the Firestore C++ SDK here returns a maxed UInt that is != NSUIntegerMax, so we make one
  // ourselves so we can convert to -1 for Dart.
  NSUInteger MAX_VAL = (NSUInteger)[@(-1) integerValue];

  if (documentChange.newIndex == NSNotFound || documentChange.newIndex == 4294967295 ||
      documentChange.newIndex == MAX_VAL) {
    newIndex = @([@(-1) intValue]);
  } else {
    newIndex = @([@(documentChange.newIndex) intValue]);
  }

  if (documentChange.oldIndex == NSNotFound || documentChange.oldIndex == 4294967295 ||
      documentChange.oldIndex == MAX_VAL) {
    oldIndex = @([@(-1) intValue]);
  } else {
    oldIndex = @([@(documentChange.oldIndex) intValue]);
  }

  return @{
    @"type" : type,
    @"data" : documentChange.document.data,
    @"path" : documentChange.document.reference.path,
    @"oldIndex" : oldIndex,
    @"newIndex" : newIndex,
    @"metadata" : documentChange.document.metadata,
  };
}

- (FIRServerTimestampBehavior)toServerTimestampBehavior:(NSString *)serverTimestampBehavior {
  if (serverTimestampBehavior == nil) {
    return FIRServerTimestampBehaviorNone;
  }

  if ([serverTimestampBehavior isEqualToString:@"estimate"]) {
    return FIRServerTimestampBehaviorEstimate;
  } else if ([serverTimestampBehavior isEqualToString:@"previous"]) {
    return FIRServerTimestampBehaviorPrevious;
  } else {
    return FIRServerTimestampBehaviorNone;
  }
}

- (NSDictionary *)FIRDocumentSnapshot:(FIRDocumentSnapshot *)documentSnapshot {
  if (documentSnapshot == nil) {
    NSLog(@"Error: documentSnapshot is nil");
    return nil;
  }

  NSNumber *documentSnapshotHash = @([documentSnapshot hash]);
  NSString *timestampBehaviorString =
      [FLTFirebaseFirestorePlugin.serverTimestampMap objectForKey:documentSnapshotHash];

  FIRServerTimestampBehavior serverTimestampBehavior =
      [self toServerTimestampBehavior:timestampBehaviorString];

  [FLTFirebaseFirestorePlugin.serverTimestampMap removeObjectForKey:documentSnapshotHash];

  return @{
    @"path" : documentSnapshot.reference.path,
    @"data" : documentSnapshot.exists
        ? (id)[documentSnapshot dataWithServerTimestampBehavior:serverTimestampBehavior]
        : [NSNull null],
    @"metadata" : documentSnapshot.metadata,
  };
}
- (NSDictionary *)FIRLoadBundleTaskProgress:(FIRLoadBundleTaskProgress *)progress {
  NSString *state;

  switch (progress.state) {
    case FIRLoadBundleTaskStateError:
      state = @"error";
      break;
    case FIRLoadBundleTaskStateSuccess:
      state = @"success";
      break;
    case FIRLoadBundleTaskStateInProgress:
      state = @"running";
      break;
  }
  return @{
    @"bytesLoaded" : @(progress.bytesLoaded),
    @"documentsLoaded" : @(progress.documentsLoaded),
    @"totalBytes" : @(progress.totalBytes),
    @"totalDocuments" : @(progress.totalDocuments),
    @"taskState" : state,
  };
}

- (NSDictionary *)FIRQuerySnapshot:(FIRQuerySnapshot *)querySnapshot {
  if (querySnapshot == nil) {
    NSLog(@"Error: querySnapshot is nil");
    return nil;
  }

  NSNumber *querySnapshotHash = @([querySnapshot hash]);

  NSMutableArray *paths = [NSMutableArray array];
  NSMutableArray *documents = [NSMutableArray array];
  NSMutableArray *metadatas = [NSMutableArray array];
  NSString *timestampBehaviorString =
      [FLTFirebaseFirestorePlugin.serverTimestampMap objectForKey:querySnapshotHash];

  FIRServerTimestampBehavior serverTimestampBehavior =
      [self toServerTimestampBehavior:timestampBehaviorString];

  [FLTFirebaseFirestorePlugin.serverTimestampMap removeObjectForKey:querySnapshotHash];

  for (FIRDocumentSnapshot *document in querySnapshot.documents) {
    [paths addObject:document.reference.path];
    [documents addObject:[document dataWithServerTimestampBehavior:serverTimestampBehavior]];
    [metadatas addObject:document.metadata];
  }

  return @{
    @"paths" : paths,
    @"documentChanges" : querySnapshot.documentChanges,
    @"documents" : documents,
    @"metadatas" : metadatas,
    @"metadata" : querySnapshot.metadata,
  };
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTLoadBundleStreamHandler.m

**크기**: 2631 bytes | **라인 수**: 81 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

//
//  FLTLoadBundleStreamHandler.m
//  cloud_firestore
//
//  Created by Russell Wheatley on 05/05/2021.
//

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h"

@interface FLTLoadBundleStreamHandler ()
@property(readwrite, strong) FIRLoadBundleTask *task;
@end

@implementation FLTLoadBundleStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore
                                   bundle:(FlutterStandardTypedData *)bundle {
  self = [super init];
  if (self) {
    _firestore = firestore;
    _bundle = bundle;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  // use completion handler to inform user of platform error.
  self.task = [_firestore
      loadBundle:_bundle.data
      completion:^(FIRLoadBundleTaskProgress *_Nullable snapshot, NSError *_Nullable error) {
        if (error != nil) {
          NSArray *codeAndMessage =
              [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
          NSString *code = codeAndMessage[0];
          NSString *message = codeAndMessage[1];
          NSDictionary *details = @{
            @"code" : code,
            @"message" : message,
          };

          dispatch_async(dispatch_get_main_queue(), ^{
            events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                         message:message
                                                 optionalDetails:details
                                              andOptionalNSError:error]);
          });
        }
      }];
  // use addObserver to update user with snapshot progress
  [self.task addObserver:^(FIRLoadBundleTaskProgress *_Nullable progress) {
    dispatch_async(dispatch_get_main_queue(), ^{
      if (progress.state != FIRLoadBundleTaskStateError) {
        events(progress);
      }
    });
  }];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.task removeAllObservers];
  self.task = nil;

  return nil;
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTQuerySnapshotStreamHandler.m

**크기**: 4494 bytes | **라인 수**: 116 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h"

@interface FLTQuerySnapshotStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTQuerySnapshotStreamHandler

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                            query:(FIRQuery *)query
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source {
  self = [super init];
  if (self) {
    _firestore = firestore;
    _query = query;
    _includeMetadataChanges = includeMetadataChanges;
    _serverTimestampBehavior = serverTimestampBehavior;
    _source = source;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  FIRQuery *query = self.query;

  if (query == nil) {
    return [FlutterError
        errorWithCode:@"sdk-error"
              message:@"An error occurred while parsing query arguments, see native logs for more "
                      @"information. Please report this issue."
              details:nil];
  }

  id listener = ^(FIRQuerySnapshot *_Nullable snapshot, NSError *_Nullable error) {
    if (error) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
      NSString *code = codeAndMessage[0];
      NSString *message = codeAndMessage[1];
      NSDictionary *details = @{
        @"code" : code,
        @"message" : message,
      };
      dispatch_async(dispatch_get_main_queue(), ^{
        events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                     message:message
                                             optionalDetails:details
                                          andOptionalNSError:error]);
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        NSMutableArray *toListResult = [[NSMutableArray alloc] initWithCapacity:3];

        NSMutableArray *documents =
            [[NSMutableArray alloc] initWithCapacity:snapshot.documents.count];
        NSMutableArray *documentChanges =
            [[NSMutableArray alloc] initWithCapacity:snapshot.documentChanges.count];

        for (FIRDocumentSnapshot *documentSnapshot in snapshot.documents) {
          [documents addObject:[[FirestorePigeonParser
                                   toPigeonDocumentSnapshot:documentSnapshot
                                    serverTimestampBehavior:self.serverTimestampBehavior] toList]];
        }

        for (FIRDocumentChange *documentChange in snapshot.documentChanges) {
          [documentChanges
              addObject:[[FirestorePigeonParser toPigeonDocumentChange:documentChange
                                               serverTimestampBehavior:self.serverTimestampBehavior]
                            toList]];
        }

        [toListResult addObject:documents];
        [toListResult addObject:documentChanges];
        [toListResult
            addObject:[[FirestorePigeonParser toPigeonSnapshotMetadata:snapshot.metadata] toList]];

        events(toListResult);
      });
    }
  };

  FIRSnapshotListenOptions *options = [[FIRSnapshotListenOptions alloc] init];
  FIRSnapshotListenOptions *optionsWithSourceAndMetadata = [[options
      optionsWithIncludeMetadataChanges:_includeMetadataChanges] optionsWithSource:_source];

  self.listenerRegistration = [query addSnapshotListenerWithOptions:optionsWithSourceAndMetadata
                                                           listener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTSnapshotsInSyncStreamHandler.m

**크기**: 1216 bytes | **라인 수**: 45 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;

#import "include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"

@interface FLTSnapshotsInSyncStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTSnapshotsInSyncStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore {
  self = [super init];
  if (self) {
    _firestore = firestore;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  id listener = ^() {
    dispatch_async(dispatch_get_main_queue(), ^{
      events(nil);
    });
  };

  self.listenerRegistration = [_firestore addSnapshotsInSyncListener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FLTTransactionStreamHandler.m

**크기**: 5659 bytes | **라인 수**: 169 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTTransactionStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"

@interface FLTTransactionStreamHandler ()
@property(nonatomic, copy, nonnull) void (^started)(FIRTransaction *);
@property(nonatomic, copy, nonnull) void (^ended)(void);
@property(strong) dispatch_semaphore_t semaphore;
@property PigeonTransactionResult resultType;
@property NSArray<PigeonTransactionCommand *> *commands;

@end

@implementation FLTTransactionStreamHandler {
  NSString *_transactionId;
}

- (instancetype)initWithId:(NSString *)transactionId
                 firestore:(FIRFirestore *)firestore
                   timeout:(nonnull NSNumber *)timeout
               maxAttempts:(nonnull NSNumber *)maxAttempts
                   started:(void (^)(FIRTransaction *))startedListener
                     ended:(void (^)(void))endedListener {
  self = [super init];
  if (self) {
    _transactionId = transactionId;
    self.firestore = firestore;
    self.maxAttempts = maxAttempts;
    self.timeout = timeout;
    self.started = startedListener;
    self.ended = endedListener;
    self.semaphore = dispatch_semaphore_create(0);
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  __weak FLTTransactionStreamHandler *weakSelf = self;

  id transactionRunBlock = ^id(FIRTransaction *transaction, NSError **pError) {
    FLTTransactionStreamHandler *strongSelf = weakSelf;

    strongSelf.started(transaction);

    dispatch_async(dispatch_get_main_queue(), ^{
      events(
          @{@"appName" : [FLTFirebasePlugin firebaseAppNameFromIosName:self.firestore.app.name]});
    });

    long timedOut = dispatch_semaphore_wait(
        strongSelf.semaphore,
        dispatch_time(DISPATCH_TIME_NOW, [self.timeout integerValue] * NSEC_PER_MSEC));

    if (timedOut) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils
          ErrorCodeAndMessageFromNSError:[NSError
                                             errorWithDomain:FIRFirestoreErrorDomain
                                                        code:FIRFirestoreErrorCodeDeadlineExceeded
                                                    userInfo:@{}]];

      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{
          @"error" : @{
            @"code" : codeAndMessage[0],
            @"message" : codeAndMessage[1],
          }
        });
      });
    }

    if (self.resultType == PigeonTransactionResultFailure) {
      // Do nothing - already handled in Dart land.
      return nil;
    }

    for (PigeonTransactionCommand *command in self.commands) {
      PigeonTransactionType commandType = command.type;
      NSString *documentPath = command.path;
      FIRDocumentReference *reference = [self.firestore documentWithPath:documentPath];

      switch (commandType) {
        case PigeonTransactionTypeDeleteType:
          [transaction deleteDocument:reference];
          break;
        case PigeonTransactionTypeUpdate:
          [transaction updateData:command.data forDocument:reference];
          break;
        case PigeonTransactionTypeSet:
          if ([command.option.merge isEqual:@YES]) {
            [transaction setData:command.data forDocument:reference merge:YES];
          } else if (command.option.mergeFields) {
            [transaction setData:command.data
                     forDocument:reference
                     mergeFields:[FirestorePigeonParser parseFieldPath:command.option.mergeFields]];
          } else {
            [transaction setData:command.data forDocument:reference];
          }
          break;
        default:
          break;
      }
    }

    return nil;
  };

  id transactionCompleteBlock = ^(id transactionResult, NSError *error) {
    FLTTransactionStreamHandler *strongSelf = weakSelf;
    if (error) {
      NSArray *details = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];

      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{
          @"error" : @{
            @"code" : details[0],
            @"message" : details[1],
          }
        });
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{@"complete" : [NSNumber numberWithBool:YES]});
      });
    }

    dispatch_async(dispatch_get_main_queue(), ^{
      events(FlutterEndOfEventStream);
    });

    strongSelf.ended();
  };
  FIRTransactionOptions *options = [[FIRTransactionOptions alloc] init];
  options.maxAttempts = _maxAttempts.integerValue;

  [_firestore runTransactionWithOptions:options
                                  block:transactionRunBlock
                             completion:transactionCompleteBlock];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  dispatch_semaphore_signal(self.semaphore);

  return nil;
}

- (void)receiveTransactionResponse:(PigeonTransactionResult)resultType
                          commands:(NSArray<PigeonTransactionCommand *> *)commands {
  self.resultType = resultType;
  self.commands = commands;

  dispatch_semaphore_signal(self.semaphore);
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FirestoreMessages.g.m

**크기**: 58285 bytes | **라인 수**: 1383 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "FirestoreMessages.g.h"
#import "FLTFirebaseFirestoreReader.h"
#import "FLTFirebaseFirestoreWriter.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

/// An enumeration of document change types.
@implementation DocumentChangeTypeBox
- (instancetype)initWithValue:(DocumentChangeType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// An enumeration of firestore source types.
@implementation SourceBox
- (instancetype)initWithValue:(Source)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// The listener retrieves data and listens to updates from the local Firestore cache only.
/// If the cache is empty, an empty snapshot will be returned.
/// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
///
/// Note that the data might be stale if the cache hasn't synchronized with recent server-side
/// changes.
@implementation ListenSourceBox
- (instancetype)initWithValue:(ListenSource)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation ServerTimestampBehaviorBox
- (instancetype)initWithValue:(ServerTimestampBehavior)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// [AggregateSource] represents the source of data for an [AggregateQuery].
@implementation AggregateSourceBox
- (instancetype)initWithValue:(AggregateSource)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// [PersistenceCacheIndexManagerRequest] represents the request types for the persistence cache
/// index manager.
@implementation PersistenceCacheIndexManagerRequestBox
- (instancetype)initWithValue:(PersistenceCacheIndexManagerRequest)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation PigeonTransactionResultBox
- (instancetype)initWithValue:(PigeonTransactionResult)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation PigeonTransactionTypeBox
- (instancetype)initWithValue:(PigeonTransactionType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation AggregateTypeBox
- (instancetype)initWithValue:(AggregateType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface PigeonFirebaseSettings ()
+ (PigeonFirebaseSettings *)fromList:(NSArray *)list;
+ (nullable PigeonFirebaseSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FirestorePigeonFirebaseApp ()
+ (FirestorePigeonFirebaseApp *)fromList:(NSArray *)list;
+ (nullable FirestorePigeonFirebaseApp *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonSnapshotMetadata ()
+ (PigeonSnapshotMetadata *)fromList:(NSArray *)list;
+ (nullable PigeonSnapshotMetadata *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentSnapshot ()
+ (PigeonDocumentSnapshot *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentSnapshot *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentChange ()
+ (PigeonDocumentChange *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentChange *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonQuerySnapshot ()
+ (PigeonQuerySnapshot *)fromList:(NSArray *)list;
+ (nullable PigeonQuerySnapshot *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonGetOptions ()
+ (PigeonGetOptions *)fromList:(NSArray *)list;
+ (nullable PigeonGetOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentOption ()
+ (PigeonDocumentOption *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentOption *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonTransactionCommand ()
+ (PigeonTransactionCommand *)fromList:(NSArray *)list;
+ (nullable PigeonTransactionCommand *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface DocumentReferenceRequest ()
+ (DocumentReferenceRequest *)fromList:(NSArray *)list;
+ (nullable DocumentReferenceRequest *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonQueryParameters ()
+ (PigeonQueryParameters *)fromList:(NSArray *)list;
+ (nullable PigeonQueryParameters *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AggregateQuery ()
+ (AggregateQuery *)fromList:(NSArray *)list;
+ (nullable AggregateQuery *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AggregateQueryResponse ()
+ (AggregateQueryResponse *)fromList:(NSArray *)list;
+ (nullable AggregateQueryResponse *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation PigeonFirebaseSettings
+ (instancetype)makeWithPersistenceEnabled:(nullable NSNumber *)persistenceEnabled
                                      host:(nullable NSString *)host
                                sslEnabled:(nullable NSNumber *)sslEnabled
                            cacheSizeBytes:(nullable NSNumber *)cacheSizeBytes
                 ignoreUndefinedProperties:(NSNumber *)ignoreUndefinedProperties {
  PigeonFirebaseSettings *pigeonResult = [[PigeonFirebaseSettings alloc] init];
  pigeonResult.persistenceEnabled = persistenceEnabled;
  pigeonResult.host = host;
  pigeonResult.sslEnabled = sslEnabled;
  pigeonResult.cacheSizeBytes = cacheSizeBytes;
  pigeonResult.ignoreUndefinedProperties = ignoreUndefinedProperties;
  return pigeonResult;
}
+ (PigeonFirebaseSettings *)fromList:(NSArray *)list {
  PigeonFirebaseSettings *pigeonResult = [[PigeonFirebaseSettings alloc] init];
  pigeonResult.persistenceEnabled = GetNullableObjectAtIndex(list, 0);
  pigeonResult.host = GetNullableObjectAtIndex(list, 1);
  pigeonResult.sslEnabled = GetNullableObjectAtIndex(list, 2);
  pigeonResult.cacheSizeBytes = GetNullableObjectAtIndex(list, 3);
  pigeonResult.ignoreUndefinedProperties = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.ignoreUndefinedProperties != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonFirebaseSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonFirebaseSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.persistenceEnabled ?: [NSNull null]),
    (self.host ?: [NSNull null]),
    (self.sslEnabled ?: [NSNull null]),
    (self.cacheSizeBytes ?: [NSNull null]),
    (self.ignoreUndefinedProperties ?: [NSNull null]),
  ];
}
@end

@implementation FirestorePigeonFirebaseApp
+ (instancetype)makeWithAppName:(NSString *)appName
                       settings:(PigeonFirebaseSettings *)settings
                    databaseURL:(NSString *)databaseURL {
  FirestorePigeonFirebaseApp *pigeonResult = [[FirestorePigeonFirebaseApp alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.settings = settings;
  pigeonResult.databaseURL = databaseURL;
  return pigeonResult;
}
+ (FirestorePigeonFirebaseApp *)fromList:(NSArray *)list {
  FirestorePigeonFirebaseApp *pigeonResult = [[FirestorePigeonFirebaseApp alloc] init];
  pigeonResult.appName = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.appName != nil, @"");
  pigeonResult.settings =
      [PigeonFirebaseSettings nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.settings != nil, @"");
  pigeonResult.databaseURL = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.databaseURL != nil, @"");
  return pigeonResult;
}
+ (nullable FirestorePigeonFirebaseApp *)nullableFromList:(NSArray *)list {
  return (list) ? [FirestorePigeonFirebaseApp fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.appName ?: [NSNull null]),
    (self.settings ? [self.settings toList] : [NSNull null]),
    (self.databaseURL ?: [NSNull null]),
  ];
}
@end

@implementation PigeonSnapshotMetadata
+ (instancetype)makeWithHasPendingWrites:(NSNumber *)hasPendingWrites
                             isFromCache:(NSNumber *)isFromCache {
  PigeonSnapshotMetadata *pigeonResult = [[PigeonSnapshotMetadata alloc] init];
  pigeonResult.hasPendingWrites = hasPendingWrites;
  pigeonResult.isFromCache = isFromCache;
  return pigeonResult;
}
+ (PigeonSnapshotMetadata *)fromList:(NSArray *)list {
  PigeonSnapshotMetadata *pigeonResult = [[PigeonSnapshotMetadata alloc] init];
  pigeonResult.hasPendingWrites = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.hasPendingWrites != nil, @"");
  pigeonResult.isFromCache = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.isFromCache != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonSnapshotMetadata *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonSnapshotMetadata fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.hasPendingWrites ?: [NSNull null]),
    (self.isFromCache ?: [NSNull null]),
  ];
}
@end

@implementation PigeonDocumentSnapshot
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                    metadata:(PigeonSnapshotMetadata *)metadata {
  PigeonDocumentSnapshot *pigeonResult = [[PigeonDocumentSnapshot alloc] init];
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.metadata = metadata;
  return pigeonResult;
}
+ (PigeonDocumentSnapshot *)fromList:(NSArray *)list {
  PigeonDocumentSnapshot *pigeonResult = [[PigeonDocumentSnapshot alloc] init];
  pigeonResult.path = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  pigeonResult.metadata =
      [PigeonSnapshotMetadata nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSAssert(pigeonResult.metadata != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonDocumentSnapshot *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentSnapshot fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.metadata ? [self.metadata toList] : [NSNull null]),
  ];
}
@end

@implementation PigeonDocumentChange
+ (instancetype)makeWithType:(DocumentChangeType)type
                    document:(PigeonDocumentSnapshot *)document
                    oldIndex:(NSNumber *)oldIndex
                    newIndex:(NSNumber *)newIndex {
  PigeonDocumentChange *pigeonResult = [[PigeonDocumentChange alloc] init];
  pigeonResult.type = type;
  pigeonResult.document = document;
  pigeonResult.oldIndex = oldIndex;
  pigeonResult.index = newIndex;
  return pigeonResult;
}
+ (PigeonDocumentChange *)fromList:(NSArray *)list {
  PigeonDocumentChange *pigeonResult = [[PigeonDocumentChange alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.document =
      [PigeonDocumentSnapshot nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.document != nil, @"");
  pigeonResult.oldIndex = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.oldIndex != nil, @"");
  pigeonResult.index = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.index != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonDocumentChange *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentChange fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.document ? [self.document toList] : [NSNull null]),
    (self.oldIndex ?: [NSNull null]),
    (self.index ?: [NSNull null]),
  ];
}
@end

@implementation PigeonQuerySnapshot
+ (instancetype)makeWithDocuments:(NSArray<PigeonDocumentSnapshot *> *)documents
                  documentChanges:(NSArray<PigeonDocumentChange *> *)documentChanges
                         metadata:(PigeonSnapshotMetadata *)metadata {
  PigeonQuerySnapshot *pigeonResult = [[PigeonQuerySnapshot alloc] init];
  pigeonResult.documents = documents;
  pigeonResult.documentChanges = documentChanges;
  pigeonResult.metadata = metadata;
  return pigeonResult;
}
+ (PigeonQuerySnapshot *)fromList:(NSArray *)list {
  PigeonQuerySnapshot *pigeonResult = [[PigeonQuerySnapshot alloc] init];
  pigeonResult.documents = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.documents != nil, @"");
  pigeonResult.documentChanges = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.documentChanges != nil, @"");
  pigeonResult.metadata =
      [PigeonSnapshotMetadata nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSAssert(pigeonResult.metadata != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonQuerySnapshot *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonQuerySnapshot fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.documents ?: [NSNull null]),
    (self.documentChanges ?: [NSNull null]),
    (self.metadata ? [self.metadata toList] : [NSNull null]),
  ];
}
@end

@implementation PigeonGetOptions
+ (instancetype)makeWithSource:(Source)source
       serverTimestampBehavior:(ServerTimestampBehavior)serverTimestampBehavior {
  PigeonGetOptions *pigeonResult = [[PigeonGetOptions alloc] init];
  pigeonResult.source = source;
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (PigeonGetOptions *)fromList:(NSArray *)list {
  PigeonGetOptions *pigeonResult = [[PigeonGetOptions alloc] init];
  pigeonResult.source = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.serverTimestampBehavior = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable PigeonGetOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonGetOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.source),
    @(self.serverTimestampBehavior),
  ];
}
@end

@implementation PigeonDocumentOption
+ (instancetype)makeWithMerge:(nullable NSNumber *)merge
                  mergeFields:(nullable NSArray<NSArray<NSString *> *> *)mergeFields {
  PigeonDocumentOption *pigeonResult = [[PigeonDocumentOption alloc] init];
  pigeonResult.merge = merge;
  pigeonResult.mergeFields = mergeFields;
  return pigeonResult;
}
+ (PigeonDocumentOption *)fromList:(NSArray *)list {
  PigeonDocumentOption *pigeonResult = [[PigeonDocumentOption alloc] init];
  pigeonResult.merge = GetNullableObjectAtIndex(list, 0);
  pigeonResult.mergeFields = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonDocumentOption *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentOption fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.merge ?: [NSNull null]),
    (self.mergeFields ?: [NSNull null]),
  ];
}
@end

@implementation PigeonTransactionCommand
+ (instancetype)makeWithType:(PigeonTransactionType)type
                        path:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                      option:(nullable PigeonDocumentOption *)option {
  PigeonTransactionCommand *pigeonResult = [[PigeonTransactionCommand alloc] init];
  pigeonResult.type = type;
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.option = option;
  return pigeonResult;
}
+ (PigeonTransactionCommand *)fromList:(NSArray *)list {
  PigeonTransactionCommand *pigeonResult = [[PigeonTransactionCommand alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.path = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  pigeonResult.option = [PigeonDocumentOption nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  return pigeonResult;
}
+ (nullable PigeonTransactionCommand *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonTransactionCommand fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.option ? [self.option toList] : [NSNull null]),
  ];
}
@end

@implementation DocumentReferenceRequest
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<id, id> *)data
                      option:(nullable PigeonDocumentOption *)option
                      source:(nullable SourceBox *)source
     serverTimestampBehavior:(nullable ServerTimestampBehaviorBox *)serverTimestampBehavior {
  DocumentReferenceRequest *pigeonResult = [[DocumentReferenceRequest alloc] init];
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.option = option;
  pigeonResult.source = source;
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (DocumentReferenceRequest *)fromList:(NSArray *)list {
  DocumentReferenceRequest *pigeonResult = [[DocumentReferenceRequest alloc] init];
  pigeonResult.path = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  pigeonResult.option = [PigeonDocumentOption nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSNumber *sourceAsNumber = GetNullableObjectAtIndex(list, 3);
  SourceBox *source =
      sourceAsNumber == nil ? nil : [[SourceBox alloc] initWithValue:[sourceAsNumber integerValue]];
  pigeonResult.source = source;
  NSNumber *serverTimestampBehaviorAsNumber = GetNullableObjectAtIndex(list, 4);
  ServerTimestampBehaviorBox *serverTimestampBehavior =
      serverTimestampBehaviorAsNumber == nil
          ? nil
          : [[ServerTimestampBehaviorBox alloc]
                initWithValue:[serverTimestampBehaviorAsNumber integerValue]];
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (nullable DocumentReferenceRequest *)nullableFromList:(NSArray *)list {
  return (list) ? [DocumentReferenceRequest fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.option ? [self.option toList] : [NSNull null]),
    (self.source == nil ? [NSNull null] : [NSNumber numberWithInteger:self.source.value]),
    (self.serverTimestampBehavior == nil
         ? [NSNull null]
         : [NSNumber numberWithInteger:self.serverTimestampBehavior.value]),
  ];
}
@end

@implementation PigeonQueryParameters
+ (instancetype)makeWithWhere:(nullable NSArray<NSArray<id> *> *)where
                      orderBy:(nullable NSArray<NSArray<id> *> *)orderBy
                        limit:(nullable NSNumber *)limit
                  limitToLast:(nullable NSNumber *)limitToLast
                      startAt:(nullable NSArray<id> *)startAt
                   startAfter:(nullable NSArray<id> *)startAfter
                        endAt:(nullable NSArray<id> *)endAt
                    endBefore:(nullable NSArray<id> *)endBefore
                      filters:(nullable NSDictionary<NSString *, id> *)filters {
  PigeonQueryParameters *pigeonResult = [[PigeonQueryParameters alloc] init];
  pigeonResult.where = where;
  pigeonResult.orderBy = orderBy;
  pigeonResult.limit = limit;
  pigeonResult.limitToLast = limitToLast;
  pigeonResult.startAt = startAt;
  pigeonResult.startAfter = startAfter;
  pigeonResult.endAt = endAt;
  pigeonResult.endBefore = endBefore;
  pigeonResult.filters = filters;
  return pigeonResult;
}
+ (PigeonQueryParameters *)fromList:(NSArray *)list {
  PigeonQueryParameters *pigeonResult = [[PigeonQueryParameters alloc] init];
  pigeonResult.where = GetNullableObjectAtIndex(list, 0);
  pigeonResult.orderBy = GetNullableObjectAtIndex(list, 1);
  pigeonResult.limit = GetNullableObjectAtIndex(list, 2);
  pigeonResult.limitToLast = GetNullableObjectAtIndex(list, 3);
  pigeonResult.startAt = GetNullableObjectAtIndex(list, 4);
  pigeonResult.startAfter = GetNullableObjectAtIndex(list, 5);
  pigeonResult.endAt = GetNullableObjectAtIndex(list, 6);
  pigeonResult.endBefore = GetNullableObjectAtIndex(list, 7);
  pigeonResult.filters = GetNullableObjectAtIndex(list, 8);
  return pigeonResult;
}
+ (nullable PigeonQueryParameters *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonQueryParameters fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.where ?: [NSNull null]),
    (self.orderBy ?: [NSNull null]),
    (self.limit ?: [NSNull null]),
    (self.limitToLast ?: [NSNull null]),
    (self.startAt ?: [NSNull null]),
    (self.startAfter ?: [NSNull null]),
    (self.endAt ?: [NSNull null]),
    (self.endBefore ?: [NSNull null]),
    (self.filters ?: [NSNull null]),
  ];
}
@end

@implementation AggregateQuery
+ (instancetype)makeWithType:(AggregateType)type field:(nullable NSString *)field {
  AggregateQuery *pigeonResult = [[AggregateQuery alloc] init];
  pigeonResult.type = type;
  pigeonResult.field = field;
  return pigeonResult;
}
+ (AggregateQuery *)fromList:(NSArray *)list {
  AggregateQuery *pigeonResult = [[AggregateQuery alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.field = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable AggregateQuery *)nullableFromList:(NSArray *)list {
  return (list) ? [AggregateQuery fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.field ?: [NSNull null]),
  ];
}
@end

@implementation AggregateQueryResponse
+ (instancetype)makeWithType:(AggregateType)type
                       field:(nullable NSString *)field
                       value:(nullable NSNumber *)value {
  AggregateQueryResponse *pigeonResult = [[AggregateQueryResponse alloc] init];
  pigeonResult.type = type;
  pigeonResult.field = field;
  pigeonResult.value = value;
  return pigeonResult;
}
+ (AggregateQueryResponse *)fromList:(NSArray *)list {
  AggregateQueryResponse *pigeonResult = [[AggregateQueryResponse alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.field = GetNullableObjectAtIndex(list, 1);
  pigeonResult.value = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable AggregateQueryResponse *)nullableFromList:(NSArray *)list {
  return (list) ? [AggregateQueryResponse fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.field ?: [NSNull null]),
    (self.value ?: [NSNull null]),
  ];
}
@end

@interface FirebaseFirestoreHostApiCodecReader : FLTFirebaseFirestoreReader
@end
@implementation FirebaseFirestoreHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AggregateQuery fromList:[self readValue]];
    case 129:
      return [AggregateQueryResponse fromList:[self readValue]];
    case 130:
      return [DocumentReferenceRequest fromList:[self readValue]];
    case 131:
      return [FirestorePigeonFirebaseApp fromList:[self readValue]];
    case 132:
      return [PigeonDocumentChange fromList:[self readValue]];
    case 133:
      return [PigeonDocumentOption fromList:[self readValue]];
    case 134:
      return [PigeonDocumentSnapshot fromList:[self readValue]];
    case 135:
      return [PigeonFirebaseSettings fromList:[self readValue]];
    case 136:
      return [PigeonGetOptions fromList:[self readValue]];
    case 137:
      return [PigeonQueryParameters fromList:[self readValue]];
    case 138:
      return [PigeonQuerySnapshot fromList:[self readValue]];
    case 139:
      return [PigeonSnapshotMetadata fromList:[self readValue]];
    case 140:
      return [PigeonTransactionCommand fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseFirestoreHostApiCodecWriter : FLTFirebaseFirestoreWriter
@end
@implementation FirebaseFirestoreHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AggregateQuery class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[AggregateQueryResponse class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[DocumentReferenceRequest class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FirestorePigeonFirebaseApp class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentChange class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentOption class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentSnapshot class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseSettings class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonGetOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonQueryParameters class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonQuerySnapshot class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSnapshotMetadata class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTransactionCommand class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseFirestoreHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseFirestoreHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseFirestoreHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseFirestoreHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseFirestoreHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseFirestoreHostApiCodecReaderWriter *readerWriter =
        [[FirebaseFirestoreHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FirebaseFirestoreHostApiSetup(id<FlutterBinaryMessenger> binaryMessenger,
                                   NSObject<FirebaseFirestoreHostApi> *api) {
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.loadBundle"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadBundleApp:bundle:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(loadBundleApp:bundle:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        FlutterStandardTypedData *arg_bundle = GetNullableObjectAtIndex(args, 1);
        [api loadBundleApp:arg_app
                    bundle:arg_bundle
                completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.namedQueryGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(namedQueryGetApp:name:options:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(namedQueryGetApp:name:options:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_name = GetNullableObjectAtIndex(args, 1);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 2);
        [api namedQueryGetApp:arg_app
                         name:arg_name
                      options:arg_options
                   completion:^(PigeonQuerySnapshot *_Nullable output,
                                FlutterError *_Nullable error) {
                     callback(wrapResult(output, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.clearPersistence"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearPersistenceApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(clearPersistenceApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api clearPersistenceApp:arg_app
                      completion:^(FlutterError *_Nullable error) {
                        callback(wrapResult(nil, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.disableNetwork"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(disableNetworkApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(disableNetworkApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api disableNetworkApp:arg_app
                    completion:^(FlutterError *_Nullable error) {
                      callback(wrapResult(nil, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.enableNetwork"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enableNetworkApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(enableNetworkApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api enableNetworkApp:arg_app
                   completion:^(FlutterError *_Nullable error) {
                     callback(wrapResult(nil, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.terminate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(terminateApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(terminateApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api terminateApp:arg_app
               completion:^(FlutterError *_Nullable error) {
                 callback(wrapResult(nil, error));
               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.waitForPendingWrites"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForPendingWritesApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(waitForPendingWritesApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api waitForPendingWritesApp:arg_app
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.setIndexConfiguration"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setIndexConfigurationApp:
                                                        indexConfiguration:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(setIndexConfigurationApp:indexConfiguration:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_indexConfiguration = GetNullableObjectAtIndex(args, 1);
        [api setIndexConfigurationApp:arg_app
                   indexConfiguration:arg_indexConfiguration
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.setLoggingEnabled"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLoggingEnabledLoggingEnabled:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(setLoggingEnabledLoggingEnabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_loggingEnabled = GetNullableObjectAtIndex(args, 0);
        [api setLoggingEnabledLoggingEnabled:arg_loggingEnabled
                                  completion:^(FlutterError *_Nullable error) {
                                    callback(wrapResult(nil, error));
                                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.snapshotsInSyncSetup"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(snapshotsInSyncSetupApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(snapshotsInSyncSetupApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api snapshotsInSyncSetupApp:arg_app
                          completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionCreate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(transactionCreateApp:
                                                               timeout:maxAttempts:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionCreateApp:timeout:maxAttempts:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_timeout = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_maxAttempts = GetNullableObjectAtIndex(args, 2);
        [api transactionCreateApp:arg_app
                          timeout:arg_timeout
                      maxAttempts:arg_maxAttempts
                       completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionStoreResult"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (transactionStoreResultTransactionId:resultType:commands:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionStoreResultTransactionId:resultType:commands:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transactionId = GetNullableObjectAtIndex(args, 0);
        PigeonTransactionResult arg_resultType = [GetNullableObjectAtIndex(args, 1) integerValue];
        NSArray<PigeonTransactionCommand *> *arg_commands = GetNullableObjectAtIndex(args, 2);
        [api transactionStoreResultTransactionId:arg_transactionId
                                      resultType:arg_resultType
                                        commands:arg_commands
                                      completion:^(FlutterError *_Nullable error) {
                                        callback(wrapResult(nil, error));
                                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(transactionGetApp:
                                                      transactionId:path:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionGetApp:transactionId:path:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transactionId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_path = GetNullableObjectAtIndex(args, 2);
        [api transactionGetApp:arg_app
                 transactionId:arg_transactionId
                          path:arg_path
                    completion:^(PigeonDocumentSnapshot *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceSet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceSetApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceSetApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceSetApp:arg_app
                             request:arg_request
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceUpdate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceUpdateApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceUpdateApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceUpdateApp:arg_app
                                request:arg_request
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceGetApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceGetApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceGetApp:arg_app
                             request:arg_request
                          completion:^(PigeonDocumentSnapshot *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceDelete"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceDeleteApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceDeleteApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceDeleteApp:arg_app
                                request:arg_request
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.queryGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (queryGetApp:path:isCollectionGroup:parameters:options:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(queryGetApp:path:isCollectionGroup:parameters:options:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 2);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 3);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 4);
        [api queryGetApp:arg_app
                         path:arg_path
            isCollectionGroup:arg_isCollectionGroup
                   parameters:arg_parameters
                      options:arg_options
                   completion:^(PigeonQuerySnapshot *_Nullable output,
                                FlutterError *_Nullable error) {
                     callback(wrapResult(output, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.aggregateQuery"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (aggregateQueryApp:
                                   path:parameters:source:queries:isCollectionGroup:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(aggregateQueryApp:path:parameters:source:queries:isCollectionGroup:"
                @"completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 2);
        AggregateSource arg_source = [GetNullableObjectAtIndex(args, 3) integerValue];
        NSArray<AggregateQuery *> *arg_queries = GetNullableObjectAtIndex(args, 4);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 5);
        [api aggregateQueryApp:arg_app
                          path:arg_path
                    parameters:arg_parameters
                        source:arg_source
                       queries:arg_queries
             isCollectionGroup:arg_isCollectionGroup
                    completion:^(NSArray<AggregateQueryResponse *> *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.writeBatchCommit"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(writeBatchCommitApp:writes:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(writeBatchCommitApp:writes:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSArray<PigeonTransactionCommand *> *arg_writes = GetNullableObjectAtIndex(args, 1);
        [api writeBatchCommitApp:arg_app
                          writes:arg_writes
                      completion:^(FlutterError *_Nullable error) {
                        callback(wrapResult(nil, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.querySnapshot"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (querySnapshotApp:
                                  path:isCollectionGroup:parameters:options:includeMetadataChanges
                                      :source:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(querySnapshotApp:path:isCollectionGroup:parameters:options:"
                @"includeMetadataChanges:source:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 2);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 3);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 4);
        NSNumber *arg_includeMetadataChanges = GetNullableObjectAtIndex(args, 5);
        ListenSource arg_source = [GetNullableObjectAtIndex(args, 6) integerValue];
        [api querySnapshotApp:arg_app
                              path:arg_path
                 isCollectionGroup:arg_isCollectionGroup
                        parameters:arg_parameters
                           options:arg_options
            includeMetadataChanges:arg_includeMetadataChanges
                            source:arg_source
                        completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceSnapshot"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (documentReferenceSnapshotApp:
                                        parameters:includeMetadataChanges:source:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceSnapshotApp:parameters:includeMetadataChanges:source:"
                @"completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_parameters = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_includeMetadataChanges = GetNullableObjectAtIndex(args, 2);
        ListenSource arg_source = [GetNullableObjectAtIndex(args, 3) integerValue];
        [api documentReferenceSnapshotApp:arg_app
                               parameters:arg_parameters
                   includeMetadataChanges:arg_includeMetadataChanges
                                   source:arg_source
                               completion:^(NSString *_Nullable output,
                                            FlutterError *_Nullable error) {
                                 callback(wrapResult(output, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.persistenceCacheIndexManagerRequest"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (persistenceCacheIndexManagerRequestApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(persistenceCacheIndexManagerRequestApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PersistenceCacheIndexManagerRequest arg_request =
            [GetNullableObjectAtIndex(args, 1) integerValue];
        [api persistenceCacheIndexManagerRequestApp:arg_app
                                            request:arg_request
                                         completion:^(FlutterError *_Nullable error) {
                                           callback(wrapResult(nil, error));
                                         }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Sources/cloud_firestore/FirestorePigeonParser.m

**크기**: 13122 bytes | **라인 수**: 313 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#import "FirestorePigeonParser.h"
#import <Foundation/Foundation.h>

@implementation FirestorePigeonParser

+ (FIRFilter *_Nonnull)filterFromJson:(NSDictionary<NSString *, id> *_Nullable)map {
  if (map[@"fieldPath"]) {
    // Deserialize a FilterQuery
    NSString *op = map[@"op"];
    FIRFieldPath *fieldPath = map[@"fieldPath"];
    id value = map[@"value"];

    // All the operators from Firebase
    if ([op isEqualToString:@"=="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isEqualTo:value];
    } else if ([op isEqualToString:@"!="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isNotEqualTo:value];
    } else if ([op isEqualToString:@"<"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThan:value];
    } else if ([op isEqualToString:@"<="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
    } else if ([op isEqualToString:@">"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThan:value];
    } else if ([op isEqualToString:@">="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
    } else if ([op isEqualToString:@"array-contains"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContains:value];
    } else if ([op isEqualToString:@"array-contains-any"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContainsAny:value];
    } else if ([op isEqualToString:@"in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath in:value];
    } else if ([op isEqualToString:@"not-in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath notIn:value];
    } else {
      @throw [NSException exceptionWithName:@"InvalidOperator"
                                     reason:@"Invalid operator"
                                   userInfo:nil];
    }
  }
  // Deserialize a FilterOperator
  NSString *op = map[@"op"];
  NSArray<NSDictionary<NSString *, id> *> *queries = map[@"queries"];

  // Map queries recursively
  NSMutableArray<FIRFilter *> *parsedFilters = [NSMutableArray array];
  for (NSDictionary<NSString *, id> *query in queries) {
    [parsedFilters addObject:[self filterFromJson:query]];
  }

  if ([op isEqualToString:@"OR"]) {
    return [FIRFilter orFilterWithFilters:parsedFilters];
  } else if ([op isEqualToString:@"AND"]) {
    return [FIRFilter andFilterWithFilters:parsedFilters];
  }

  @throw [NSException exceptionWithName:@"InvalidOperator" reason:@"Invalid operator" userInfo:nil];
}

+ (FIRQuery *_Nonnull)parseQueryWithParameters:(nonnull PigeonQueryParameters *)parameters
                                     firestore:(nonnull FIRFirestore *)firestore
                                          path:(nonnull NSString *)path
                             isCollectionGroup:(Boolean)isCollectionGroup {
  @try {
    FIRQuery *query;

    NSArray *whereConditions = parameters.where;

    if (isCollectionGroup) {
      query = [firestore collectionGroupWithID:path];
    } else {
      query = (FIRQuery *)[firestore collectionWithPath:path];
    }

    BOOL isFilterQuery = parameters.filters != nil;
    if (isFilterQuery) {
      FIRFilter *filter = [FirestorePigeonParser filterFromJson:parameters.filters];
      query = [query queryWhereFilter:filter];
    }

    // Filters
    for (id item in whereConditions) {
      NSArray *condition = item;
      FIRFieldPath *fieldPath = (FIRFieldPath *)condition[0];
      NSString *operator= condition[1];
      id value = condition[2];
          if ([operator isEqualToString:@"=="]) {
            query = [query queryWhereFieldPath:fieldPath isEqualTo:value];
          } else if ([operator isEqualToString:@"!="]) {
            query = [query queryWhereFieldPath:fieldPath isNotEqualTo:value];
          } else if ([operator isEqualToString:@"<"]) {
            query = [query queryWhereFieldPath:fieldPath isLessThan:value];
          } else if ([operator isEqualToString:@"<="]) {
            query = [query queryWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
          } else if ([operator isEqualToString:@">"]) {
            query = [query queryWhereFieldPath:fieldPath isGreaterThan:value];
          } else if ([operator isEqualToString:@">="]) {
            query = [query queryWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
          } else if ([operator isEqualToString:@"array-contains"]) {
            query = [query queryWhereFieldPath:fieldPath arrayContains:value];
          } else if ([operator isEqualToString:@"array-contains-any"]) {
            query = [query queryWhereFieldPath:fieldPath arrayContainsAny:value];
          } else if ([operator isEqualToString:@"in"]) {
            query = [query queryWhereFieldPath:fieldPath in:value];
          } else if ([operator isEqualToString:@"not-in"]) {
            query = [query queryWhereFieldPath:fieldPath notIn:value];
          } else {
            NSLog(
                @"FLTFirebaseFirestore: An invalid query operator %@ was received but not handled.",
                operator);
          }
    }

    // Limit
    id limit = parameters.limit;
    if (limit) {
      query = [query queryLimitedTo:((NSNumber *)limit).intValue];
    }

    // Limit To Last
    id limitToLast = parameters.limitToLast;
    if (limitToLast) {
      query = [query queryLimitedToLast:((NSNumber *)limitToLast).intValue];
    }

    // Ordering
    NSArray *orderBy = parameters.orderBy;
    if (!orderBy) {
      // We return early if no ordering set as cursor queries below require at least one orderBy
      // set
      return query;
    }

    for (NSArray *orderByParameters in orderBy) {
      FIRFieldPath *fieldPath = (FIRFieldPath *)orderByParameters[0];
      NSNumber *descending = orderByParameters[1];
      query = [query queryOrderedByFieldPath:fieldPath descending:[descending boolValue]];
    }

    // Start At
    id startAt = parameters.startAt;
    if (startAt) query = [query queryStartingAtValues:(NSArray *)startAt];
    // Start After
    id startAfter = parameters.startAfter;
    if (startAfter) query = [query queryStartingAfterValues:(NSArray *)startAfter];
    // End At
    id endAt = parameters.endAt;
    if (endAt) query = [query queryEndingAtValues:(NSArray *)endAt];
    // End Before
    id endBefore = parameters.endBefore;
    if (endBefore) query = [query queryEndingBeforeValues:(NSArray *)endBefore];

    return query;
  } @catch (NSException *exception) {
    NSLog(@"An error occurred while parsing query arguments, this is most likely an error with "
          @"this SDK. %@",
          [exception callStackSymbols]);
    return nil;
  }
}

+ (FIRFirestoreSource)parseSource:(Source)source {
  switch (source) {
    case SourceServerAndCache:
      return FIRFirestoreSourceDefault;
    case SourceServer:
      return FIRFirestoreSourceServer;
    case SourceCache:
      return FIRFirestoreSourceCache;
    default:
      @throw [NSException exceptionWithName:@"Invalid Source"
                                     reason:@"This source is not supported by the SDK"
                                   userInfo:nil];
  }
}

+ (NSArray<FIRFieldPath *> *_Nonnull)parseFieldPath:
    (NSArray<NSArray<NSString *> *> *_Nonnull)fieldPaths {
  NSMutableArray<FIRFieldPath *> *paths = [NSMutableArray arrayWithCapacity:[fieldPaths count]];
  for (NSArray<NSString *> *fieldPath in fieldPaths) {
    FIRFieldPath *parsed = [[FIRFieldPath alloc] initWithFields:fieldPath];
    [paths addObject:parsed];
  }
  return [NSArray arrayWithArray:paths];
}

+ (FIRServerTimestampBehavior)parseServerTimestampBehavior:
    (ServerTimestampBehavior)serverTimestampBehavior {
  switch (serverTimestampBehavior) {
    case ServerTimestampBehaviorNone:
      return FIRServerTimestampBehaviorNone;
    case ServerTimestampBehaviorEstimate:
      return FIRServerTimestampBehaviorEstimate;
    case ServerTimestampBehaviorPrevious:
      return FIRServerTimestampBehaviorPrevious;
    default:
      @throw [NSException
          exceptionWithName:@"Invalid Server Timestamp Behavior"
                     reason:@"This Server Timestamp Behavior is not supported by the SDK"
                   userInfo:nil];
  }
}

+ (FIRListenSource)parseListenSource:(ListenSource)source {
  switch (source) {
    case ListenSourceDefaultSource:
      return FIRListenSourceDefault;
    case ListenSourceCache:
      return FIRListenSourceCache;
    default:
      @throw
          [NSException exceptionWithName:@"Invalid ListenSource"
                                  reason:@"This ListenSource Behavior is not supported by the SDK"
                                userInfo:nil];
  }
}

+ (PigeonSnapshotMetadata *_Nonnull)toPigeonSnapshotMetadata:
    (FIRSnapshotMetadata *_Nonnull)snapshotMetadata {
  return [PigeonSnapshotMetadata
      makeWithHasPendingWrites:[NSNumber numberWithBool:snapshotMetadata.hasPendingWrites]
                   isFromCache:[NSNumber numberWithBool:snapshotMetadata.isFromCache]];
}

+ (PigeonDocumentSnapshot *_Nonnull)
    toPigeonDocumentSnapshot:(FIRDocumentSnapshot *_Nonnull)documentSnapshot
     serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior {
  return [PigeonDocumentSnapshot
      makeWithPath:documentSnapshot.reference.path
              data:[documentSnapshot dataWithServerTimestampBehavior:serverTimestampBehavior]
          metadata:[FirestorePigeonParser toPigeonSnapshotMetadata:documentSnapshot.metadata]];
}

+ (DocumentChangeType)toPigeonDocumentChangeType:(FIRDocumentChangeType)documentChangeType {
  switch (documentChangeType) {
    case FIRDocumentChangeTypeAdded:
      return DocumentChangeTypeAdded;
    case FIRDocumentChangeTypeModified:
      return DocumentChangeTypeModified;
    case FIRDocumentChangeTypeRemoved:
      return DocumentChangeTypeRemoved;
    default:
      @throw [NSException exceptionWithName:@"InvalidDocumentChangeType"
                                     reason:@"Invalid document change type"
                                   userInfo:nil];
  }
}

+ (PigeonDocumentChange *_Nonnull)toPigeonDocumentChange:(FIRDocumentChange *_Nonnull)documentChange
                                 serverTimestampBehavior:
                                     (FIRServerTimestampBehavior)serverTimestampBehavior {
  NSNumber *oldIndex;
  NSNumber *newIndex;

  // Note the Firestore C++ SDK here returns a maxed UInt that is != NSUIntegerMax, so we make one
  // ourselves so we can convert to -1 for Dart.
  NSUInteger MAX_VAL = (NSUInteger)[@(-1) integerValue];

  if (documentChange.newIndex == NSNotFound || documentChange.newIndex == 4294967295 ||
      documentChange.newIndex == MAX_VAL) {
    newIndex = @([@(-1) intValue]);
  } else {
    newIndex = @([@(documentChange.newIndex) intValue]);
  }

  if (documentChange.oldIndex == NSNotFound || documentChange.oldIndex == 4294967295 ||
      documentChange.oldIndex == MAX_VAL) {
    oldIndex = @([@(-1) intValue]);
  } else {
    oldIndex = @([@(documentChange.oldIndex) intValue]);
  }

  return [PigeonDocumentChange
      makeWithType:[FirestorePigeonParser toPigeonDocumentChangeType:documentChange.type]
          document:[FirestorePigeonParser toPigeonDocumentSnapshot:documentChange.document
                                           serverTimestampBehavior:serverTimestampBehavior]
          oldIndex:oldIndex
          newIndex:newIndex];
}

+ (NSArray<PigeonDocumentChange *> *_Nonnull)
    toPigeonDocumentChanges:(NSArray<FIRDocumentChange *> *_Nonnull)documentChanges
    serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior {
  NSMutableArray *pigeonDocumentChanges = [NSMutableArray array];
  for (FIRDocumentChange *documentChange in documentChanges) {
    [pigeonDocumentChanges
        addObject:[FirestorePigeonParser toPigeonDocumentChange:documentChange
                                        serverTimestampBehavior:serverTimestampBehavior]];
  }
  return pigeonDocumentChanges;
}

+ (PigeonQuerySnapshot *_Nonnull)toPigeonQuerySnapshot:(FIRQuerySnapshot *_Nonnull)querySnaphot
                               serverTimestampBehavior:
                                   (FIRServerTimestampBehavior)serverTimestampBehavior {
  NSMutableArray *documentSnapshots = [NSMutableArray array];
  for (FIRDocumentSnapshot *documentSnapshot in querySnaphot.documents) {
    [documentSnapshots
        addObject:[FirestorePigeonParser toPigeonDocumentSnapshot:documentSnapshot
                                          serverTimestampBehavior:serverTimestampBehavior]];
  }
  return [PigeonQuerySnapshot
      makeWithDocuments:documentSnapshots
        documentChanges:[FirestorePigeonParser toPigeonDocumentChanges:querySnaphot.documentChanges
                                               serverTimestampBehavior:serverTimestampBehavior]
               metadata:[FirestorePigeonParser toPigeonSnapshotMetadata:querySnaphot.metadata]];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/cloud_firestore/Package.swift

**크기**: 4258 bytes | **라인 수**: 117 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let firestoreDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    firestoreDirectory,
    "..",
    "generated_firebase_sdk_version.txt",
  ])
  do {
    let version = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
      .trimmingCharacters(in: .whitespacesAndNewlines)
    return version
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing generated_firebase_sdk_version.txt: \(error)")
  }
}

func loadPubspecVersions() throws -> (packageVersion: String, firebaseCoreVersion: String) {
  let pubspecPath = NSString.path(withComponents: [firestoreDirectory, "..", "..", "pubspec.yaml"])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    let lines = yamlString.split(separator: "\n")

    guard let packageVersionLine = lines.first(where: { $0.starts(with: "version:") }) else {
      throw ConfigurationError.invalidFormat("No package version line found in pubspec.yaml")
    }
    var packageVersion = packageVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
      .replacingOccurrences(of: "+", with: "-")
    packageVersion = packageVersion.replacingOccurrences(of: "^", with: "")

    guard let firebaseCoreVersionLine = lines.first(where: { $0.contains("firebase_core:") }) else {
      throw ConfigurationError
        .invalidFormat("No firebase_core dependency version line found in pubspec.yaml")
    }
    var firebaseCoreVersion = firebaseCoreVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
    firebaseCoreVersion = firebaseCoreVersion.replacingOccurrences(of: "^", with: "")

    return (packageVersion, firebaseCoreVersion)
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

let library_version: String
let firebase_sdk_version_string: String
let firebase_core_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version = try loadPubspecVersions().packageVersion
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
  firebase_core_version_string = try loadPubspecVersions().firebaseCoreVersion
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

guard let shared_spm_version = Version("\(firebase_core_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(firebase_core_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "cloud_firestore",
  platforms: [
    .iOS("15.0"),
  ],
  products: [
    .library(name: "cloud-firestore", targets: ["cloud_firestore"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "cloud_firestore",
      dependencies: [
        .product(name: "FirebaseFirestore", package: "firebase-ios-sdk"),
        // Wrapper dependency
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/cloud_firestore/Private"),
        .headerSearchPath("include/cloud_firestore/Public"),
        .define("LIBRARY_VERSION", to: "\"\(library_version)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-fst\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/ios/generated_firebase_sdk_version.txt

**크기**: 6 bytes | **라인 수**: 1 | **타입**: text

```
12.2.0
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/utils/codec_utility.dart

**크기**: 3513 bytes | **라인 수**: 124 | **타입**: text

```
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../../cloud_firestore.dart';

// ignore: do_not_use_environment
const kIsWasm = bool.fromEnvironment('dart.library.js_interop') &&
    // html package is not available in wasm
    // ignore: do_not_use_environment
    !bool.fromEnvironment('dart.library.html');

class _CodecUtility {
  static Map<String, dynamic>? replaceValueWithDelegatesInMap(
    Map<dynamic, dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    Map<String, dynamic> output = Map.from(data);
    output.updateAll((_, value) => valueEncode(value));
    return output;
  }

  static Map<FieldPath, dynamic>? replaceValueWithDelegatesInMapFieldPath(
    Map<Object, dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    Map<FieldPath, dynamic> output = <FieldPath, dynamic>{};
    data.forEach((key, value) {
      if (key is FieldPath) {
        output[key] = valueEncode(value);
      } else if (key is String) {
        output[FieldPath.fromString(key)] = valueEncode(value);
      } else {
        throw StateError(
          'Invalid key type for map. Expected String or FieldPath, but got $key: ${key.runtimeType}.',
        );
      }
    });
    return output;
  }

  static List<dynamic>? replaceValueWithDelegatesInArray(
    Iterable<dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    return List.from(data).map(valueEncode).toList();
  }

  static Map<String, dynamic>? replaceDelegatesWithValueInMap(
    Map<dynamic, dynamic>? data,
    FirebaseFirestore firestore,
  ) {
    if (data == null) {
      return null;
    }
    Map<String, dynamic> output = Map.from(data);
    output.updateAll((_, value) => valueDecode(value, firestore));
    return output;
  }

  static List<dynamic>? replaceDelegatesWithValueInArray(
    List<dynamic>? data,
    FirebaseFirestore firestore,
  ) {
    if (data == null) {
      return null;
    }
    return List.from(data)
        .map((value) => valueDecode(value, firestore))
        .toList();
  }

  static dynamic valueEncode(dynamic value) {
    if (value is DocumentReference) {
      return value._delegate;
    } else if (value is Iterable) {
      return replaceValueWithDelegatesInArray(value);
    } else if (value is Map<dynamic, dynamic>) {
      return replaceValueWithDelegatesInMap(value);
    }
    return value;
  }

  static dynamic valueDecode(dynamic value, FirebaseFirestore firestore) {
    if (value is DocumentReferencePlatform) {
      return _JsonDocumentReference(firestore, value);
    } else if (value is List) {
      return replaceDelegatesWithValueInArray(value, firestore);
    } else if (value is Map<dynamic, dynamic>) {
      return replaceDelegatesWithValueInMap(value, firestore);
    } else if (value is num) {
      return convertNum(value);
    }
    return value;
  }
}

num convertNum(num input) {
  // This workaround is only needed for WASM
  if (!kIsWasm) {
    return input;
  }
  // Can fail for NaN, Infinity, etc.
  try {
    if (input is int) {
      return input; // It's already an int
    } else if (input is double) {
      if (input == input.toInt()) {
        return input.toInt(); // Convert to int if no fractional part
      }
    }

    return input; // Return as double if fractional part exists
  } catch (_) {
    return input;
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/aggregate_query.dart

**크기**: 1233 bytes | **라인 수**: 33 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// [AggregateQuery] represents the data at a particular location for retrieving metadata
/// without retrieving the actual documents.
class AggregateQuery {
  AggregateQuery._(this._delegate, this.query) {
    AggregateQueryPlatform.verify(_delegate);
  }

  /// [Query] represents the query over the data at a particular location used by the [AggregateQuery] to
  /// retrieve the metadata.
  final Query query;

  final AggregateQueryPlatform _delegate;

  /// Returns an [AggregateQuerySnapshot] with the count of the documents that match the query.
  Future<AggregateQuerySnapshot> get({
    AggregateSource source = AggregateSource.server,
  }) async {
    return AggregateQuerySnapshot._(await _delegate.get(source: source), query);
  }

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  AggregateQuery count() {
    return AggregateQuery._(_delegate.count(), query);
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/aggregate_query_snapshot.dart

**크기**: 1081 bytes | **라인 수**: 27 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// [AggregateQuerySnapshot] represents a response to an [AggregateQuery] request.
class AggregateQuerySnapshot {
  AggregateQuerySnapshot._(this._delegate, this.query) {
    AggregateQuerySnapshotPlatform.verifyExtends(_delegate);
  }
  final AggregateQuerySnapshotPlatform _delegate;

  /// [Query] represents the query over the data at a particular location used by the [AggregateQuery] to
  /// retrieve the metadata.
  final Query query;

  /// Returns the count of the documents that match the query.
  int? get count => _delegate.count;

  /// Returns the sum of the values of the documents that match the query.
  double? getSum(String field) => _delegate.getSum(field);

  /// Returns the average of the values of the documents that match the query.
  double? getAverage(String field) => _delegate.getAverage(field);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/collection_reference.dart

**크기**: 7434 bytes | **라인 수**: 236 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

@immutable
// `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
abstract class CollectionReference<T extends Object?> implements Query<T> {
  /// Returns the ID of the referenced collection.
  String get id;

  /// Returns the parent [DocumentReference] of this collection or `null`.
  ///
  /// If this collection is a root collection, `null` is returned.
  // This always returns a DocumentReference even when using withConverter
  // because we do not know what is the correct type for the parent doc. @override
  DocumentReference<Map<String, dynamic>>? get parent;

  /// A string containing the slash-separated path to this  CollectionReference
  /// (relative to the root of the database).
  String get path;

  /// Returns a `DocumentReference` with an auto-generated ID, after
  /// populating it with provided [data].
  ///
  /// The unique key generated is prefixed with a client-generated timestamp
  /// so that the resulting list will be chronologically-sorted.
  Future<DocumentReference<T>> add(T data);

  /// {@template cloud_firestore.collection_reference.doc}
  /// Returns a `DocumentReference` with the provided path.
  ///
  /// If no [path] is provided, an auto-generated ID is used.
  ///
  /// The unique key generated is prefixed with a client-generated timestamp
  /// so that the resulting list will be chronologically-sorted.
  /// {@endtemplate}
  DocumentReference<T> doc([String? path]);

  /// Transforms a [CollectionReference] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final modelsRef = FirebaseFirestore
  ///     .instance
  ///     .collection('models')
  ///     .withConverter<Model>(
  ///       fromFirestore: (snapshot, _) => Model.fromJson(snapshot.data()!),
  ///       toFirestore: (model, _) => model.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   // Writes now take a Model as parameter instead of a Map
  ///   await modelsRef.add(Model());
  ///
  ///   // Reads now return a Model instead of a Map
  ///   final Model model = await modelsRef.doc('123').get().then((s) => s.data());
  /// }
  /// ```
  // `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });
}

/// A [CollectionReference] object can be used for adding documents, getting
/// [DocumentReference]s, and querying for documents (using the methods
/// inherited from [Query]).
@immutable
class _JsonCollectionReference extends _JsonQuery
    implements CollectionReference<Map<String, dynamic>> {
  _JsonCollectionReference(
    FirebaseFirestore firestore,
    CollectionReferencePlatform _delegate,
  ) : super(firestore, _delegate);

  @override
  CollectionReferencePlatform get _delegate =>
      super._delegate as CollectionReferencePlatform;

  @override
  String get id => _delegate.id;

  @override
  DocumentReference<Map<String, dynamic>>? get parent {
    DocumentReferencePlatform? _documentReferencePlatform = _delegate.parent;

    // Only subcollections have a parent
    if (_documentReferencePlatform == null) {
      return null;
    }

    return _JsonDocumentReference(firestore, _documentReferencePlatform);
  }

  @override
  String get path => _delegate.path;

  @override
  Future<DocumentReference<Map<String, dynamic>>> add(
    Map<String, dynamic> data,
  ) async {
    final newDocument = doc();
    await newDocument.set(data);
    return newDocument;
  }

  @override
  DocumentReference<Map<String, dynamic>> doc([String? path]) {
    if (path != null) {
      if (path.isEmpty) {
        throw ArgumentError('A document path must be a non-empty string');
      } else if (path.contains('//')) {
        throw ArgumentError('A document path must not contain "//"');
      } else if (path == '/') {
        throw ArgumentError('A document path must point to a valid document');
      }
    }

    return _JsonDocumentReference(firestore, _delegate.doc(path));
  }

  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterCollectionReference(
      this,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _JsonCollectionReference &&
      other.runtimeType == runtimeType &&
      other.firestore == firestore &&
      other.path == path;

  @override
  int get hashCode => Object.hash(firestore, path);

  @override
  String toString() => 'CollectionReference<Map<String, dynamic>>($path)';
}

/// A [CollectionReference] object can be used for adding documents, getting
/// [DocumentReference]s, and querying for documents (using the methods
/// inherited from [Query]).
@immutable
class _WithConverterCollectionReference<T extends Object?>
    extends _WithConverterQuery<T> implements CollectionReference<T> {
  _WithConverterCollectionReference(
    CollectionReference<Map<String, dynamic>> collectionReference,
    FromFirestore<T> fromFirestore,
    ToFirestore<T> toFirestore,
  ) : super(collectionReference, fromFirestore, toFirestore);

  CollectionReference<Map<String, dynamic>>
      get _originalCollectionReferenceQuery {
    return super._originalQuery as CollectionReference<Map<String, dynamic>>;
  }

  @override
  String get id => _originalCollectionReferenceQuery.id;

  @override
  DocumentReference<Map<String, dynamic>>? get parent {
    return _originalCollectionReferenceQuery.parent;
  }

  @override
  String get path => _originalCollectionReferenceQuery.path;

  @override
  Future<DocumentReference<T>> add(T data) async {
    final snapshot = await _originalCollectionReferenceQuery.add(
      _toFirestore(data, null),
    );

    return _WithConverterDocumentReference<T>(
      snapshot,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  DocumentReference<T> doc([String? path]) {
    return _WithConverterDocumentReference<T>(
      _originalCollectionReferenceQuery.doc(path),
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterCollectionReference(
      _originalCollectionReferenceQuery,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _WithConverterCollectionReference<T> &&
      other.runtimeType == runtimeType &&
      other._originalCollectionReferenceQuery ==
          _originalCollectionReferenceQuery &&
      other._fromFirestore == _fromFirestore &&
      other._toFirestore == _toFirestore;

  @override
  int get hashCode => Object.hash(
        runtimeType,
        _originalCollectionReferenceQuery,
        _fromFirestore,
        _toFirestore,
      );

  @override
  String toString() => 'CollectionReference<$T>($path)';
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/document_change.dart

**크기**: 2604 bytes | **라인 수**: 86 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [DocumentChange] represents a change to the documents matching a query.
///
/// It contains the document affected and the type of change that occurred
/// (added, modified, or removed).
abstract class DocumentChange<T extends Object?> {
  /// The type of change that occurred (added, modified, or removed).
  DocumentChangeType get type;

  /// The index of the changed document in the result set immediately prior to
  /// this [DocumentChange] (i.e. supposing that all prior [DocumentChange] objects
  /// have been applied).
  ///
  /// -1 is returned for [DocumentChangeType.added] events.
  int get oldIndex;

  /// The index of the changed document in the result set immediately after this
  /// [DocumentChange] (i.e. supposing that all prior [DocumentChange] objects
  /// and the current [DocumentChange] object have been applied).
  ///
  /// -1 is returned for [DocumentChangeType.removed] events.
  int get newIndex;

  /// Returns the [DocumentSnapshot] for this instance.
  DocumentSnapshot<T> get doc;
}

class _JsonDocumentChange implements DocumentChange<Map<String, dynamic>> {
  _JsonDocumentChange(this._firestore, this._delegate) {
    DocumentChangePlatform.verify(_delegate);
  }

  final DocumentChangePlatform _delegate;
  final FirebaseFirestore _firestore;

  @override
  DocumentChangeType get type => _delegate.type;

  @override
  int get oldIndex => _delegate.oldIndex;

  @override
  int get newIndex => _delegate.newIndex;

  @override
  DocumentSnapshot<Map<String, dynamic>> get doc {
    return _JsonDocumentSnapshot(_firestore, _delegate.document);
  }
}

class _WithConverterDocumentChange<T extends Object?>
    implements DocumentChange<T> {
  _WithConverterDocumentChange(
    this._originalDocumentChange,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentChange<Map<String, dynamic>> _originalDocumentChange;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  DocumentChangeType get type => _originalDocumentChange.type;

  @override
  int get oldIndex => _originalDocumentChange.oldIndex;

  @override
  int get newIndex => _originalDocumentChange.newIndex;

  @override
  DocumentSnapshot<T> get doc {
    return _WithConverterDocumentSnapshot<T>(
      _originalDocumentChange.doc,
      _fromFirestore,
      _toFirestore,
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/document_reference.dart

**크기**: 9891 bytes | **라인 수**: 337 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [DocumentReference] refers to a document location in a [FirebaseFirestore] database
/// and can be used to write, read, or listen to the location.
///
/// The document at the referenced location may or may not exist.
/// A [DocumentReference] can also be used to create a [CollectionReference]
/// to a subcollection.
@sealed
@immutable
abstract class DocumentReference<T extends Object?> {
  DocumentReferencePlatform get _delegate;

  /// The Firestore instance associated with this document reference.
  FirebaseFirestore get firestore;

  /// This document's given ID within the collection.
  String get id;

  /// The parent [CollectionReference] of this document.
  CollectionReference<T> get parent;

  /// A string representing the path of the referenced document (relative to the
  /// root of the database).
  String get path;

  /// Gets a [CollectionReference] instance that refers to the collection at the
  /// specified path, relative from this [DocumentReference].
  CollectionReference<Map<String, dynamic>> collection(String collectionPath);

  /// Deletes the current document from the collection.
  Future<void> delete();

  /// Updates data on the document. Data will be merged with any existing
  /// document data.
  ///
  /// Objects key can be a String or a FieldPath.
  ///
  /// If no document exists yet, the update will fail.
  Future<void> update(Map<Object, Object?> data);

  /// Reads the document referenced by this [DocumentReference].
  ///
  /// By providing [options], this method can be configured to fetch results only
  /// from the server, only from the local cache or attempt to fetch results
  /// from the server and fall back to the cache (which is the default).
  Future<DocumentSnapshot<T>> get([GetOptions? options]);

  /// Notifies of document updates at this location.
  ///
  /// An initial event is immediately sent, and further events will be
  /// sent whenever the document is modified.
  Stream<DocumentSnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  });

  /// Sets data on the document, overwriting any existing data. If the document
  /// does not yet exist, it will be created.
  ///
  /// If [SetOptions] are provided, the data can be merged into an existing
  /// document instead of overwriting.
  Future<void> set(T data, [SetOptions? options]);

  /// Transforms a [DocumentReference] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final modelRef = FirebaseFirestore
  ///     .instance
  ///     .collection('models')
  ///     .doc('123')
  ///     .withConverter<Model>(
  ///       fromFirestore: (snapshot, _) => Model.fromJson(snapshot.data()!),
  ///       toFirestore: (model, _) => model.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   // Writes now take a Model as parameter instead of a Map
  ///   await modelRef.set(Model());
  ///
  ///   // Reads now return a Model instead of a Map
  ///   final Model model = await modelRef.get().then((s) => s.data());
  /// }
  /// ```
  DocumentReference<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });
}

@immutable
class _JsonDocumentReference
    implements DocumentReference<Map<String, dynamic>> {
  _JsonDocumentReference(this.firestore, this._delegate) {
    DocumentReferencePlatform.verify(_delegate);
  }

  @override
  final DocumentReferencePlatform _delegate;

  @override
  final FirebaseFirestore firestore;

  @override
  String get id => _delegate.id;

  @override
  CollectionReference<Map<String, dynamic>> get parent =>
      _JsonCollectionReference(firestore, _delegate.parent);

  @override
  String get path => _delegate.path;

  @override
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collectionPath must be a non-empty string.');
    } else if (collectionPath.contains('//')) {
      throw ArgumentError('A collection path must not contain "//".');
    } else if (!isValidCollectionPath(collectionPath)) {
      throw ArgumentError(
        'A collection path must point to a valid collection.',
      );
    }

    return _JsonCollectionReference(
      firestore,
      _delegate.collection(collectionPath),
    );
  }

  @override
  Future<void> delete() => _delegate.delete();

  @override
  Future<DocumentSnapshot<Map<String, dynamic>>> get([
    GetOptions? options,
  ]) async {
    return _JsonDocumentSnapshot(
      firestore,
      await _delegate.get(
        options ?? const GetOptions(),
      ),
    );
  }

  @override
  Stream<DocumentSnapshot<Map<String, dynamic>>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    if (source == ListenSource.cache &&
        defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        'Listening from cache is not supported on Windows',
      );
    }

    return _delegate
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          listenSource: source,
        )
        .map(
          (delegateSnapshot) =>
              _JsonDocumentSnapshot(firestore, delegateSnapshot),
        );
  }

  @override
  Future<void> set(Map<String, dynamic> data, [SetOptions? options]) {
    return _delegate.set(
      _CodecUtility.replaceValueWithDelegatesInMap(data)!,
      options,
    );
  }

  @override
  Future<void> update(Map<Object, Object?> data) {
    return _delegate
        .update(_CodecUtility.replaceValueWithDelegatesInMapFieldPath(data)!);
  }

  @override
  DocumentReference<T> withConverter<T>({
    required FromFirestore<T> fromFirestore,
    required ToFirestore<T> toFirestore,
  }) {
    return _WithConverterDocumentReference(this, fromFirestore, toFirestore);
  }

  @override
  bool operator ==(Object other) =>
      other is DocumentReference &&
      other.firestore == firestore &&
      other.path == path;

  @override
  int get hashCode => Object.hash(firestore, path);

  @override
  String toString() => 'DocumentReference<Map<String, dynamic>>($path)';
}

/// A [DocumentReference] refers to a document location in a [FirebaseFirestore] database
/// and can be used to write, read, or listen to the location.
///
/// The document at the referenced location may or may not exist.
/// A [DocumentReference] can also be used to create a [CollectionReference]
/// to a subcollection.
@immutable
class _WithConverterDocumentReference<T extends Object?>
    implements DocumentReference<T> {
  _WithConverterDocumentReference(
    this._originalDocumentReference,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentReference<Map<String, dynamic>> _originalDocumentReference;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    return _originalDocumentReference.collection(collectionPath);
  }

  @override
  Future<void> delete() {
    return _originalDocumentReference.delete();
  }

  @override
  Future<_WithConverterDocumentSnapshot<T>> get([GetOptions? options]) {
    return _originalDocumentReference.get(options).then((snapshot) {
      return _WithConverterDocumentSnapshot<T>(
        snapshot,
        _fromFirestore,
        _toFirestore,
      );
    });
  }

  @override
  DocumentReferencePlatform get _delegate =>
      _originalDocumentReference._delegate;

  @override
  FirebaseFirestore get firestore => _originalDocumentReference.firestore;

  @override
  String get id => _originalDocumentReference.id;

  @override
  CollectionReference<T> get parent {
    return _WithConverterCollectionReference<T>(
      _originalDocumentReference.parent,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  String get path => _originalDocumentReference.path;

  @override
  Future<void> set(T data, [SetOptions? options]) {
    return _originalDocumentReference.set(
      _toFirestore(data, options),
      options,
    );
  }

  @override
  Stream<_WithConverterDocumentSnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    return _originalDocumentReference
        .snapshots(
      includeMetadataChanges: includeMetadataChanges,
      source: source,
    )
        .map((snapshot) {
      return _WithConverterDocumentSnapshot<T>(
        snapshot,
        _fromFirestore,
        _toFirestore,
      );
    });
  }

  @override
  Future<void> update(Map<Object, Object?> data) {
    return _originalDocumentReference.update(data);
  }

  @override
  DocumentReference<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterDocumentReference(
      _originalDocumentReference,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _WithConverterDocumentReference<T> &&
      other.runtimeType == runtimeType &&
      other._originalDocumentReference == _originalDocumentReference &&
      other._fromFirestore == _fromFirestore &&
      other._toFirestore == _toFirestore;

  @override
  int get hashCode => Object.hash(
        runtimeType,
        _originalDocumentReference,
        _fromFirestore,
        _toFirestore,
      );

  @override
  String toString() => 'DocumentReference<$T>($path)';
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/document_snapshot.dart

**크기**: 4311 bytes | **라인 수**: 144 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

typedef FromFirestore<T> = T Function(
  DocumentSnapshot<Map<String, dynamic>> snapshot,
  SnapshotOptions? options,
);
typedef ToFirestore<T> = Map<String, Object?> Function(
  T value,
  SetOptions? options,
);

/// Options that configure how data is retrieved from a DocumentSnapshot
/// (e.g. the desired behavior for server timestamps that have not yet been set to their final value).
///
/// Currently unsupported by FlutterFire, but exposed to avoid breaking changes
/// in the future once this class is supported.
@sealed
class SnapshotOptions {}

/// A [DocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database.
///
/// The data can be extracted with the data property or by using subscript
/// syntax to access a specific field.
@sealed
abstract class DocumentSnapshot<T extends Object?> {
  /// This document's given ID for this snapshot.
  String get id;

  /// Returns the reference of this snapshot.
  DocumentReference<T> get reference;

  /// Metadata about this document concerning its source and if it has local
  /// modifications.
  SnapshotMetadata get metadata;

  /// Returns `true` if the document exists.
  bool get exists;

  /// Contains all the data of this document snapshot.
  T? data();

  /// {@template firestore.documentsnapshot.get}
  /// Gets a nested field by [String] or [FieldPath] from this [DocumentSnapshot].
  ///
  /// Data can be accessed by providing a dot-notated path or [FieldPath]
  /// which recursively finds the specified data. If no data could be found
  /// at the specified path, a [StateError] will be thrown.
  /// {@endtemplate}
  dynamic get(Object field);

  /// {@macro firestore.documentsnapshot.get}
  dynamic operator [](Object field);
}

class _JsonDocumentSnapshot implements DocumentSnapshot<Map<String, dynamic>> {
  _JsonDocumentSnapshot(this._firestore, this._delegate) {
    DocumentSnapshotPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final DocumentSnapshotPlatform _delegate;

  @override
  String get id => _delegate.id;

  @override
  late final DocumentReference<Map<String, dynamic>> reference =
      _firestore.doc(_delegate.reference.path);

  @override
  late final SnapshotMetadata metadata = SnapshotMetadata._(_delegate.metadata);

  @override
  bool get exists => _delegate.exists;

  @override
  Map<String, dynamic>? data() {
    // TODO(rrousselGit): can we cache the result, to avoid deserializing it on every read?
    return _CodecUtility.replaceDelegatesWithValueInMap(
      _delegate.data(),
      _firestore,
    );
  }

  @override
  dynamic get(Object field) {
    return _CodecUtility.valueDecode(_delegate.get(field), _firestore);
  }

  @override
  dynamic operator [](Object field) => get(field);
}

/// A [DocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database.
///
/// The data can be extracted with the data property or by using subscript
/// syntax to access a specific field.
class _WithConverterDocumentSnapshot<T> implements DocumentSnapshot<T> {
  _WithConverterDocumentSnapshot(
    this._originalDocumentSnapshot,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentSnapshot<Map<String, dynamic>> _originalDocumentSnapshot;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  T? data() {
    if (!_originalDocumentSnapshot.exists) return null;

    return _fromFirestore(_originalDocumentSnapshot, null);
  }

  @override
  bool get exists => _originalDocumentSnapshot.exists;

  @override
  String get id => _originalDocumentSnapshot.id;

  @override
  SnapshotMetadata get metadata => _originalDocumentSnapshot.metadata;

  @override
  DocumentReference<T> get reference => _WithConverterDocumentReference<T>(
        _originalDocumentSnapshot.reference,
        _fromFirestore,
        _toFirestore,
      );

  @override
  dynamic get(Object field) => _originalDocumentSnapshot.get(field);

  @override
  dynamic operator [](Object field) => _originalDocumentSnapshot[field];
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/field_value.dart

**크기**: 2757 bytes | **라인 수**: 67 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Sentinel values that can be used when writing document fields with set() or
/// update().
///
/// This class serves as a static factory for [FieldValuePlatform] instances, but also
/// as a facade for the [FieldValue] type, so plugin users don't need to worry about
/// the actual internal implementation of their [FieldValue]s after they're created.
@immutable
// ignore: must_be_immutable
class FieldValue extends FieldValuePlatform {
  static final FieldValueFactoryPlatform _factory =
      FieldValueFactoryPlatform.instance;

  FieldValue._(this._delegate) : super(_delegate);

  /// Returns a [FieldValue] that tells the server to union the given elements
  /// with any array value that already exists on the server.
  ///
  /// Each specified element that doesn't already exist in the array will be
  /// added to the end. If the field being modified is not already an array it
  /// will be overwritten with an array containing exactly the specified
  /// elements.
  static FieldValue arrayUnion(List<dynamic> elements) =>
      FieldValue._(_factory.arrayUnion(_CodecUtility.valueEncode(elements)));

  /// Returns a [FieldValue] that tells the server to remove the given
  /// elements from any array value that already exists on the server.
  ///
  /// All instances of each element specified will be removed from the array.
  /// If the field being modified is not already an array it will be overwritten
  /// with an empty array.
  static FieldValue arrayRemove(List<dynamic> elements) =>
      FieldValue._(_factory.arrayRemove(_CodecUtility.valueEncode(elements)));

  /// Returns a sentinel for use with update() to mark a field for deletion.
  static FieldValue delete() => FieldValue._(_factory.delete());

  /// Returns a sentinel for use with set() or update() to include a
  /// server-generated timestamp in the written data.
  static FieldValue serverTimestamp() =>
      FieldValue._(_factory.serverTimestamp());

  /// Returns a special value for use with set() or update() that tells the
  /// server to increment the field’s current value by the given value.
  static FieldValue increment(num value) =>
      FieldValue._(_factory.increment(value));

  dynamic _delegate;

  @override
  String toString() => '$FieldValue($_delegate)';

  @override
  bool operator ==(Object other) {
    return other is FieldValue && other._delegate == _delegate;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => _delegate.hashCode;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/filters.dart

**크기**: 10743 bytes | **라인 수**: 407 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class _FilterObject {
  Map<String, Object?> build() {
    throw UnimplementedError();
  }
}

class _FilterQuery extends _FilterObject {
  _FilterQuery(this._field, this._operator, this._value)
      : assert(_field is FieldPathType || _field is FieldPath);

  final Object _field;
  final String _operator;
  final Object? _value;

  @override
  Map<String, Object?> build() {
    return <String, Object?>{
      'fieldPath': _field,
      'op': _operator,
      'value': _value,
    };
  }
}

class _FilterOperator extends _FilterObject {
  _FilterOperator(this._operator, this._queries);

  final String _operator;
  final List<_FilterObject> _queries;

  @override
  Map<String, Object> build() {
    return <String, Object>{
      'op': _operator,
      'queries': _queries.map((e) => e.build()).toList(),
    };
  }
}

/// A [Filter] represents a restriction on one or more field values and can be used to refine
/// the results of a [Query].
class Filter extends FilterPlatformInterface {
  late final _FilterQuery? _filterQuery;
  late final _FilterOperator? _filterOperator;

  Filter._(this._filterQuery, this._filterOperator)
      : assert(
          (_filterQuery != null && _filterOperator == null) ||
              (_filterQuery == null && _filterOperator != null),
          'Exactly one operator must be specified',
        );

  /// A [Filter] represents a restriction on one or more field values and can be used to refine
  /// the results of a [Query].
  ///
  /// Only one operator can be specified at a time.
  Filter(
    /// The field or [FieldPath] to filter on.
    Object field, {
    /// Creates a new filter for checking that the given field is equal to the given value.
    Object? isEqualTo,

    /// Creates a new filter for checking that the given field is not equal to the given value.
    Object? isNotEqualTo,

    /// Creates a new filter for checking that the given field is less than the given value.
    Object? isLessThan,

    /// Creates a new filter for checking that the given field is less than or equal to the given value.
    Object? isLessThanOrEqualTo,

    /// Creates a new filter for checking that the given field is greater than the given value.
    Object? isGreaterThan,

    /// Creates a new filter for checking that the given field is greater than or equal to the given value.
    Object? isGreaterThanOrEqualTo,

    /// Creates a new filter for checking that the given array field contains the given value.
    Object? arrayContains,

    /// Creates a new filter for checking that the given array field contains any of the given values.
    Iterable<Object?>? arrayContainsAny,

    /// Creates a new filter for checking that the given field equals any of the given values.
    Iterable<Object?>? whereIn,

    /// Creates a new filter for checking that the given field does not equal any of the given values.
    Iterable<Object?>? whereNotIn,

    /// Creates a new filter for checking that the given field is null.
    bool? isNull,
  })  : assert(
          () {
            final operators = [
              isEqualTo,
              isNotEqualTo,
              isLessThan,
              isLessThanOrEqualTo,
              isGreaterThan,
              isGreaterThanOrEqualTo,
              arrayContains,
              arrayContainsAny,
              whereIn,
              whereNotIn,
              isNull,
            ];
            final operatorsUsed = operators.where((e) => e != null).length;
            return operatorsUsed == 1;
          }(),
          'Exactly one operator must be specified',
        ),
        assert(
          field is String || field is FieldPath || field is FieldPathType,
        ) {
    final _field = (field is String ? FieldPath.fromString(field) : field);

    _filterQuery = _FilterQuery(
      _field,
      _getOperator(
        isEqualTo,
        isNotEqualTo,
        isLessThan,
        isLessThanOrEqualTo,
        isGreaterThan,
        isGreaterThanOrEqualTo,
        arrayContains,
        arrayContainsAny,
        whereIn,
        whereNotIn,
        isNull,
      ),
      _CodecUtility.valueEncode(
        _getValue(
          isEqualTo,
          isNotEqualTo,
          isLessThan,
          isLessThanOrEqualTo,
          isGreaterThan,
          isGreaterThanOrEqualTo,
          arrayContains,
          arrayContainsAny,
          whereIn,
          whereNotIn,
          isNull,
        ),
      ),
    );
    _filterOperator = null;
  }

  String _getOperator(
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  ) {
    if (isEqualTo != null) return '==';
    if (isNotEqualTo != null) return '!=';
    if (isLessThan != null) return '<';
    if (isLessThanOrEqualTo != null) return '<=';
    if (isGreaterThan != null) return '>';
    if (isGreaterThanOrEqualTo != null) return '>=';
    if (arrayContains != null) return 'array-contains';
    if (arrayContainsAny != null) return 'array-contains-any';
    if (whereIn != null) return 'in';
    if (whereNotIn != null) return 'not-in';
    if (isNull != null) {
      if (isNull) {
        return '==';
      } else {
        return '!=';
      }
    }
    throw Exception('Exactly one operator must be specified');
  }

  Object? _getValue(
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  ) {
    if (isEqualTo != null) return isEqualTo;
    if (isNotEqualTo != null) return isNotEqualTo;
    if (isLessThan != null) return isLessThan;
    if (isLessThanOrEqualTo != null) return isLessThanOrEqualTo;
    if (isGreaterThan != null) return isGreaterThan;
    if (isGreaterThanOrEqualTo != null) return isGreaterThanOrEqualTo;
    if (arrayContains != null) return arrayContains;
    if (arrayContainsAny != null) return arrayContainsAny;
    if (whereIn != null) return whereIn;
    if (whereNotIn != null) return whereNotIn;
    if (isNull != null) {
      if (isNull == true) {
        return null;
      } else {
        return null;
      }
    }
    throw Exception('Exactly one operator must be specified');
  }

  /// Creates a new filter that is a disjunction of the given filters.
  ///
  /// A disjunction filter includes a document if it satisfies any of the given filters.
  static Filter or(
    Filter filter1,
    Filter filter2,
    // Number of OR operation is limited on the server side
    // We let here 30 as a limit
    [
    Filter? filter3,
    Filter? filter4,
    Filter? filter5,
    Filter? filter6,
    Filter? filter7,
    Filter? filter8,
    Filter? filter9,
    Filter? filter10,
    Filter? filter11,
    Filter? filter12,
    Filter? filter13,
    Filter? filter14,
    Filter? filter15,
    Filter? filter16,
    Filter? filter17,
    Filter? filter18,
    Filter? filter19,
    Filter? filter20,
    Filter? filter21,
    Filter? filter22,
    Filter? filter23,
    Filter? filter24,
    Filter? filter25,
    Filter? filter26,
    Filter? filter27,
    Filter? filter28,
    Filter? filter29,
    Filter? filter30,
  ]) {
    return _generateFilter(
      'OR',
      [
        filter1,
        filter2,
        filter3,
        filter4,
        filter5,
        filter6,
        filter7,
        filter8,
        filter9,
        filter10,
        filter11,
        filter12,
        filter13,
        filter14,
        filter15,
        filter16,
        filter17,
        filter18,
        filter19,
        filter20,
        filter21,
        filter22,
        filter23,
        filter24,
        filter25,
        filter26,
        filter27,
        filter28,
        filter29,
        filter30,
      ],
    );
  }

  /// Creates a new filter that is a conjunction of the given filters.
  ///
  /// A conjunction filter includes document if it satisfies all of the given filters.
  static Filter and(
    Filter filter1,
    Filter filter2, [
    Filter? filter3,
    Filter? filter4,
    Filter? filter5,
    Filter? filter6,
    Filter? filter7,
    Filter? filter8,
    Filter? filter9,
    Filter? filter10,
    Filter? filter11,
    Filter? filter12,
    Filter? filter13,
    Filter? filter14,
    Filter? filter15,
    Filter? filter16,
    Filter? filter17,
    Filter? filter18,
    Filter? filter19,
    Filter? filter20,
    Filter? filter21,
    Filter? filter22,
    Filter? filter23,
    Filter? filter24,
    Filter? filter25,
    Filter? filter26,
    Filter? filter27,
    Filter? filter28,
    Filter? filter29,
    Filter? filter30,
  ]) {
    return _generateFilter(
      'AND',
      [
        filter1,
        filter2,
        filter3,
        filter4,
        filter5,
        filter6,
        filter7,
        filter8,
        filter9,
        filter10,
        filter11,
        filter12,
        filter13,
        filter14,
        filter15,
        filter16,
        filter17,
        filter18,
        filter19,
        filter20,
        filter21,
        filter22,
        filter23,
        filter24,
        filter25,
        filter26,
        filter27,
        filter28,
        filter29,
        filter30,
      ],
    );
  }

  static Filter _generateFilter(
    String operator,
    List<Filter?> filters,
  ) {
    assert(
      () {
        final filtersUsed = filters.where((e) => e != null).length;
        return filtersUsed >= 2;
      }(),
      'At least two filters must be specified',
    );
    return Filter._(
      null,
      _FilterOperator(
        operator,
        [
          for (final filter in filters)
            if (filter != null && filter._filterQuery != null)
              filter._filterQuery
            else if (filter != null && filter._filterOperator != null)
              filter._filterOperator,
        ],
      ),
    );
  }

  /// Returns a map representation of this filter.
  @override
  Map<String, Object?> toJson() {
    if (_filterOperator != null) {
      return _filterOperator.build();
    } else if (_filterQuery != null) {
      return _filterQuery.build();
    }
    throw Exception('Exactly one operator must be specified');
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/firestore.dart

**크기**: 15104 bytes | **라인 수**: 373 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// The entry point for accessing a [FirebaseFirestore].
///
/// You can get an instance by calling [FirebaseFirestore.instance]. The instance
/// can also be created with a secondary [Firebase] app by calling
/// [FirebaseFirestore.instanceFor], for example:
///
/// ```dart
/// FirebaseApp secondaryApp = Firebase.app('SecondaryApp');
///
/// FirebaseFirestore firestore = FirebaseFirestore.instanceFor(app: secondaryApp);
/// ```
class FirebaseFirestore extends FirebasePluginPlatform {
  FirebaseFirestore._({
    required this.app,
    required this.databaseId,
  }) : super(app.name, 'plugins.flutter.io/firebase_firestore');

  static final Map<String, FirebaseFirestore> _cachedInstances = {};

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseFirestore get instance {
    return FirebaseFirestore.instanceFor(
      app: Firebase.app(),
    );
  }

  /// Returns an instance using a specified [FirebaseApp].
  static FirebaseFirestore instanceFor({
    required FirebaseApp app,
    String? databaseId,
  }) {
    String firestoreDatabaseId = databaseId ?? '(default)';
    String cacheKey = '${app.name}|$firestoreDatabaseId';
    if (_cachedInstances.containsKey(cacheKey)) {
      return _cachedInstances[cacheKey]!;
    }

    FirebaseFirestore newInstance = FirebaseFirestore._(
      app: app,
      databaseId: firestoreDatabaseId,
    );
    _cachedInstances[cacheKey] = newInstance;

    return newInstance;
  }

  // Cached and lazily loaded instance of [FirestorePlatform] to avoid
  // creating a [MethodChannelFirestore] when not needed or creating an
  // instance with the default app before a user specifies an app.
  FirebaseFirestorePlatform? _delegatePackingProperty;

  FirebaseFirestorePlatform get _delegate {
    return _delegatePackingProperty ??= FirebaseFirestorePlatform.instanceFor(
      app: app,
      databaseId: databaseId,
    );
  }

  /// The [FirebaseApp] for this current [FirebaseFirestore] instance.
  FirebaseApp app;

  /// Firestore Database ID for this instance. Falls back to default database: "(default)"
  String databaseId;

  /// Gets a [CollectionReference] for the specified Firestore path.
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collection path must be a non-empty string.');
    } else if (collectionPath.contains('//')) {
      throw ArgumentError('A collection path must not contain "//".');
    } else if (!isValidCollectionPath(collectionPath)) {
      throw ArgumentError(
        'A collection path must point to a valid collection.',
      );
    }

    return _JsonCollectionReference(this, _delegate.collection(collectionPath));
  }

  /// Returns a [WriteBatch], used for performing multiple writes as a single
  /// atomic operation.
  ///
  /// Unlike [Transaction]s, [WriteBatch]es are persisted offline and therefore are
  /// preferable when you don’t need to condition your writes on read data.
  WriteBatch batch() {
    return WriteBatch._(this, _delegate.batch());
  }

  /// Clears the persistent storage, including pending writes and cached documents.
  ///
  /// Must be called while the FirebaseFirestore instance is not started (after the app is shutdown or when the app is first initialized).
  /// On startup, this method must be called before other methods (other than [FirebaseFirestore.instance.settings]).
  /// If the FirebaseFirestore instance is still running, the Future will fail.
  ///
  /// Note: clearPersistence() is primarily intended to help write reliable tests that use Cloud Firestore.
  /// It uses an efficient mechanism for dropping existing data but does not attempt to securely
  /// overwrite or otherwise make cached data unrecoverable. For applications that are sensitive to
  /// the disclosure of cached data in between user sessions, we strongly recommend not enabling persistence at all.
  Future<void> clearPersistence() {
    return _delegate.clearPersistence();
  }

  LoadBundleTask loadBundle(Uint8List bundle) {
    return LoadBundleTask._(_delegate.loadBundle(bundle));
  }

  /// Changes this instance to point to a FirebaseFirestore emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "8080" (port 8080 is default)
  ///
  /// Note: Must be called immediately, prior to accessing FirebaseFirestore methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  void useFirestoreEmulator(
    String host,
    int port, {
    bool sslEnabled = false,
    bool automaticHostMapping = true,
  }) {
    if (kIsWeb) {
      // use useEmulator() API for web as settings are set immediately unlike native platforms
      try {
        _delegate.useEmulator(host, port);
      } catch (e) {
        // We convert to string to be compatible with Flutter <= 3.7 and Flutter >= 3.10
        // .code is only available in Flutter <= 3.7
        String strError = e.toString();

        // this catches FirebaseError from web that occurs after hot reloading & hot restarting
        if (!strError.contains('failed-precondition')) {
          rethrow;
        }
      }
    } else {
      String mappedHost = host;
      // Android considers localhost as 10.0.2.2 - automatically handle this for users.
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
        if ((mappedHost == 'localhost' || mappedHost == '127.0.0.1') &&
            automaticHostMapping) {
          // ignore: avoid_print
          print('Mapping Firestore Emulator host "$mappedHost" to "10.0.2.2".');
          mappedHost = '10.0.2.2';
        }
      }

      _delegate.settings = _delegate.settings.copyWith(
        // "sslEnabled" has to be set to false for android to work
        sslEnabled: sslEnabled,
        host: '$mappedHost:$port',
      );
    }
  }

  /// Performs a [namedQueryGet] and decode the result using [Query.withConverter].
  Future<QuerySnapshot<T>> namedQueryWithConverterGet<T>(
    String name, {
    GetOptions options = const GetOptions(),
    required FromFirestore<T> fromFirestore,
    required ToFirestore<T> toFirestore,
  }) async {
    final snapshot = await namedQueryGet(name, options: options);

    return _WithConverterQuerySnapshot<T>(snapshot, fromFirestore, toFirestore);
  }

  /// Reads a [QuerySnapshot] if a namedQuery has been retrieved and passed as a [Buffer] to [loadBundle()]. To read from cache, pass [GetOptions.source] value as [Source.cache].
  /// To read from the Firestore backend, use [GetOptions.source] as [Source.server].
  Future<QuerySnapshot<Map<String, dynamic>>> namedQueryGet(
    String name, {
    GetOptions options = const GetOptions(),
  }) async {
    QuerySnapshotPlatform snapshotDelegate =
        await _delegate.namedQueryGet(name, options: options);
    return _JsonQuerySnapshot(FirebaseFirestore.instance, snapshotDelegate);
  }

  /// Gets a [Query] for the specified collection group.
  Query<Map<String, dynamic>> collectionGroup(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collection path must be a non-empty string.');
    } else if (collectionPath.contains('/')) {
      throw ArgumentError(
        'A collection path passed to collectionGroup() cannot contain "/".',
      );
    }

    return _JsonQuery(this, _delegate.collectionGroup(collectionPath));
  }

  /// Instructs [FirebaseFirestore] to disable the network for the instance.
  ///
  /// Once disabled, any writes will only resolve once connection has been
  /// restored. However, the local database will still be updated and any
  /// listeners will still trigger.
  Future<void> disableNetwork() {
    return _delegate.disableNetwork();
  }

  /// Gets a [DocumentReference] for the specified Firestore path.
  DocumentReference<Map<String, dynamic>> doc(String documentPath) {
    if (documentPath.isEmpty) {
      throw ArgumentError('A document path must be a non-empty string.');
    } else if (documentPath.contains('//')) {
      throw ArgumentError('A document path must not contain "//".');
    } else if (!isValidDocumentPath(documentPath)) {
      throw ArgumentError('A document path must point to a valid document.');
    }

    return _JsonDocumentReference(this, _delegate.doc(documentPath));
  }

  /// Enables the network for this instance. Any pending local-only writes
  /// will be written to the remote servers.
  Future<void> enableNetwork() {
    return _delegate.enableNetwork();
  }

  /// Returns a [Stream] which is called each time all of the active listeners
  /// have been synchronized.
  Stream<void> snapshotsInSync() {
    return _delegate.snapshotsInSync();
  }

  /// Executes the given [TransactionHandler] and then attempts to commit the
  /// changes applied within an atomic transaction.
  ///
  /// In the [TransactionHandler], a set of reads and writes can be performed
  /// atomically using the [Transaction] object passed to the [TransactionHandler].
  /// After the [TransactionHandler] is run, [FirebaseFirestore] will attempt to apply the
  /// changes to the server. If any of the data read has been modified outside
  /// of this [Transaction] since being read, then the transaction will be
  /// retried by executing the provided [TransactionHandler] again. If the transaction still
  /// fails after 5 retries, then the transaction will fail.s
  ///
  /// The [TransactionHandler] may be executed multiple times, it should be able
  /// to handle multiple executions.
  ///
  /// Data accessed with the transaction will not reflect local changes that
  /// have not been committed. For this reason, it is required that all
  /// reads are performed before any writes. Transactions must be performed
  /// while online. Otherwise, reads will fail, and the final commit will fail.
  ///
  /// By default transactions are limited to 30 seconds of execution time. This
  /// timeout can be adjusted by setting the timeout parameter.
  ///
  /// By default transactions will retry 5 times. You can change the number of attempts
  /// with [maxAttempts]. Attempts should be at least 1.
  Future<T> runTransaction<T>(
    TransactionHandler<T> transactionHandler, {
    Duration timeout = const Duration(seconds: 30),
    int maxAttempts = 5,
  }) async {
    late T output;
    await _delegate.runTransaction(
      (transaction) async {
        output = await transactionHandler(Transaction._(this, transaction));
      },
      timeout: timeout,
      maxAttempts: maxAttempts,
    );

    return output;
  }

  /// Specifies custom settings to be used to configure this [FirebaseFirestore] instance.
  ///
  /// You must set these before invoking any other methods on this [FirebaseFirestore] instance.
  set settings(Settings settings) {
    _delegate.settings = _delegate.settings.copyWith(
      sslEnabled: settings.sslEnabled,
      persistenceEnabled: settings.persistenceEnabled,
      host: settings.host,
      cacheSizeBytes: settings.cacheSizeBytes,
      webExperimentalForceLongPolling: settings.webExperimentalForceLongPolling,
      webExperimentalAutoDetectLongPolling:
          settings.webExperimentalAutoDetectLongPolling,
      webExperimentalLongPollingOptions:
          settings.webExperimentalLongPollingOptions,
    );
  }

  /// The current [Settings] for this [FirebaseFirestore] instance.
  Settings get settings {
    return _delegate.settings;
  }

  /// Terminates this [FirebaseFirestore] instance.
  ///
  /// After calling [terminate()] only the [clearPersistence()] method may be used.
  /// Any other method will throw a [FirebaseException].
  ///
  /// Termination does not cancel any pending writes, and any promises that are
  /// awaiting a response from the server will not be resolved. If you have
  /// persistence enabled, the next time you start this instance, it will resume
  ///  sending these writes to the server.
  ///
  /// Note: Under normal circumstances, calling [terminate()] is not required.
  /// This method is useful only when you want to force this instance to release
  ///  all of its resources or in combination with [clearPersistence()] to ensure
  ///  that all local state is destroyed between test runs.
  Future<void> terminate() {
    return _delegate.terminate();
  }

  /// Waits until all currently pending writes for the active user have been
  /// acknowledged by the backend.
  ///
  /// The returned Future resolves immediately if there are no outstanding writes.
  /// Otherwise, the Promise waits for all previously issued writes (including
  /// those written in a previous app session), but it does not wait for writes
  /// that were added after the method is called. If you want to wait for
  /// additional writes, call [waitForPendingWrites] again.
  ///
  /// Any outstanding [waitForPendingWrites] calls are rejected during user changes.
  Future<void> waitForPendingWrites() {
    return _delegate.waitForPendingWrites();
  }

  PersistentCacheIndexManager? persistentCacheIndexManager() {
    if (defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        '`PersistentCacheIndexManager` is not available on Windows platform',
      );
    }

    PersistentCacheIndexManagerPlatform? indexManager =
        _delegate.persistentCacheIndexManager();
    if (indexManager != null) {
      return PersistentCacheIndexManager._(
        indexManager,
      );
    }
    return null;
  }

  /// Configures indexing for local query execution. Any previous index configuration is overridden.
  ///
  /// The index entries themselves are created asynchronously. You can continue to use queries that
  /// require indexing even if the indices are not yet available. Query execution will automatically
  /// start using the index once the index entries have been written.
  /// See Firebase documentation to learn how to configure your index configuration JSON file:
  /// https://firebase.google.com/docs/reference/firestore/indexes
  ///
  /// This API is in preview mode and is subject to change.
  @experimental
  Future<void> setIndexConfigurationFromJSON(String json) async {
    return _delegate.setIndexConfiguration(json);
  }

  /// Globally enables / disables Cloud Firestore logging for the SDK.
  static Future<void> setLoggingEnabled(bool enabled) {
    return FirebaseFirestorePlatform.instance.setLoggingEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) =>
      other is FirebaseFirestore && other.app.name == app.name;

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(app.name, app.options);

  @override
  String toString() => '$FirebaseFirestore(app: ${app.name})';
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/load_bundle_task.dart

**크기**: 605 bytes | **라인 수**: 18 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class LoadBundleTask {
  LoadBundleTask._(this._delegate) {
    LoadBundleTaskPlatform.verify(_delegate);
  }

  final LoadBundleTaskPlatform _delegate;

  late final Stream<LoadBundleTaskSnapshot> stream =
      // ignore: unnecessary_lambdas, false positive, event is dynamic
      _delegate.stream.map((event) => LoadBundleTaskSnapshot._(event));
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/load_bundle_task_snapshot.dart

**크기**: 1163 bytes | **라인 수**: 32 | **타입**: text

```
// Copyright 2021, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [LoadBundleTaskSnapshot] is returned as the result or on-going process of a [LoadBundleTask].
class LoadBundleTaskSnapshot {
  LoadBundleTaskSnapshot._(this._delegate) {
    LoadBundleTaskSnapshotPlatform.verify(_delegate);
  }
  LoadBundleTaskSnapshotPlatform _delegate;

  /// How many bytes have been loaded.
  int get bytesLoaded => _delegate.bytesLoaded;

  /// How many documents have been loaded.
  int get documentsLoaded => _delegate.documentsLoaded;

  /// The current load bundle task snapshot state.
  ///
  /// The state indicates the current progress of the task, such as whether it
  /// is running, paused or completed.
  LoadBundleTaskState get taskState => _delegate.taskState;

  /// The total bytes of the load bundle task.
  int get totalBytes => _delegate.totalBytes;

  /// How many documents are in the bundle being loaded.
  int get totalDocuments => _delegate.totalDocuments;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/persistent_cache_index_manager.dart

**크기**: 1354 bytes | **라인 수**: 34 | **타입**: text

```
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class PersistentCacheIndexManager {
  PersistentCacheIndexManager._(this._delegate) {
    PersistentCacheIndexManagerPlatform.verify(_delegate);
  }

  /// The platform delegate that interacts with the platform code.
  final PersistentCacheIndexManagerPlatform _delegate;

  /// Enables the SDK to create persistent cache indexes automatically for local query
  /// execution when the SDK believes cache indexes can help improves performance.
  /// This feature is disabled by default.
  Future<void> enableIndexAutoCreation() {
    return _delegate.enableIndexAutoCreation();
  }

  /// Stops creating persistent cache indexes automatically for local query execution.
  /// The indexes which have been created by calling `enableIndexAutoCreation()` still take effect.
  Future<void> disableIndexAutoCreation() {
    return _delegate.disableIndexAutoCreation();
  }

  /// Removes all persistent cache indexes. Note this function also deletes indexes
  /// generated by `setIndexConfiguration()`, which is deprecated.
  Future<void> deleteAllIndexes() {
    return _delegate.deleteAllIndexes();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/query.dart

**크기**: 38692 bytes | **라인 수**: 1148 | **타입**: text

```
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Represents a [Query] over the data at a particular location.
///
/// Can construct refined [Query] objects by adding filters and ordering.
// `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
@sealed
@immutable
abstract class Query<T extends Object?> {
  /// The [FirebaseFirestore] instance of this query.
  FirebaseFirestore get firestore;

  /// Exposes the [parameters] on the query delegate.
  ///
  /// This should only be used for testing to ensure that all
  /// query modifiers are correctly set on the underlying delegate
  /// when being tested from a different package.
  Map<String, dynamic> get parameters;

  /// Creates and returns a new [Query] that ends at the provided document
  /// (inclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Cannot be used in combination with [endBefore], [endBeforeDocument], or
  /// [endAt], but can be used in combination with [startAt],
  /// [startAfter], [startAtDocument] and [startAfterDocument].
  ///
  /// See also:
  ///
  ///  * [startAfterDocument] for a query that starts after a document.
  ///  * [startAtDocument] for a query that starts at a document.
  ///  * [endBeforeDocument] for a query that ends before a document.
  Query<T> endAtDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that ends at the
  /// provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endAt(Iterable<Object?> values);

  /// Creates and returns a new [Query] that ends before the provided document
  /// snapshot (exclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endBeforeDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that ends before
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endBefore(Iterable<Object?> values);

  /// Fetch the documents for this query.
  ///
  /// To modify how the query is fetched, the [options] parameter can be provided
  /// with a [GetOptions] instance.
  Future<QuerySnapshot<T>> get([GetOptions? options]);

  /// Creates and returns a new Query that's additionally limited to only return up
  /// to the specified number of documents.
  Query<T> limit(int limit);

  /// Creates and returns a new Query that only returns the last matching documents.
  ///
  /// You must specify at least one orderBy clause for limitToLast queries,
  /// otherwise an exception will be thrown during execution.
  Query<T> limitToLast(int limit);

  /// Notifies of query results at this location.
  Stream<QuerySnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  });

  /// Creates and returns a new [Query] that's additionally sorted by the specified
  /// [field].
  /// The field may be a [String] representing a single field name or a [FieldPath].
  ///
  /// After a [FieldPath.documentId] order by call, you cannot add any more [orderBy]
  /// calls.
  ///
  /// Furthermore, you may not use [orderBy] on the [FieldPath.documentId] [field] when
  /// using [startAfterDocument], [startAtDocument], [endBeforeDocument],
  /// or [endAtDocument] because the order by clause on the document id
  /// is added by these methods implicitly.
  Query<T> orderBy(Object field, {bool descending = false});

  /// Creates and returns a new [Query] that starts after the provided document
  /// (exclusive). The starting position is relative to the order of the query.
  /// The [documentSnapshot] must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAfterDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that starts
  /// after the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAfter(Iterable<Object?> values);

  /// Creates and returns a new [Query] that starts at the provided document
  /// (inclusive). The starting position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAtDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that starts at
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAt(Iterable<Object?> values);

  /// Creates and returns a new [Query] with additional filter on specified
  /// [field]. [field] refers to a field in a document.
  ///
  /// The [field] may be a [String] consisting of a single field name
  /// (referring to a top level field in the document),
  /// or a series of field names separated by dots '.'
  /// (referring to a nested field in the document).
  /// Alternatively, the [field] can also be a [FieldPath].
  ///
  /// Only documents satisfying provided condition are included in the result
  /// set.
  Query<T> where(
    Object field, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  });

  /// Transforms a [Query] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final personsRef = FirebaseFirestore
  ///     .instance
  ///     .collection('persons')
  ///     .where('age', isGreaterThan: 0)
  ///     .withConverter<Person>(
  ///       fromFirestore: (snapshot, _) => Person.fromJson(snapshot.data()!),
  ///       toFirestore: (person, _) => person.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   List<QuerySnapshot<Person>> persons = await personsRef.get().then((s) => s.docs);
  /// }
  /// ```
  Query<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });

  AggregateQuery count();

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]);
}

/// Represents a [Query] over the data at a particular location.
///
/// Can construct refined [Query] objects by adding filters and ordering.
class _JsonQuery implements Query<Map<String, dynamic>> {
  _JsonQuery(
    this.firestore,
    this._delegate,
  ) {
    QueryPlatform.verify(_delegate);
  }

  @override
  final FirebaseFirestore firestore;

  final QueryPlatform _delegate;

  /// Exposes the [parameters] on the query delegate.
  ///
  /// This should only be used for testing to ensure that all
  /// query modifiers are correctly set on the underlying delegate
  /// when being tested from a different package.
  @override
  Map<String, dynamic> get parameters {
    return _delegate.parameters;
  }

  /// Returns whether the current query has a "start" cursor query.
  bool _hasStartCursor() {
    return parameters['startAt'] != null || parameters['startAfter'] != null;
  }

  /// Returns whether the current query has a "end" cursor query.
  bool _hasEndCursor() {
    return parameters['endAt'] != null || parameters['endBefore'] != null;
  }

  bool isNotIn(String operator) {
    return operator == 'not-in';
  }

  /// Asserts that a [DocumentSnapshot] can be used within the current
  /// query.
  ///
  /// Since a native DocumentSnapshot cannot be created without additional
  /// database calls, any ordered values are extracted from the document and
  /// passed to the query.
  Map<String, dynamic> _assertQueryCursorSnapshot(
    DocumentSnapshot documentSnapshot,
  ) {
    assert(
      documentSnapshot.exists,
      'a document snapshot must exist to be used within a query',
    );

    List<List<dynamic>> orders = List.from(parameters['orderBy']);
    List<dynamic> values = [];

    for (final List<dynamic> order in orders) {
      dynamic field = order[0];

      // All order by fields must exist within the snapshot
      if (field != FieldPath.documentId) {
        try {
          final codecValue =
              _CodecUtility.valueEncode(documentSnapshot.get(field));
          values.add(codecValue);
        } on StateError {
          throw "You are trying to start or end a query using a document for which the field '$field' (used as the orderBy) does not exist.";
        }
      }
    }

    // Any time you construct a query and don't include 'name' in the orderBys,
    // Firestore will implicitly assume an additional .orderBy('__name__', DIRECTION)
    // where DIRECTION will match the last orderBy direction of your query (or 'asc' if you have no orderBys).
    if (orders.isNotEmpty) {
      List<dynamic> lastOrder = orders.last;

      if (lastOrder[0] != FieldPath.documentId) {
        orders.add([FieldPath.documentId, lastOrder[1]]);
      }
    } else {
      orders.add([FieldPath.documentId, false]);
    }

    if (_delegate.isCollectionGroupQuery) {
      values.add(documentSnapshot.reference.path);
    } else {
      values.add(documentSnapshot.id);
    }

    return <String, dynamic>{
      'orders': orders,
      'values': values,
    };
  }

  /// Common handler for all non-document based cursor queries.
  Iterable<dynamic> _assertQueryCursorValues(Iterable<Object?> fields) {
    List<List<Object?>> orders = List.from(parameters['orderBy']);

    assert(
      fields.length <= orders.length,
      'Too many arguments provided. '
      'The number of arguments must be less than or equal to the number of orderBy() clauses.',
    );

    return fields;
  }

  /// Asserts that the query [field] is either a String or a [FieldPath].
  void _assertValidFieldType(Object field) {
    assert(
      field is String ||
          field is FieldPath ||
          field == FieldPath.documentId ||
          field is Filter,
      'Supported [field] types are [String], [FieldPath], and [Filter].',
    );
  }

  /// Creates and returns a new [Query] that ends at the provided document
  /// (inclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Cannot be used in combination with [endBefore], [endBeforeDocument], or
  /// [endAt], but can be used in combination with [startAt],
  /// [startAfter], [startAtDocument] and [startAfterDocument].
  ///
  /// See also:
  ///
  ///  * [startAfterDocument] for a query that starts after a document.
  ///  * [startAtDocument] for a query that starts at a document.
  ///  * [endBeforeDocument] for a query that ends before a document.
  @override
  Query<Map<String, dynamic>> endAtDocument(DocumentSnapshot documentSnapshot) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);
    return _JsonQuery(
      firestore,
      _delegate.endAtDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that ends at the
  /// provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endAt(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.endAt(values.toList()));
  }

  /// Creates and returns a new [Query] that ends before the provided document
  /// snapshot (exclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endBeforeDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);
    return _JsonQuery(
      firestore,
      _delegate.endBeforeDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that ends before
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endBefore(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(
      firestore,
      _delegate.endBefore(values.toList()),
    );
  }

  /// Fetch the documents for this query.
  ///
  /// To modify how the query is fetched, the [options] parameter can be provided
  /// with a [GetOptions] instance.
  @override
  Future<QuerySnapshot<Map<String, dynamic>>> get([GetOptions? options]) async {
    QuerySnapshotPlatform snapshotDelegate =
        await _delegate.get(options ?? const GetOptions());
    return _JsonQuerySnapshot(firestore, snapshotDelegate);
  }

  /// Creates and returns a new Query that's additionally limited to only return up
  /// to the specified number of documents.
  @override
  Query<Map<String, dynamic>> limit(int limit) {
    assert(limit > 0, 'limit must be a positive number greater than 0');
    return _JsonQuery(firestore, _delegate.limit(limit));
  }

  /// Creates and returns a new Query that only returns the last matching documents.
  ///
  /// You must specify at least one orderBy clause for limitToLast queries,
  /// otherwise an exception will be thrown during execution.
  @override
  Query<Map<String, dynamic>> limitToLast(int limit) {
    assert(limit > 0, 'limit must be a positive number greater than 0');
    List<List<dynamic>> orders = List.from(parameters['orderBy']);
    assert(
      orders.isNotEmpty,
      'limitToLast() queries require specifying at least one orderBy() clause',
    );
    return _JsonQuery(firestore, _delegate.limitToLast(limit));
  }

  /// Notifies of query results at this location.
  @override
  Stream<QuerySnapshot<Map<String, dynamic>>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    if (source == ListenSource.cache &&
        defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        'Listening from cache is not supported on Windows',
      );
    }

    return _delegate
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          listenSource: source,
        )
        .map((item) => _JsonQuerySnapshot(firestore, item));
  }

  /// Creates and returns a new [Query] that's additionally sorted by the specified
  /// [field].
  /// The field may be a [String] representing a single field name or a [FieldPath].
  ///
  /// After a [FieldPath.documentId] order by call, you cannot add any more [orderBy]
  /// calls.
  ///
  /// Furthermore, you may not use [orderBy] on the [FieldPath.documentId] [field] when
  /// using [startAfterDocument], [startAtDocument], [endBeforeDocument],
  /// or [endAtDocument] because the order by clause on the document id
  /// is added by these methods implicitly.
  @override
  Query<Map<String, dynamic>> orderBy(
    Object field, {
    bool descending = false,
  }) {
    _assertValidFieldType(field);
    assert(
      !_hasStartCursor(),
      'Invalid query. '
      'You must not call startAt(), startAtDocument(), '
      'startAfter() or startAfterDocument() before calling orderBy()',
    );
    assert(
      !_hasEndCursor(),
      'Invalid query. '
      'You must not call endAt(), endAtDocument(), '
      'endBefore() or endBeforeDocument() before calling orderBy()',
    );

    final List<List<dynamic>> orders =
        List<List<dynamic>>.from(parameters['orderBy']);

    assert(
      orders.where((List<dynamic> item) => field == item[0]).isEmpty,
      'OrderBy field "$field" already exists in this query',
    );

    if (field == FieldPath.documentId) {
      orders.add([field, descending]);
    } else {
      FieldPath fieldPath =
          field is String ? FieldPath.fromString(field) : field as FieldPath;
      orders.add([fieldPath, descending]);
    }

    return _JsonQuery(firestore, _delegate.orderBy(orders));
  }

  /// Creates and returns a new [Query] that starts after the provided document
  /// (exclusive). The starting position is relative to the order of the query.
  /// The [documentSnapshot] must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAfterDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);

    return _JsonQuery(
      firestore,
      _delegate.startAfterDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that starts
  /// after the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAfter(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.startAfter(values.toList()));
  }

  /// Creates and returns a new [Query] that starts at the provided document
  /// (inclusive). The starting position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAtDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);

    return _JsonQuery(
      firestore,
      _delegate.startAtDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that starts at
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAt(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.startAt(values.toList()));
  }

  /// Creates and returns a new [Query] with additional filter on specified
  /// [fieldOrFilter]. [fieldOrFilter] refers to a field in a document or a [Filter] object.
  ///
  /// The [fieldOrFilter] may be a [String] consisting of a single field name
  /// (referring to a top level field in the document),
  /// a series of field names separated by dots '.'
  /// (referring to a nested field in the document),
  /// or a [Filter] that can be used to combine multiple conditions.
  /// Alternatively, the [field] can also be a [FieldPath].
  ///
  /// Only documents satisfying provided condition are included in the result
  /// set.
  @override
  Query<Map<String, dynamic>> where(
    Object fieldOrFilter, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  }) {
    _assertValidFieldType(fieldOrFilter);

    if (fieldOrFilter is Filter) {
      assert(
        isEqualTo == null &&
            isNotEqualTo == null &&
            isLessThan == null &&
            isLessThanOrEqualTo == null &&
            isGreaterThan == null &&
            isGreaterThanOrEqualTo == null &&
            arrayContains == null &&
            arrayContainsAny == null &&
            whereIn == null &&
            whereNotIn == null &&
            isNull == null,
        'Conditions cannot be used with a Filter. Use a single Filter instead, or use a String or a FieldPath as the first parameter.',
      );
      return _JsonQuery(firestore, _delegate.whereFilter(fieldOrFilter));
    }

    final field = fieldOrFilter;

    const ListEquality<dynamic> equality = ListEquality<dynamic>();
    final List<List<dynamic>> conditions =
        List<List<dynamic>>.from(parameters['where']);

    // Conditions can be chained from other [Query] instances
    void addCondition(dynamic field, String operator, dynamic value) {
      List<dynamic> condition;
      dynamic codecValue = _CodecUtility.valueEncode(value);

      if (field == FieldPath.documentId) {
        condition = <dynamic>[field, operator, codecValue];
      } else {
        FieldPath fieldPath =
            field is String ? FieldPath.fromString(field) : field as FieldPath;
        condition = <dynamic>[fieldPath, operator, codecValue];
      }

      assert(
        conditions
            .where((List<dynamic> item) => equality.equals(condition, item))
            .isEmpty,
        'Condition $condition already exists in this query.',
      );
      conditions.add(condition);
    }

    if (isEqualTo != null) addCondition(field, '==', isEqualTo);
    if (isNotEqualTo != null) addCondition(field, '!=', isNotEqualTo);
    if (isLessThan != null) addCondition(field, '<', isLessThan);
    if (isLessThanOrEqualTo != null) {
      addCondition(field, '<=', isLessThanOrEqualTo);
    }
    if (isGreaterThan != null) addCondition(field, '>', isGreaterThan);
    if (isGreaterThanOrEqualTo != null) {
      addCondition(field, '>=', isGreaterThanOrEqualTo);
    }
    if (arrayContains != null) {
      addCondition(field, 'array-contains', arrayContains);
    }
    if (arrayContainsAny != null) {
      addCondition(field, 'array-contains-any', arrayContainsAny);
    }
    if (whereIn != null) addCondition(field, 'in', whereIn);
    if (whereNotIn != null) addCondition(field, 'not-in', whereNotIn);
    if (isNull != null) {
      if (isNull == true) {
        addCondition(field, '==', null);
      } else {
        addCondition(field, '!=', null);
      }
    }

    bool hasIn = false;
    bool hasNotIn = false;
    bool hasNotEqualTo = false;
    bool hasNotEqualToOperatorAndNotDocumentIdField = false;
    bool hasArrayContains = false;
    bool hasArrayContainsAny = false;
    bool hasDocumentIdField = false;

    // Once all conditions have been set, we must now check them to ensure the
    // query is valid.
    for (final dynamic condition in conditions) {
      dynamic field = condition[0]; // FieldPath or FieldPathType
      String operator = condition[1];
      dynamic value = condition[2];

      if (field != FieldPath.documentId && hasDocumentIdField) {
        assert(
          operator != '!=',
          "You cannot use '!=' filters whilst using a FieldPath.documentId field in another filter.",
        );
      }

      if (field == FieldPath.documentId) {
        assert(
          !hasNotEqualToOperatorAndNotDocumentIdField,
          "You cannot use FieldPath.documentId field whilst using a '!=' filter on a different field.",
        );
        hasDocumentIdField = true;
      }

      if (operator == 'in' ||
          operator == 'array-contains-any' ||
          isNotIn(operator)) {
        assert(
          value is Iterable,
          "A non-empty [Iterable] is required for '$operator' filters.",
        );
        // This assert checks every operator other than "in" or "array-contains-any" have 10 or less filters
        assert(
          (operator == 'in' || operator == 'array-contains-any') ||
              (value as Iterable).length <= 10,
          "'$operator' filters support a maximum of 10 elements in the value [Iterable].",
        );
        // This assert checks whether "in" or "array-contains-any" have 30 or less filters
        assert(
          (operator != 'in' && operator != 'array-contains-any') ||
              (value as Iterable).length <= 30,
          "'$operator' filters support a maximum of 30 elements in the value [Iterable].",
        );
        assert(
          (value as Iterable).isNotEmpty,
          "'$operator' filters require a non-empty [Iterable].",
        );
        assert(
          (value as Iterable).where((value) => value == null).isEmpty,
          "'$operator' filters cannot contain 'null' in the [Iterable].",
        );
      }

      if (operator == '!=') {
        assert(!hasNotEqualTo, "You cannot use '!=' filters more than once.");
        assert(!hasNotIn, "You cannot use '!=' filters with 'not-in' filters.");

        hasNotEqualTo = true;

        if (field != FieldPath.documentId) {
          hasNotEqualToOperatorAndNotDocumentIdField = true;
        }
      }

      if (isNotIn(operator)) {
        assert(!hasNotIn, "You cannot use 'not-in' filters more than once.");
        assert(
          !hasNotEqualTo,
          "You cannot use 'not-in' filters with '!=' filters.",
        );
        assert(
          !hasIn,
          "You cannot use 'not-in' filters with 'in' filters.",
        );
        hasNotIn = true;
      }

      if (operator == 'in') {
        assert(
          !hasNotIn,
          "You cannot use 'in' filters with 'not-in' filters.",
        );
        hasIn = true;
      }

      if (operator == 'array-contains') {
        assert(
          !hasArrayContains,
          "You cannot use 'array-contains' filters more than once.",
        );
        hasArrayContains = true;
      }

      if (operator == 'array-contains-any') {
        assert(
          !hasArrayContainsAny,
          "You cannot use 'array-contains-any' filters more than once.",
        );
        hasArrayContainsAny = true;
      }

      if (operator == 'array-contains' || operator == 'array-contains-any') {
        assert(
          !(hasArrayContains && hasArrayContainsAny),
          "You cannot use both 'array-contains-any' or 'array-contains' filters together.",
        );
      }
    }

    return _JsonQuery(firestore, _delegate.where(conditions));
  }

  @override
  Query<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterQuery(
      this,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) {
    return runtimeType == other.runtimeType &&
        other is _JsonQuery &&
        other.firestore == firestore &&
        other._delegate == _delegate;
  }

  @override
  int get hashCode => Object.hash(runtimeType, firestore, _delegate);

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  @override
  AggregateQuery count() {
    return AggregateQuery._(_delegate.count(), this);
  }

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  @override
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]) {
    return AggregateQuery._(
      _delegate.aggregate(
        aggregateField1,
        aggregateField2,
        aggregateField3,
        aggregateField4,
        aggregateField5,
        aggregateField6,
        aggregateField7,
        aggregateField8,
        aggregateField9,
        aggregateField10,
        aggregateField11,
        aggregateField12,
        aggregateField13,
        aggregateField14,
        aggregateField15,
        aggregateField16,
        aggregateField17,
        aggregateField18,
        aggregateField19,
        aggregateField20,
        aggregateField21,
        aggregateField22,
        aggregateField23,
        aggregateField24,
        aggregateField25,
        aggregateField26,
        aggregateField27,
        aggregateField28,
        aggregateField29,
        aggregateField30,
      ),
      this,
    );
  }
}

class _WithConverterQuery<T extends Object?> implements Query<T> {
  _WithConverterQuery(
    this._originalQuery,
    this._fromFirestore,
    this._toFirestore,
  );

  final Query<Map<String, dynamic>> _originalQuery;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  FirebaseFirestore get firestore => _originalQuery.firestore;

  @override
  Map<String, dynamic> get parameters => _originalQuery.parameters;

  Query<T> _mapQuery(Query<Map<String, dynamic>> newOriginalQuery) {
    return _WithConverterQuery<T>(
      newOriginalQuery,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  Future<QuerySnapshot<T>> get([GetOptions? options]) async {
    final snapshot = await _originalQuery.get(options);
    return _WithConverterQuerySnapshot<T>(
      snapshot,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  Stream<QuerySnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    return _originalQuery
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          source: source,
        )
        .map(
          (snapshot) => _WithConverterQuerySnapshot<T>(
            snapshot,
            _fromFirestore,
            _toFirestore,
          ),
        );
  }

  @override
  Query<T> endAt(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.endAt(values));
  }

  @override
  Query<T> endAtDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.endAtDocument(documentSnapshot));
  }

  @override
  Query<T> endBefore(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.endBefore(values));
  }

  @override
  Query<T> endBeforeDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.endBeforeDocument(documentSnapshot));
  }

  @override
  Query<T> limit(int limit) {
    return _mapQuery(_originalQuery.limit(limit));
  }

  @override
  Query<T> limitToLast(int limit) {
    return _mapQuery(_originalQuery.limitToLast(limit));
  }

  @override
  Query<T> orderBy(Object field, {bool descending = false}) {
    return _mapQuery(_originalQuery.orderBy(field, descending: descending));
  }

  @override
  Query<T> startAfter(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.startAfter(values));
  }

  @override
  Query<T> startAfterDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.startAfterDocument(documentSnapshot));
  }

  @override
  Query<T> startAt(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.startAt(values));
  }

  @override
  Query<T> startAtDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.startAtDocument(documentSnapshot));
  }

  @override
  Query<T> where(
    Object field, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  }) {
    return _mapQuery(
      _originalQuery.where(
        field,
        isEqualTo: isEqualTo,
        isNotEqualTo: isNotEqualTo,
        isLessThan: isLessThan,
        isLessThanOrEqualTo: isLessThanOrEqualTo,
        isGreaterThan: isGreaterThan,
        isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
        arrayContains: arrayContains,
        arrayContainsAny: arrayContainsAny,
        whereIn: whereIn,
        whereNotIn: whereNotIn,
        isNull: isNull,
      ),
    );
  }

  @override
  Query<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterQuery(
      _originalQuery,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) {
    return runtimeType == other.runtimeType &&
        other is _WithConverterQuery<T> &&
        other._fromFirestore == _fromFirestore &&
        other._toFirestore == _toFirestore &&
        other._originalQuery == _originalQuery;
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, _fromFirestore, _toFirestore, _originalQuery);

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  @override
  AggregateQuery count() {
    return _originalQuery.count();
  }

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  @override
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]) {
    return _originalQuery.aggregate(
      aggregateField1,
      aggregateField2,
      aggregateField3,
      aggregateField4,
      aggregateField5,
      aggregateField6,
      aggregateField7,
      aggregateField8,
      aggregateField9,
      aggregateField10,
      aggregateField11,
      aggregateField12,
      aggregateField13,
      aggregateField14,
      aggregateField15,
      aggregateField16,
      aggregateField17,
      aggregateField18,
      aggregateField19,
      aggregateField20,
      aggregateField21,
      aggregateField22,
      aggregateField23,
      aggregateField24,
      aggregateField25,
      aggregateField26,
      aggregateField27,
      aggregateField28,
      aggregateField29,
      aggregateField30,
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/query_document_snapshot.dart

**크기**: 1945 bytes | **라인 수**: 57 | **타입**: text

```
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [QueryDocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database as part of a query.
///
/// A [QueryDocumentSnapshot] offers the same API surface as a [DocumentSnapshot].
/// Since query results contain only existing documents, the exists property
/// will always be `true` and [data()] will never return `null`.
@sealed
abstract class QueryDocumentSnapshot<T extends Object?>
    implements DocumentSnapshot<T> {
  @override
  T data();
}

class _JsonQueryDocumentSnapshot extends _JsonDocumentSnapshot
    implements QueryDocumentSnapshot<Map<String, dynamic>> {
  _JsonQueryDocumentSnapshot(_firestore, _delegate)
      : super(_firestore, _delegate);

  @override
  bool get exists => true;

  @override
  Map<String, dynamic> data() => super.data()!;
}

/// A [QueryDocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database as part of a query.
///
/// A [QueryDocumentSnapshot] offers the same API surface as a [DocumentSnapshot].
/// Since query results contain only existing documents, the exists property
/// will always be `true` and [data()] will never return `null`.
class _WithConverterQueryDocumentSnapshot<T extends Object?>
    extends _WithConverterDocumentSnapshot<T>
    implements QueryDocumentSnapshot<T> {
  _WithConverterQueryDocumentSnapshot(
    QueryDocumentSnapshot<Map<String, dynamic>> originalQueryDocumentSnapshot,
    FromFirestore<T> fromFirestore,
    ToFirestore<T> toFirestore,
  ) : super(
          originalQueryDocumentSnapshot,
          fromFirestore,
          toFirestore,
        );

  @override
  bool get exists => true;

  @override
  T data() => super.data() as T;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/query_snapshot.dart

**크기**: 2945 bytes | **라인 수**: 100 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
abstract class QuerySnapshot<T extends Object?> {
  /// Gets a list of all the documents included in this snapshot.
  List<QueryDocumentSnapshot<T>> get docs;

  /// An array of the documents that changed since the last snapshot. If this
  /// is the first snapshot, all documents will be in the list as Added changes.
  List<DocumentChange<T>> get docChanges;

  /// Returns the [SnapshotMetadata] for this snapshot.
  SnapshotMetadata get metadata;

  /// Returns the size (number of documents) of this snapshot.
  int get size;
}

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
class _JsonQuerySnapshot implements QuerySnapshot<Map<String, dynamic>> {
  _JsonQuerySnapshot(this._firestore, this._delegate) {
    QuerySnapshotPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final QuerySnapshotPlatform _delegate;

  @override
  List<QueryDocumentSnapshot<Map<String, dynamic>>> get docs => _delegate.docs
      .map(
        (documentDelegate) =>
            _JsonQueryDocumentSnapshot(_firestore, documentDelegate),
      )
      .toList();

  @override
  List<DocumentChange<Map<String, dynamic>>> get docChanges {
    return _delegate.docChanges.map((documentDelegate) {
      return _JsonDocumentChange(_firestore, documentDelegate);
    }).toList();
  }

  @override
  SnapshotMetadata get metadata => SnapshotMetadata._(_delegate.metadata);

  @override
  int get size => _delegate.size;
}

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
class _WithConverterQuerySnapshot<T extends Object?>
    implements QuerySnapshot<T> {
  _WithConverterQuerySnapshot(
    this._originalQuerySnapshot,
    this._fromFirestore,
    this._toFirestore,
  );

  final QuerySnapshot<Map<String, dynamic>> _originalQuerySnapshot;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  List<QueryDocumentSnapshot<T>> get docs {
    return [
      for (final snapshot in _originalQuerySnapshot.docs)
        _WithConverterQueryDocumentSnapshot<T>(
          snapshot,
          _fromFirestore,
          _toFirestore,
        ),
    ];
  }

  @override
  List<DocumentChange<T>> get docChanges {
    return [
      for (final change in _originalQuerySnapshot.docChanges)
        _WithConverterDocumentChange<T>(
          change,
          _fromFirestore,
          _toFirestore,
        ),
    ];
  }

  @override
  SnapshotMetadata get metadata => _originalQuerySnapshot.metadata;

  @override
  int get size => _originalQuerySnapshot.size;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/snapshot_metadata.dart

**크기**: 1321 bytes | **라인 수**: 31 | **타입**: text

```
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Metadata about a snapshot, describing the state of the snapshot.
class SnapshotMetadata {
  SnapshotMetadataPlatform _delegate;

  SnapshotMetadata._(this._delegate);

  /// Whether the snapshot contains the result of local writes that have not yet
  /// been committed to the backend.
  ///
  /// If you called [DocumentReference.snapshots] or [Query.snapshots] with
  /// `includeMetadataChanges` parameter set to `true` you will receive another
  /// snapshot with `hasPendingWrites` equal to `false` once the writes have been
  /// committed to the backend.
  bool get hasPendingWrites => _delegate.hasPendingWrites;

  /// Whether the snapshot was created from cached data rather than guaranteed
  /// up-to-date server data.
  ///
  /// If you called [DocumentReference.snapshots] or [Query.snapshots] with
  /// `includeMetadataChanges` parameter set to `true` you will receive another
  /// snapshot with `isFromCache` equal to `false` once the client has received
  /// up-to-date data from the backend.
  bool get isFromCache => _delegate.isFromCache;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/transaction.dart

**크기**: 3537 bytes | **라인 수**: 112 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// The [TransactionHandler] may be executed multiple times; it should be able
/// to handle multiple executions.
typedef TransactionHandler<T> = Future<T> Function(Transaction transaction);

/// Transaction class which is created from a call to [runTransaction()].
class Transaction {
  final FirebaseFirestore _firestore;
  final TransactionPlatform _delegate;

  Transaction._(this._firestore, this._delegate) {
    TransactionPlatform.verify(_delegate);
  }

  /// Reads the document referenced by the provided [DocumentReference].
  ///
  /// If the document changes whilst the transaction is in progress, it will
  /// be re-tried up to five times.
  Future<DocumentSnapshot<T>> get<T extends Object?>(
    DocumentReference<T> documentReference,
  ) async {
    DocumentSnapshotPlatform documentSnapshotPlatform =
        await _delegate.get(documentReference.path);

    final snapshot =
        _JsonDocumentSnapshot(_firestore, documentSnapshotPlatform);

    if (snapshot is DocumentSnapshot<T>) {
      return snapshot as DocumentSnapshot<T>;
    }

    final withConverterDocRef =
        documentReference as _WithConverterDocumentReference<T>;

    return _WithConverterDocumentSnapshot<T>(
      snapshot,
      withConverterDocRef._fromFirestore,
      withConverterDocRef._toFirestore,
    );
  }

  /// Deletes the document referred to by the provided [documentReference].
  Transaction delete(DocumentReference documentReference) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    return Transaction._(
      _firestore,
      _delegate.delete(documentReference.path),
    );
  }

  /// Updates fields in the document referred to by [documentReference].
  /// The update will fail if applied to a document that does not exist.
  Transaction update(
    DocumentReference documentReference,
    Map<String, dynamic> data,
  ) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    return Transaction._(
      _firestore,
      _delegate.update(
        documentReference.path,
        _CodecUtility.replaceValueWithDelegatesInMap(data)!,
      ),
    );
  }

  /// Writes to the document referred to by the provided [DocumentReference].
  /// If the document does not exist yet, it will be created. If you pass
  /// [SetOptions], the provided data can be merged into the existing document.
  Transaction set<T>(
    DocumentReference<T> documentReference,
    T data, [
    SetOptions? options,
  ]) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    Map<String, dynamic> firestoreData;
    if (documentReference is _JsonDocumentReference) {
      firestoreData = data as Map<String, dynamic>;
    } else {
      final withConverterDoc =
          documentReference as _WithConverterDocumentReference<T>;
      firestoreData = withConverterDoc._toFirestore(data, options);
    }

    return Transaction._(
      _firestore,
      _delegate.set(
        documentReference.path,
        _CodecUtility.replaceValueWithDelegatesInMap(firestoreData)!,
        options,
      ),
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/src/write_batch.dart

**크기**: 2562 bytes | **라인 수**: 80 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [WriteBatch] is a series of write operations to be performed as one unit.
///
/// Operations done on a [WriteBatch] do not take effect until you [commit()].
///
/// Once committed, no further operations can be performed on the [WriteBatch],
/// nor can it be committed again.
class WriteBatch {
  WriteBatch._(this._firestore, this._delegate) {
    WriteBatchPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final WriteBatchPlatform _delegate;

  /// Commits all of the writes in this write batch as a single atomic unit.
  ///
  /// Calling this method prevents any future operations from being added.
  Future<void> commit() => _delegate.commit();

  /// Deletes the document referred to by [document].
  void delete(DocumentReference document) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );
    return _delegate.delete(document.path);
  }

  /// Writes to the document referred to by [document].
  ///
  /// If the document does not yet exist, it will be created.
  ///
  /// If [SetOptions] are provided, the data will be merged into an existing
  /// document instead of overwriting.
  void set<T>(
    DocumentReference<T> document,
    T data, [
    SetOptions? options,
  ]) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    Map<String, dynamic> firestoreData;
    if (document is _JsonDocumentReference) {
      firestoreData = data as Map<String, dynamic>;
    } else {
      final withConverterDoc = document as _WithConverterDocumentReference<T>;
      firestoreData = withConverterDoc._toFirestore(data, options);
    }

    return _delegate.set(
      document.path,
      _CodecUtility.replaceValueWithDelegatesInMap(firestoreData)!,
      options,
    );
  }

  /// Updates a given [document].
  ///
  /// If the document does not yet exist, an exception will be thrown.
  void update(DocumentReference document, Map<String, dynamic> data) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );
    return _delegate.update(
      document.path,
      _CodecUtility.replaceValueWithDelegatesInMap(data)!,
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/lib/cloud_firestore.dart

**크기**: 2033 bytes | **라인 수**: 64 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebasePluginPlatform;
import 'package:flutter/foundation.dart';
import 'package:meta/meta.dart';

export 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart'
    show
        AggregateField,
        AggregateSource,
        ListEquality,
        FieldPath,
        Blob,
        GeoPoint,
        VectorValue,
        Timestamp,
        Source,
        GetOptions,
        ServerTimestampBehavior,
        SetOptions,
        ListenSource,
        DocumentChangeType,
        PersistenceSettings,
        Settings,
        WebExperimentalLongPollingOptions,
        IndexField,
        Index,
        FieldOverrides,
        FieldOverrideIndex,
        Order,
        ArrayConfig,
        QueryScope,
        LoadBundleTaskState,
        average,
        count,
        sum;
export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseException;

part 'src/aggregate_query.dart';
part 'src/aggregate_query_snapshot.dart';
part 'src/collection_reference.dart';
part 'src/document_change.dart';
part 'src/document_reference.dart';
part 'src/document_snapshot.dart';
part 'src/field_value.dart';
part 'src/filters.dart';
part 'src/firestore.dart';
part 'src/load_bundle_task.dart';
part 'src/load_bundle_task_snapshot.dart';
part 'src/persistent_cache_index_manager.dart';
part 'src/query.dart';
part 'src/query_document_snapshot.dart';
part 'src/query_snapshot.dart';
part 'src/snapshot_metadata.dart';
part 'src/transaction.dart';
part 'src/utils/codec_utility.dart';
part 'src/write_batch.dart';

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h

**크기**: 1214 bytes | **라인 수**: 38 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTDocumentSnapshotStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FIRDocumentReference *reference;
@property(nonatomic, assign) BOOL includeMetadataChanges;
@property(nonatomic, assign) FIRListenSource source;
@property(nonatomic, assign) FIRServerTimestampBehavior serverTimestampBehavior;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                        reference:(FIRDocumentReference *)reference
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h

**크기**: 567 bytes | **라인 수**: 16 | **타입**: text

```
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <FirebaseFirestore/FirebaseFirestore.h>
#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreExtension : NSObject

@property(nonatomic, strong, readonly) FIRFirestore *instance;
@property(nonatomic, strong, readonly) NSString *databaseURL;

- (instancetype)initWithFirestoreInstance:(FIRFirestore *)instance
                              databaseURL:(NSString *)databaseURL;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h

**크기**: 471 bytes | **라인 수**: 18 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreReader : FlutterStandardReader
- (id)readValueOfType:(UInt8)type;
+ (dispatch_queue_t)getFirestoreQueue;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h

**크기**: 2655 bytes | **라인 수**: 67 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#import <Foundation/Foundation.h>
#import "FLTFirebaseFirestoreExtension.h"

typedef NS_ENUM(UInt8, FirestoreDataType) {
  FirestoreDataTypeDateTime = 180,
  FirestoreDataTypeGeoPoint = 181,
  FirestoreDataTypeDocumentReference = 182,
  FirestoreDataTypeBlob = 183,
  FirestoreDataTypeArrayUnion = 184,
  FirestoreDataTypeArrayRemove = 185,
  FirestoreDataTypeDelete = 186,
  FirestoreDataTypeServerTimestamp = 187,
  FirestoreDataTypeTimestamp = 188,
  FirestoreDataTypeIncrementDouble = 189,
  FirestoreDataTypeIncrementInteger = 190,
  FirestoreDataTypeDocumentId = 191,
  FirestoreDataTypeFieldPath = 192,
  FirestoreDataTypeNaN = 193,
  FirestoreDataTypeInfinity = 194,
  FirestoreDataTypeNegativeInfinity = 195,
  FirestoreDataTypeFirestoreInstance = 196,
  FirestoreDataTypeFirestoreQuery = 197,
  FirestoreDataTypeFirestoreSettings = 198,
  FirestoreDataTypeVectorValue = 199,
};

@interface FLTFirebaseFirestoreReaderWriter : FlutterStandardReaderWriter
- (FlutterStandardWriter *_Nonnull)writerWithData:(NSMutableData *_Nullable)data;
- (FlutterStandardReader *_Nonnull)readerWithData:(NSData *_Nullable)data;
@end

@interface FLTFirebaseFirestoreUtils : NSObject
+ (FIRFirestoreSource)FIRFirestoreSourceFromArguments:(NSDictionary *_Nonnull)arguments;
+ (NSArray *_Nonnull)ErrorCodeAndMessageFromNSError:(NSError *_Nonnull)error;
+ (FLTFirebaseFirestoreExtension *_Nullable)
    getCachedFIRFirestoreInstanceForAppName:(NSString *_Nonnull)appName
                                databaseURL:(NSString *_Nonnull)url;
+ (void)setCachedFIRFirestoreInstance:(FIRFirestore *_Nonnull)firestore
                           forAppName:(NSString *_Nonnull)appName
                          databaseURL:(NSString *_Nonnull)url;
+ (void)destroyCachedInstanceForFirestore:(NSString *_Nonnull)appName
                              databaseURL:(NSString *_Nonnull)databaseURL;
+ (FIRFirestore *_Nullable)getFirestoreInstanceByName:(NSString *_Nonnull)appName
                                          databaseURL:(NSString *_Nonnull)databaseURL;
+ (void)cleanupFirestoreInstances:(void (^_Nullable)(void))completion;
+ (NSUInteger)count;
+ (FLTFirebaseFirestoreExtension *_Nullable)getCachedInstanceForFirestore:
    (FIRFirestore *_Nonnull)firestore;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h

**크기**: 427 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

@interface FLTFirebaseFirestoreWriter : FlutterStandardWriter
- (void)writeValue:(id)value;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h

**크기**: 968 bytes | **라인 수**: 41 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

//
//  FLTLoadBundleStreamHandler.h
//  Pods
//
//  Created by Russell Wheatley on 05/05/2021.
//
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTLoadBundleStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FlutterStandardTypedData *bundle;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                           bundle:(FlutterStandardTypedData *)bundle;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h

**크기**: 1072 bytes | **라인 수**: 32 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTQuerySnapshotStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) FIRQuery *query;
@property(nonatomic, assign) BOOL includeMetadataChanges;
@property(nonatomic, assign) FIRListenSource source;
@property(nonatomic, assign) FIRServerTimestampBehavior serverTimestampBehavior;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                            query:(FIRQuery *)query
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h

**크기**: 577 bytes | **라인 수**: 24 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTSnapshotsInSyncStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;

- (instancetype)initWithFirestore:(FIRFirestore *)firestore;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FLTTransactionStreamHandler.h

**크기**: 1384 bytes | **라인 수**: 43 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#if __has_include(<cloud_firestore/FirestoreMessages.g.h>)
#import <cloud_firestore/FirestoreMessages.g.h>
#else
#import "../Public/FirestoreMessages.g.h"
#endif
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface FLTTransactionStreamHandler : NSObject <FlutterStreamHandler>
@property(nonatomic, strong) FIRFirestore *firestore;
@property(nonatomic, strong) NSNumber *timeout;
@property(nonatomic, strong) NSNumber *maxAttempts;

- (instancetype)initWithId:(NSString *)transactionId
                 firestore:(FIRFirestore *)firestore
                   timeout:(nonnull NSNumber *)timeout
               maxAttempts:(nonnull NSNumber *)maxAttempts
                   started:(void (^)(FIRTransaction *))startedListener
                     ended:(void (^)(void))endedListener;
- (void)receiveTransactionResponse:(PigeonTransactionResult)resultType
                          commands:(NSArray<PigeonTransactionCommand *> *)commands;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Private/FirestorePigeonParser.h

**크기**: 2428 bytes | **라인 수**: 59 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#if TARGET_OS_OSX
#import <FirebaseFirestore/FirebaseFirestore.h>
#else
@import FirebaseFirestore;
#endif
#import <Foundation/Foundation.h>
#if __has_include(<cloud_firestore/FirestoreMessages.g.h>)
#import <cloud_firestore/FirestoreMessages.g.h>
#else
#import "../Public/FirestoreMessages.g.h"
#endif
@interface FirestorePigeonParser : NSObject

+ (FIRFilter *_Nonnull)filterFromJson:(NSDictionary<NSString *, id> *_Nullable)map;

+ (FIRQuery *_Nonnull)parseQueryWithParameters:(nonnull PigeonQueryParameters *)parameters
                                     firestore:(nonnull FIRFirestore *)firestore
                                          path:(nonnull NSString *)path
                             isCollectionGroup:(Boolean)isCollectionGroup;

+ (FIRFirestoreSource)parseSource:(Source)source;

+ (NSArray<FIRFieldPath *> *_Nonnull)parseFieldPath:
    (NSArray<NSArray<NSString *> *> *_Nonnull)fieldPaths;

+ (FIRServerTimestampBehavior)parseServerTimestampBehavior:
    (ServerTimestampBehavior)serverTimestampBehavior;

+ (FIRListenSource)parseListenSource:(ListenSource)source;

+ (PigeonSnapshotMetadata *_Nonnull)toPigeonSnapshotMetadata:
    (FIRSnapshotMetadata *_Nonnull)snapshotMetadata;

+ (PigeonDocumentSnapshot *_Nonnull)
    toPigeonDocumentSnapshot:(FIRDocumentSnapshot *_Nonnull)documentSnapshot
     serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior;

+ (DocumentChangeType)toPigeonDocumentChangeType:(FIRDocumentChangeType)documentChangeType;

+ (PigeonDocumentChange *_Nonnull)toPigeonDocumentChange:(FIRDocumentChange *_Nonnull)documentChange
                                 serverTimestampBehavior:
                                     (FIRServerTimestampBehavior)serverTimestampBehavior;

+ (NSArray<PigeonDocumentChange *> *_Nonnull)
    toPigeonDocumentChanges:(NSArray<FIRDocumentChange *> *_Nonnull)documentChanges
    serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior;

+ (PigeonQuerySnapshot *_Nonnull)toPigeonQuerySnapshot:(FIRQuerySnapshot *_Nonnull)querySnaphot
                               serverTimestampBehavior:
                                   (FIRServerTimestampBehavior)serverTimestampBehavior;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h

**크기**: 411 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import "FirestoreMessages.g.h"

@interface PigeonDocumentSnapshot (Map)
- (NSDictionary *)toList;
@end

@interface PigeonDocumentChange (Map)
- (NSDictionary *)toList;
@end

@interface PigeonSnapshotMetadata (Map)
- (NSDictionary *)toList;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h

**크기**: 701 bytes | **라인 수**: 24 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>
#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "FirestoreMessages.g.h"

@interface FLTFirebaseFirestorePlugin
    : FLTFirebasePlugin <FlutterPlugin, FLTFirebasePlugin, FirebaseFirestoreHostApi>
+ (NSMutableDictionary<NSNumber *, NSString *> *)serverTimestampMap;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/include/cloud_firestore/Public/FirestoreMessages.g.h

**크기**: 20917 bytes | **라인 수**: 425 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

/// An enumeration of document change types.
typedef NS_ENUM(NSUInteger, DocumentChangeType) {
  /// Indicates a new document was added to the set of documents matching the
  /// query.
  DocumentChangeTypeAdded = 0,
  /// Indicates a document within the query was modified.
  DocumentChangeTypeModified = 1,
  /// Indicates a document within the query was removed (either deleted or no
  /// longer matches the query.
  DocumentChangeTypeRemoved = 2,
};

/// Wrapper for DocumentChangeType to allow for nullability.
@interface DocumentChangeTypeBox : NSObject
@property(nonatomic, assign) DocumentChangeType value;
- (instancetype)initWithValue:(DocumentChangeType)value;
@end

/// An enumeration of firestore source types.
typedef NS_ENUM(NSUInteger, Source) {
  /// Causes Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall back
  /// to
  /// returning cached data if the server can't be reached.
  SourceServerAndCache = 0,
  /// Causes Firestore to avoid the cache, generating an error if the server cannot be reached. Note
  /// that the cache will still be updated if the server request succeeds. Also note that
  /// latency-compensation still takes effect, so any pending write operations will be visible in
  /// the
  /// returned data (merged into the server-provided data).
  SourceServer = 1,
  /// Causes Firestore to immediately return a value from the cache, ignoring the server completely
  /// (implying that the returned value may be stale with respect to the value on the server). If
  /// there is no data in the cache to satisfy the `get` call,
  /// [DocumentReference.get] will throw a [FirebaseException] and
  /// [Query.get] will return an empty [QuerySnapshotPlatform] with no documents.
  SourceCache = 2,
};

/// Wrapper for Source to allow for nullability.
@interface SourceBox : NSObject
@property(nonatomic, assign) Source value;
- (instancetype)initWithValue:(Source)value;
@end

/// The listener retrieves data and listens to updates from the local Firestore cache only.
/// If the cache is empty, an empty snapshot will be returned.
/// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
///
/// Note that the data might be stale if the cache hasn't synchronized with recent server-side
/// changes.
typedef NS_ENUM(NSUInteger, ListenSource) {
  /// The default behavior. The listener attempts to return initial snapshot from cache and retrieve
  /// up-to-date snapshots from the Firestore server.
  /// Snapshot events will be triggered on local mutations and server side updates.
  ListenSourceDefaultSource = 0,
  /// The listener retrieves data and listens to updates from the local Firestore cache only.
  /// If the cache is empty, an empty snapshot will be returned.
  /// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
  ListenSourceCache = 1,
};

/// Wrapper for ListenSource to allow for nullability.
@interface ListenSourceBox : NSObject
@property(nonatomic, assign) ListenSource value;
- (instancetype)initWithValue:(ListenSource)value;
@end

typedef NS_ENUM(NSUInteger, ServerTimestampBehavior) {
  /// Return null for [FieldValue.serverTimestamp()] values that have not yet
  ServerTimestampBehaviorNone = 0,
  /// Return local estimates for [FieldValue.serverTimestamp()] values that have not yet been set to
  /// their final value.
  ServerTimestampBehaviorEstimate = 1,
  /// Return the previous value for [FieldValue.serverTimestamp()] values that have not yet been set
  /// to their final value.
  ServerTimestampBehaviorPrevious = 2,
};

/// Wrapper for ServerTimestampBehavior to allow for nullability.
@interface ServerTimestampBehaviorBox : NSObject
@property(nonatomic, assign) ServerTimestampBehavior value;
- (instancetype)initWithValue:(ServerTimestampBehavior)value;
@end

/// [AggregateSource] represents the source of data for an [AggregateQuery].
typedef NS_ENUM(NSUInteger, AggregateSource) {
  /// Indicates that the data should be retrieved from the server.
  AggregateSourceServer = 0,
};

/// Wrapper for AggregateSource to allow for nullability.
@interface AggregateSourceBox : NSObject
@property(nonatomic, assign) AggregateSource value;
- (instancetype)initWithValue:(AggregateSource)value;
@end

/// [PersistenceCacheIndexManagerRequest] represents the request types for the persistence cache
/// index manager.
typedef NS_ENUM(NSUInteger, PersistenceCacheIndexManagerRequest) {
  PersistenceCacheIndexManagerRequestEnableIndexAutoCreation = 0,
  PersistenceCacheIndexManagerRequestDisableIndexAutoCreation = 1,
  PersistenceCacheIndexManagerRequestDeleteAllIndexes = 2,
};

/// Wrapper for PersistenceCacheIndexManagerRequest to allow for nullability.
@interface PersistenceCacheIndexManagerRequestBox : NSObject
@property(nonatomic, assign) PersistenceCacheIndexManagerRequest value;
- (instancetype)initWithValue:(PersistenceCacheIndexManagerRequest)value;
@end

typedef NS_ENUM(NSUInteger, PigeonTransactionResult) {
  PigeonTransactionResultSuccess = 0,
  PigeonTransactionResultFailure = 1,
};

/// Wrapper for PigeonTransactionResult to allow for nullability.
@interface PigeonTransactionResultBox : NSObject
@property(nonatomic, assign) PigeonTransactionResult value;
- (instancetype)initWithValue:(PigeonTransactionResult)value;
@end

typedef NS_ENUM(NSUInteger, PigeonTransactionType) {
  PigeonTransactionTypeGet = 0,
  PigeonTransactionTypeUpdate = 1,
  PigeonTransactionTypeSet = 2,
  PigeonTransactionTypeDeleteType = 3,
};

/// Wrapper for PigeonTransactionType to allow for nullability.
@interface PigeonTransactionTypeBox : NSObject
@property(nonatomic, assign) PigeonTransactionType value;
- (instancetype)initWithValue:(PigeonTransactionType)value;
@end

typedef NS_ENUM(NSUInteger, AggregateType) {
  AggregateTypeCount = 0,
  AggregateTypeSum = 1,
  AggregateTypeAverage = 2,
};

/// Wrapper for AggregateType to allow for nullability.
@interface AggregateTypeBox : NSObject
@property(nonatomic, assign) AggregateType value;
- (instancetype)initWithValue:(AggregateType)value;
@end

@class PigeonFirebaseSettings;
@class FirestorePigeonFirebaseApp;
@class PigeonSnapshotMetadata;
@class PigeonDocumentSnapshot;
@class PigeonDocumentChange;
@class PigeonQuerySnapshot;
@class PigeonGetOptions;
@class PigeonDocumentOption;
@class PigeonTransactionCommand;
@class DocumentReferenceRequest;
@class PigeonQueryParameters;
@class AggregateQuery;
@class AggregateQueryResponse;

@interface PigeonFirebaseSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPersistenceEnabled:(nullable NSNumber *)persistenceEnabled
                                      host:(nullable NSString *)host
                                sslEnabled:(nullable NSNumber *)sslEnabled
                            cacheSizeBytes:(nullable NSNumber *)cacheSizeBytes
                 ignoreUndefinedProperties:(NSNumber *)ignoreUndefinedProperties;
@property(nonatomic, strong, nullable) NSNumber *persistenceEnabled;
@property(nonatomic, copy, nullable) NSString *host;
@property(nonatomic, strong, nullable) NSNumber *sslEnabled;
@property(nonatomic, strong, nullable) NSNumber *cacheSizeBytes;
@property(nonatomic, strong) NSNumber *ignoreUndefinedProperties;
@end

@interface FirestorePigeonFirebaseApp : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppName:(NSString *)appName
                       settings:(PigeonFirebaseSettings *)settings
                    databaseURL:(NSString *)databaseURL;
@property(nonatomic, copy) NSString *appName;
@property(nonatomic, strong) PigeonFirebaseSettings *settings;
@property(nonatomic, copy) NSString *databaseURL;
@end

@interface PigeonSnapshotMetadata : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithHasPendingWrites:(NSNumber *)hasPendingWrites
                             isFromCache:(NSNumber *)isFromCache;
@property(nonatomic, strong) NSNumber *hasPendingWrites;
@property(nonatomic, strong) NSNumber *isFromCache;
@end

@interface PigeonDocumentSnapshot : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                    metadata:(PigeonSnapshotMetadata *)metadata;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *data;
@property(nonatomic, strong) PigeonSnapshotMetadata *metadata;
@end

@interface PigeonDocumentChange : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(DocumentChangeType)type
                    document:(PigeonDocumentSnapshot *)document
                    oldIndex:(NSNumber *)oldIndex
                    newIndex:(NSNumber *)newIndex;
@property(nonatomic, assign) DocumentChangeType type;
@property(nonatomic, strong) PigeonDocumentSnapshot *document;
@property(nonatomic, strong) NSNumber *oldIndex;
@property(nonatomic, strong) NSNumber *index;
@end

@interface PigeonQuerySnapshot : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDocuments:(NSArray<PigeonDocumentSnapshot *> *)documents
                  documentChanges:(NSArray<PigeonDocumentChange *> *)documentChanges
                         metadata:(PigeonSnapshotMetadata *)metadata;
@property(nonatomic, strong) NSArray<PigeonDocumentSnapshot *> *documents;
@property(nonatomic, strong) NSArray<PigeonDocumentChange *> *documentChanges;
@property(nonatomic, strong) PigeonSnapshotMetadata *metadata;
@end

@interface PigeonGetOptions : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithSource:(Source)source
       serverTimestampBehavior:(ServerTimestampBehavior)serverTimestampBehavior;
@property(nonatomic, assign) Source source;
@property(nonatomic, assign) ServerTimestampBehavior serverTimestampBehavior;
@end

@interface PigeonDocumentOption : NSObject
+ (instancetype)makeWithMerge:(nullable NSNumber *)merge
                  mergeFields:(nullable NSArray<NSArray<NSString *> *> *)mergeFields;
@property(nonatomic, strong, nullable) NSNumber *merge;
@property(nonatomic, strong, nullable) NSArray<NSArray<NSString *> *> *mergeFields;
@end

@interface PigeonTransactionCommand : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(PigeonTransactionType)type
                        path:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                      option:(nullable PigeonDocumentOption *)option;
@property(nonatomic, assign) PigeonTransactionType type;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *data;
@property(nonatomic, strong, nullable) PigeonDocumentOption *option;
@end

@interface DocumentReferenceRequest : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<id, id> *)data
                      option:(nullable PigeonDocumentOption *)option
                      source:(nullable SourceBox *)source
     serverTimestampBehavior:(nullable ServerTimestampBehaviorBox *)serverTimestampBehavior;
@property(nonatomic, copy) NSString *path;
@property(nonatomic, strong, nullable) NSDictionary<id, id> *data;
@property(nonatomic, strong, nullable) PigeonDocumentOption *option;
@property(nonatomic, strong, nullable) SourceBox *source;
@property(nonatomic, strong, nullable) ServerTimestampBehaviorBox *serverTimestampBehavior;
@end

@interface PigeonQueryParameters : NSObject
+ (instancetype)makeWithWhere:(nullable NSArray<NSArray<id> *> *)where
                      orderBy:(nullable NSArray<NSArray<id> *> *)orderBy
                        limit:(nullable NSNumber *)limit
                  limitToLast:(nullable NSNumber *)limitToLast
                      startAt:(nullable NSArray<id> *)startAt
                   startAfter:(nullable NSArray<id> *)startAfter
                        endAt:(nullable NSArray<id> *)endAt
                    endBefore:(nullable NSArray<id> *)endBefore
                      filters:(nullable NSDictionary<NSString *, id> *)filters;
@property(nonatomic, strong, nullable) NSArray<NSArray<id> *> *where;
@property(nonatomic, strong, nullable) NSArray<NSArray<id> *> *orderBy;
@property(nonatomic, strong, nullable) NSNumber *limit;
@property(nonatomic, strong, nullable) NSNumber *limitToLast;
@property(nonatomic, strong, nullable) NSArray<id> *startAt;
@property(nonatomic, strong, nullable) NSArray<id> *startAfter;
@property(nonatomic, strong, nullable) NSArray<id> *endAt;
@property(nonatomic, strong, nullable) NSArray<id> *endBefore;
@property(nonatomic, strong, nullable) NSDictionary<NSString *, id> *filters;
@end

@interface AggregateQuery : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(AggregateType)type field:(nullable NSString *)field;
@property(nonatomic, assign) AggregateType type;
@property(nonatomic, copy, nullable) NSString *field;
@end

@interface AggregateQueryResponse : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithType:(AggregateType)type
                       field:(nullable NSString *)field
                       value:(nullable NSNumber *)value;
@property(nonatomic, assign) AggregateType type;
@property(nonatomic, copy, nullable) NSString *field;
@property(nonatomic, strong, nullable) NSNumber *value;
@end

/// The codec used by FirebaseFirestoreHostApi.
NSObject<FlutterMessageCodec> *FirebaseFirestoreHostApiGetCodec(void);

@protocol FirebaseFirestoreHostApi
- (void)loadBundleApp:(FirestorePigeonFirebaseApp *)app
               bundle:(FlutterStandardTypedData *)bundle
           completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)namedQueryGetApp:(FirestorePigeonFirebaseApp *)app
                    name:(NSString *)name
                 options:(PigeonGetOptions *)options
              completion:
                  (void (^)(PigeonQuerySnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)clearPersistenceApp:(FirestorePigeonFirebaseApp *)app
                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)disableNetworkApp:(FirestorePigeonFirebaseApp *)app
               completion:(void (^)(FlutterError *_Nullable))completion;
- (void)enableNetworkApp:(FirestorePigeonFirebaseApp *)app
              completion:(void (^)(FlutterError *_Nullable))completion;
- (void)terminateApp:(FirestorePigeonFirebaseApp *)app
          completion:(void (^)(FlutterError *_Nullable))completion;
- (void)waitForPendingWritesApp:(FirestorePigeonFirebaseApp *)app
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setIndexConfigurationApp:(FirestorePigeonFirebaseApp *)app
              indexConfiguration:(NSString *)indexConfiguration
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setLoggingEnabledLoggingEnabled:(NSNumber *)loggingEnabled
                             completion:(void (^)(FlutterError *_Nullable))completion;
- (void)snapshotsInSyncSetupApp:(FirestorePigeonFirebaseApp *)app
                     completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)transactionCreateApp:(FirestorePigeonFirebaseApp *)app
                     timeout:(NSNumber *)timeout
                 maxAttempts:(NSNumber *)maxAttempts
                  completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)transactionStoreResultTransactionId:(NSString *)transactionId
                                 resultType:(PigeonTransactionResult)resultType
                                   commands:(nullable NSArray<PigeonTransactionCommand *> *)commands
                                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)transactionGetApp:(FirestorePigeonFirebaseApp *)app
            transactionId:(NSString *)transactionId
                     path:(NSString *)path
               completion:
                   (void (^)(PigeonDocumentSnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)documentReferenceSetApp:(FirestorePigeonFirebaseApp *)app
                        request:(DocumentReferenceRequest *)request
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)documentReferenceUpdateApp:(FirestorePigeonFirebaseApp *)app
                           request:(DocumentReferenceRequest *)request
                        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)documentReferenceGetApp:(FirestorePigeonFirebaseApp *)app
                        request:(DocumentReferenceRequest *)request
                     completion:(void (^)(PigeonDocumentSnapshot *_Nullable,
                                          FlutterError *_Nullable))completion;
- (void)documentReferenceDeleteApp:(FirestorePigeonFirebaseApp *)app
                           request:(DocumentReferenceRequest *)request
                        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)queryGetApp:(FirestorePigeonFirebaseApp *)app
                 path:(NSString *)path
    isCollectionGroup:(NSNumber *)isCollectionGroup
           parameters:(PigeonQueryParameters *)parameters
              options:(PigeonGetOptions *)options
           completion:(void (^)(PigeonQuerySnapshot *_Nullable, FlutterError *_Nullable))completion;
- (void)aggregateQueryApp:(FirestorePigeonFirebaseApp *)app
                     path:(NSString *)path
               parameters:(PigeonQueryParameters *)parameters
                   source:(AggregateSource)source
                  queries:(NSArray<AggregateQuery *> *)queries
        isCollectionGroup:(NSNumber *)isCollectionGroup
               completion:(void (^)(NSArray<AggregateQueryResponse *> *_Nullable,
                                    FlutterError *_Nullable))completion;
- (void)writeBatchCommitApp:(FirestorePigeonFirebaseApp *)app
                     writes:(NSArray<PigeonTransactionCommand *> *)writes
                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)querySnapshotApp:(FirestorePigeonFirebaseApp *)app
                      path:(NSString *)path
         isCollectionGroup:(NSNumber *)isCollectionGroup
                parameters:(PigeonQueryParameters *)parameters
                   options:(PigeonGetOptions *)options
    includeMetadataChanges:(NSNumber *)includeMetadataChanges
                    source:(ListenSource)source
                completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)documentReferenceSnapshotApp:(FirestorePigeonFirebaseApp *)app
                          parameters:(DocumentReferenceRequest *)parameters
              includeMetadataChanges:(NSNumber *)includeMetadataChanges
                              source:(ListenSource)source
                          completion:
                              (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)persistenceCacheIndexManagerRequestApp:(FirestorePigeonFirebaseApp *)app
                                       request:(PersistenceCacheIndexManagerRequest)request
                                    completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void FirebaseFirestoreHostApiSetup(id<FlutterBinaryMessenger> binaryMessenger,
                                          NSObject<FirebaseFirestoreHostApi> *_Nullable api);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTDocumentSnapshotStreamHandler.m

**크기**: 3186 bytes | **라인 수**: 83 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h"

@interface FLTDocumentSnapshotStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTDocumentSnapshotStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore
                                reference:(nonnull FIRDocumentReference *)reference
                   includeMetadataChanges:(BOOL)includeMetadataChanges
                  serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                                   source:(FIRListenSource)source {
  self = [super init];
  if (self) {
    self.firestore = firestore;
    self.reference = reference;
    self.includeMetadataChanges = includeMetadataChanges;
    self.serverTimestampBehavior = serverTimestampBehavior;
    self.source = source;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  id listener = ^(FIRDocumentSnapshot *snapshot, NSError *_Nullable error) {
    if (error) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
      NSString *code = codeAndMessage[0];
      NSString *message = codeAndMessage[1];
      NSDictionary *details = @{
        @"code" : code,
        @"message" : message,
      };
      dispatch_async(dispatch_get_main_queue(), ^{
        events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                     message:message
                                             optionalDetails:details
                                          andOptionalNSError:error]);
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        events(
            [[FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                     serverTimestampBehavior:self.serverTimestampBehavior] toList]);
      });
    }
  };

  FIRSnapshotListenOptions *options = [[FIRSnapshotListenOptions alloc] init];
  FIRSnapshotListenOptions *optionsWithSourceAndMetadata = [[options
      optionsWithIncludeMetadataChanges:_includeMetadataChanges] optionsWithSource:_source];

  self.listenerRegistration =
      [_reference addSnapshotListenerWithOptions:optionsWithSourceAndMetadata listener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreExtension.m

**크기**: 760 bytes | **라인 수**: 28 | **타입**: text

```
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseFirestore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h"

@interface FLTFirebaseFirestoreExtension ()

@property(nonatomic, strong, readwrite) FIRFirestore *instance;
@property(nonatomic, strong, readwrite) NSString *databaseURL;

@end

@implementation FLTFirebaseFirestoreExtension

- (instancetype)initWithFirestoreInstance:(FIRFirestore *)firestore
                              databaseURL:(NSString *)databaseURL {
  self = [super init];
  if (self) {
    _instance = firestore;
    _databaseURL = [databaseURL copy];
  }
  return self;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestorePlugin.m

**크기**: 39160 bytes | **라인 수**: 879 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import <TargetConditionals.h>
#import "FirebaseFirestoreInternal/FIRPersistentCacheIndexManager.h"
#import "include/cloud_firestore/Private/FLTDocumentSnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h"
#import "include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h"
#import "include/cloud_firestore/Private/FLTTransactionStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h"

NSString *const kFLTFirebaseFirestoreChannelName = @"plugins.flutter.io/firebase_firestore";
NSString *const kFLTFirebaseFirestoreQuerySnapshotEventChannelName =
    @"plugins.flutter.io/firebase_firestore/query";
NSString *const kFLTFirebaseFirestoreDocumentSnapshotEventChannelName =
    @"plugins.flutter.io/firebase_firestore/document";
NSString *const kFLTFirebaseFirestoreSnapshotsInSyncEventChannelName =
    @"plugins.flutter.io/firebase_firestore/snapshotsInSync";
NSString *const kFLTFirebaseFirestoreTransactionChannelName =
    @"plugins.flutter.io/firebase_firestore/transaction";
NSString *const kFLTFirebaseFirestoreLoadBundleChannelName =
    @"plugins.flutter.io/firebase_firestore/loadBundle";

@interface FLTFirebaseFirestorePlugin ()
@property(nonatomic, retain) NSMutableDictionary *transactions;

/// Registers a unique event channel based on a channel prefix.
///
/// Once registered, the plugin will take care of removing the stream handler and cleaning up,
/// if the engine is detached.
///
/// This function generates a random ID.
///
/// @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
///     "namespace/component" whereas the last / is added internally.
/// @param handler The handler object for responding to channel events and submitting data.
/// @return The generated identifier.
/// @see #registerEventChannel(String, String, StreamHandler)
- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler;

/// Registers a unique event channel based on a channel prefix.
///
/// Once registered, the plugin will take care of removing the stream handler and cleaning up,
/// if the engine is detached.
///
/// @param prefix Channel prefix onto which the unique ID will be appended on. The convention is
/// "namespace/component" whereas the last / is added internally.
/// @param identifier A identifier which will be appended to the prefix.
/// @param handler The handler object for responding to channel events and submitting data.
/// @return The passed identifier.
/// @see #registerEventChannel(String, String, StreamHandler)
- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                                  identifier:(NSString *)identifier
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler;
@end

static NSCache<NSNumber *, NSString *> *_serverTimestampMap;

@implementation FLTFirebaseFirestorePlugin {
  NSMutableDictionary<NSString *, FlutterEventChannel *> *_eventChannels;
  NSMutableDictionary<NSString *, NSObject<FlutterStreamHandler> *> *_streamHandlers;
  NSMutableDictionary<NSString *, FLTTransactionStreamHandler *> *_transactionHandlers;
  NSObject<FlutterBinaryMessenger> *_binaryMessenger;
}

FlutterStandardMethodCodec *_codec;

+ (NSCache<NSNumber *, NSString *> *)serverTimestampMap {
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    _serverTimestampMap = [NSCache<NSNumber *, NSString *> new];
  });
  return _serverTimestampMap;
}

+ (void)initialize {
  _codec =
      [FlutterStandardMethodCodec codecWithReaderWriter:[FLTFirebaseFirestoreReaderWriter new]];
}

#pragma mark - FlutterPlugin

// Returns a singleton instance of the Firebase Firestore plugin.
//+ (instancetype)sharedInstance {
//  static dispatch_once_t onceToken;
//  static FLTFirebaseFirestorePlugin *instance;
//
//  dispatch_once(&onceToken, ^{
//    instance = [[FLTFirebaseFirestorePlugin alloc] init];
//    // Register with the Flutter Firebase plugin registry.
//    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:instance];
//  });
//
//  return instance;
//}

- (instancetype)init:(NSObject<FlutterBinaryMessenger> *)messenger {
  self = [super init];
  if (self) {
    _binaryMessenger = messenger;
    _transactions = [NSMutableDictionary<NSNumber *, FIRTransaction *> dictionary];
    _eventChannels = [NSMutableDictionary dictionary];
    _streamHandlers = [NSMutableDictionary dictionary];
    _transactionHandlers = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FLTFirebaseFirestorePlugin *instance =
      [[FLTFirebaseFirestorePlugin alloc] init:[registrar messenger]];

#if TARGET_OS_OSX
// TODO(Salakar): Publish does not exist on MacOS version of FlutterPluginRegistrar.
#else
  [registrar publish:instance];
#endif
  FirebaseFirestoreHostApiSetup(registrar.messenger, instance);
}

- (void)cleanupEventListeners {
  for (FlutterEventChannel *channel in self->_eventChannels.allValues) {
    [channel setStreamHandler:nil];
  }
  [self->_eventChannels removeAllObjects];
  for (NSObject<FlutterStreamHandler> *handler in self->_streamHandlers.allValues) {
    [handler onCancelWithArguments:nil];
  }
  [self->_streamHandlers removeAllObjects];

  @synchronized(self->_transactions) {
    [self->_transactions removeAllObjects];
  }
}

- (void)cleanupFirestoreInstances:(void (^)(void))completion {
  if ([FLTFirebaseFirestoreUtils count] > 0) {
    [FLTFirebaseFirestoreUtils cleanupFirestoreInstances:completion];
  } else {
    if (completion != nil) completion();
  }
}

- (void)detachFromEngineForRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  [self cleanupEventListeners];
}

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^)(void))completion {
  [self cleanupEventListeners];
  [self cleanupFirestoreInstances:completion];
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *)firebase_app {
  return @{};
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  return kFLTFirebaseFirestoreChannelName;
}

#pragma mark - Firestore API

- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler {
  return [self registerEventChannelWithPrefix:prefix
                                   identifier:[[[NSUUID UUID] UUIDString] lowercaseString]
                                streamHandler:handler];
}

- (NSString *)registerEventChannelWithPrefix:(NSString *)prefix
                                  identifier:(NSString *)identifier
                               streamHandler:(NSObject<FlutterStreamHandler> *)handler {
  NSString *channelName = [NSString stringWithFormat:@"%@/%@", prefix, identifier];

  FlutterEventChannel *channel = [[FlutterEventChannel alloc] initWithName:channelName
                                                           binaryMessenger:_binaryMessenger
                                                                     codec:_codec];

  [channel setStreamHandler:handler];
  [_eventChannels setObject:channel forKey:identifier];
  [_streamHandlers setObject:handler forKey:identifier];

  return identifier;
}

- (FIRFirestore *_Nullable)getFIRFirestoreFromAppNameFromPigeon:
    (FirestorePigeonFirebaseApp *)pigeonApp {
  @synchronized(self) {
    NSString *appNameDart = pigeonApp.appName;
    NSString *databaseUrl = pigeonApp.databaseURL;

    FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:appNameDart];

    if ([FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                  databaseURL:databaseUrl] != nil) {
      return [FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                       databaseURL:databaseUrl];
    }

    FIRFirestoreSettings *settings = [[FIRFirestoreSettings alloc] init];
    if (pigeonApp.settings.persistenceEnabled != nil) {
      bool persistEnabled = [pigeonApp.settings.persistenceEnabled boolValue];

      // We default to the maximum amount of cache allowed.
      NSNumber *size = @(kFIRFirestoreCacheSizeUnlimited);

      if (pigeonApp.settings.cacheSizeBytes) {
        NSNumber *cacheSizeBytes = pigeonApp.settings.cacheSizeBytes;
        if ([cacheSizeBytes intValue] != -1) {
          size = cacheSizeBytes;
        }
      }

      if (persistEnabled) {
        settings.cacheSettings = [[FIRPersistentCacheSettings alloc] initWithSizeBytes:size];
      } else {
        settings.cacheSettings = [[FIRMemoryCacheSettings alloc]
            initWithGarbageCollectorSettings:[[FIRMemoryLRUGCSettings alloc] init]];
      }
    }

    if (pigeonApp.settings.host != nil) {
      settings.host = pigeonApp.settings.host;
      // Only allow changing ssl if host is also specified.
      if (pigeonApp.settings.sslEnabled != nil) {
        settings.sslEnabled = [pigeonApp.settings.sslEnabled boolValue];
      }
    }

    settings.dispatchQueue = [FLTFirebaseFirestoreReader getFirestoreQueue];

    FIRFirestore *firestore = [FIRFirestore firestoreForApp:app database:databaseUrl];
    firestore.settings = settings;

    [FLTFirebaseFirestoreUtils setCachedFIRFirestoreInstance:firestore
                                                  forAppName:app.name
                                                 databaseURL:databaseUrl];
    return firestore;
  }
}

- (FlutterError *)convertToFlutterError:(NSError *)error {
  NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
  NSString *_Nullable code = codeAndMessage[0];
  NSString *_Nullable message = codeAndMessage[1];
  NSDictionary *_Nullable details = @{
    @"code" : code,
    @"message" : message,
  };

  return [FlutterError errorWithCode:code message:message details:details];
}

- (void)clearPersistenceApp:(nonnull FirestorePigeonFirebaseApp *)app
                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore clearPersistenceWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)disableNetworkApp:(nonnull FirestorePigeonFirebaseApp *)app
               completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore disableNetworkWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)documentReferenceDeleteApp:(nonnull FirestorePigeonFirebaseApp *)app
                           request:(nonnull DocumentReferenceRequest *)request
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  [document deleteDocumentWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)terminate:(id)arguments withMethodCallResult:(FLTFirebaseMethodCallResult *)result {
  FIRFirestore *firestore = arguments[@"firestore"];
  [firestore terminateWithCompletion:^(NSError *error) {
    if (error != nil) {
      result.error(nil, nil, nil, error);
    } else {
      FLTFirebaseFirestoreExtension *firestoreExtension =
          [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
      [FLTFirebaseFirestoreUtils destroyCachedInstanceForFirestore:firestore.app.name
                                                       databaseURL:firestoreExtension.databaseURL];
      result.success(nil);
    }
  }];
}

- (void)documentReferenceGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                        request:(nonnull DocumentReferenceRequest *)request
                     completion:(nonnull void (^)(PigeonDocumentSnapshot *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];
  FIRFirestoreSource source = [FirestorePigeonParser parseSource:request.source.value];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:request.serverTimestampBehavior.value];

  id completionGet = ^(FIRDocumentSnapshot *_Nullable snapshot, NSError *_Nullable error) {
    if (error != nil) {
      completion(nil, [self convertToFlutterError:error]);
    } else {
      completion([FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                         serverTimestampBehavior:serverTimestampBehavior],
                 nil);
    }
  };

  [document getDocumentWithSource:source completion:completionGet];
}

- (void)documentReferenceSetApp:(nonnull FirestorePigeonFirebaseApp *)app
                        request:(nonnull DocumentReferenceRequest *)request
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  id data = request.data;
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  void (^completionBlock)(NSError *) = ^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  };

  if ([request.option.merge isEqual:@YES]) {
    [document setData:data merge:YES completion:completionBlock];
  } else if (request.option.mergeFields) {
    [document setData:data
          mergeFields:[FirestorePigeonParser parseFieldPath:request.option.mergeFields]
           completion:completionBlock];
  } else {
    [document setData:data completion:completionBlock];
  }
}

- (void)documentReferenceSnapshotApp:(nonnull FirestorePigeonFirebaseApp *)app
                          parameters:(nonnull DocumentReferenceRequest *)parameters
              includeMetadataChanges:(nonnull NSNumber *)includeMetadataChanges
                              source:(ListenSource)source
                          completion:(nonnull void (^)(NSString *_Nullable,
                                                       FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:parameters.path];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:parameters.serverTimestampBehavior.value];
  FIRListenSource listenSource = [FirestorePigeonParser parseListenSource:source];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreDocumentSnapshotEventChannelName
                             streamHandler:[[FLTDocumentSnapshotStreamHandler alloc]
                                                     initWithFirestore:firestore
                                                             reference:document
                                                includeMetadataChanges:includeMetadataChanges
                                                                           .boolValue
                                               serverTimestampBehavior:serverTimestampBehavior
                                                                source:listenSource]],
      nil);
}

- (void)documentReferenceUpdateApp:(nonnull FirestorePigeonFirebaseApp *)app
                           request:(nonnull DocumentReferenceRequest *)request
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  id data = request.data;
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRDocumentReference *document = [firestore documentWithPath:request.path];

  [document updateData:data
            completion:^(NSError *error) {
              if (error != nil) {
                completion([self convertToFlutterError:error]);
              } else {
                completion(nil);
              }
            }];
}

- (void)enableNetworkApp:(nonnull FirestorePigeonFirebaseApp *)app
              completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore enableNetworkWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)loadBundleApp:(nonnull FirestorePigeonFirebaseApp *)app
               bundle:(nonnull FlutterStandardTypedData *)bundle
           completion:(nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  completion([self registerEventChannelWithPrefix:kFLTFirebaseFirestoreLoadBundleChannelName
                                    streamHandler:[[FLTLoadBundleStreamHandler alloc]
                                                      initWithFirestore:firestore
                                                                 bundle:bundle]],
             nil);
}

- (void)namedQueryGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                    name:(nonnull NSString *)name
                 options:(nonnull PigeonGetOptions *)options
              completion:(nonnull void (^)(PigeonQuerySnapshot *_Nullable,
                                           FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  FIRFirestoreSource source = [FirestorePigeonParser parseSource:options.source];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];

  [firestore
      getQueryNamed:name
         completion:^(FIRQuery *_Nullable query) {
           if (query == nil) {
             completion(nil,
                        [FlutterError errorWithCode:@"non-existent-named-query"
                                            message:@"Named query has not been found. Please check "
                                                    @"it has been loaded properly via loadBundle()."
                                            details:nil]);

             return;
           }
           [query getDocumentsWithSource:source
                              completion:^(FIRQuerySnapshot *_Nullable snapshot,
                                           NSError *_Nullable error) {
                                if (error != nil) {
                                  completion(nil, [self convertToFlutterError:error]);
                                } else {
                                  completion([FirestorePigeonParser
                                                   toPigeonQuerySnapshot:snapshot
                                                 serverTimestampBehavior:serverTimestampBehavior],
                                             nil);
                                }
                              }];
         }];
}

- (void)queryGetApp:(nonnull FirestorePigeonFirebaseApp *)app
                 path:(nonnull NSString *)path
    isCollectionGroup:(nonnull NSNumber *)isCollectionGroup
           parameters:(nonnull PigeonQueryParameters *)parameters
              options:(nonnull PigeonGetOptions *)options
           completion:(nonnull void (^)(PigeonQuerySnapshot *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  FIRFirestoreSource source = [FirestorePigeonParser parseSource:options.source];
  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];

  [query getDocumentsWithSource:source
                     completion:^(FIRQuerySnapshot *_Nullable snapshot, NSError *_Nullable error) {
                       if (error != nil) {
                         completion(nil, [self convertToFlutterError:error]);
                       } else {
                         completion(
                             [FirestorePigeonParser toPigeonQuerySnapshot:snapshot
                                                  serverTimestampBehavior:serverTimestampBehavior],
                             nil);
                       }
                     }];
}

- (void)querySnapshotApp:(nonnull FirestorePigeonFirebaseApp *)app
                      path:(nonnull NSString *)path
         isCollectionGroup:(nonnull NSNumber *)isCollectionGroup
                parameters:(nonnull PigeonQueryParameters *)parameters
                   options:(nonnull PigeonGetOptions *)options
    includeMetadataChanges:(nonnull NSNumber *)includeMetadataChanges
                    source:(ListenSource)source
                completion:
                    (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  FIRServerTimestampBehavior serverTimestampBehavior =
      [FirestorePigeonParser parseServerTimestampBehavior:options.serverTimestampBehavior];
  FIRListenSource listenSource = [FirestorePigeonParser parseListenSource:source];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreQuerySnapshotEventChannelName
                             streamHandler:[[FLTQuerySnapshotStreamHandler alloc]
                                                     initWithFirestore:firestore
                                                                 query:query
                                                includeMetadataChanges:includeMetadataChanges
                                                                           .boolValue
                                               serverTimestampBehavior:serverTimestampBehavior
                                                                source:listenSource]],
      nil);
}

- (void)setIndexConfigurationApp:(nonnull FirestorePigeonFirebaseApp *)app
              indexConfiguration:(nonnull NSString *)indexConfiguration
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  [firestore setIndexConfigurationFromJSON:indexConfiguration
                                completion:^(NSError *_Nullable error) {
                                  if (error != nil) {
                                    completion([self convertToFlutterError:error]);
                                  } else {
                                    completion(nil);
                                  }
                                }];
}

- (void)persistenceCacheIndexManagerRequestApp:(FirestorePigeonFirebaseApp *)app
                                       request:(PersistenceCacheIndexManagerRequest)request
                                    completion:(void (^)(FlutterError *_Nullable))completion {
  FIRPersistentCacheIndexManager *persistentCacheIndexManager =
      [self getFIRFirestoreFromAppNameFromPigeon:app].persistentCacheIndexManager;

  if (persistentCacheIndexManager) {
    switch (request) {
      case PersistenceCacheIndexManagerRequestEnableIndexAutoCreation:
        [persistentCacheIndexManager enableIndexAutoCreation];
        break;
      case PersistenceCacheIndexManagerRequestDisableIndexAutoCreation:
        [persistentCacheIndexManager disableIndexAutoCreation];
        break;
      case PersistenceCacheIndexManagerRequestDeleteAllIndexes:
        [persistentCacheIndexManager deleteAllIndexes];
        break;
    }
  } else {
    // Put because `persistentCacheIndexManager` is a nullable property
    NSLog(@"FLTFirebaseFirestore: `PersistentCacheIndexManager` is not available.");
  }
  completion(nil);
}

- (void)setLoggingEnabledLoggingEnabled:(nonnull NSNumber *)loggingEnabled
                             completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  [FIRFirestore enableLogging:[loggingEnabled boolValue]];
  completion(nil);
}

- (void)terminateApp:(nonnull FirestorePigeonFirebaseApp *)app
          completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore terminateWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      FLTFirebaseFirestoreExtension *firestoreExtension =
          [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
      [FLTFirebaseFirestoreUtils destroyCachedInstanceForFirestore:firestore.app.name
                                                       databaseURL:firestoreExtension.databaseURL];
      completion(nil);
    }
  }];
}

- (void)transactionGetApp:(nonnull FirestorePigeonFirebaseApp *)app
            transactionId:(nonnull NSString *)transactionId
                     path:(nonnull NSString *)path
               completion:(nonnull void (^)(PigeonDocumentSnapshot *_Nullable,
                                            FlutterError *_Nullable))completion {
  // Dispatching to main thread allow us to ensure that the auth token are fetched in time
  // for the transaction
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
    FIRDocumentReference *document = [firestore documentWithPath:path];

    FIRTransaction *transaction = self->_transactions[transactionId];

    if (transaction == nil) {
      completion(
          nil,
          [FlutterError
              errorWithCode:@"missing-transaction"
                    message:@"An error occurred while getting the native transaction. "
                            @"It could be caused by a timeout in a preceding transaction operation."
                    details:nil]);
      return;
    }

    NSError *error = nil;
    FIRDocumentSnapshot *snapshot = [transaction getDocument:document error:&error];

    if (error != nil) {
      completion(nil, [self convertToFlutterError:error]);
    } else if (snapshot != nil) {
      completion([FirestorePigeonParser toPigeonDocumentSnapshot:snapshot
                                         serverTimestampBehavior:FIRServerTimestampBehaviorNone],
                 nil);
    } else {
      completion(nil, nil);
    }
  });
}

- (void)transactionStoreResultTransactionId:(nonnull NSString *)transactionId
                                 resultType:(PigeonTransactionResult)resultType
                                   commands:(nullable NSArray<PigeonTransactionCommand *> *)commands
                                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  [_transactionHandlers[transactionId] receiveTransactionResponse:resultType commands:commands];

  completion(nil);
}

- (void)waitForPendingWritesApp:(nonnull FirestorePigeonFirebaseApp *)app
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  [firestore waitForPendingWritesWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)writeBatchCommitApp:(nonnull FirestorePigeonFirebaseApp *)app
                     writes:(nonnull NSArray<PigeonTransactionCommand *> *)writes
                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];
  FIRWriteBatch *batch = [firestore batch];

  for (PigeonTransactionCommand *write in writes) {
    PigeonTransactionType type = write.type;
    NSString *path = write.path;
    FIRDocumentReference *reference = [firestore documentWithPath:path];

    switch (type) {
      case PigeonTransactionTypeGet:
        break;
      case PigeonTransactionTypeDeleteType:
        [batch deleteDocument:reference];
        break;
      case PigeonTransactionTypeUpdate:
        [batch updateData:write.data forDocument:reference];
        break;
      case PigeonTransactionTypeSet:
        if ([write.option.merge isEqual:@YES]) {
          [batch setData:write.data forDocument:reference merge:YES];
        } else if (write.option.mergeFields) {
          [batch setData:write.data
              forDocument:reference
              mergeFields:[FirestorePigeonParser parseFieldPath:write.option.mergeFields]];
        } else {
          [batch setData:write.data forDocument:reference];
        }
        break;
    }
  }

  [batch commitWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion([self convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)snapshotsInSyncSetupApp:(nonnull FirestorePigeonFirebaseApp *)app
                     completion:(nonnull void (^)(NSString *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  completion(
      [self registerEventChannelWithPrefix:kFLTFirebaseFirestoreSnapshotsInSyncEventChannelName
                             streamHandler:[[FLTSnapshotsInSyncStreamHandler alloc]
                                               initWithFirestore:firestore]],
      nil);
}

- (void)transactionCreateApp:(nonnull FirestorePigeonFirebaseApp *)app
                     timeout:(nonnull NSNumber *)timeout
                 maxAttempts:(nonnull NSNumber *)maxAttempts
                  completion:
                      (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  NSString *transactionId = [[[NSUUID UUID] UUIDString] lowercaseString];

  FLTTransactionStreamHandler *handler =
      [[FLTTransactionStreamHandler alloc] initWithId:transactionId
          firestore:firestore
          timeout:timeout
          maxAttempts:maxAttempts
          started:^(FIRTransaction *_Nonnull transaction) {
            self->_transactions[transactionId] = transaction;
          }
          ended:^{
            self->_transactions[transactionId] = nil;
          }];

  _transactionHandlers[transactionId] = handler;

  completion([self registerEventChannelWithPrefix:kFLTFirebaseFirestoreTransactionChannelName
                                       identifier:transactionId
                                    streamHandler:handler],
             nil);
}

- (void)aggregateQueryApp:(nonnull FirestorePigeonFirebaseApp *)app
                     path:(nonnull NSString *)path
               parameters:(nonnull PigeonQueryParameters *)parameters
                   source:(AggregateSource)source
                  queries:(nonnull NSArray<AggregateQuery *> *)queries
        isCollectionGroup:(NSNumber *)isCollectionGroup
               completion:(nonnull void (^)(NSArray<AggregateQueryResponse *> *_Nullable,
                                            FlutterError *_Nullable))completion {
  FIRFirestore *firestore = [self getFIRFirestoreFromAppNameFromPigeon:app];

  FIRQuery *query = [FirestorePigeonParser parseQueryWithParameters:parameters
                                                          firestore:firestore
                                                               path:path
                                                  isCollectionGroup:[isCollectionGroup boolValue]];
  if (query == nil) {
    completion(nil, [FlutterError errorWithCode:@"error-parsing"
                                        message:@"An error occurred while parsing query arguments, "
                                                @"this is most likely an error with this SDK."
                                        details:nil]);
    return;
  }

  NSMutableArray<FIRAggregateField *> *aggregateFields =
      [[NSMutableArray<FIRAggregateField *> alloc] init];

  for (AggregateQuery *queryRequest in queries) {
    switch ([queryRequest type]) {
      case AggregateTypeCount:
        [aggregateFields addObject:[FIRAggregateField aggregateFieldForCount]];
        break;
      case AggregateTypeSum:
        [aggregateFields
            addObject:[FIRAggregateField aggregateFieldForSumOfField:[queryRequest field]]];
        break;
      case AggregateTypeAverage:
        [aggregateFields
            addObject:[FIRAggregateField aggregateFieldForAverageOfField:[queryRequest field]]];
        break;
      default:
        // Handle the default case
        break;
    }
  }

  FIRAggregateQuery *aggregateQuery = [query aggregate:aggregateFields];

  [aggregateQuery
      aggregationWithSource:FIRAggregateSourceServer
                 completion:^(FIRAggregateQuerySnapshot *_Nullable snapshot,
                              NSError *_Nullable error) {
                   if (error != nil) {
                     completion(nil, [self convertToFlutterError:error]);
                     return;
                   }
                   NSMutableArray<AggregateQueryResponse *> *aggregateResponses =
                       [[NSMutableArray alloc] init];

                   for (AggregateQuery *queryRequest in queries) {
                     switch (queryRequest.type) {
                       case AggregateTypeCount: {
                         double doubleValue = [snapshot.count doubleValue];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeCount
                                                  field:nil
                                                  value:[NSNumber numberWithDouble:doubleValue]]];
                         break;
                       }
                       case AggregateTypeSum: {
                         NSNumber *value = [snapshot
                             valueForAggregateField:[FIRAggregateField
                                                        aggregateFieldForSumOfField:[queryRequest
                                                                                        field]]];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeSum
                                                  field:queryRequest.field
                                                  // This passes either a double (wrapped in
                                                  // NSNumber) or null value
                                                  value:value != ((id)[NSNull null])
                                                            ? [NSNumber
                                                                  numberWithDouble:[value
                                                                                       doubleValue]]
                                                            : value]];
                         break;
                       }
                       case AggregateTypeAverage: {
                         NSNumber *value = [snapshot
                             valueForAggregateField:
                                 [FIRAggregateField
                                     aggregateFieldForAverageOfField:[queryRequest field]]];

                         [aggregateResponses
                             addObject:[AggregateQueryResponse
                                           makeWithType:AggregateTypeAverage
                                                  field:queryRequest.field
                                                  // This passes either a double (wrapped in
                                                  // NSNumber) or null value
                                                  value:value != ((id)[NSNull null])
                                                            ? [NSNumber
                                                                  numberWithDouble:[value
                                                                                       doubleValue]]
                                                            : value]];
                         break;
                       }
                     }
                   }

                   completion(aggregateResponses, nil);
                 }];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreReader.m

**크기**: 12564 bytes | **라인 수**: 319 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"

@implementation FLTFirebaseFirestoreReader

- (id)readValueOfType:(UInt8)type {
  switch (type) {
    case FirestoreDataTypeDateTime: {
      SInt64 value;
      [self readBytes:&value length:8];
      return [NSDate dateWithTimeIntervalSince1970:(value / 1000.0)];
    }
    case FirestoreDataTypeTimestamp: {
      SInt64 seconds;
      int nanoseconds;
      [self readBytes:&seconds length:8];
      [self readBytes:&nanoseconds length:4];
      return [[FIRTimestamp alloc] initWithSeconds:seconds nanoseconds:nanoseconds];
    }
    case FirestoreDataTypeGeoPoint: {
      Float64 latitude;
      Float64 longitude;
      [self readAlignment:8];
      [self readBytes:&latitude length:8];
      [self readBytes:&longitude length:8];
      return [[FIRGeoPoint alloc] initWithLatitude:latitude longitude:longitude];
    }
    case FirestoreDataTypeVectorValue: {
      return [[FIRVectorValue alloc] initWithArray:[self readValue]];
    }
    case FirestoreDataTypeDocumentReference: {
      FIRFirestore *firestore = [self readValue];
      NSString *documentPath = [self readValue];
      return [firestore documentWithPath:documentPath];
    }
    case FirestoreDataTypeFieldPath: {
      UInt32 length = [self readSize];
      NSMutableArray *array = [NSMutableArray arrayWithCapacity:length];
      for (UInt32 i = 0; i < length; i++) {
        id value = [self readValue];
        [array addObject:(value == nil ? [NSNull null] : value)];
      }
      return [[FIRFieldPath alloc] initWithFields:array];
    }
    case FirestoreDataTypeBlob:
      return [self readData:[self readSize]];
    case FirestoreDataTypeArrayUnion:
      return [FIRFieldValue fieldValueForArrayUnion:[self readValue]];
    case FirestoreDataTypeArrayRemove:
      return [FIRFieldValue fieldValueForArrayRemove:[self readValue]];
    case FirestoreDataTypeDelete:
      return [FIRFieldValue fieldValueForDelete];
    case FirestoreDataTypeServerTimestamp:
      return [FIRFieldValue fieldValueForServerTimestamp];
    case FirestoreDataTypeIncrementDouble:
      return
          [FIRFieldValue fieldValueForDoubleIncrement:((NSNumber *)[self readValue]).doubleValue];
    case FirestoreDataTypeIncrementInteger:
      return [FIRFieldValue fieldValueForIntegerIncrement:((NSNumber *)[self readValue]).intValue];
    case FirestoreDataTypeDocumentId:
      return [FIRFieldPath documentID];
    case FirestoreDataTypeFirestoreInstance:
      return [self FIRFirestore];
    case FirestoreDataTypeFirestoreQuery:
      return [self FIRQuery];
    case FirestoreDataTypeFirestoreSettings:
      return [self FIRFirestoreSettings];
    case FirestoreDataTypeNaN:
      return @(NAN);
    case FirestoreDataTypeInfinity:
      return @(INFINITY);
    case FirestoreDataTypeNegativeInfinity:
      return @(-INFINITY);
    default:
      return [super readValueOfType:type];
  }
}

+ (dispatch_queue_t)getFirestoreQueue {
  static dispatch_queue_t firestoreQueue;
  static dispatch_once_t once;
  dispatch_once(&once, ^{
    firestoreQueue = dispatch_queue_create("dev.flutter.firebase.firestore", DISPATCH_QUEUE_SERIAL);
  });
  return firestoreQueue;
}

- (FIRFirestoreSettings *)FIRFirestoreSettings {
  NSDictionary *values = [self readValue];
  FIRFirestoreSettings *settings = [[FIRFirestoreSettings alloc] init];

  if (![values[@"persistenceEnabled"] isEqual:[NSNull null]]) {
    bool persistEnabled = [((NSNumber *)values[@"persistenceEnabled"]) boolValue];

    // We default to the maximum amount of cache allowed.
    NSNumber *size = @(kFIRFirestoreCacheSizeUnlimited);

    if (![values[@"cacheSizeBytes"] isEqual:[NSNull null]]) {
      NSNumber *cacheSizeBytes = ((NSNumber *)values[@"cacheSizeBytes"]);
      if ([cacheSizeBytes intValue] != -1) {
        size = cacheSizeBytes;
      }
    }

    if (persistEnabled) {
      settings.cacheSettings = [[FIRPersistentCacheSettings alloc] initWithSizeBytes:size];
    } else {
      settings.cacheSettings = [[FIRMemoryCacheSettings alloc]
          initWithGarbageCollectorSettings:[[FIRMemoryLRUGCSettings alloc] init]];
    }
  }

  if (![values[@"host"] isEqual:[NSNull null]]) {
    settings.host = (NSString *)values[@"host"];
    // Only allow changing ssl if host is also specified.
    if (![values[@"sslEnabled"] isEqual:[NSNull null]]) {
      settings.sslEnabled = [((NSNumber *)values[@"sslEnabled"]) boolValue];
    }
  }

  settings.dispatchQueue = [FLTFirebaseFirestoreReader getFirestoreQueue];

  return settings;
}

- (FIRFilter *)filterFromJson:(NSDictionary<NSString *, id> *)map {
  if (map[@"fieldPath"]) {
    // Deserialize a FilterQuery
    NSString *op = map[@"op"];
    FIRFieldPath *fieldPath = map[@"fieldPath"];
    id value = map[@"value"];

    // All the operators from Firebase
    if ([op isEqualToString:@"=="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isEqualTo:value];
    } else if ([op isEqualToString:@"!="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isNotEqualTo:value];
    } else if ([op isEqualToString:@"<"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThan:value];
    } else if ([op isEqualToString:@"<="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
    } else if ([op isEqualToString:@">"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThan:value];
    } else if ([op isEqualToString:@">="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
    } else if ([op isEqualToString:@"array-contains"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContains:value];
    } else if ([op isEqualToString:@"array-contains-any"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContainsAny:value];
    } else if ([op isEqualToString:@"in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath in:value];
    } else if ([op isEqualToString:@"not-in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath notIn:value];
    } else {
      @throw [NSException exceptionWithName:@"InvalidOperator"
                                     reason:@"Invalid operator"
                                   userInfo:nil];
    }
  }
  // Deserialize a FilterOperator
  NSString *op = map[@"op"];
  NSArray<NSDictionary<NSString *, id> *> *queries = map[@"queries"];

  // Map queries recursively
  NSMutableArray<FIRFilter *> *parsedFilters = [NSMutableArray array];
  for (NSDictionary<NSString *, id> *query in queries) {
    [parsedFilters addObject:[self filterFromJson:query]];
  }

  if ([op isEqualToString:@"OR"]) {
    return [FIRFilter orFilterWithFilters:parsedFilters];
  } else if ([op isEqualToString:@"AND"]) {
    return [FIRFilter andFilterWithFilters:parsedFilters];
  }

  @throw [NSException exceptionWithName:@"InvalidOperator" reason:@"Invalid operator" userInfo:nil];
}

- (FIRQuery *)FIRQuery {
  @try {
    FIRQuery *query;
    NSDictionary *values = [self readValue];
    FIRFirestore *firestore = values[@"firestore"];

    NSDictionary *parameters = values[@"parameters"];
    NSArray *whereConditions = parameters[@"where"];
    BOOL isCollectionGroup = ((NSNumber *)values[@"isCollectionGroup"]).boolValue;

    if (isCollectionGroup) {
      query = [firestore collectionGroupWithID:values[@"path"]];
    } else {
      query = (FIRQuery *)[firestore collectionWithPath:values[@"path"]];
    }

    BOOL isFilterQuery = [parameters objectForKey:@"filters"] != nil;
    if (isFilterQuery) {
      FIRFilter *filter =
          [self filterFromJson:(NSDictionary<NSString *, id> *)parameters[@"filters"]];
      query = [query queryWhereFilter:filter];
    }

    // Filters
    for (id item in whereConditions) {
      NSArray *condition = item;
      FIRFieldPath *fieldPath = (FIRFieldPath *)condition[0];
      NSString *operator= condition[1];
      id value = condition[2];
      if ([operator isEqualToString:@"=="]) {
        query = [query queryWhereFieldPath:fieldPath isEqualTo:value];
      } else if ([operator isEqualToString:@"!="]) {
        query = [query queryWhereFieldPath:fieldPath isNotEqualTo:value];
      } else if ([operator isEqualToString:@"<"]) {
        query = [query queryWhereFieldPath:fieldPath isLessThan:value];
      } else if ([operator isEqualToString:@"<="]) {
        query = [query queryWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
      } else if ([operator isEqualToString:@">"]) {
        query = [query queryWhereFieldPath:fieldPath isGreaterThan:value];
      } else if ([operator isEqualToString:@">="]) {
        query = [query queryWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
      } else if ([operator isEqualToString:@"array-contains"]) {
        query = [query queryWhereFieldPath:fieldPath arrayContains:value];
      } else if ([operator isEqualToString:@"array-contains-any"]) {
        query = [query queryWhereFieldPath:fieldPath arrayContainsAny:value];
      } else if ([operator isEqualToString:@"in"]) {
        query = [query queryWhereFieldPath:fieldPath in:value];
      } else if ([operator isEqualToString:@"not-in"]) {
        query = [query queryWhereFieldPath:fieldPath notIn:value];
      } else {
        NSLog(@"FLTFirebaseFirestore: An invalid query operator %@ was received but not handled.",
              operator);
      }
    }

    // Limit
    id limit = parameters[@"limit"];
    if (![limit isEqual:[NSNull null]]) {
      query = [query queryLimitedTo:((NSNumber *)limit).intValue];
    }

    // Limit To Last
    id limitToLast = parameters[@"limitToLast"];
    if (![limitToLast isEqual:[NSNull null]]) {
      query = [query queryLimitedToLast:((NSNumber *)limitToLast).intValue];
    }

    // Ordering
    NSArray *orderBy = parameters[@"orderBy"];
    if ([orderBy isEqual:[NSNull null]]) {
      // We return early if no ordering set as cursor queries below require at least one orderBy set
      return query;
    }

    for (NSArray *orderByParameters in orderBy) {
      FIRFieldPath *fieldPath = (FIRFieldPath *)orderByParameters[0];
      NSNumber *descending = orderByParameters[1];
      query = [query queryOrderedByFieldPath:fieldPath descending:[descending boolValue]];
    }

    // Start At
    id startAt = parameters[@"startAt"];
    if (![startAt isEqual:[NSNull null]]) query = [query queryStartingAtValues:(NSArray *)startAt];
    // Start After
    id startAfter = parameters[@"startAfter"];
    if (![startAfter isEqual:[NSNull null]])
      query = [query queryStartingAfterValues:(NSArray *)startAfter];
    // End At
    id endAt = parameters[@"endAt"];
    if (![endAt isEqual:[NSNull null]]) query = [query queryEndingAtValues:(NSArray *)endAt];
    // End Before
    id endBefore = parameters[@"endBefore"];
    if (![endBefore isEqual:[NSNull null]])
      query = [query queryEndingBeforeValues:(NSArray *)endBefore];

    return query;
  } @catch (NSException *exception) {
    NSLog(@"An error occurred while parsing query arguments, this is most likely an error with "
          @"this SDK. %@",
          [exception callStackSymbols]);
    return nil;
  }
}

- (FIRFirestore *)FIRFirestore {
  @synchronized(self) {
    NSString *appNameDart = [self readValue];
    NSString *databaseUrl = [self readValue];
    FIRFirestoreSettings *settings = [self readValue];
    FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:appNameDart];

    if ([FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                  databaseURL:databaseUrl] != nil) {
      return [FLTFirebaseFirestoreUtils getFirestoreInstanceByName:app.name
                                                       databaseURL:databaseUrl];
    }

    FIRFirestore *firestore = [FIRFirestore firestoreForApp:app database:databaseUrl];
    firestore.settings = settings;

    [FLTFirebaseFirestoreUtils setCachedFIRFirestoreInstance:firestore
                                                  forAppName:app.name
                                                 databaseURL:databaseUrl];
    return firestore;
  }
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreUtils.m

**크기**: 9574 bytes | **라인 수**: 253 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreExtension.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreReader.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h"

@implementation FLTFirebaseFirestoreReaderWriter
- (FlutterStandardWriter *_Nonnull)writerWithData:(NSMutableData *)data {
  return [[FLTFirebaseFirestoreWriter alloc] initWithData:data];
}
- (FlutterStandardReader *_Nonnull)readerWithData:(NSData *)data {
  return [[FLTFirebaseFirestoreReader alloc] initWithData:data];
}
@end

NSMutableDictionary<NSString *, FLTFirebaseFirestoreExtension *> *firestoreInstanceCache;

@implementation FLTFirebaseFirestoreUtils

+ (NSString *)generateKeyForAppName:(NSString *)appName andDatabaseURL:(NSString *)databaseURL {
  return [NSString stringWithFormat:@"%@|%@", appName, databaseURL];
}

+ (FLTFirebaseFirestoreExtension *_Nullable)
    getCachedFIRFirestoreInstanceForAppName:(NSString *_Nonnull)appName
                                databaseURL:(NSString *_Nonnull)url {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
      return nil;
    } else {
      NSString *key = [self generateKeyForAppName:appName andDatabaseURL:url];
      return firestoreInstanceCache[key];
    }
  }
}

+ (void)setCachedFIRFirestoreInstance:(FIRFirestore *_Nonnull)firestore
                           forAppName:(NSString *_Nonnull)appName
                          databaseURL:(NSString *_Nonnull)url {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
    }
    NSString *key = [self generateKeyForAppName:appName andDatabaseURL:url];
    firestoreInstanceCache[key] =
        [[FLTFirebaseFirestoreExtension alloc] initWithFirestoreInstance:firestore databaseURL:url];
  }
}

+ (void)destroyCachedInstanceForFirestore:(NSString *_Nonnull)appName
                              databaseURL:(NSString *_Nonnull)databaseURL {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache != nil) {
      NSString *key = [self generateKeyForAppName:appName andDatabaseURL:databaseURL];
      FLTFirebaseFirestoreExtension *extension = firestoreInstanceCache[key];

      if (extension != nil) {
        [firestoreInstanceCache removeObjectForKey:key];
      }
    }
  }
}

+ (FIRFirestore *)getFirestoreInstanceByName:(NSString *)appName
                                 databaseURL:(NSString *)databaseURL {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache == nil) {
      firestoreInstanceCache = [NSMutableDictionary dictionary];
    }
    NSString *key = [self generateKeyForAppName:appName andDatabaseURL:databaseURL];
    FLTFirebaseFirestoreExtension *extension = firestoreInstanceCache[key];

    if (extension != nil) {
      return extension.instance;
    }

    return nil;
  }
}

+ (NSUInteger)count {
  return [firestoreInstanceCache count];
}

// Require this method when we don't have access to the "databaseURL"
+ (FLTFirebaseFirestoreExtension *_Nullable)getCachedInstanceForFirestore:
    (FIRFirestore *_Nonnull)firestore {
  @synchronized(firestoreInstanceCache) {
    if (firestoreInstanceCache != nil) {
      NSEnumerator *enumerator = [firestoreInstanceCache keyEnumerator];
      NSString *key;

      while ((key = [enumerator nextObject])) {
        FLTFirebaseFirestoreExtension *value = firestoreInstanceCache[key];

        if (value.instance == firestore) {
          return value;
        }
      }
    }
    @throw [NSException exceptionWithName:@"NoCachedInstance"
                                   reason:@"No cached instance of Firestore"
                                 userInfo:nil];
  }
}

+ (void)cleanupFirestoreInstances:(void (^)(void))completion {
  __block int instancesTerminated = 0;
  NSUInteger numberOfInstances = [firestoreInstanceCache count];
  void (^firestoreTerminateInstanceCompletion)(NSError *) = ^void(NSError *error) {
    instancesTerminated++;
    if (instancesTerminated == numberOfInstances && completion != nil) {
      completion();
    }
  };

  if (numberOfInstances > 0) {
    for (NSString *key in firestoreInstanceCache) {
      FLTFirebaseFirestoreExtension *firestoreExtension = firestoreInstanceCache[key];
      FIRFirestore *firestore = firestoreExtension.instance;

      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        [firestore terminateWithCompletion:^(NSError *error) {
          [FLTFirebaseFirestoreUtils
              destroyCachedInstanceForFirestore:firestore.app.name
                                    databaseURL:firestoreExtension.databaseURL];
          firestoreTerminateInstanceCompletion(error);
        }];
      });
    }
  }
}

+ (FIRFirestoreSource)FIRFirestoreSourceFromArguments:(NSDictionary *)arguments {
  NSString *source = arguments[@"source"];
  if ([@"server" isEqualToString:source]) {
    return FIRFirestoreSourceServer;
  }

  if ([@"cache" isEqualToString:source]) {
    return FIRFirestoreSourceCache;
  }

  return FIRFirestoreSourceDefault;
}

+ (NSArray *)ErrorCodeAndMessageFromNSError:(NSError *)error {
  NSString *code = @"unknown";

  if (error == nil) {
    return @[ code, @"An unknown error has occurred." ];
  }

  NSString *message;

  switch (error.code) {
    case FIRFirestoreErrorCodeAborted:
      code = @"aborted";
      message = @"The operation was aborted, typically due to a concurrency issue like transaction "
                @"aborts, etc.";
      break;
    case FIRFirestoreErrorCodeAlreadyExists:
      code = @"already-exists";
      message = @"Some document that we attempted to create already exists.";
      break;
    case FIRFirestoreErrorCodeCancelled:
      code = @"cancelled";
      message = @"The operation was cancelled (typically by the caller).";
      break;
    case FIRFirestoreErrorCodeDataLoss:
      code = @"data-loss";
      message = @"Unrecoverable data loss or corruption.";
      break;
    case FIRFirestoreErrorCodeDeadlineExceeded:
      code = @"deadline-exceeded";
      message = @"Deadline expired before operation could complete. For operations that change the "
                @"state of the system, this error may be returned even if the operation has "
                @"completed successfully. For example, a successful response from a server could "
                @"have been delayed long enough for the deadline to expire.";
      break;
    case FIRFirestoreErrorCodeFailedPrecondition:
      code = @"failed-precondition";
      if ([error.localizedDescription containsString:@"index"]) {
        message = error.localizedDescription;
      } else {
        message = @"Operation was rejected because the system is not in a state required for the "
                  @"operation's execution. If performing a query, ensure it has been indexed via "
                  @"the Firebase console.";
      }
      break;
    case FIRFirestoreErrorCodeInternal:
      code = @"internal";
      message = @"Internal errors. Means some invariants expected by underlying system has been "
                @"broken. If you see one of these errors, something is very broken.";
      break;
    case FIRFirestoreErrorCodeInvalidArgument:
      code = @"invalid-argument";
      message = @"Client specified an invalid argument. Note that this differs from "
                @"failed-precondition. invalid-argument indicates arguments that are problematic "
                @"regardless of the state of the system (e.g., an invalid field name).";
      break;
    case FIRFirestoreErrorCodeNotFound:
      code = @"not-found";
      message = @"Some requested document was not found.";
      break;
    case FIRFirestoreErrorCodeOutOfRange:
      code = @"out-of-range";
      message = @"Operation was attempted past the valid range.";
      break;
    case FIRFirestoreErrorCodePermissionDenied:
      code = @"permission-denied";
      message = @"The caller does not have permission to execute the specified operation.";
      break;
    case FIRFirestoreErrorCodeResourceExhausted:
      code = @"resource-exhausted";
      message = @"Some resource has been exhausted, perhaps a per-user quota, or perhaps the "
                @"entire file system is out of space.";
      break;
    case FIRFirestoreErrorCodeUnauthenticated:
      code = @"unauthenticated";
      message = @"The request does not have valid authentication credentials for the operation.";
      break;
    case FIRFirestoreErrorCodeUnavailable:
      code = @"unavailable";
      message = @"The service is currently unavailable. This is a most likely a transient "
                @"condition and may be corrected by retrying with a backoff.";
      break;
    case FIRFirestoreErrorCodeUnimplemented:
      code = @"unimplemented";
      message = @"Operation is not implemented or not supported/enabled.";
      break;
    case FIRFirestoreErrorCodeUnknown:
      code = @"unknown";
      message = @"Unknown error or an error from a different error domain.";
      break;
    default:
      code = @"unknown";
      message = @"An unknown error occurred.";
      break;
  }

  return @[ code, message ];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTFirebaseFirestoreWriter.m

**크기**: 8368 bytes | **라인 수**: 242 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
@import FirebaseCore;

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreWriter.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Public/FLTFirebaseFirestorePlugin.h"

@implementation FLTFirebaseFirestoreWriter : FlutterStandardWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[NSDate class]]) {
    [self writeByte:FirestoreDataTypeDateTime];
    NSDate *date = value;
    NSTimeInterval time = date.timeIntervalSince1970;
    SInt64 ms = (SInt64)(time * 1000.0);
    [self writeBytes:&ms length:8];
  } else if ([value isKindOfClass:[FIRTimestamp class]]) {
    FIRTimestamp *timestamp = value;
    SInt64 seconds = timestamp.seconds;
    int nanoseconds = timestamp.nanoseconds;
    [self writeByte:FirestoreDataTypeTimestamp];
    [self writeBytes:(UInt8 *)&seconds length:8];
    [self writeBytes:(UInt8 *)&nanoseconds length:4];
  } else if ([value isKindOfClass:[FIRGeoPoint class]]) {
    FIRGeoPoint *geoPoint = value;
    Float64 latitude = geoPoint.latitude;
    Float64 longitude = geoPoint.longitude;
    [self writeByte:FirestoreDataTypeGeoPoint];
    [self writeAlignment:8];
    [self writeBytes:(UInt8 *)&latitude length:8];
    [self writeBytes:(UInt8 *)&longitude length:8];
  } else if ([value isKindOfClass:[FIRVectorValue class]]) {
    FIRVectorValue *vector = value;
    [self writeByte:FirestoreDataTypeVectorValue];
    [self writeValue:vector.array];
  } else if ([value isKindOfClass:[FIRDocumentReference class]]) {
    FIRDocumentReference *document = value;
    NSString *documentPath = [document path];
    NSString *appName = [FLTFirebasePlugin firebaseAppNameFromIosName:document.firestore.app.name];
    [self writeByte:FirestoreDataTypeDocumentReference];
    [self writeValue:appName];
    [self writeValue:documentPath];

    FIRFirestore *firestore = document.firestore;

    FLTFirebaseFirestoreExtension *extension =
        [FLTFirebaseFirestoreUtils getCachedInstanceForFirestore:firestore];
    [self writeValue:extension.databaseURL];

  } else if ([value isKindOfClass:[FIRDocumentSnapshot class]]) {
    [super writeValue:[self FIRDocumentSnapshot:value]];
  } else if ([value isKindOfClass:[FIRLoadBundleTaskProgress class]]) {
    [super writeValue:[self FIRLoadBundleTaskProgress:value]];
  } else if ([value isKindOfClass:[FIRQuerySnapshot class]]) {
    [super writeValue:[self FIRQuerySnapshot:value]];
  } else if ([value isKindOfClass:[FIRDocumentChange class]]) {
    [super writeValue:[self FIRDocumentChange:value]];
  } else if ([value isKindOfClass:[FIRSnapshotMetadata class]]) {
    [super writeValue:[self FIRSnapshotMetadata:value]];
  } else if ([value isKindOfClass:[NSNumber class]]) {
    NSNumber *number = (NSNumber *)value;

    // Infinity
    if ([number isEqual:@(INFINITY)]) {
      [self writeByte:FirestoreDataTypeInfinity];
      return;
    }

    // -Infinity
    if ([number isEqual:@(-INFINITY)]) {
      [self writeByte:FirestoreDataTypeNegativeInfinity];
      return;
    }

    // NaN
    if ([[value description].lowercaseString isEqual:@"nan"]) {
      [self writeByte:FirestoreDataTypeNaN];
      return;
    }

    [super writeValue:value];
  } else if ([value isKindOfClass:[NSData class]]) {
    NSData *blob = value;
    [self writeByte:FirestoreDataTypeBlob];
    [self writeSize:(UInt32)blob.length];
    [self writeData:blob];
  } else {
    [super writeValue:value];
  }
}

- (NSDictionary *)FIRSnapshotMetadata:(FIRSnapshotMetadata *)snapshotMetadata {
  return @{
    @"hasPendingWrites" : @(snapshotMetadata.hasPendingWrites),
    @"isFromCache" : @(snapshotMetadata.isFromCache),
  };
}

- (NSDictionary *)FIRDocumentChange:(FIRDocumentChange *)documentChange {
  NSString *type;

  switch (documentChange.type) {
    case FIRDocumentChangeTypeAdded:
      type = @"DocumentChangeType.added";
      break;
    case FIRDocumentChangeTypeModified:
      type = @"DocumentChangeType.modified";
      break;
    case FIRDocumentChangeTypeRemoved:
      type = @"DocumentChangeType.removed";
      break;
  }

  NSNumber *oldIndex;
  NSNumber *newIndex;

  // Note the Firestore C++ SDK here returns a maxed UInt that is != NSUIntegerMax, so we make one
  // ourselves so we can convert to -1 for Dart.
  NSUInteger MAX_VAL = (NSUInteger)[@(-1) integerValue];

  if (documentChange.newIndex == NSNotFound || documentChange.newIndex == 4294967295 ||
      documentChange.newIndex == MAX_VAL) {
    newIndex = @([@(-1) intValue]);
  } else {
    newIndex = @([@(documentChange.newIndex) intValue]);
  }

  if (documentChange.oldIndex == NSNotFound || documentChange.oldIndex == 4294967295 ||
      documentChange.oldIndex == MAX_VAL) {
    oldIndex = @([@(-1) intValue]);
  } else {
    oldIndex = @([@(documentChange.oldIndex) intValue]);
  }

  return @{
    @"type" : type,
    @"data" : documentChange.document.data,
    @"path" : documentChange.document.reference.path,
    @"oldIndex" : oldIndex,
    @"newIndex" : newIndex,
    @"metadata" : documentChange.document.metadata,
  };
}

- (FIRServerTimestampBehavior)toServerTimestampBehavior:(NSString *)serverTimestampBehavior {
  if (serverTimestampBehavior == nil) {
    return FIRServerTimestampBehaviorNone;
  }

  if ([serverTimestampBehavior isEqualToString:@"estimate"]) {
    return FIRServerTimestampBehaviorEstimate;
  } else if ([serverTimestampBehavior isEqualToString:@"previous"]) {
    return FIRServerTimestampBehaviorPrevious;
  } else {
    return FIRServerTimestampBehaviorNone;
  }
}

- (NSDictionary *)FIRDocumentSnapshot:(FIRDocumentSnapshot *)documentSnapshot {
  if (documentSnapshot == nil) {
    NSLog(@"Error: documentSnapshot is nil");
    return nil;
  }

  NSNumber *documentSnapshotHash = @([documentSnapshot hash]);
  NSString *timestampBehaviorString =
      [FLTFirebaseFirestorePlugin.serverTimestampMap objectForKey:documentSnapshotHash];

  FIRServerTimestampBehavior serverTimestampBehavior =
      [self toServerTimestampBehavior:timestampBehaviorString];

  [FLTFirebaseFirestorePlugin.serverTimestampMap removeObjectForKey:documentSnapshotHash];

  return @{
    @"path" : documentSnapshot.reference.path,
    @"data" : documentSnapshot.exists
        ? (id)[documentSnapshot dataWithServerTimestampBehavior:serverTimestampBehavior]
        : [NSNull null],
    @"metadata" : documentSnapshot.metadata,
  };
}
- (NSDictionary *)FIRLoadBundleTaskProgress:(FIRLoadBundleTaskProgress *)progress {
  NSString *state;

  switch (progress.state) {
    case FIRLoadBundleTaskStateError:
      state = @"error";
      break;
    case FIRLoadBundleTaskStateSuccess:
      state = @"success";
      break;
    case FIRLoadBundleTaskStateInProgress:
      state = @"running";
      break;
  }
  return @{
    @"bytesLoaded" : @(progress.bytesLoaded),
    @"documentsLoaded" : @(progress.documentsLoaded),
    @"totalBytes" : @(progress.totalBytes),
    @"totalDocuments" : @(progress.totalDocuments),
    @"taskState" : state,
  };
}

- (NSDictionary *)FIRQuerySnapshot:(FIRQuerySnapshot *)querySnapshot {
  if (querySnapshot == nil) {
    NSLog(@"Error: querySnapshot is nil");
    return nil;
  }

  NSNumber *querySnapshotHash = @([querySnapshot hash]);

  NSMutableArray *paths = [NSMutableArray array];
  NSMutableArray *documents = [NSMutableArray array];
  NSMutableArray *metadatas = [NSMutableArray array];
  NSString *timestampBehaviorString =
      [FLTFirebaseFirestorePlugin.serverTimestampMap objectForKey:querySnapshotHash];

  FIRServerTimestampBehavior serverTimestampBehavior =
      [self toServerTimestampBehavior:timestampBehaviorString];

  [FLTFirebaseFirestorePlugin.serverTimestampMap removeObjectForKey:querySnapshotHash];

  for (FIRDocumentSnapshot *document in querySnapshot.documents) {
    [paths addObject:document.reference.path];
    [documents addObject:[document dataWithServerTimestampBehavior:serverTimestampBehavior]];
    [metadatas addObject:document.metadata];
  }

  return @{
    @"paths" : paths,
    @"documentChanges" : querySnapshot.documentChanges,
    @"documents" : documents,
    @"metadatas" : metadatas,
    @"metadata" : querySnapshot.metadata,
  };
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTLoadBundleStreamHandler.m

**크기**: 2631 bytes | **라인 수**: 81 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

//
//  FLTLoadBundleStreamHandler.m
//  cloud_firestore
//
//  Created by Russell Wheatley on 05/05/2021.
//

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTLoadBundleStreamHandler.h"

@interface FLTLoadBundleStreamHandler ()
@property(readwrite, strong) FIRLoadBundleTask *task;
@end

@implementation FLTLoadBundleStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore
                                   bundle:(FlutterStandardTypedData *)bundle {
  self = [super init];
  if (self) {
    _firestore = firestore;
    _bundle = bundle;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  // use completion handler to inform user of platform error.
  self.task = [_firestore
      loadBundle:_bundle.data
      completion:^(FIRLoadBundleTaskProgress *_Nullable snapshot, NSError *_Nullable error) {
        if (error != nil) {
          NSArray *codeAndMessage =
              [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
          NSString *code = codeAndMessage[0];
          NSString *message = codeAndMessage[1];
          NSDictionary *details = @{
            @"code" : code,
            @"message" : message,
          };

          dispatch_async(dispatch_get_main_queue(), ^{
            events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                         message:message
                                                 optionalDetails:details
                                              andOptionalNSError:error]);
          });
        }
      }];
  // use addObserver to update user with snapshot progress
  [self.task addObserver:^(FIRLoadBundleTaskProgress *_Nullable progress) {
    dispatch_async(dispatch_get_main_queue(), ^{
      if (progress.state != FIRLoadBundleTaskStateError) {
        events(progress);
      }
    });
  }];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.task removeAllObservers];
  self.task = nil;

  return nil;
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTQuerySnapshotStreamHandler.m

**크기**: 4494 bytes | **라인 수**: 116 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTQuerySnapshotStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"
#import "include/cloud_firestore/Public/CustomPigeonHeaderFirestore.h"

@interface FLTQuerySnapshotStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTQuerySnapshotStreamHandler

- (instancetype)initWithFirestore:(FIRFirestore *)firestore
                            query:(FIRQuery *)query
           includeMetadataChanges:(BOOL)includeMetadataChanges
          serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior
                           source:(FIRListenSource)source {
  self = [super init];
  if (self) {
    _firestore = firestore;
    _query = query;
    _includeMetadataChanges = includeMetadataChanges;
    _serverTimestampBehavior = serverTimestampBehavior;
    _source = source;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  FIRQuery *query = self.query;

  if (query == nil) {
    return [FlutterError
        errorWithCode:@"sdk-error"
              message:@"An error occurred while parsing query arguments, see native logs for more "
                      @"information. Please report this issue."
              details:nil];
  }

  id listener = ^(FIRQuerySnapshot *_Nullable snapshot, NSError *_Nullable error) {
    if (error) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];
      NSString *code = codeAndMessage[0];
      NSString *message = codeAndMessage[1];
      NSDictionary *details = @{
        @"code" : code,
        @"message" : message,
      };
      dispatch_async(dispatch_get_main_queue(), ^{
        events([FLTFirebasePlugin createFlutterErrorFromCode:code
                                                     message:message
                                             optionalDetails:details
                                          andOptionalNSError:error]);
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        NSMutableArray *toListResult = [[NSMutableArray alloc] initWithCapacity:3];

        NSMutableArray *documents =
            [[NSMutableArray alloc] initWithCapacity:snapshot.documents.count];
        NSMutableArray *documentChanges =
            [[NSMutableArray alloc] initWithCapacity:snapshot.documentChanges.count];

        for (FIRDocumentSnapshot *documentSnapshot in snapshot.documents) {
          [documents addObject:[[FirestorePigeonParser
                                   toPigeonDocumentSnapshot:documentSnapshot
                                    serverTimestampBehavior:self.serverTimestampBehavior] toList]];
        }

        for (FIRDocumentChange *documentChange in snapshot.documentChanges) {
          [documentChanges
              addObject:[[FirestorePigeonParser toPigeonDocumentChange:documentChange
                                               serverTimestampBehavior:self.serverTimestampBehavior]
                            toList]];
        }

        [toListResult addObject:documents];
        [toListResult addObject:documentChanges];
        [toListResult
            addObject:[[FirestorePigeonParser toPigeonSnapshotMetadata:snapshot.metadata] toList]];

        events(toListResult);
      });
    }
  };

  FIRSnapshotListenOptions *options = [[FIRSnapshotListenOptions alloc] init];
  FIRSnapshotListenOptions *optionsWithSourceAndMetadata = [[options
      optionsWithIncludeMetadataChanges:_includeMetadataChanges] optionsWithSource:_source];

  self.listenerRegistration = [query addSnapshotListenerWithOptions:optionsWithSourceAndMetadata
                                                           listener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTSnapshotsInSyncStreamHandler.m

**크기**: 1216 bytes | **라인 수**: 45 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;

#import "include/cloud_firestore/Private/FLTSnapshotsInSyncStreamHandler.h"
#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"

@interface FLTSnapshotsInSyncStreamHandler ()
@property(readwrite, strong) id<FIRListenerRegistration> listenerRegistration;
@end

@implementation FLTSnapshotsInSyncStreamHandler

- (nonnull instancetype)initWithFirestore:(nonnull FIRFirestore *)firestore {
  self = [super init];
  if (self) {
    _firestore = firestore;
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  id listener = ^() {
    dispatch_async(dispatch_get_main_queue(), ^{
      events(nil);
    });
  };

  self.listenerRegistration = [_firestore addSnapshotsInSyncListener:listener];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  [self.listenerRegistration remove];
  self.listenerRegistration = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FLTTransactionStreamHandler.m

**크기**: 5659 bytes | **라인 수**: 169 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseFirestore;
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/cloud_firestore/Private/FLTFirebaseFirestoreUtils.h"
#import "include/cloud_firestore/Private/FLTTransactionStreamHandler.h"
#import "include/cloud_firestore/Private/FirestorePigeonParser.h"

@interface FLTTransactionStreamHandler ()
@property(nonatomic, copy, nonnull) void (^started)(FIRTransaction *);
@property(nonatomic, copy, nonnull) void (^ended)(void);
@property(strong) dispatch_semaphore_t semaphore;
@property PigeonTransactionResult resultType;
@property NSArray<PigeonTransactionCommand *> *commands;

@end

@implementation FLTTransactionStreamHandler {
  NSString *_transactionId;
}

- (instancetype)initWithId:(NSString *)transactionId
                 firestore:(FIRFirestore *)firestore
                   timeout:(nonnull NSNumber *)timeout
               maxAttempts:(nonnull NSNumber *)maxAttempts
                   started:(void (^)(FIRTransaction *))startedListener
                     ended:(void (^)(void))endedListener {
  self = [super init];
  if (self) {
    _transactionId = transactionId;
    self.firestore = firestore;
    self.maxAttempts = maxAttempts;
    self.timeout = timeout;
    self.started = startedListener;
    self.ended = endedListener;
    self.semaphore = dispatch_semaphore_create(0);
  }
  return self;
}

- (FlutterError *_Nullable)onListenWithArguments:(id _Nullable)arguments
                                       eventSink:(nonnull FlutterEventSink)events {
  __weak FLTTransactionStreamHandler *weakSelf = self;

  id transactionRunBlock = ^id(FIRTransaction *transaction, NSError **pError) {
    FLTTransactionStreamHandler *strongSelf = weakSelf;

    strongSelf.started(transaction);

    dispatch_async(dispatch_get_main_queue(), ^{
      events(
          @{@"appName" : [FLTFirebasePlugin firebaseAppNameFromIosName:self.firestore.app.name]});
    });

    long timedOut = dispatch_semaphore_wait(
        strongSelf.semaphore,
        dispatch_time(DISPATCH_TIME_NOW, [self.timeout integerValue] * NSEC_PER_MSEC));

    if (timedOut) {
      NSArray *codeAndMessage = [FLTFirebaseFirestoreUtils
          ErrorCodeAndMessageFromNSError:[NSError
                                             errorWithDomain:FIRFirestoreErrorDomain
                                                        code:FIRFirestoreErrorCodeDeadlineExceeded
                                                    userInfo:@{}]];

      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{
          @"error" : @{
            @"code" : codeAndMessage[0],
            @"message" : codeAndMessage[1],
          }
        });
      });
    }

    if (self.resultType == PigeonTransactionResultFailure) {
      // Do nothing - already handled in Dart land.
      return nil;
    }

    for (PigeonTransactionCommand *command in self.commands) {
      PigeonTransactionType commandType = command.type;
      NSString *documentPath = command.path;
      FIRDocumentReference *reference = [self.firestore documentWithPath:documentPath];

      switch (commandType) {
        case PigeonTransactionTypeDeleteType:
          [transaction deleteDocument:reference];
          break;
        case PigeonTransactionTypeUpdate:
          [transaction updateData:command.data forDocument:reference];
          break;
        case PigeonTransactionTypeSet:
          if ([command.option.merge isEqual:@YES]) {
            [transaction setData:command.data forDocument:reference merge:YES];
          } else if (command.option.mergeFields) {
            [transaction setData:command.data
                     forDocument:reference
                     mergeFields:[FirestorePigeonParser parseFieldPath:command.option.mergeFields]];
          } else {
            [transaction setData:command.data forDocument:reference];
          }
          break;
        default:
          break;
      }
    }

    return nil;
  };

  id transactionCompleteBlock = ^(id transactionResult, NSError *error) {
    FLTTransactionStreamHandler *strongSelf = weakSelf;
    if (error) {
      NSArray *details = [FLTFirebaseFirestoreUtils ErrorCodeAndMessageFromNSError:error];

      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{
          @"error" : @{
            @"code" : details[0],
            @"message" : details[1],
          }
        });
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        events(@{@"complete" : [NSNumber numberWithBool:YES]});
      });
    }

    dispatch_async(dispatch_get_main_queue(), ^{
      events(FlutterEndOfEventStream);
    });

    strongSelf.ended();
  };
  FIRTransactionOptions *options = [[FIRTransactionOptions alloc] init];
  options.maxAttempts = _maxAttempts.integerValue;

  [_firestore runTransactionWithOptions:options
                                  block:transactionRunBlock
                             completion:transactionCompleteBlock];

  return nil;
}

- (FlutterError *_Nullable)onCancelWithArguments:(id _Nullable)arguments {
  dispatch_semaphore_signal(self.semaphore);

  return nil;
}

- (void)receiveTransactionResponse:(PigeonTransactionResult)resultType
                          commands:(NSArray<PigeonTransactionCommand *> *)commands {
  self.resultType = resultType;
  self.commands = commands;

  dispatch_semaphore_signal(self.semaphore);
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FirestoreMessages.g.m

**크기**: 58285 bytes | **라인 수**: 1383 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "FirestoreMessages.g.h"
#import "FLTFirebaseFirestoreReader.h"
#import "FLTFirebaseFirestoreWriter.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

/// An enumeration of document change types.
@implementation DocumentChangeTypeBox
- (instancetype)initWithValue:(DocumentChangeType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// An enumeration of firestore source types.
@implementation SourceBox
- (instancetype)initWithValue:(Source)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// The listener retrieves data and listens to updates from the local Firestore cache only.
/// If the cache is empty, an empty snapshot will be returned.
/// Snapshot events will be triggered on cache updates, like local mutations or load bundles.
///
/// Note that the data might be stale if the cache hasn't synchronized with recent server-side
/// changes.
@implementation ListenSourceBox
- (instancetype)initWithValue:(ListenSource)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation ServerTimestampBehaviorBox
- (instancetype)initWithValue:(ServerTimestampBehavior)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// [AggregateSource] represents the source of data for an [AggregateQuery].
@implementation AggregateSourceBox
- (instancetype)initWithValue:(AggregateSource)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// [PersistenceCacheIndexManagerRequest] represents the request types for the persistence cache
/// index manager.
@implementation PersistenceCacheIndexManagerRequestBox
- (instancetype)initWithValue:(PersistenceCacheIndexManagerRequest)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation PigeonTransactionResultBox
- (instancetype)initWithValue:(PigeonTransactionResult)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation PigeonTransactionTypeBox
- (instancetype)initWithValue:(PigeonTransactionType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation AggregateTypeBox
- (instancetype)initWithValue:(AggregateType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface PigeonFirebaseSettings ()
+ (PigeonFirebaseSettings *)fromList:(NSArray *)list;
+ (nullable PigeonFirebaseSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FirestorePigeonFirebaseApp ()
+ (FirestorePigeonFirebaseApp *)fromList:(NSArray *)list;
+ (nullable FirestorePigeonFirebaseApp *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonSnapshotMetadata ()
+ (PigeonSnapshotMetadata *)fromList:(NSArray *)list;
+ (nullable PigeonSnapshotMetadata *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentSnapshot ()
+ (PigeonDocumentSnapshot *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentSnapshot *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentChange ()
+ (PigeonDocumentChange *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentChange *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonQuerySnapshot ()
+ (PigeonQuerySnapshot *)fromList:(NSArray *)list;
+ (nullable PigeonQuerySnapshot *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonGetOptions ()
+ (PigeonGetOptions *)fromList:(NSArray *)list;
+ (nullable PigeonGetOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonDocumentOption ()
+ (PigeonDocumentOption *)fromList:(NSArray *)list;
+ (nullable PigeonDocumentOption *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonTransactionCommand ()
+ (PigeonTransactionCommand *)fromList:(NSArray *)list;
+ (nullable PigeonTransactionCommand *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface DocumentReferenceRequest ()
+ (DocumentReferenceRequest *)fromList:(NSArray *)list;
+ (nullable DocumentReferenceRequest *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonQueryParameters ()
+ (PigeonQueryParameters *)fromList:(NSArray *)list;
+ (nullable PigeonQueryParameters *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AggregateQuery ()
+ (AggregateQuery *)fromList:(NSArray *)list;
+ (nullable AggregateQuery *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AggregateQueryResponse ()
+ (AggregateQueryResponse *)fromList:(NSArray *)list;
+ (nullable AggregateQueryResponse *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation PigeonFirebaseSettings
+ (instancetype)makeWithPersistenceEnabled:(nullable NSNumber *)persistenceEnabled
                                      host:(nullable NSString *)host
                                sslEnabled:(nullable NSNumber *)sslEnabled
                            cacheSizeBytes:(nullable NSNumber *)cacheSizeBytes
                 ignoreUndefinedProperties:(NSNumber *)ignoreUndefinedProperties {
  PigeonFirebaseSettings *pigeonResult = [[PigeonFirebaseSettings alloc] init];
  pigeonResult.persistenceEnabled = persistenceEnabled;
  pigeonResult.host = host;
  pigeonResult.sslEnabled = sslEnabled;
  pigeonResult.cacheSizeBytes = cacheSizeBytes;
  pigeonResult.ignoreUndefinedProperties = ignoreUndefinedProperties;
  return pigeonResult;
}
+ (PigeonFirebaseSettings *)fromList:(NSArray *)list {
  PigeonFirebaseSettings *pigeonResult = [[PigeonFirebaseSettings alloc] init];
  pigeonResult.persistenceEnabled = GetNullableObjectAtIndex(list, 0);
  pigeonResult.host = GetNullableObjectAtIndex(list, 1);
  pigeonResult.sslEnabled = GetNullableObjectAtIndex(list, 2);
  pigeonResult.cacheSizeBytes = GetNullableObjectAtIndex(list, 3);
  pigeonResult.ignoreUndefinedProperties = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.ignoreUndefinedProperties != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonFirebaseSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonFirebaseSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.persistenceEnabled ?: [NSNull null]),
    (self.host ?: [NSNull null]),
    (self.sslEnabled ?: [NSNull null]),
    (self.cacheSizeBytes ?: [NSNull null]),
    (self.ignoreUndefinedProperties ?: [NSNull null]),
  ];
}
@end

@implementation FirestorePigeonFirebaseApp
+ (instancetype)makeWithAppName:(NSString *)appName
                       settings:(PigeonFirebaseSettings *)settings
                    databaseURL:(NSString *)databaseURL {
  FirestorePigeonFirebaseApp *pigeonResult = [[FirestorePigeonFirebaseApp alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.settings = settings;
  pigeonResult.databaseURL = databaseURL;
  return pigeonResult;
}
+ (FirestorePigeonFirebaseApp *)fromList:(NSArray *)list {
  FirestorePigeonFirebaseApp *pigeonResult = [[FirestorePigeonFirebaseApp alloc] init];
  pigeonResult.appName = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.appName != nil, @"");
  pigeonResult.settings =
      [PigeonFirebaseSettings nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.settings != nil, @"");
  pigeonResult.databaseURL = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.databaseURL != nil, @"");
  return pigeonResult;
}
+ (nullable FirestorePigeonFirebaseApp *)nullableFromList:(NSArray *)list {
  return (list) ? [FirestorePigeonFirebaseApp fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.appName ?: [NSNull null]),
    (self.settings ? [self.settings toList] : [NSNull null]),
    (self.databaseURL ?: [NSNull null]),
  ];
}
@end

@implementation PigeonSnapshotMetadata
+ (instancetype)makeWithHasPendingWrites:(NSNumber *)hasPendingWrites
                             isFromCache:(NSNumber *)isFromCache {
  PigeonSnapshotMetadata *pigeonResult = [[PigeonSnapshotMetadata alloc] init];
  pigeonResult.hasPendingWrites = hasPendingWrites;
  pigeonResult.isFromCache = isFromCache;
  return pigeonResult;
}
+ (PigeonSnapshotMetadata *)fromList:(NSArray *)list {
  PigeonSnapshotMetadata *pigeonResult = [[PigeonSnapshotMetadata alloc] init];
  pigeonResult.hasPendingWrites = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.hasPendingWrites != nil, @"");
  pigeonResult.isFromCache = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.isFromCache != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonSnapshotMetadata *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonSnapshotMetadata fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.hasPendingWrites ?: [NSNull null]),
    (self.isFromCache ?: [NSNull null]),
  ];
}
@end

@implementation PigeonDocumentSnapshot
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                    metadata:(PigeonSnapshotMetadata *)metadata {
  PigeonDocumentSnapshot *pigeonResult = [[PigeonDocumentSnapshot alloc] init];
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.metadata = metadata;
  return pigeonResult;
}
+ (PigeonDocumentSnapshot *)fromList:(NSArray *)list {
  PigeonDocumentSnapshot *pigeonResult = [[PigeonDocumentSnapshot alloc] init];
  pigeonResult.path = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  pigeonResult.metadata =
      [PigeonSnapshotMetadata nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSAssert(pigeonResult.metadata != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonDocumentSnapshot *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentSnapshot fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.metadata ? [self.metadata toList] : [NSNull null]),
  ];
}
@end

@implementation PigeonDocumentChange
+ (instancetype)makeWithType:(DocumentChangeType)type
                    document:(PigeonDocumentSnapshot *)document
                    oldIndex:(NSNumber *)oldIndex
                    newIndex:(NSNumber *)newIndex {
  PigeonDocumentChange *pigeonResult = [[PigeonDocumentChange alloc] init];
  pigeonResult.type = type;
  pigeonResult.document = document;
  pigeonResult.oldIndex = oldIndex;
  pigeonResult.index = newIndex;
  return pigeonResult;
}
+ (PigeonDocumentChange *)fromList:(NSArray *)list {
  PigeonDocumentChange *pigeonResult = [[PigeonDocumentChange alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.document =
      [PigeonDocumentSnapshot nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.document != nil, @"");
  pigeonResult.oldIndex = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.oldIndex != nil, @"");
  pigeonResult.index = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.index != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonDocumentChange *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentChange fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.document ? [self.document toList] : [NSNull null]),
    (self.oldIndex ?: [NSNull null]),
    (self.index ?: [NSNull null]),
  ];
}
@end

@implementation PigeonQuerySnapshot
+ (instancetype)makeWithDocuments:(NSArray<PigeonDocumentSnapshot *> *)documents
                  documentChanges:(NSArray<PigeonDocumentChange *> *)documentChanges
                         metadata:(PigeonSnapshotMetadata *)metadata {
  PigeonQuerySnapshot *pigeonResult = [[PigeonQuerySnapshot alloc] init];
  pigeonResult.documents = documents;
  pigeonResult.documentChanges = documentChanges;
  pigeonResult.metadata = metadata;
  return pigeonResult;
}
+ (PigeonQuerySnapshot *)fromList:(NSArray *)list {
  PigeonQuerySnapshot *pigeonResult = [[PigeonQuerySnapshot alloc] init];
  pigeonResult.documents = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.documents != nil, @"");
  pigeonResult.documentChanges = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.documentChanges != nil, @"");
  pigeonResult.metadata =
      [PigeonSnapshotMetadata nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSAssert(pigeonResult.metadata != nil, @"");
  return pigeonResult;
}
+ (nullable PigeonQuerySnapshot *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonQuerySnapshot fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.documents ?: [NSNull null]),
    (self.documentChanges ?: [NSNull null]),
    (self.metadata ? [self.metadata toList] : [NSNull null]),
  ];
}
@end

@implementation PigeonGetOptions
+ (instancetype)makeWithSource:(Source)source
       serverTimestampBehavior:(ServerTimestampBehavior)serverTimestampBehavior {
  PigeonGetOptions *pigeonResult = [[PigeonGetOptions alloc] init];
  pigeonResult.source = source;
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (PigeonGetOptions *)fromList:(NSArray *)list {
  PigeonGetOptions *pigeonResult = [[PigeonGetOptions alloc] init];
  pigeonResult.source = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.serverTimestampBehavior = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable PigeonGetOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonGetOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.source),
    @(self.serverTimestampBehavior),
  ];
}
@end

@implementation PigeonDocumentOption
+ (instancetype)makeWithMerge:(nullable NSNumber *)merge
                  mergeFields:(nullable NSArray<NSArray<NSString *> *> *)mergeFields {
  PigeonDocumentOption *pigeonResult = [[PigeonDocumentOption alloc] init];
  pigeonResult.merge = merge;
  pigeonResult.mergeFields = mergeFields;
  return pigeonResult;
}
+ (PigeonDocumentOption *)fromList:(NSArray *)list {
  PigeonDocumentOption *pigeonResult = [[PigeonDocumentOption alloc] init];
  pigeonResult.merge = GetNullableObjectAtIndex(list, 0);
  pigeonResult.mergeFields = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonDocumentOption *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonDocumentOption fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.merge ?: [NSNull null]),
    (self.mergeFields ?: [NSNull null]),
  ];
}
@end

@implementation PigeonTransactionCommand
+ (instancetype)makeWithType:(PigeonTransactionType)type
                        path:(NSString *)path
                        data:(nullable NSDictionary<NSString *, id> *)data
                      option:(nullable PigeonDocumentOption *)option {
  PigeonTransactionCommand *pigeonResult = [[PigeonTransactionCommand alloc] init];
  pigeonResult.type = type;
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.option = option;
  return pigeonResult;
}
+ (PigeonTransactionCommand *)fromList:(NSArray *)list {
  PigeonTransactionCommand *pigeonResult = [[PigeonTransactionCommand alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.path = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  pigeonResult.option = [PigeonDocumentOption nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  return pigeonResult;
}
+ (nullable PigeonTransactionCommand *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonTransactionCommand fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.option ? [self.option toList] : [NSNull null]),
  ];
}
@end

@implementation DocumentReferenceRequest
+ (instancetype)makeWithPath:(NSString *)path
                        data:(nullable NSDictionary<id, id> *)data
                      option:(nullable PigeonDocumentOption *)option
                      source:(nullable SourceBox *)source
     serverTimestampBehavior:(nullable ServerTimestampBehaviorBox *)serverTimestampBehavior {
  DocumentReferenceRequest *pigeonResult = [[DocumentReferenceRequest alloc] init];
  pigeonResult.path = path;
  pigeonResult.data = data;
  pigeonResult.option = option;
  pigeonResult.source = source;
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (DocumentReferenceRequest *)fromList:(NSArray *)list {
  DocumentReferenceRequest *pigeonResult = [[DocumentReferenceRequest alloc] init];
  pigeonResult.path = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.path != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  pigeonResult.option = [PigeonDocumentOption nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  NSNumber *sourceAsNumber = GetNullableObjectAtIndex(list, 3);
  SourceBox *source =
      sourceAsNumber == nil ? nil : [[SourceBox alloc] initWithValue:[sourceAsNumber integerValue]];
  pigeonResult.source = source;
  NSNumber *serverTimestampBehaviorAsNumber = GetNullableObjectAtIndex(list, 4);
  ServerTimestampBehaviorBox *serverTimestampBehavior =
      serverTimestampBehaviorAsNumber == nil
          ? nil
          : [[ServerTimestampBehaviorBox alloc]
                initWithValue:[serverTimestampBehaviorAsNumber integerValue]];
  pigeonResult.serverTimestampBehavior = serverTimestampBehavior;
  return pigeonResult;
}
+ (nullable DocumentReferenceRequest *)nullableFromList:(NSArray *)list {
  return (list) ? [DocumentReferenceRequest fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.path ?: [NSNull null]),
    (self.data ?: [NSNull null]),
    (self.option ? [self.option toList] : [NSNull null]),
    (self.source == nil ? [NSNull null] : [NSNumber numberWithInteger:self.source.value]),
    (self.serverTimestampBehavior == nil
         ? [NSNull null]
         : [NSNumber numberWithInteger:self.serverTimestampBehavior.value]),
  ];
}
@end

@implementation PigeonQueryParameters
+ (instancetype)makeWithWhere:(nullable NSArray<NSArray<id> *> *)where
                      orderBy:(nullable NSArray<NSArray<id> *> *)orderBy
                        limit:(nullable NSNumber *)limit
                  limitToLast:(nullable NSNumber *)limitToLast
                      startAt:(nullable NSArray<id> *)startAt
                   startAfter:(nullable NSArray<id> *)startAfter
                        endAt:(nullable NSArray<id> *)endAt
                    endBefore:(nullable NSArray<id> *)endBefore
                      filters:(nullable NSDictionary<NSString *, id> *)filters {
  PigeonQueryParameters *pigeonResult = [[PigeonQueryParameters alloc] init];
  pigeonResult.where = where;
  pigeonResult.orderBy = orderBy;
  pigeonResult.limit = limit;
  pigeonResult.limitToLast = limitToLast;
  pigeonResult.startAt = startAt;
  pigeonResult.startAfter = startAfter;
  pigeonResult.endAt = endAt;
  pigeonResult.endBefore = endBefore;
  pigeonResult.filters = filters;
  return pigeonResult;
}
+ (PigeonQueryParameters *)fromList:(NSArray *)list {
  PigeonQueryParameters *pigeonResult = [[PigeonQueryParameters alloc] init];
  pigeonResult.where = GetNullableObjectAtIndex(list, 0);
  pigeonResult.orderBy = GetNullableObjectAtIndex(list, 1);
  pigeonResult.limit = GetNullableObjectAtIndex(list, 2);
  pigeonResult.limitToLast = GetNullableObjectAtIndex(list, 3);
  pigeonResult.startAt = GetNullableObjectAtIndex(list, 4);
  pigeonResult.startAfter = GetNullableObjectAtIndex(list, 5);
  pigeonResult.endAt = GetNullableObjectAtIndex(list, 6);
  pigeonResult.endBefore = GetNullableObjectAtIndex(list, 7);
  pigeonResult.filters = GetNullableObjectAtIndex(list, 8);
  return pigeonResult;
}
+ (nullable PigeonQueryParameters *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonQueryParameters fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.where ?: [NSNull null]),
    (self.orderBy ?: [NSNull null]),
    (self.limit ?: [NSNull null]),
    (self.limitToLast ?: [NSNull null]),
    (self.startAt ?: [NSNull null]),
    (self.startAfter ?: [NSNull null]),
    (self.endAt ?: [NSNull null]),
    (self.endBefore ?: [NSNull null]),
    (self.filters ?: [NSNull null]),
  ];
}
@end

@implementation AggregateQuery
+ (instancetype)makeWithType:(AggregateType)type field:(nullable NSString *)field {
  AggregateQuery *pigeonResult = [[AggregateQuery alloc] init];
  pigeonResult.type = type;
  pigeonResult.field = field;
  return pigeonResult;
}
+ (AggregateQuery *)fromList:(NSArray *)list {
  AggregateQuery *pigeonResult = [[AggregateQuery alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.field = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable AggregateQuery *)nullableFromList:(NSArray *)list {
  return (list) ? [AggregateQuery fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.field ?: [NSNull null]),
  ];
}
@end

@implementation AggregateQueryResponse
+ (instancetype)makeWithType:(AggregateType)type
                       field:(nullable NSString *)field
                       value:(nullable NSNumber *)value {
  AggregateQueryResponse *pigeonResult = [[AggregateQueryResponse alloc] init];
  pigeonResult.type = type;
  pigeonResult.field = field;
  pigeonResult.value = value;
  return pigeonResult;
}
+ (AggregateQueryResponse *)fromList:(NSArray *)list {
  AggregateQueryResponse *pigeonResult = [[AggregateQueryResponse alloc] init];
  pigeonResult.type = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.field = GetNullableObjectAtIndex(list, 1);
  pigeonResult.value = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable AggregateQueryResponse *)nullableFromList:(NSArray *)list {
  return (list) ? [AggregateQueryResponse fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.type),
    (self.field ?: [NSNull null]),
    (self.value ?: [NSNull null]),
  ];
}
@end

@interface FirebaseFirestoreHostApiCodecReader : FLTFirebaseFirestoreReader
@end
@implementation FirebaseFirestoreHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AggregateQuery fromList:[self readValue]];
    case 129:
      return [AggregateQueryResponse fromList:[self readValue]];
    case 130:
      return [DocumentReferenceRequest fromList:[self readValue]];
    case 131:
      return [FirestorePigeonFirebaseApp fromList:[self readValue]];
    case 132:
      return [PigeonDocumentChange fromList:[self readValue]];
    case 133:
      return [PigeonDocumentOption fromList:[self readValue]];
    case 134:
      return [PigeonDocumentSnapshot fromList:[self readValue]];
    case 135:
      return [PigeonFirebaseSettings fromList:[self readValue]];
    case 136:
      return [PigeonGetOptions fromList:[self readValue]];
    case 137:
      return [PigeonQueryParameters fromList:[self readValue]];
    case 138:
      return [PigeonQuerySnapshot fromList:[self readValue]];
    case 139:
      return [PigeonSnapshotMetadata fromList:[self readValue]];
    case 140:
      return [PigeonTransactionCommand fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseFirestoreHostApiCodecWriter : FLTFirebaseFirestoreWriter
@end
@implementation FirebaseFirestoreHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AggregateQuery class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[AggregateQueryResponse class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[DocumentReferenceRequest class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FirestorePigeonFirebaseApp class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentChange class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentOption class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonDocumentSnapshot class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseSettings class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonGetOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonQueryParameters class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonQuerySnapshot class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSnapshotMetadata class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTransactionCommand class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseFirestoreHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseFirestoreHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseFirestoreHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseFirestoreHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseFirestoreHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseFirestoreHostApiCodecReaderWriter *readerWriter =
        [[FirebaseFirestoreHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FirebaseFirestoreHostApiSetup(id<FlutterBinaryMessenger> binaryMessenger,
                                   NSObject<FirebaseFirestoreHostApi> *api) {
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.loadBundle"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadBundleApp:bundle:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(loadBundleApp:bundle:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        FlutterStandardTypedData *arg_bundle = GetNullableObjectAtIndex(args, 1);
        [api loadBundleApp:arg_app
                    bundle:arg_bundle
                completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.namedQueryGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(namedQueryGetApp:name:options:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(namedQueryGetApp:name:options:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_name = GetNullableObjectAtIndex(args, 1);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 2);
        [api namedQueryGetApp:arg_app
                         name:arg_name
                      options:arg_options
                   completion:^(PigeonQuerySnapshot *_Nullable output,
                                FlutterError *_Nullable error) {
                     callback(wrapResult(output, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.clearPersistence"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearPersistenceApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(clearPersistenceApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api clearPersistenceApp:arg_app
                      completion:^(FlutterError *_Nullable error) {
                        callback(wrapResult(nil, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.disableNetwork"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(disableNetworkApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(disableNetworkApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api disableNetworkApp:arg_app
                    completion:^(FlutterError *_Nullable error) {
                      callback(wrapResult(nil, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.enableNetwork"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enableNetworkApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(enableNetworkApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api enableNetworkApp:arg_app
                   completion:^(FlutterError *_Nullable error) {
                     callback(wrapResult(nil, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.terminate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(terminateApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(terminateApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api terminateApp:arg_app
               completion:^(FlutterError *_Nullable error) {
                 callback(wrapResult(nil, error));
               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.waitForPendingWrites"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForPendingWritesApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(waitForPendingWritesApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api waitForPendingWritesApp:arg_app
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.setIndexConfiguration"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setIndexConfigurationApp:
                                                        indexConfiguration:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(setIndexConfigurationApp:indexConfiguration:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_indexConfiguration = GetNullableObjectAtIndex(args, 1);
        [api setIndexConfigurationApp:arg_app
                   indexConfiguration:arg_indexConfiguration
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.setLoggingEnabled"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLoggingEnabledLoggingEnabled:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(setLoggingEnabledLoggingEnabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_loggingEnabled = GetNullableObjectAtIndex(args, 0);
        [api setLoggingEnabledLoggingEnabled:arg_loggingEnabled
                                  completion:^(FlutterError *_Nullable error) {
                                    callback(wrapResult(nil, error));
                                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.snapshotsInSyncSetup"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(snapshotsInSyncSetupApp:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(snapshotsInSyncSetupApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api snapshotsInSyncSetupApp:arg_app
                          completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionCreate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(transactionCreateApp:
                                                               timeout:maxAttempts:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionCreateApp:timeout:maxAttempts:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_timeout = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_maxAttempts = GetNullableObjectAtIndex(args, 2);
        [api transactionCreateApp:arg_app
                          timeout:arg_timeout
                      maxAttempts:arg_maxAttempts
                       completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionStoreResult"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (transactionStoreResultTransactionId:resultType:commands:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionStoreResultTransactionId:resultType:commands:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transactionId = GetNullableObjectAtIndex(args, 0);
        PigeonTransactionResult arg_resultType = [GetNullableObjectAtIndex(args, 1) integerValue];
        NSArray<PigeonTransactionCommand *> *arg_commands = GetNullableObjectAtIndex(args, 2);
        [api transactionStoreResultTransactionId:arg_transactionId
                                      resultType:arg_resultType
                                        commands:arg_commands
                                      completion:^(FlutterError *_Nullable error) {
                                        callback(wrapResult(nil, error));
                                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.transactionGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(transactionGetApp:
                                                      transactionId:path:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(transactionGetApp:transactionId:path:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transactionId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_path = GetNullableObjectAtIndex(args, 2);
        [api transactionGetApp:arg_app
                 transactionId:arg_transactionId
                          path:arg_path
                    completion:^(PigeonDocumentSnapshot *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceSet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceSetApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceSetApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceSetApp:arg_app
                             request:arg_request
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceUpdate"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceUpdateApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceUpdateApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceUpdateApp:arg_app
                                request:arg_request
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceGetApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceGetApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceGetApp:arg_app
                             request:arg_request
                          completion:^(PigeonDocumentSnapshot *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceDelete"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(documentReferenceDeleteApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceDeleteApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api documentReferenceDeleteApp:arg_app
                                request:arg_request
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.queryGet"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (queryGetApp:path:isCollectionGroup:parameters:options:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(queryGetApp:path:isCollectionGroup:parameters:options:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 2);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 3);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 4);
        [api queryGetApp:arg_app
                         path:arg_path
            isCollectionGroup:arg_isCollectionGroup
                   parameters:arg_parameters
                      options:arg_options
                   completion:^(PigeonQuerySnapshot *_Nullable output,
                                FlutterError *_Nullable error) {
                     callback(wrapResult(output, error));
                   }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.aggregateQuery"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (aggregateQueryApp:
                                   path:parameters:source:queries:isCollectionGroup:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(aggregateQueryApp:path:parameters:source:queries:isCollectionGroup:"
                @"completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 2);
        AggregateSource arg_source = [GetNullableObjectAtIndex(args, 3) integerValue];
        NSArray<AggregateQuery *> *arg_queries = GetNullableObjectAtIndex(args, 4);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 5);
        [api aggregateQueryApp:arg_app
                          path:arg_path
                    parameters:arg_parameters
                        source:arg_source
                       queries:arg_queries
             isCollectionGroup:arg_isCollectionGroup
                    completion:^(NSArray<AggregateQueryResponse *> *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.writeBatchCommit"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(writeBatchCommitApp:writes:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(writeBatchCommitApp:writes:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSArray<PigeonTransactionCommand *> *arg_writes = GetNullableObjectAtIndex(args, 1);
        [api writeBatchCommitApp:arg_app
                          writes:arg_writes
                      completion:^(FlutterError *_Nullable error) {
                        callback(wrapResult(nil, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.querySnapshot"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (querySnapshotApp:
                                  path:isCollectionGroup:parameters:options:includeMetadataChanges
                                      :source:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(querySnapshotApp:path:isCollectionGroup:parameters:options:"
                @"includeMetadataChanges:source:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_path = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_isCollectionGroup = GetNullableObjectAtIndex(args, 2);
        PigeonQueryParameters *arg_parameters = GetNullableObjectAtIndex(args, 3);
        PigeonGetOptions *arg_options = GetNullableObjectAtIndex(args, 4);
        NSNumber *arg_includeMetadataChanges = GetNullableObjectAtIndex(args, 5);
        ListenSource arg_source = [GetNullableObjectAtIndex(args, 6) integerValue];
        [api querySnapshotApp:arg_app
                              path:arg_path
                 isCollectionGroup:arg_isCollectionGroup
                        parameters:arg_parameters
                           options:arg_options
            includeMetadataChanges:arg_includeMetadataChanges
                            source:arg_source
                        completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.documentReferenceSnapshot"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (documentReferenceSnapshotApp:
                                        parameters:includeMetadataChanges:source:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(documentReferenceSnapshotApp:parameters:includeMetadataChanges:source:"
                @"completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        DocumentReferenceRequest *arg_parameters = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_includeMetadataChanges = GetNullableObjectAtIndex(args, 2);
        ListenSource arg_source = [GetNullableObjectAtIndex(args, 3) integerValue];
        [api documentReferenceSnapshotApp:arg_app
                               parameters:arg_parameters
                   includeMetadataChanges:arg_includeMetadataChanges
                                   source:arg_source
                               completion:^(NSString *_Nullable output,
                                            FlutterError *_Nullable error) {
                                 callback(wrapResult(output, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:@"dev.flutter.pigeon.cloud_firestore_platform_interface."
                        @"FirebaseFirestoreHostApi.persistenceCacheIndexManagerRequest"
        binaryMessenger:binaryMessenger
                  codec:FirebaseFirestoreHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (persistenceCacheIndexManagerRequestApp:request:completion:)],
                @"FirebaseFirestoreHostApi api (%@) doesn't respond to "
                @"@selector(persistenceCacheIndexManagerRequestApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FirestorePigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PersistenceCacheIndexManagerRequest arg_request =
            [GetNullableObjectAtIndex(args, 1) integerValue];
        [api persistenceCacheIndexManagerRequestApp:arg_app
                                            request:arg_request
                                         completion:^(FlutterError *_Nullable error) {
                                           callback(wrapResult(nil, error));
                                         }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Sources/cloud_firestore/FirestorePigeonParser.m

**크기**: 13122 bytes | **라인 수**: 313 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#import "FirestorePigeonParser.h"
#import <Foundation/Foundation.h>

@implementation FirestorePigeonParser

+ (FIRFilter *_Nonnull)filterFromJson:(NSDictionary<NSString *, id> *_Nullable)map {
  if (map[@"fieldPath"]) {
    // Deserialize a FilterQuery
    NSString *op = map[@"op"];
    FIRFieldPath *fieldPath = map[@"fieldPath"];
    id value = map[@"value"];

    // All the operators from Firebase
    if ([op isEqualToString:@"=="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isEqualTo:value];
    } else if ([op isEqualToString:@"!="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isNotEqualTo:value];
    } else if ([op isEqualToString:@"<"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThan:value];
    } else if ([op isEqualToString:@"<="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
    } else if ([op isEqualToString:@">"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThan:value];
    } else if ([op isEqualToString:@">="]) {
      return [FIRFilter filterWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
    } else if ([op isEqualToString:@"array-contains"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContains:value];
    } else if ([op isEqualToString:@"array-contains-any"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath arrayContainsAny:value];
    } else if ([op isEqualToString:@"in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath in:value];
    } else if ([op isEqualToString:@"not-in"]) {
      return [FIRFilter filterWhereFieldPath:fieldPath notIn:value];
    } else {
      @throw [NSException exceptionWithName:@"InvalidOperator"
                                     reason:@"Invalid operator"
                                   userInfo:nil];
    }
  }
  // Deserialize a FilterOperator
  NSString *op = map[@"op"];
  NSArray<NSDictionary<NSString *, id> *> *queries = map[@"queries"];

  // Map queries recursively
  NSMutableArray<FIRFilter *> *parsedFilters = [NSMutableArray array];
  for (NSDictionary<NSString *, id> *query in queries) {
    [parsedFilters addObject:[self filterFromJson:query]];
  }

  if ([op isEqualToString:@"OR"]) {
    return [FIRFilter orFilterWithFilters:parsedFilters];
  } else if ([op isEqualToString:@"AND"]) {
    return [FIRFilter andFilterWithFilters:parsedFilters];
  }

  @throw [NSException exceptionWithName:@"InvalidOperator" reason:@"Invalid operator" userInfo:nil];
}

+ (FIRQuery *_Nonnull)parseQueryWithParameters:(nonnull PigeonQueryParameters *)parameters
                                     firestore:(nonnull FIRFirestore *)firestore
                                          path:(nonnull NSString *)path
                             isCollectionGroup:(Boolean)isCollectionGroup {
  @try {
    FIRQuery *query;

    NSArray *whereConditions = parameters.where;

    if (isCollectionGroup) {
      query = [firestore collectionGroupWithID:path];
    } else {
      query = (FIRQuery *)[firestore collectionWithPath:path];
    }

    BOOL isFilterQuery = parameters.filters != nil;
    if (isFilterQuery) {
      FIRFilter *filter = [FirestorePigeonParser filterFromJson:parameters.filters];
      query = [query queryWhereFilter:filter];
    }

    // Filters
    for (id item in whereConditions) {
      NSArray *condition = item;
      FIRFieldPath *fieldPath = (FIRFieldPath *)condition[0];
      NSString *operator= condition[1];
      id value = condition[2];
          if ([operator isEqualToString:@"=="]) {
            query = [query queryWhereFieldPath:fieldPath isEqualTo:value];
          } else if ([operator isEqualToString:@"!="]) {
            query = [query queryWhereFieldPath:fieldPath isNotEqualTo:value];
          } else if ([operator isEqualToString:@"<"]) {
            query = [query queryWhereFieldPath:fieldPath isLessThan:value];
          } else if ([operator isEqualToString:@"<="]) {
            query = [query queryWhereFieldPath:fieldPath isLessThanOrEqualTo:value];
          } else if ([operator isEqualToString:@">"]) {
            query = [query queryWhereFieldPath:fieldPath isGreaterThan:value];
          } else if ([operator isEqualToString:@">="]) {
            query = [query queryWhereFieldPath:fieldPath isGreaterThanOrEqualTo:value];
          } else if ([operator isEqualToString:@"array-contains"]) {
            query = [query queryWhereFieldPath:fieldPath arrayContains:value];
          } else if ([operator isEqualToString:@"array-contains-any"]) {
            query = [query queryWhereFieldPath:fieldPath arrayContainsAny:value];
          } else if ([operator isEqualToString:@"in"]) {
            query = [query queryWhereFieldPath:fieldPath in:value];
          } else if ([operator isEqualToString:@"not-in"]) {
            query = [query queryWhereFieldPath:fieldPath notIn:value];
          } else {
            NSLog(
                @"FLTFirebaseFirestore: An invalid query operator %@ was received but not handled.",
                operator);
          }
    }

    // Limit
    id limit = parameters.limit;
    if (limit) {
      query = [query queryLimitedTo:((NSNumber *)limit).intValue];
    }

    // Limit To Last
    id limitToLast = parameters.limitToLast;
    if (limitToLast) {
      query = [query queryLimitedToLast:((NSNumber *)limitToLast).intValue];
    }

    // Ordering
    NSArray *orderBy = parameters.orderBy;
    if (!orderBy) {
      // We return early if no ordering set as cursor queries below require at least one orderBy
      // set
      return query;
    }

    for (NSArray *orderByParameters in orderBy) {
      FIRFieldPath *fieldPath = (FIRFieldPath *)orderByParameters[0];
      NSNumber *descending = orderByParameters[1];
      query = [query queryOrderedByFieldPath:fieldPath descending:[descending boolValue]];
    }

    // Start At
    id startAt = parameters.startAt;
    if (startAt) query = [query queryStartingAtValues:(NSArray *)startAt];
    // Start After
    id startAfter = parameters.startAfter;
    if (startAfter) query = [query queryStartingAfterValues:(NSArray *)startAfter];
    // End At
    id endAt = parameters.endAt;
    if (endAt) query = [query queryEndingAtValues:(NSArray *)endAt];
    // End Before
    id endBefore = parameters.endBefore;
    if (endBefore) query = [query queryEndingBeforeValues:(NSArray *)endBefore];

    return query;
  } @catch (NSException *exception) {
    NSLog(@"An error occurred while parsing query arguments, this is most likely an error with "
          @"this SDK. %@",
          [exception callStackSymbols]);
    return nil;
  }
}

+ (FIRFirestoreSource)parseSource:(Source)source {
  switch (source) {
    case SourceServerAndCache:
      return FIRFirestoreSourceDefault;
    case SourceServer:
      return FIRFirestoreSourceServer;
    case SourceCache:
      return FIRFirestoreSourceCache;
    default:
      @throw [NSException exceptionWithName:@"Invalid Source"
                                     reason:@"This source is not supported by the SDK"
                                   userInfo:nil];
  }
}

+ (NSArray<FIRFieldPath *> *_Nonnull)parseFieldPath:
    (NSArray<NSArray<NSString *> *> *_Nonnull)fieldPaths {
  NSMutableArray<FIRFieldPath *> *paths = [NSMutableArray arrayWithCapacity:[fieldPaths count]];
  for (NSArray<NSString *> *fieldPath in fieldPaths) {
    FIRFieldPath *parsed = [[FIRFieldPath alloc] initWithFields:fieldPath];
    [paths addObject:parsed];
  }
  return [NSArray arrayWithArray:paths];
}

+ (FIRServerTimestampBehavior)parseServerTimestampBehavior:
    (ServerTimestampBehavior)serverTimestampBehavior {
  switch (serverTimestampBehavior) {
    case ServerTimestampBehaviorNone:
      return FIRServerTimestampBehaviorNone;
    case ServerTimestampBehaviorEstimate:
      return FIRServerTimestampBehaviorEstimate;
    case ServerTimestampBehaviorPrevious:
      return FIRServerTimestampBehaviorPrevious;
    default:
      @throw [NSException
          exceptionWithName:@"Invalid Server Timestamp Behavior"
                     reason:@"This Server Timestamp Behavior is not supported by the SDK"
                   userInfo:nil];
  }
}

+ (FIRListenSource)parseListenSource:(ListenSource)source {
  switch (source) {
    case ListenSourceDefaultSource:
      return FIRListenSourceDefault;
    case ListenSourceCache:
      return FIRListenSourceCache;
    default:
      @throw
          [NSException exceptionWithName:@"Invalid ListenSource"
                                  reason:@"This ListenSource Behavior is not supported by the SDK"
                                userInfo:nil];
  }
}

+ (PigeonSnapshotMetadata *_Nonnull)toPigeonSnapshotMetadata:
    (FIRSnapshotMetadata *_Nonnull)snapshotMetadata {
  return [PigeonSnapshotMetadata
      makeWithHasPendingWrites:[NSNumber numberWithBool:snapshotMetadata.hasPendingWrites]
                   isFromCache:[NSNumber numberWithBool:snapshotMetadata.isFromCache]];
}

+ (PigeonDocumentSnapshot *_Nonnull)
    toPigeonDocumentSnapshot:(FIRDocumentSnapshot *_Nonnull)documentSnapshot
     serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior {
  return [PigeonDocumentSnapshot
      makeWithPath:documentSnapshot.reference.path
              data:[documentSnapshot dataWithServerTimestampBehavior:serverTimestampBehavior]
          metadata:[FirestorePigeonParser toPigeonSnapshotMetadata:documentSnapshot.metadata]];
}

+ (DocumentChangeType)toPigeonDocumentChangeType:(FIRDocumentChangeType)documentChangeType {
  switch (documentChangeType) {
    case FIRDocumentChangeTypeAdded:
      return DocumentChangeTypeAdded;
    case FIRDocumentChangeTypeModified:
      return DocumentChangeTypeModified;
    case FIRDocumentChangeTypeRemoved:
      return DocumentChangeTypeRemoved;
    default:
      @throw [NSException exceptionWithName:@"InvalidDocumentChangeType"
                                     reason:@"Invalid document change type"
                                   userInfo:nil];
  }
}

+ (PigeonDocumentChange *_Nonnull)toPigeonDocumentChange:(FIRDocumentChange *_Nonnull)documentChange
                                 serverTimestampBehavior:
                                     (FIRServerTimestampBehavior)serverTimestampBehavior {
  NSNumber *oldIndex;
  NSNumber *newIndex;

  // Note the Firestore C++ SDK here returns a maxed UInt that is != NSUIntegerMax, so we make one
  // ourselves so we can convert to -1 for Dart.
  NSUInteger MAX_VAL = (NSUInteger)[@(-1) integerValue];

  if (documentChange.newIndex == NSNotFound || documentChange.newIndex == 4294967295 ||
      documentChange.newIndex == MAX_VAL) {
    newIndex = @([@(-1) intValue]);
  } else {
    newIndex = @([@(documentChange.newIndex) intValue]);
  }

  if (documentChange.oldIndex == NSNotFound || documentChange.oldIndex == 4294967295 ||
      documentChange.oldIndex == MAX_VAL) {
    oldIndex = @([@(-1) intValue]);
  } else {
    oldIndex = @([@(documentChange.oldIndex) intValue]);
  }

  return [PigeonDocumentChange
      makeWithType:[FirestorePigeonParser toPigeonDocumentChangeType:documentChange.type]
          document:[FirestorePigeonParser toPigeonDocumentSnapshot:documentChange.document
                                           serverTimestampBehavior:serverTimestampBehavior]
          oldIndex:oldIndex
          newIndex:newIndex];
}

+ (NSArray<PigeonDocumentChange *> *_Nonnull)
    toPigeonDocumentChanges:(NSArray<FIRDocumentChange *> *_Nonnull)documentChanges
    serverTimestampBehavior:(FIRServerTimestampBehavior)serverTimestampBehavior {
  NSMutableArray *pigeonDocumentChanges = [NSMutableArray array];
  for (FIRDocumentChange *documentChange in documentChanges) {
    [pigeonDocumentChanges
        addObject:[FirestorePigeonParser toPigeonDocumentChange:documentChange
                                        serverTimestampBehavior:serverTimestampBehavior]];
  }
  return pigeonDocumentChanges;
}

+ (PigeonQuerySnapshot *_Nonnull)toPigeonQuerySnapshot:(FIRQuerySnapshot *_Nonnull)querySnaphot
                               serverTimestampBehavior:
                                   (FIRServerTimestampBehavior)serverTimestampBehavior {
  NSMutableArray *documentSnapshots = [NSMutableArray array];
  for (FIRDocumentSnapshot *documentSnapshot in querySnaphot.documents) {
    [documentSnapshots
        addObject:[FirestorePigeonParser toPigeonDocumentSnapshot:documentSnapshot
                                          serverTimestampBehavior:serverTimestampBehavior]];
  }
  return [PigeonQuerySnapshot
      makeWithDocuments:documentSnapshots
        documentChanges:[FirestorePigeonParser toPigeonDocumentChanges:querySnaphot.documentChanges
                                               serverTimestampBehavior:serverTimestampBehavior]
               metadata:[FirestorePigeonParser toPigeonSnapshotMetadata:querySnaphot.metadata]];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/macos/cloud_firestore/Package.swift

**크기**: 4282 bytes | **라인 수**: 119 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let firestoreDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    firestoreDirectory,
    "..",
    "..",
    "ios",
    "generated_firebase_sdk_version.txt",
  ])
  do {
    let version = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
      .trimmingCharacters(in: .whitespacesAndNewlines)
    return version
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing generated_firebase_sdk_version.txt: \(error)")
  }
}

func loadPubspecVersions() throws -> (packageVersion: String, firebaseCoreVersion: String) {
  let pubspecPath = NSString.path(withComponents: [firestoreDirectory, "..", "..", "pubspec.yaml"])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    let lines = yamlString.split(separator: "\n")

    guard let packageVersionLine = lines.first(where: { $0.starts(with: "version:") }) else {
      throw ConfigurationError.invalidFormat("No package version line found in pubspec.yaml")
    }
    var packageVersion = packageVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
      .replacingOccurrences(of: "+", with: "-")
    packageVersion = packageVersion.replacingOccurrences(of: "^", with: "")

    guard let firebaseCoreVersionLine = lines.first(where: { $0.contains("firebase_core:") }) else {
      throw ConfigurationError
        .invalidFormat("No firebase_core dependency version line found in pubspec.yaml")
    }
    var firebaseCoreVersion = firebaseCoreVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
    firebaseCoreVersion = firebaseCoreVersion.replacingOccurrences(of: "^", with: "")

    return (packageVersion, firebaseCoreVersion)
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

let library_version: String
let firebase_sdk_version_string: String
let firebase_core_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version = try loadPubspecVersions().packageVersion
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
  firebase_core_version_string = try loadPubspecVersions().firebaseCoreVersion
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

guard let shared_spm_version = Version("\(firebase_core_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(firebase_core_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "cloud_firestore",
  platforms: [
    .macOS("10.15"),
  ],
  products: [
    .library(name: "cloud-firestore", targets: ["cloud_firestore"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "cloud_firestore",
      dependencies: [
        .product(name: "FirebaseFirestore", package: "firebase-ios-sdk"),
        // Wrapper dependency
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/cloud_firestore/Private"),
        .headerSearchPath("include/cloud_firestore/Public"),
        .define("LIBRARY_VERSION", to: "\"\(library_version)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-fst\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/cloud_firestore_test.dart

**크기**: 3372 bytes | **라인 수**: 117 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  FirebaseFirestore? firestore;
  FirebaseFirestore? firestoreSecondary;
  FirebaseApp? secondaryApp;

  group('$FirebaseFirestore', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      secondaryApp = await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
      firestoreSecondary = FirebaseFirestore.instanceFor(app: secondaryApp!);
    });

    test('equality', () {
      expect(firestore, equals(FirebaseFirestore.instance));
      expect(firestore.hashCode, firestore.hashCode);
      expect(
        firestoreSecondary,
        equals(FirebaseFirestore.instanceFor(app: secondaryApp!)),
      );
    });

    test('databaseId', () {
      final firestore = FirebaseFirestore.instanceFor(
        app: Firebase.app(),
        databaseId: 'foo',
      );

      expect(firestore.databaseId, equals('foo'));

      final firestore2 =
          FirebaseFirestore.instanceFor(app: Firebase.app(), databaseId: 'bar');

      expect(firestore2.databaseId, equals('bar'));

      final firestore3 = FirebaseFirestore.instanceFor(
        app: Firebase.app(),
        databaseId: 'fire',
      );

      expect(firestore3.databaseId, equals('fire'));
    });

    test('returns the correct $FirebaseApp', () {
      expect(firestore!.app, equals(Firebase.app()));
      expect(firestoreSecondary!.app, equals(Firebase.app('foo')));
    });

    group('.collection', () {
      test('returns a $CollectionReference', () {
        expect(firestore!.collection('foo'), isA<CollectionReference>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.collection(''), throwsArgumentError);
      });

      test('does accept an invalid path', () {
        // 'foo/bar' points to a document
        expect(() => firestore!.collection('foo/bar'), throwsArgumentError);
      });
    });

    group('.collectionGroup', () {
      test('returns a $Query', () {
        expect(firestore!.collectionGroup('foo'), isA<Query>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.collectionGroup(''), throwsArgumentError);
      });

      test('does accept a path containing "/"', () {
        expect(
          () => firestore!.collectionGroup('foo/bar/baz'),
          throwsArgumentError,
        );
      });
    });

    group('.document', () {
      test('returns a $DocumentReference', () {
        expect(firestore!.doc('foo/bar'), isA<DocumentReference>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.doc(''), throwsArgumentError);
      });

      test('does accept an invalid path', () {
        // 'foo' points to a collection
        expect(() => firestore!.doc('bar'), throwsArgumentError);
      });
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/collection_reference_test.dart

**크기**: 10440 bytes | **라인 수**: 341 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  late FirebaseFirestore firestore;
  late FirebaseFirestore firestoreSecondary;

  group('$CollectionReference', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      FirebaseApp secondaryApp = await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
      firestoreSecondary = FirebaseFirestore.instanceFor(app: secondaryApp);
    });

    test('extends $Query', () {
      // The `firestore` property is publicly accessible via Query.
      // Is there a better way to test this?
      CollectionReference ref = firestore.collection('foo');

      expect(ref.firestore, equals(firestore));
    });

    test('toString', () async {
      expect(
        firestore.collection('foo').toString(),
        'CollectionReference<Map<String, dynamic>>(foo)',
      );
    });

    test('equality', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestoreSecondary.collection('foo');
      CollectionReference ref3 = firestore.collection('bar');

      expect(ref == firestore.collection('foo'), isTrue);
      expect(ref2 == firestoreSecondary.collection('foo'), isTrue);
      expect(ref3 == ref, isFalse);

      DocumentReference docRef = firestore.collection('foo').doc('bar');
      DocumentReference docRef2 =
          firestoreSecondary.collection('foo').doc('bar');

      expect(docRef, firestore.collection('foo').doc('bar'));
      expect(docRef2, firestoreSecondary.collection('foo').doc('bar'));
      expect(docRef == docRef2, isFalse);
    });

    test('returns the correct id', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.id, equals('foo'));
      expect(ref2.id, equals('baz'));
    });

    test('returns the correct parent', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.parent, isNull);
      expect(ref2.parent, isA<DocumentReference>());

      DocumentReference docRef = firestore.doc('foo/bar');
      expect(ref2.parent, equals(docRef));
    });

    test('returns the correct path', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.path, equals('foo'));
      expect(ref2.path, equals('foo/bar/baz'));
    });

    test('doc() returns the correct $DocumentReference', () {
      CollectionReference ref = firestore.collection('foo');

      expect(ref.doc('bar'), firestore.doc('foo/bar'));
    });

    test('path must be non-empty strings', () {
      DocumentReference docRef = firestore.doc('foo/bar');
      expect(() => firestore.collection(''), throwsArgumentError);
      expect(() => docRef.collection(''), throwsArgumentError);
    });

    test('path must be odd length', () {
      DocumentReference docRef = firestore.doc('foo/bar');
      expect(() => firestore.collection('foo/bar'), throwsArgumentError);
      expect(
        () => firestore.collection('foo/bar/baz/quu'),
        throwsArgumentError,
      );
      expect(() => docRef.collection('foo/bar'), throwsArgumentError);
      expect(() => docRef.collection('foo/bar/baz/quu'), throwsArgumentError);
    });

    test('must not have empty segments', () {
      // NOTE: Leading / trailing slashes are okay.
      firestore.collection('/foo/');
      firestore.collection('/foo');
      firestore.collection('foo/');

      const badPaths = ['foo//bar//baz', '//foo', 'foo//'];
      CollectionReference colRef = firestore.collection('test-collection');
      DocumentReference docRef = colRef.doc('test-document');

      for (final path in badPaths) {
        expect(() => firestore.collection(path), throwsArgumentError);
        expect(() => firestore.doc(path), throwsArgumentError);
        expect(() => colRef.doc(path), throwsArgumentError);
        expect(() => docRef.collection(path), throwsArgumentError);
      }
    });

    group('validate', () {
      test('path must be non-empty strings', () {
        DocumentReference docRef = firestore.doc('foo/bar');
        expect(() => firestore.collection(''), throwsArgumentError);
        expect(() => docRef.collection(''), throwsArgumentError);
      });

      test('path must be odd length', () {
        DocumentReference docRef = firestore.doc('foo/bar');
        expect(() => firestore.collection('foo/bar'), throwsArgumentError);
        expect(
          () => firestore.collection('foo/bar/baz/quu'),
          throwsArgumentError,
        );
        expect(() => docRef.collection('foo/bar'), throwsArgumentError);
        expect(
          () => docRef.collection('foo/bar/baz/quu'),
          throwsArgumentError,
        );
      });

      test('must not have empty segments', () {
        // NOTE: Leading / trailing slashes are okay.
        firestore.collection('/foo/');
        firestore.collection('/foo');
        firestore.collection('foo/');

        final badPaths = ['foo//bar//baz', '//foo', 'foo//'];
        CollectionReference colRef = firestore.collection('test-collection');
        DocumentReference docRef = colRef.doc('test-document');

        for (final String path in badPaths) {
          expect(() => firestore.collection(path), throwsArgumentError);
          expect(() => firestore.doc(path), throwsArgumentError);
          expect(() => colRef.doc(path), throwsArgumentError);
          expect(() => docRef.collection(path), throwsArgumentError);
        }
      });
    });

    group('withConverter', () {
      test('implements ==', () {
        int fromFirestore(
          DocumentSnapshot snapshot,
          SnapshotOptions? options,
        ) =>
            42;
        Map<String, dynamic> toFirestore(Object value, SetOptions? options) =>
            {};

        final foo = firestore.collection('foo');
        final bar = firestore.collection('bar');

        final intFoo = foo.withConverter<int>(
          fromFirestore: fromFirestore,
          toFirestore: toFirestore,
        );

        // utilities to check == in both directions as it is possible that
        // a == b is true but b == a is false since the former invoke a's == operator
        // while the latter invoke b's == operator
        void expectEqual(Object? a, Object? b) {
          expect(a, b);
          expect(b, a);
        }

        void expectNotEqual(Object? a, Object? b) {
          expect(a, isNot(b));
          expect(b, isNot(a));
        }

        expectEqual(
          foo.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          bar.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<Object>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<int>(
            fromFirestore: (_, __) => 42,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: (_, __) => {},
          ),
          intFoo,
        );
      });

      test('toString', () {
        final foo = firestore.collection('foo');

        expect(
          foo
              .withConverter<int>(
                fromFirestore: (map, _) => 42,
                toFirestore: (value, _) => {},
              )
              .toString(),
          'CollectionReference<int>(foo)',
        );

        expect(
          foo
              .withConverter<double>(
                fromFirestore: (map, _) => 42,
                toFirestore: (value, _) => {},
              )
              .toString(),
          'CollectionReference<double>(foo)',
        );
      });

      test('id', () {
        final foo = firestore.collection('foo');

        expect(
          foo
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .id,
          foo.id,
        );
      });

      test('path', () {
        final subCollection =
            firestore.collection('foo').doc('42').collection('bar');

        expect(
          subCollection
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .path,
          subCollection.path,
        );
      });

      test('parent', () {
        final subCollection =
            firestore.collection('foo').doc('42').collection('bar');

        expect(
          subCollection
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .parent,
          subCollection.parent,
        );
      });

      test('doc', () {
        final foo = firestore.collection('foo');

        int fromFirestore(
          DocumentSnapshot snapshot,
          SnapshotOptions? options,
        ) =>
            42;
        Map<String, dynamic> toFirestore(Object value, SetOptions? options) =>
            {};

        expect(
          foo
              .withConverter(
                fromFirestore: fromFirestore,
                toFirestore: toFirestore,
              )
              .doc('42'),
          foo.doc('42').withConverter(
                fromFirestore: fromFirestore,
                toFirestore: toFirestore,
              ),
        );
      });
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/field_value_test.dart

**크기**: 606 bytes | **라인 수**: 20 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('$FieldValue', () {
    test('equality', () {
      expect(FieldValue.delete() == FieldValue.delete(), isTrue);
      expect(
        FieldValue.serverTimestamp() == FieldValue.serverTimestamp(),
        isTrue,
      );
      expect(FieldValue.delete() == FieldValue.serverTimestamp(), isFalse);
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/mock.dart

**크기**: 509 bytes | **라인 수**: 16 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/test.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

typedef Callback = void Function(MethodCall call);

void setupCloudFirestoreMocks([Callback? customHandlers]) {
  TestWidgetsFlutterBinding.ensureInitialized();

  setupFirebaseCoreMocks();
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/query_test.dart

**크기**: 13094 bytes | **라인 수**: 403 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  late FirebaseFirestore firestore;
  Query? query;

  group('$Query', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      // secondary app
      await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
    });

    setUp(() {
      // Reset the query before each test
      query = firestore.collection('foo');
    });

    test('.limit() throws if limit is negative', () {
      expect(() => query!.limit(0), throwsAssertionError);
      expect(() => query!.limitToLast(-1), throwsAssertionError);
    });

    group('.where()', () {
      test('throws if field is invalid', () {
        expect(() => query!.where(123), throwsAssertionError);
      });

      test('allows multiple inequalities on different paths is provided', () {
        query!
            .where('foo.bar', isGreaterThanOrEqualTo: 123)
            .where('bar', isLessThan: 123);
      });

      test('allows inequality on the same path', () {
        query!
            .where('foo.bar', isGreaterThan: 123)
            .where('foo.bar', isGreaterThan: 1234);
      });

      test('throw an exception when making query combining `in` & `not-in`',
          () {
        expect(
          () => query!.where('number', whereIn: [1, 2], whereNotIn: [3, 4]),
          throwsAssertionError,
        );

        expect(
          () => query!.where('number', whereIn: [1, 2]).where(
            'number',
            whereNotIn: [3, 4],
          ),
          throwsAssertionError,
        );

        expect(
          () => query!.where('number', whereNotIn: [3, 4]).where(
            'number',
            whereIn: [1, 2],
          ),
          throwsAssertionError,
        );
      });

      test('allows inequality  different to first orderBy', () {
        query!.where('foo', isGreaterThan: 123).orderBy('bar');
        query!.orderBy('bar').where('foo', isGreaterThan: 123);
        query!.where('foo', isGreaterThan: 123).orderBy('bar').orderBy('foo');
        query!.orderBy('bar').orderBy('foo').where('foo', isGreaterThan: 123);
        query!.where(FieldPath.documentId, whereNotIn: ['bar']).orderBy('foo');
        query!.where(FieldPath.documentId, isLessThan: 3).orderBy('foo');
        query!.where(FieldPath.documentId, isGreaterThan: 3).orderBy('foo');
        query!.where('foo', whereNotIn: ['bar']).orderBy('baz');
        query!.where('foo', isLessThan: 3).orderBy('bar');
        query!.where('foo', isGreaterThan: 3).orderBy('bar');
      });

      test('throws if whereIn query length is greater than 30', () {
        List<int> numbers = List.generate(31, (i) => i + 1);
        expect(
          () => query!.where('foo.bar', whereIn: numbers),
          throwsAssertionError,
        );
      });

      test('throws if arrayContainsAny query length is greater than 30', () {
        List<int> numbers = List.generate(31, (i) => i + 1);
        expect(
          () => query!.where(
            'foo',
            arrayContainsAny: numbers,
          ),
          throwsAssertionError,
        );
      });

      test('throws if whereNotIn query length is greater than 10', () {
        expect(
          () => query!.where(
            'foo',
            whereNotIn: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          ),
          throwsAssertionError,
        );
      });

      test('throws if empty array used for whereIn filters', () {
        expect(() => query!.where('foo', whereIn: []), throwsAssertionError);
      });

      test('throws if empty array used for arrayContainsAny filters', () {
        expect(
          () => query!.where('foo', arrayContainsAny: []),
          throwsAssertionError,
        );
      });

      test('throws if multiple array filters in query', () {
        expect(
          () => query!
              .where('foo.bar', arrayContains: 1)
              .where('foo.bar', arrayContains: 2),
          throwsAssertionError,
        );
        expect(
          () => query!
              .where('foo.bar', arrayContains: 1)
              .where('foo.bar', arrayContainsAny: [2, 3]),
          throwsAssertionError,
        );
        expect(
          () => query!.where(
            'foo.bar',
            arrayContainsAny: [1, 2],
          ).where('foo.bar', arrayContains: 3),
          throwsAssertionError,
        );
      });

      test('throws if multiple disjunctive filters in query', () {
        expect(
          () => query!.where('foo', arrayContainsAny: [1]).where(
            'foo',
            arrayContainsAny: [2, 3],
          ),
          throwsAssertionError,
        );
        expect(
          () => query!
              .where('foo', whereIn: [2, 3])
              .where('foo', arrayContains: 1)
              .where('foo', arrayContainsAny: [2]),
          throwsAssertionError,
        );
        expect(
          () => query!.where('foo', arrayContains: 1).where(
            'foo',
            whereIn: [2, 3],
          ).where('foo', arrayContainsAny: [2]),
          throwsAssertionError,
        );
      });

      test(
          'throws if FieldPath.documentId field is used in conjunction with isNotEqualTo filter',
          () {
        expect(
          () => query!
              .where(FieldPath.documentId, isEqualTo: 'fake-id')
              .where('foo', isNotEqualTo: 'bar'),
          throwsAssertionError,
        );

        expect(
          () => query!
              .where('foo', isNotEqualTo: 'bar')
              .where(FieldPath.documentId, whereIn: [2, 3]),
          throwsAssertionError,
        );
      });

      test(
          'allow isNotEqualTo filter on FieldPath.documentId field & a different field on a separate filter',
          () {
        query!
            .where(FieldPath.documentId, isNotEqualTo: 'fake-id')
            .where(FieldPath.documentId, isEqualTo: 'another-fake-id')
            .where('foo', isNull: true);
      });

      test('allows arrayContains with whereIn filter', () {
        query!.where('foo', arrayContains: 1).where('foo', whereIn: [2, 3]);
        query!.where('foo', whereIn: [2, 3]).where('foo', arrayContains: 1);
        // cannot use more than one 'array-contains' or 'whereIn' filter
        expect(
          () => query!
              .where('foo', whereIn: [2, 3])
              .where('foo', arrayContains: 1)
              .where('foo', arrayContains: 2),
          throwsAssertionError,
        );
      });
    });

    group('cursor queries', () {
      test('throws if starting or ending point specified after orderBy', () {
        Query q = query!.orderBy('foo');
        expect(() => q.startAt([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.startAfter([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.endAt([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.endBefore([1]).orderBy('bar'), throwsAssertionError);
      });

      test('throws if inconsistent arguments number', () {
        expect(
          () => query!.orderBy('foo').startAt(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').startAfter(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').endAt(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').endBefore(['bar', 'baz']),
          throwsAssertionError,
        );
      });

      test('throws if fields are not a String or FieldPath', () {
        expect(() => query!.endAt([123, {}]), throwsAssertionError);
        expect(() => query!.startAt(['123', []]), throwsAssertionError);
        expect(() => query!.endBefore([true]), throwsAssertionError);
        expect(() => query!.startAfter([false]), throwsAssertionError);
      });

      test('throws if fields is greater than the number of orders', () {
        expect(() => query!.endAt(['123']), throwsAssertionError);
        expect(
          () => query!.startAt([
            FieldPath(const ['123']),
          ]),
          throwsAssertionError,
        );
      });

      test('endAt() replaces all end parameters', () {
        Query q = query!.orderBy('foo').endBefore(['123']);
        expect(q.parameters['endBefore'], equals(['123']));
        q = q.endAt(['456']);
        expect(q.parameters['endBefore'], isNull);
        expect(q.parameters['endAt'], equals(['456']));
      });
    });

    group('withConverter', () {
      test('overrides ==', () {
        final query = firestore.collection('/movies').limit(42);
        final query2 = firestore.collection('/movies').limit(21);

        int fromFirestore(Object? snapshot, Object? options) => 42;
        Map<String, Object?> toFirestore(Object? value, Object? options) => {};
        Map<String, Object?> intToFirestore(int value, Object? options) => {};

        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: intToFirestore,
          ),
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: intToFirestore,
          ),
        );

        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<Object?>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<Object?>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query2.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: (_, __) => 21,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: (_, __) => {},
            ),
          ),
        );
      });
    });

    group('Settings()', () {
      test('Test the assert for setting `cacheSizeBytes` minimum and maximum',
          () {
        void configureCache(int? cacheSizeBytes) {
          assert(
            cacheSizeBytes == null ||
                cacheSizeBytes == Settings.CACHE_SIZE_UNLIMITED ||
                (cacheSizeBytes >= 1048576 && cacheSizeBytes <= 104857600),
            'Cache size, if specified, must be either CACHE_SIZE_UNLIMITED or between 1048576 bytes (inclusive) and 104857600 bytes (inclusive).',
          );
        }

        // Happy paths
        expect(() => configureCache(null), returnsNormally);
        expect(
          () => configureCache(Settings.CACHE_SIZE_UNLIMITED),
          returnsNormally,
        );
        expect(() => configureCache(5000000), returnsNormally);
        expect(() => configureCache(1048577), returnsNormally);
        expect(() => configureCache(104857600), returnsNormally);
        expect(() => configureCache(104857500), returnsNormally);

        // Assertion triggers
        expect(() => configureCache(1), throwsA(isA<AssertionError>()));
        expect(() => configureCache(1000), throwsA(isA<AssertionError>()));
        expect(() => configureCache(200000000), throwsA(isA<AssertionError>()));
        expect(() => configureCache(500000), throwsA(isA<AssertionError>()));
      });
    });
  });
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/test/test_firestore_message_codec.dart

**크기**: 3979 bytes | **라인 수**: 97 | **타입**: text

```
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/method_channel_firestore.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/method_channel_query.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/utils/firestore_message_codec.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';

/// This codec is able to decode FieldValues.
/// This ability is only required in tests, hence why
/// those values are only decoded in tests.
class TestFirestoreMessageCodec extends FirestoreMessageCodec {
  /// Constructor.
  const TestFirestoreMessageCodec();
  static const int _kDocumentReference = 130;
  static const int _kArrayUnion = 132;
  static const int _kArrayRemove = 133;
  static const int _kDelete = 134;
  static const int _kServerTimestamp = 135;
  static const int _kFirestoreInstance = 144;
  static const int _kFirestoreQuery = 145;
  static const int _kFirestoreSettings = 146;

  static const int _kIncrementDouble = 137;
  static const int _kIncrementInteger = 138;

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      // The following cases are only used by unit tests, and not by actual application
      // code paths.
      case _kArrayUnion:
        final List<dynamic> value = readValue(buffer)! as List<dynamic>;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.arrayUnion(value),
        );
      case _kArrayRemove:
        final List<dynamic> value = readValue(buffer)! as List<dynamic>;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.arrayRemove(value),
        );
      case _kDelete:
        return FieldValuePlatform(FieldValueFactoryPlatform.instance.delete());
      case _kServerTimestamp:
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.serverTimestamp(),
        );
      case _kIncrementDouble:
        final double value = readValue(buffer)! as double;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.increment(value),
        );
      case _kIncrementInteger:
        final int value = readValue(buffer)! as int;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.increment(value),
        );
      case _kFirestoreInstance:
        String appName = readValue(buffer)! as String;
        String databaseId = readValue(buffer)! as String;
        readValue(buffer);
        final FirebaseApp app = Firebase.app(appName);
        return MethodChannelFirebaseFirestore(
          app: app,
          databaseId: databaseId,
        );
      case _kFirestoreQuery:
        String appName = readValue(buffer)! as String;
        Map<dynamic, dynamic> values =
            readValue(buffer)! as Map<dynamic, dynamic>;
        final FirebaseApp app = Firebase.app(appName);
        return MethodChannelQuery(
          MethodChannelFirebaseFirestore(app: app, databaseId: '(default)'),
          values['path'],
          FirestorePigeonFirebaseApp(
            appName: "['DEFAULT']",
            settings: PigeonFirebaseSettings(ignoreUndefinedProperties: true),
            databaseURL: '',
          ),
        );
      case _kFirestoreSettings:
        readValue(buffer);
        return const Settings();
      case _kDocumentReference:
        MethodChannelFirebaseFirestore firestore =
            readValue(buffer)! as MethodChannelFirebaseFirestore;
        String path = readValue(buffer)! as String;
        return firestore.doc(path);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/include/cloud_firestore/cloud_firestore_plugin_c_api.h

**크기**: 797 bytes | **라인 수**: 30 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_C_API_H_
#define FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_C_API_H_

#include <flutter_plugin_registrar.h>

#ifdef FLUTTER_PLUGIN_IMPL
#define FLUTTER_PLUGIN_EXPORT __declspec(dllexport)
#else
#define FLUTTER_PLUGIN_EXPORT __declspec(dllimport)
#endif

#if defined(__cplusplus)
extern "C" {
#endif

FLUTTER_PLUGIN_EXPORT void CloudFirestorePluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar);

#if defined(__cplusplus)
}  // extern "C"
#endif

#endif  // FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_C_API_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/test/cloud_firestore_plugin_test.cpp

**크기**: 749 bytes | **라인 수**: 31 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "cloud_firestore_plugin.h"

#include <flutter/method_call.h>
#include <flutter/method_result_functions.h>
#include <flutter/standard_method_codec.h>
#include <gtest/gtest.h>
#include <windows.h>

#include <memory>
#include <string>
#include <variant>

namespace cloud_firestore_windows {
namespace test {

namespace {

using flutter::EncodableMap;
using flutter::EncodableValue;
using flutter::MethodCall;
using flutter::MethodResultFunctions;

}  // namespace

}  // namespace test
}  // namespace cloud_firestore_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/CMakeLists.txt

**크기**: 5082 bytes | **라인 수**: 130 | **타입**: text

```
# The Flutter tooling requires that developers have a version of Visual Studio
# installed that includes CMake 3.14 or later. You should not increase this
# version, as doing so will cause the plugin to fail to compile for some
# customers of the plugin.
cmake_minimum_required(VERSION 3.14)

# Project-level configuration.
set(PROJECT_NAME "cloud_firestore")
project(${PROJECT_NAME} LANGUAGES CXX)

# This value is used when generating builds using this plugin, so it must
# not be changed
set(PLUGIN_NAME "cloud_firestore_plugin")

# Any new source files that you add to the plugin should be added here.
list(APPEND PLUGIN_SOURCES
  "cloud_firestore_plugin.cpp"
  "cloud_firestore_plugin.h"
  "messages.g.cpp"
  "messages.g.h"
  "firestore_codec.cpp"
  "firestore_codec.h"
)

# Read version from pubspec.yaml
file(STRINGS "../pubspec.yaml" pubspec_content)
foreach(line ${pubspec_content})
  string(FIND ${line} "version: " has_version)
  
  if("${has_version}" STREQUAL "0")
    string(FIND ${line} ": " version_start_pos)
    math(EXPR version_start_pos "${version_start_pos} + 2")
    string(LENGTH ${line} version_end_pos)
    math(EXPR len "${version_end_pos} - ${version_start_pos}")
    string(SUBSTRING ${line} ${version_start_pos} ${len} PLUGIN_VERSION)
    break()
  endif()
endforeach(line)

configure_file(plugin_version.h.in ${CMAKE_BINARY_DIR}/generated/cloud_firestore/plugin_version.h)
include_directories(${CMAKE_BINARY_DIR}/generated/)

# Define the plugin library target. Its name must not be changed (see comment
# on PLUGIN_NAME above).
add_library(${PLUGIN_NAME} STATIC
  "include/cloud_firestore/cloud_firestore_plugin_c_api.h"
  "cloud_firestore_plugin_c_api.cpp"
  ${PLUGIN_SOURCES}
  ${CMAKE_BINARY_DIR}/generated/cloud_firestore/plugin_version.h
)

# Apply a standard set of build settings that are configured in the
# application-level CMakeLists.txt. This can be removed for plugins that want
# full control over build settings.
apply_standard_settings(${PLUGIN_NAME})

# Symbols are hidden by default to reduce the chance of accidental conflicts
# between plugins. This should not be removed; any symbols that should be
# exported should be explicitly exported with the FLUTTER_PLUGIN_EXPORT macro.
set_target_properties(${PLUGIN_NAME} PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_compile_definitions(${PLUGIN_NAME} PUBLIC FLUTTER_PLUGIN_IMPL)
# Enable firebase-cpp-sdk's platform logging api.
target_compile_definitions(${PLUGIN_NAME} PRIVATE -DINTERNAL_EXPERIMENTAL=1)

# Source include directories and library dependencies. Add any plugin-specific
# dependencies here.
set(MSVC_RUNTIME_MODE MD)
set(firebase_libs firebase_core_plugin firebase_auth firebase_firestore)
set(ADDITIONAL_LIBS advapi32 ws2_32 crypt32 rpcrt4 ole32 shell32 Bcrypt.lib DbgHelp.lib)
target_link_libraries(${PLUGIN_NAME} PRIVATE "${firebase_libs}" "${ADDITIONAL_LIBS}")


# Source include directories and library dependencies. Add any plugin-specific
# dependencies here.
target_include_directories(${PLUGIN_NAME} INTERFACE
  "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(${PLUGIN_NAME} PRIVATE flutter flutter_wrapper_plugin)

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(cloud_firestore_bundled_libraries
  ""
  PARENT_SCOPE
)

# === Tests ===
# These unit tests can be run from a terminal after building the example, or
# from Visual Studio after opening the generated solution file.

# Only enable test builds when building the example (which sets this variable)
# so that plugin clients aren't building the tests.
if (${include_${PROJECT_NAME}_tests})
set(TEST_RUNNER "${PROJECT_NAME}_test")
enable_testing()

# Add the Google Test dependency.
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/release-1.11.0.zip
)
# Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
# Disable install commands for gtest so it doesn't end up in the bundle.
set(INSTALL_GTEST OFF CACHE BOOL "Disable installation of googletest" FORCE)
FetchContent_MakeAvailable(googletest)

# The plugin's C API is not very useful for unit testing, so build the sources
# directly into the test binary rather than using the DLL.
add_executable(${TEST_RUNNER}
  test/cloud_firestore_plugin_test.cpp
  ${PLUGIN_SOURCES}
)
apply_standard_settings(${TEST_RUNNER})
target_include_directories(${TEST_RUNNER} PRIVATE "${CMAKE_CURRENT_SOURCE_DIR}")
target_link_libraries(${TEST_RUNNER} PRIVATE flutter_wrapper_plugin)
target_link_libraries(${TEST_RUNNER} PRIVATE gtest_main gmock)
# flutter_wrapper_plugin has link dependencies on the Flutter DLL.
add_custom_command(TARGET ${TEST_RUNNER} POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_if_different
  "${FLUTTER_LIBRARY}" $<TARGET_FILE_DIR:${TEST_RUNNER}>
)

# Enable automatic test discovery.
include(GoogleTest)
gtest_discover_tests(${TEST_RUNNER})
endif()

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/cloud_firestore_plugin.cpp

**크기**: 64768 bytes | **라인 수**: 1747 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#pragma comment(lib, \
                "rpcrt4.lib")  // UuidCreate - Minimum supported OS Win 2000

#include "cloud_firestore_plugin.h"

// This must be included before many other Windows headers.
#include <flutter/event_channel.h>
#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>
#include <flutter/standard_method_codec.h>
#include <windows.h>

#include <condition_variable>
#include <future>
#include <memory>
#include <mutex>
#include <sstream>

#include "cloud_firestore/plugin_version.h"
#include "firebase/app.h"
#include "firebase/firestore.h"
#include "firebase/firestore/filter.h"
#include "firebase/log.h"
#include "firebase_core/firebase_core_plugin_c_api.h"
#include "messages.g.h"

using namespace firebase::firestore;
using firebase::App;
using firebase::firestore::DocumentSnapshot;
using firebase::firestore::Firestore;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

namespace cloud_firestore_windows {

static std::string kLibraryName = "flutter-fire-fst";
// static
void CloudFirestorePlugin::RegisterWithRegistrar(
    flutter::PluginRegistrarWindows* registrar) {
  auto channel =
      std::make_unique<flutter::MethodChannel<flutter::EncodableValue>>(
          registrar->messenger(), "cloud_firestore",
          &flutter::StandardMethodCodec::GetInstance());

  auto plugin = std::make_unique<CloudFirestorePlugin>();

  messenger_ = registrar->messenger();

  FirebaseFirestoreHostApi::SetUp(registrar->messenger(), plugin.get());

  registrar->AddPlugin(std::move(plugin));

  // Register for platform logging
  App::RegisterLibrary(kLibraryName.c_str(), getPluginVersion().c_str(),
                       nullptr);
}

firebase::firestore::FieldValue CloudFirestorePlugin::ConvertToFieldValue(
    const flutter::EncodableValue& variant) {
  if (std::holds_alternative<std::monostate>(variant)) {
    return firebase::firestore::FieldValue::Null();
  } else if (std::holds_alternative<bool>(variant)) {
    return firebase::firestore::FieldValue::Boolean(std::get<bool>(variant));
  } else if (std::holds_alternative<int32_t>(variant)) {
    return firebase::firestore::FieldValue::Integer(std::get<int32_t>(variant));
  } else if (std::holds_alternative<int64_t>(variant)) {
    return firebase::firestore::FieldValue::Integer(std::get<int64_t>(variant));
  } else if (std::holds_alternative<double>(variant)) {
    return firebase::firestore::FieldValue::Double(std::get<double>(variant));
  } else if (std::holds_alternative<std::string>(variant)) {
    return firebase::firestore::FieldValue::String(
        std::get<std::string>(variant));
  } else if (std::holds_alternative<flutter::EncodableList>(variant)) {
    const flutter::EncodableList& list =
        std::get<flutter::EncodableList>(variant);
    std::vector<firebase::firestore::FieldValue> convertedList;
    for (const auto& item : list) {
      convertedList.push_back(ConvertToFieldValue(item));
    }
    return firebase::firestore::FieldValue::Array(convertedList);
  } else if (std::holds_alternative<flutter::EncodableMap>(variant)) {
    const flutter::EncodableMap& map = std::get<flutter::EncodableMap>(variant);
    firebase::firestore::MapFieldValue convertedMap =
        ConvertToMapFieldValue(map);
    return firebase::firestore::FieldValue::Map(convertedMap);
  } else if (std::holds_alternative<flutter::CustomEncodableValue>(variant)) {
    const CustomEncodableValue& custom_value =
        std::get<CustomEncodableValue>(variant);

    using firebase::Timestamp;

    if (custom_value.type() ==
        typeid(firebase::firestore::FieldValue::Timestamp)) {
      const firebase::firestore::FieldValue& timestamp =
          std::any_cast<firebase::firestore::FieldValue>(custom_value);
      return timestamp;
    } else if (custom_value.type() ==
               typeid(firebase::firestore::DocumentReference)) {
      const firebase::firestore::DocumentReference& documentReference =
          std::any_cast<firebase::firestore::DocumentReference>(custom_value);
      return firebase::firestore::FieldValue::Reference(documentReference);
    }
    // check if nan and store it in number
    else if (custom_value.type() == typeid(double)) {
      const double& number = std::any_cast<double>(custom_value);
      return firebase::firestore::FieldValue::Double(number);
    }

    const firebase::firestore::FieldValue& anyField =
        std::any_cast<firebase::firestore::FieldValue>(custom_value);
    return anyField;
  } else {
    // Add more types as needed
    // You may throw an exception or handle this some other way
    throw std::runtime_error("Unsupported EncodableValue type");
  }
}

flutter::BinaryMessenger*
    cloud_firestore_windows::CloudFirestorePlugin::messenger_ = nullptr;

std::map<std::string,
         std::unique_ptr<flutter::EventChannel<flutter::EncodableValue>>>
    event_channels_;
std::map<std::string, std::unique_ptr<flutter::StreamHandler<>>>
    stream_handlers_;
std::map<std::string,
         std::unique_ptr<flutter::StreamHandler<flutter::EncodableValue>>>
    cloud_firestore_windows::CloudFirestorePlugin::transaction_handlers_;
std::map<std::string, std::shared_ptr<firebase::firestore::Transaction>>
    cloud_firestore_windows::CloudFirestorePlugin::transactions_;
std::map<std::string, std::unique_ptr<firebase::firestore::Firestore>>
    cloud_firestore_windows::CloudFirestorePlugin::firestoreInstances_;

std::string RegisterEventChannelWithUUID(
    std::string prefix, std::string uuid,
    std::unique_ptr<flutter::StreamHandler<flutter::EncodableValue>> handler) {
  std::string channelName = prefix + uuid;
  event_channels_[channelName] =
      std::make_unique<flutter::EventChannel<flutter::EncodableValue>>(
          CloudFirestorePlugin::messenger_, channelName,
          &flutter::StandardMethodCodec::GetInstance(
              &FirebaseFirestoreHostApiCodecSerializer::GetInstance()));

  stream_handlers_[channelName] = std::move(handler);

  event_channels_[channelName]->SetStreamHandler(
      std::move(stream_handlers_[channelName]));

  return channelName;
}

std::string RegisterEventChannel(
    std::string prefix,
    std::unique_ptr<flutter::StreamHandler<flutter::EncodableValue>> handler) {
  UUID uuid;
  UuidCreate(&uuid);
  char* str;
  UuidToStringA(&uuid, (RPC_CSTR*)&str);

  std::string channelName = prefix + str;
  event_channels_[channelName] =
      std::make_unique<flutter::EventChannel<flutter::EncodableValue>>(
          CloudFirestorePlugin::messenger_, channelName,
          &flutter::StandardMethodCodec::GetInstance(
              &FirebaseFirestoreHostApiCodecSerializer::GetInstance()));
  stream_handlers_[channelName] = std::move(handler);

  event_channels_[channelName]->SetStreamHandler(
      std::move(stream_handlers_[channelName]));

  return str;
}

CloudFirestorePlugin::CloudFirestorePlugin() {}

CloudFirestorePlugin::~CloudFirestorePlugin() {}

Firestore* GetFirestoreFromPigeon(const FirestorePigeonFirebaseApp& pigeonApp) {
  std::string cacheKey =
      pigeonApp.app_name() + "-" + pigeonApp.database_u_r_l();

  if (CloudFirestorePlugin::firestoreInstances_.find(cacheKey) !=
      CloudFirestorePlugin::firestoreInstances_.end()) {
    return CloudFirestorePlugin::firestoreInstances_[cacheKey].get();
  }

  App* app = App::GetInstance(pigeonApp.app_name().c_str());

  Firestore* firestore =
      Firestore::GetInstance(app, pigeonApp.database_u_r_l().c_str());

  firebase::firestore::Settings settings;

  if (pigeonApp.settings().persistence_enabled()) {
    bool persistEnabled = pigeonApp.settings().persistence_enabled();

    // This is the maximum amount of cache allowed. We use the same number on
    // android.
    int64_t size = 104857600;

    if (pigeonApp.settings().cache_size_bytes()) {
      const int64_t* cacheSizeBytes = pigeonApp.settings().cache_size_bytes();
      if (*cacheSizeBytes != -1) {
        size = *cacheSizeBytes;
      }
    }

    if (persistEnabled) {
      settings.set_cache_size_bytes(size);
    }
  }

  if (pigeonApp.settings().host()) {
    settings.set_host(*pigeonApp.settings().host());

    // Only allow changing ssl if host is also specified.
    settings.set_ssl_enabled(false);
  }

  firestore->set_settings(settings);

  CloudFirestorePlugin::firestoreInstances_[cacheKey] =
      std::unique_ptr<firebase::firestore::Firestore>(firestore);

  return firestore;
}

std::string CloudFirestorePlugin::GetErrorCode(
    firebase::firestore::Error error) {
  switch (error) {
    case kErrorOk:
      return "ok";
    case kErrorCancelled:
      return "cancelled";
    case kErrorUnknown:
      return "unknown";
    case kErrorInvalidArgument:
      return "invalid-argument";
    case kErrorDeadlineExceeded:
      return "deadline-exceeded";
    case kErrorNotFound:
      return "not-found";
    case kErrorAlreadyExists:
      return "already-exists";
    case kErrorPermissionDenied:
      return "permission-denied";
    case kErrorResourceExhausted:
      return "resource-exhausted";
    case kErrorFailedPrecondition:
      return "failed-precondition";
    case kErrorAborted:
      return "aborted";
    case kErrorOutOfRange:
      return "out-of-range";
    case kErrorUnimplemented:
      return "unimplemented";
    case kErrorInternal:
      return "internal";
    case kErrorUnavailable:
      return "unavailable";
    case kErrorDataLoss:
      return "data-loss";
    case kErrorUnauthenticated:
      return "unauthenticated";
    default:
      return "unknown-error";
  }
}

FlutterError CloudFirestorePlugin::ParseError(
    const firebase::FutureBase& completed_future) {
  const firebase::firestore::Error errorCode =
      static_cast<const firebase::firestore::Error>(completed_future.error());

  EncodableMap details;
  details[EncodableValue("code")] =
      EncodableValue(CloudFirestorePlugin::GetErrorCode(errorCode));
  details[EncodableValue("message")] =
      EncodableValue(completed_future.error_message());

  return FlutterError("firebase_firestore", completed_future.error_message(),
                      details);
}

firebase::firestore::Source GetSourceFromPigeon(const Source& pigeonSource) {
  switch (pigeonSource) {
    case Source::serverAndCache:
    default:
      return firebase::firestore::Source::kDefault;
    case Source::server:
      return firebase::firestore::Source::kServer;
    case Source::cache:
      return firebase::firestore::Source::kCache;
  }
}

firebase::firestore::DocumentSnapshot::ServerTimestampBehavior
GetServerTimestampBehaviorFromPigeon(
    const ServerTimestampBehavior& pigeonServerTimestampBehavior) {
  switch (pigeonServerTimestampBehavior) {
    case ServerTimestampBehavior::estimate:
      return firebase::firestore::DocumentSnapshot::ServerTimestampBehavior::
          kEstimate;
    case ServerTimestampBehavior::previous:
      return firebase::firestore::DocumentSnapshot::ServerTimestampBehavior::
          kPrevious;
    case ServerTimestampBehavior::none:
    default:
      return firebase::firestore::DocumentSnapshot::ServerTimestampBehavior::
          kNone;
  }
}

EncodableValue ConvertFieldValueToEncodableValue(const FieldValue& fieldValue) {
  switch (fieldValue.type()) {
    case FieldValue::Type::kNull:
      return EncodableValue();

    case FieldValue::Type::kBoolean:
      return EncodableValue(fieldValue.boolean_value());

    case FieldValue::Type::kInteger:
      return EncodableValue(static_cast<int64_t>(fieldValue.integer_value()));

    case FieldValue::Type::kDouble:
      return EncodableValue(fieldValue.double_value());

    case FieldValue::Type::kTimestamp:
      // Assuming timestamp can be converted to int64_t or some other type that
      // EncodableValue accepts
      return CustomEncodableValue(fieldValue.timestamp_value());

    case FieldValue::Type::kString:
      return EncodableValue(fieldValue.string_value());

    case FieldValue::Type::kMap: {
      EncodableMap encodableMap;
      for (const auto& [key, val] : fieldValue.map_value()) {
        encodableMap[EncodableValue(key)] =
            ConvertFieldValueToEncodableValue(val);
      }
      return EncodableValue(encodableMap);
    }

    case FieldValue::Type::kArray: {
      flutter::EncodableList encodableList;
      for (const auto& val : fieldValue.array_value()) {
        encodableList.push_back(ConvertFieldValueToEncodableValue(val));
      }
      return encodableList;
    }

    case FieldValue::Type::kGeoPoint: {
      return CustomEncodableValue(fieldValue.geo_point_value());
    }

    case FieldValue::Type::kReference: {
      return CustomEncodableValue(fieldValue.reference_value());
    }

    default:
      return EncodableValue(nullptr);
  }
}

flutter::EncodableMap ConvertToEncodableMap(
    const firebase::firestore::MapFieldValue& originalMap) {
  EncodableMap convertedMap;
  for (const auto& kv : originalMap) {
    EncodableValue key = EncodableValue(kv.first);
    EncodableValue value = ConvertFieldValueToEncodableValue(
        kv.second);             // convert FieldValue to EncodableValue
    convertedMap[key] = value;  // insert into the new map
  }
  return convertedMap;
}

PigeonSnapshotMetadata ParseSnapshotMetadata(
    const firebase::firestore::SnapshotMetadata& metadata) {
  PigeonSnapshotMetadata pigeonSnapshotMetadata = PigeonSnapshotMetadata(
      metadata.has_pending_writes(), metadata.is_from_cache());
  return pigeonSnapshotMetadata;
}

PigeonDocumentSnapshot ParseDocumentSnapshot(
    DocumentSnapshot document,
    DocumentSnapshot::ServerTimestampBehavior serverTimestampBehavior) {
  flutter::EncodableMap tempMap =
      ConvertToEncodableMap(document.GetData(serverTimestampBehavior));

  if (tempMap.empty()) {
    return PigeonDocumentSnapshot(document.reference().path(), nullptr,
                                  ParseSnapshotMetadata(document.metadata()));
  }

  PigeonDocumentSnapshot pigeonDocumentSnapshot =
      PigeonDocumentSnapshot(document.reference().path(), &tempMap,
                             ParseSnapshotMetadata(document.metadata()));
  return pigeonDocumentSnapshot;
}

flutter::EncodableList ParseDocumentSnapshots(
    std::vector<DocumentSnapshot> documents,
    DocumentSnapshot::ServerTimestampBehavior serverTimestampBehavior) {
  flutter::EncodableList pigeonDocumentSnapshot = flutter::EncodableList();

  for (const auto& document : documents) {
    pigeonDocumentSnapshot.push_back(CustomEncodableValue(
        ParseDocumentSnapshot(document, serverTimestampBehavior)));
  }
  return pigeonDocumentSnapshot;
}

DocumentChangeType ParseDocumentChangeType(
    const firebase::firestore::DocumentChange::Type& type) {
  switch (type) {
    case firebase::firestore::DocumentChange::Type::kAdded:
      return DocumentChangeType::added;
    case firebase::firestore::DocumentChange::Type::kRemoved:
      return DocumentChangeType::removed;
    case firebase::firestore::DocumentChange::Type::kModified:
      return DocumentChangeType::modified;
  }

  throw std::invalid_argument("Invalid DocumentChangeType");
}

PigeonDocumentChange ParseDocumentChange(
    const firebase::firestore::DocumentChange& document_change,
    DocumentSnapshot::ServerTimestampBehavior serverTimestampBehavior) {
  PigeonDocumentChange pigeonDocumentChange = PigeonDocumentChange(
      ParseDocumentChangeType(document_change.type()),
      ParseDocumentSnapshot(document_change.document(),
                            serverTimestampBehavior),
      document_change.old_index(), document_change.new_index());
  return pigeonDocumentChange;
}

flutter::EncodableList ParseDocumentChanges(
    std::vector<firebase::firestore::DocumentChange> document_changes,
    DocumentSnapshot::ServerTimestampBehavior serverTimestampBehavior) {
  flutter::EncodableList pigeonDocumentChanges = flutter::EncodableList();
  for (const auto& document_change : document_changes) {
    pigeonDocumentChanges.push_back(CustomEncodableValue(
        ParseDocumentChange(document_change, serverTimestampBehavior)));
  }
  return pigeonDocumentChanges;
}

PigeonQuerySnapshot ParseQuerySnapshot(
    const firebase::firestore::QuerySnapshot* query_snapshot,
    DocumentSnapshot::ServerTimestampBehavior serverTimestampBehavior) {
  PigeonQuerySnapshot pigeonQuerySnapshot = PigeonQuerySnapshot(
      ParseDocumentSnapshots(query_snapshot->documents(),
                             serverTimestampBehavior),
      ParseDocumentChanges(query_snapshot->DocumentChanges(),
                           serverTimestampBehavior),
      ParseSnapshotMetadata(query_snapshot->metadata()));

  return pigeonQuerySnapshot;
}

std::vector<firebase::firestore::FieldValue> ConvertToFieldValueList(
    const flutter::EncodableList& originalList) {
  std::vector<firebase::firestore::FieldValue> convertedList;
  for (const auto& item : originalList) {
    firebase::firestore::FieldValue convertedItem =
        CloudFirestorePlugin::ConvertToFieldValue(item);
    convertedList.push_back(convertedItem);
  }
  return convertedList;
}

firebase::firestore::MapFieldValue ConvertToMapFieldValue(
    const EncodableMap& originalMap) {
  firebase::firestore::MapFieldValue convertedMap;

  for (const auto& kv : originalMap) {
    if (std::holds_alternative<std::string>(kv.first)) {
      std::string key = std::get<std::string>(kv.first);
      firebase::firestore::FieldValue value =
          CloudFirestorePlugin::ConvertToFieldValue(kv.second);
      convertedMap[key] = value;
    } else {
      // Handle or skip non-string keys
      // You may throw an exception or handle this some other way
      throw std::runtime_error("Unsupported key type");
    }
  }

  return convertedMap;
}

using flutter::CustomEncodableValue;

firebase::firestore::MapFieldPathValue ConvertToMapFieldPathValue(
    const EncodableMap& originalMap) {
  firebase::firestore::MapFieldPathValue convertedMap;

  for (const auto& kv : originalMap) {
    if (std::holds_alternative<std::string>(kv.first)) {
      std::string key = std::get<std::string>(kv.first);
      std::vector<std::string> convertedList;
      convertedList.push_back(key);

      firebase::firestore::FieldValue value =
          CloudFirestorePlugin::ConvertToFieldValue(kv.second);
      convertedMap[FieldPath(convertedList)] = value;
    } else if (std::holds_alternative<CustomEncodableValue>(kv.first)) {
      const FieldPath& fieldPath =
          std::any_cast<FieldPath>(std::get<CustomEncodableValue>(kv.first));
      firebase::firestore::FieldValue value =
          CloudFirestorePlugin::ConvertToFieldValue(kv.second);
      convertedMap[fieldPath] = value;
    } else {
      // Handle or skip non-string keys
      // You may throw an exception or handle this some other way
      throw std::runtime_error("Unsupported key type");
    }
  }

  return convertedMap;
}

class LoadBundleStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  LoadBundleStreamHandler(Firestore* firestore, std::string bundle) {
    firestore_ = firestore;
    bundle_ = bundle;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    events_ = std::move(events);
    events.reset();
    firestore_->LoadBundle(
        bundle_, [this](const LoadBundleTaskProgress& progress) {
          flutter::EncodableMap map;
          map[flutter::EncodableValue("bytesLoaded")] =
              flutter::EncodableValue(progress.bytes_loaded());
          map[flutter::EncodableValue("documentsLoaded")] =
              flutter::EncodableValue(progress.documents_loaded());
          map[flutter::EncodableValue("totalBytes")] =
              flutter::EncodableValue(progress.total_bytes());
          map[flutter::EncodableValue("totalDocuments")] =
              flutter::EncodableValue(progress.total_documents());
          switch (progress.state()) {
            case LoadBundleTaskProgress::State::kError: {
              EncodableMap details;
              details[EncodableValue("code")] =
                  EncodableValue("load-bundle-error");
              details[EncodableValue("message")] =
                  EncodableValue("Error loading the bundle");

              events_->Error("firebase_firestore", "Error loading the bundle",
                             details);
              events_->EndOfStream();
              return;
            }
            case LoadBundleTaskProgress::State::kInProgress: {
              std::cout << "Bytes loaded from bundle: "
                        << progress.bytes_loaded() << std::endl;
              map[flutter::EncodableValue("taskState")] =
                  flutter::EncodableValue("running");

              events_->Success(map);
              break;
            }
            case LoadBundleTaskProgress::State::kSuccess: {
              std::cout << "Bundle load succeeded" << std::endl;
              map[flutter::EncodableValue("taskState")] =
                  flutter::EncodableValue("success");

              events_->Success(map);
              events_->EndOfStream();
              break;
            }
          }
        });
    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    events_->EndOfStream();
    return nullptr;
  }

 private:
  Firestore* firestore_;
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> events_;
  std::string bundle_;
};

void CloudFirestorePlugin::LoadBundle(
    const FirestorePigeonFirebaseApp& app, const std::vector<uint8_t>& bundle,
    std::function<void(ErrorOr<std::string> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);

  std::string bundleConverted(bundle.begin(), bundle.end());

  auto handler =
      std::make_unique<LoadBundleStreamHandler>(firestore, bundleConverted);

  std::string channelName = RegisterEventChannel(
      "plugins.flutter.io/firebase_firestore/loadBundle/", std::move(handler));

  result(channelName);
}

using firebase::Future;
using firebase::firestore::Query;
using firebase::firestore::QuerySnapshot;

void CloudFirestorePlugin::NamedQueryGet(
    const FirestorePigeonFirebaseApp& app, const std::string& name,
    const PigeonGetOptions& options,
    std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  Future<Query> future = firestore->NamedQuery(name.c_str());

  future.OnCompletion([result, options](const Future<Query>& completed_future) {
    const Query* query = completed_future.result();

    if (query == nullptr) {
      result(
          FlutterError("Named query has not been found. Please check it has "
                       "been loaded properly via loadBundle()."));
      return;
    }

    using firebase::firestore::QuerySnapshot;

    query->Get(GetSourceFromPigeon(options.source()))
        .OnCompletion(
            [result, options](const Future<QuerySnapshot>& completed_future) {
              if (completed_future.error() == firebase::firestore::kErrorOk) {
                const QuerySnapshot* query_snapshot = completed_future.result();
                result(ParseQuerySnapshot(
                    query_snapshot, GetServerTimestampBehaviorFromPigeon(
                                        options.server_timestamp_behavior())));
              } else {
                result(CloudFirestorePlugin::ParseError(completed_future));
                return;
              }
            });
  });
}

void CloudFirestorePlugin::ClearPersistence(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  firestore->ClearPersistence().OnCompletion(
      [result](const Future<void>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          result(std::nullopt);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::DisableNetwork(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  firestore->DisableNetwork().OnCompletion(
      [result](const Future<void>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          result(std::nullopt);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::EnableNetwork(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  firestore->EnableNetwork().OnCompletion(
      [result](const Future<void>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          result(std::nullopt);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::Terminate(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  firestore->Terminate().OnCompletion(
      [result](const Future<void>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          result(std::nullopt);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::WaitForPendingWrites(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  firestore->WaitForPendingWrites().OnCompletion(
      [result](const Future<void>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          result(std::nullopt);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::SetIndexConfiguration(
    const FirestorePigeonFirebaseApp& app,
    const std::string& index_configuration,
    std::function<void(std::optional<FlutterError> reply)> result) {
  // TODO: not available in C++ SDK
  result(FlutterError("Not available in C++ SDK"));
}

void CloudFirestorePlugin::SetLoggingEnabled(
    bool logging_enabled,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::firestore::Firestore::set_log_level(
      logging_enabled ? firebase::LogLevel::kLogLevelDebug
                      : firebase::LogLevel::kLogLevelError);
  result(std::nullopt);
}

class SnapshotInSyncStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  SnapshotInSyncStreamHandler(Firestore* firestore) { firestore_ = firestore; }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    events_ = std::move(events);
    events.reset();
    // We do this to bind the event to the main channel
    auto boundSendEvent =
        std::bind(&SnapshotInSyncStreamHandler::SendEvent, this);
    this->SetSendEventFunction(boundSendEvent);

    listener_ = firestore_->AddSnapshotsInSyncListener([this]() {
      if (sendEventFunc_) sendEventFunc_();
    });
    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    listener_.Remove();
    events_->EndOfStream();
    return nullptr;
  }

  void SetSendEventFunction(std::function<void()> func) {
    sendEventFunc_ = func;
  }

  void SendEvent() { events_->Success(flutter::EncodableValue()); }

 private:
  Firestore* firestore_;
  ListenerRegistration listener_;
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> events_;
  std::function<void()> sendEventFunc_;
};

void CloudFirestorePlugin::SnapshotsInSyncSetup(
    const FirestorePigeonFirebaseApp& app,
    std::function<void(ErrorOr<std::string> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);

  auto handler = std::make_unique<SnapshotInSyncStreamHandler>(firestore);

  UUID uuid;
  UuidCreate(&uuid);
  char* str;
  UuidToStringA(&uuid, (RPC_CSTR*)&str);
  std::string snapshotInSyncId(str);

  std::string channelName = RegisterEventChannelWithUUID(
      "plugins.flutter.io/firebase_firestore/snapshotsInSync/",
      snapshotInSyncId, std::move(handler));
  result(snapshotInSyncId);
}

class TransactionStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  TransactionStreamHandler(Firestore* firestore, long timeout, int maxAttempts,
                           std::string transactionId)
      : firestore_(firestore),
        timeout_(timeout),
        maxAttempts_(maxAttempts),
        transactionId_(transactionId) {}

  void ReceiveTransactionResponse(
      PigeonTransactionResult resultType,
      std::vector<PigeonTransactionCommand> commands) {
    std::lock_guard<std::mutex> lock(commands_mutex_);
    resultType_ = resultType;
    commands_ = commands;
    cv_.notify_one();
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    events_ = std::move(events);
    events.reset();
    TransactionOptions options;
    options.set_max_attempts(maxAttempts_);

    firestore_
        ->RunTransaction(
            options,
            [this](Transaction& transaction, std::string& str) -> Error {
              auto noopDeleter = [](Transaction*) {};
              std::shared_ptr<Transaction> ptr(&transaction, noopDeleter);
              CloudFirestorePlugin::transactions_[transactionId_] =
                  std::move(ptr);

              flutter::EncodableMap map;
              map.emplace("appName", firestore_->app()->name());
              events_->Success(flutter::EncodableValue(map));

              std::unique_lock<std::mutex> lock(mtx_);
              if (cv_.wait_for(lock, std::chrono::milliseconds(timeout_)) ==
                  std::cv_status::timeout) {
                events_->Error("Timeout", "Transaction timed out.");
                events_->EndOfStream();
                return Error::kErrorDeadlineExceeded;
              }

              std::lock_guard<std::mutex> command_lock(commands_mutex_);
              if (commands_.empty()) return Error::kErrorOk;

              for (PigeonTransactionCommand& command : commands_) {
                std::string path = command.path();
                PigeonTransactionType type = command.type();
                if (path.empty() /* or some other invalid condition */) {
                  std::cerr << "Path is invalid: " << path << std::endl;
                  continue;  // Skip this iteration.
                }

                std::cout << "Before: " << path << std::endl;  // Debug print.

                DocumentReference reference = firestore_->Document(path);
                std::cout << "After: " << command.path()
                          << std::endl;  // debug print

                switch (type) {
                  case PigeonTransactionType::set:
                    std::cout << "Transaction set" << path
                              << std::endl;  // Debug print.

                    if (command.option()->merge() != nullptr &&
                        command.option()->merge()) {
                      transaction.Set(reference,
                                      ConvertToMapFieldValue(*command.data()),
                                      SetOptions::Merge());
                    } else if (command.option()->merge_fields()) {
                      transaction.Set(
                          reference, ConvertToMapFieldValue(*command.data()),
                          SetOptions::MergeFieldPaths(ConvertToFieldPathVector(
                              *command.option()->merge_fields())));
                    } else {
                      transaction.Set(reference,
                                      ConvertToMapFieldValue(*command.data()));
                    }

                    break;
                  case PigeonTransactionType::update:
                    std::cout << "Transaction update" << path
                              << std::endl;  // Debug print.

                    transaction.Update(reference,
                                       ConvertToMapFieldValue(*command.data()));
                    break;
                  case PigeonTransactionType::deleteType:
                    std::cout << "Transaction delete" << path
                              << std::endl;  // Debug print.

                    transaction.Delete(reference);
                    break;
                }
              }
              return Error::kErrorOk;
            })
        .OnCompletion([this](const Future<void>& completed_future) {
          flutter::EncodableMap result;
          if (completed_future.error() == firebase::firestore::kErrorOk) {
            result.insert(std::make_pair(flutter::EncodableValue("complete"),
                                         flutter::EncodableValue(true)));
            events_->Success(result);
          } else {
            events_->Error("transaction_error",
                           completed_future.error_message());
          }
          events_->EndOfStream();
        });

    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    std::unique_lock<std::mutex> lock(mtx_);
    cv_.notify_one();
    events_->EndOfStream();
    return nullptr;
  }

 private:
  Firestore* firestore_;
  long timeout_;
  int maxAttempts_;
  std::string transactionId_;
  std::vector<PigeonTransactionCommand> commands_;
  PigeonTransactionResult resultType_;
  std::mutex mtx_;
  std::mutex commands_mutex_;
  std::condition_variable cv_;
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> events_;
};

void CloudFirestorePlugin::TransactionCreate(
    const FirestorePigeonFirebaseApp& app, int64_t timeout,
    int64_t max_attempts,
    std::function<void(ErrorOr<std::string> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);

  UUID uuid;
  UuidCreate(&uuid);
  char* str;
  UuidToStringA(&uuid, (RPC_CSTR*)&str);
  std::string transactionId(str);

  auto handler = std::make_unique<TransactionStreamHandler>(
      firestore, static_cast<long>(timeout), static_cast<int>(max_attempts),
      transactionId);

  // Temporarily release the ownership.
  TransactionStreamHandler* raw_handler = handler.release();
  CloudFirestorePlugin::transaction_handlers_[transactionId] =
      std::unique_ptr<TransactionStreamHandler>(raw_handler);

  // Register the event channel.
  std::string channelName = RegisterEventChannelWithUUID(
      "plugins.flutter.io/firebase_firestore/transaction/", transactionId,
      std::unique_ptr<TransactionStreamHandler>(raw_handler));

  // Return the result (assumed to be transaction ID in this example).
  result(transactionId);
}

using flutter::CustomEncodableValue;

void CloudFirestorePlugin::TransactionStoreResult(
    const std::string& transaction_id,
    const PigeonTransactionResult& result_type,
    const flutter::EncodableList* commands,
    std::function<void(std::optional<FlutterError> reply)> result) {
  if (CloudFirestorePlugin::transaction_handlers_[transaction_id]) {
    TransactionStreamHandler& handler = *static_cast<TransactionStreamHandler*>(
        CloudFirestorePlugin::transaction_handlers_[transaction_id].get());
    std::vector<PigeonTransactionCommand> commandVector;
    for (const auto& element : *commands) {
      const PigeonTransactionCommand& command =
          std::any_cast<PigeonTransactionCommand>(
              std::get<CustomEncodableValue>(element));
      commandVector.push_back(command);
    }
    handler.ReceiveTransactionResponse(result_type, commandVector);
    result(std::nullopt);

  } else {
    result(std::make_optional(FlutterError(
        "transaction_not_found", "Transaction not found", transaction_id)));
  }
}

void CloudFirestorePlugin::TransactionGet(
    const FirestorePigeonFirebaseApp& app, const std::string& transaction_id,
    const std::string& path,
    std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  DocumentReference reference = firestore->Document(path);

  std::shared_ptr<Transaction> transaction = transactions_[transaction_id];
  Error error_code;
  std::string error_message;

  // Call the Get function
  DocumentSnapshot snapshot =
      transaction->Get(reference, &error_code, &error_message);

  if (error_code != Error::kErrorOk) {
    result(FlutterError(error_message));
  } else {
    result(ParseDocumentSnapshot(
        snapshot, DocumentSnapshot::ServerTimestampBehavior::kDefault));
  }
}

using firebase::firestore::DocumentReference;
using firebase::firestore::SetOptions;

std::vector<firebase::firestore::FieldPath> ConvertToFieldPathVector(
    const flutter::EncodableList& encodableList) {
  std::vector<firebase::firestore::FieldPath> fieldVector;

  for (const auto& element : encodableList) {
    flutter::EncodableList fieldPath =
        std::get<flutter::EncodableList>(element);

    std::vector<std::string> convertedList;
    for (const auto& field : fieldPath) {
      convertedList.push_back(std::get<std::string>(field));
    }

    // Was already converted by the Codec
    fieldVector.push_back(firebase::firestore::FieldPath(convertedList));
  }

  return fieldVector;
}

void CloudFirestorePlugin::DocumentReferenceSet(
    const FirestorePigeonFirebaseApp& app,
    const DocumentReferenceRequest& request,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  DocumentReference document_reference = firestore->Document(request.path());

  // Get the data
  Future<void> future;

  if (request.option()->merge() != nullptr && request.option()->merge()) {
    future = document_reference.Set(ConvertToMapFieldValue(*request.data()),
                                    SetOptions::Merge());
  } else if (request.option()->merge_fields()) {
    future = document_reference.Set(
        ConvertToMapFieldValue(*request.data()),
        SetOptions::MergeFieldPaths(
            ConvertToFieldPathVector(*request.option()->merge_fields())));
  } else {
    future = document_reference.Set(ConvertToMapFieldValue(*request.data()));
  }

  future.OnCompletion([result](const Future<void>& completed_future) {
    if (completed_future.error() == firebase::firestore::kErrorOk) {
      result(std::nullopt);
    } else {
      result(CloudFirestorePlugin::ParseError(completed_future));
      return;
    }
  });
}

void CloudFirestorePlugin::DocumentReferenceUpdate(
    const FirestorePigeonFirebaseApp& app,
    const DocumentReferenceRequest& request,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  DocumentReference document_reference = firestore->Document(request.path());

  // Get the data
  MapFieldPathValue data = ConvertToMapFieldPathValue(*request.data());
  Future<void> future = document_reference.Update(data);

  future.OnCompletion([result](const Future<void>& completed_future) {
    if (completed_future.error() == firebase::firestore::kErrorOk) {
      result(std::nullopt);
    } else {
      result(CloudFirestorePlugin::ParseError(completed_future));
      return;
    }
  });
}

void CloudFirestorePlugin::DocumentReferenceGet(
    const FirestorePigeonFirebaseApp& app,
    const DocumentReferenceRequest& request,
    std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  DocumentReference document_reference = firestore->Document(request.path());

  firebase::firestore::Source source = GetSourceFromPigeon(*request.source());

  Future<DocumentSnapshot> future = document_reference.Get(source);

  future.OnCompletion(
      [result, request](const Future<DocumentSnapshot>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          const DocumentSnapshot* document_snapshot = completed_future.result();
          result(ParseDocumentSnapshot(
              *document_snapshot, GetServerTimestampBehaviorFromPigeon(
                                      *request.server_timestamp_behavior())));
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
          return;
        }
      });
}

void CloudFirestorePlugin::DocumentReferenceDelete(
    const FirestorePigeonFirebaseApp& app,
    const DocumentReferenceRequest& request,
    std::function<void(std::optional<FlutterError> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  DocumentReference document_reference = firestore->Document(request.path());

  Future<void> future = document_reference.Delete();

  future.OnCompletion([result](const Future<void>& completed_future) {
    if (completed_future.error() == firebase::firestore::kErrorOk) {
      result(std::nullopt);
    } else {
      result(CloudFirestorePlugin::ParseError(completed_future));
      return;
    }
  });
}

// Convert EncodableList to std::vector<std::vector<EncodableValue>>
std::vector<std::vector<EncodableValue>> ConvertToConditions(
    const flutter::EncodableList& encodableList) {
  std::vector<std::vector<EncodableValue>> conditions;

  for (const auto& element : encodableList) {
    std::vector<EncodableValue> condition;

    for (const auto& conditionElement :
         std::get<flutter::EncodableList>(element)) {
      condition.push_back(conditionElement);
    }

    conditions.push_back(condition);
  }

  return conditions;
}

using firebase::firestore::Filter;

firebase::firestore::Filter filterFromJson(const EncodableMap& map) {
  if (map.find(EncodableValue("fieldPath")) != map.end()) {
    // Deserialize a FilterQuery
    std::string op = std::get<std::string>(map.at(EncodableValue("op")));
    const FieldPath& fieldPath = std::any_cast<FieldPath>(
        std::get<CustomEncodableValue>(map.at(EncodableValue("fieldPath"))));

    auto value = map.at(EncodableValue("value"));

    // All the operators from Firebase
    if (op == "==") {
      return Filter::EqualTo(fieldPath,
                             CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == "!=") {
      return Filter::NotEqualTo(
          fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == "<") {
      return Filter::LessThan(fieldPath,
                              CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == "<=") {
      return Filter::LessThanOrEqualTo(
          fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == ">") {
      return Filter::GreaterThan(
          fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == ">=") {
      return Filter::GreaterThanOrEqualTo(
          fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == "array-contains") {
      return Filter::ArrayContains(
          fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
    } else if (op == "array-contains-any") {
      // Here you should make sure 'value' is the correct type, e.g., a vector
      return Filter::ArrayContainsAny(
          fieldPath,
          ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
    } else if (op == "in") {
      return Filter::In(
          fieldPath,
          ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
    } else if (op == "not-in") {
      return Filter::NotIn(
          fieldPath,
          ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
    } else {
      throw std::runtime_error("Invalid operator");
    }
  }

  // Deserialize a FilterOperator
  std::string op = std::get<std::string>(map.at(EncodableValue("op")));
  // Assuming the queries are a list of maps

  std::vector<EncodableMap> queries;
  for (const auto& query :
       std::get<flutter::EncodableList>(map.at(EncodableValue("queries")))) {
    queries.push_back(std::get<EncodableMap>(query));
  }

  std::vector<Filter> parsedFilters;
  for (const auto& query : queries) {
    parsedFilters.push_back(filterFromJson(query));
  }

  if (op == "OR") {
    return Filter::Or(parsedFilters);
  } else if (op == "AND") {
    return Filter::And(parsedFilters);
  }

  throw std::runtime_error("Invalid operator");
}

firebase::firestore::Query ParseQuery(firebase::firestore::Firestore* firestore,
                                      const std::string& path,
                                      bool isCollectionGroup,
                                      const PigeonQueryParameters& parameters) {
  try {
    firebase::firestore::Query query;

    if (isCollectionGroup) {
      query = firestore->CollectionGroup(path);
    } else {
      query = firestore->Collection(path);
    }

    if (parameters.filters()) {
      Filter filter = filterFromJson(*parameters.filters());
      query = query.Where(filter);
    }

    std::vector<std::vector<EncodableValue>> conditions =
        ConvertToConditions(*parameters.where());

    for (const auto& condition : conditions) {
      const FieldPath& fieldPath = std::any_cast<FieldPath>(
          std::get<CustomEncodableValue>(condition[0]));
      const std::string& op = std::get<std::string>(condition[1]);

      auto value = condition[2];
      if (op == "==") {
        query = query.WhereEqualTo(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == "!=") {
        query = query.WhereNotEqualTo(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == "<") {
        query = query.WhereLessThan(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == "<=") {
        query = query.WhereLessThanOrEqualTo(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == ">") {
        query = query.WhereGreaterThan(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == ">=") {
        query = query.WhereGreaterThanOrEqualTo(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == "array-contains") {
        query = query.WhereArrayContains(
            fieldPath, CloudFirestorePlugin::ConvertToFieldValue(value));
      } else if (op == "array-contains-any") {
        query = query.WhereArrayContainsAny(
            fieldPath,
            ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
      } else if (op == "in") {
        query = query.WhereIn(
            fieldPath,
            ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
      } else if (op == "not-in") {
        query = query.WhereNotIn(
            fieldPath,
            ConvertToFieldValueList(std::get<flutter::EncodableList>(value)));
      } else {
        throw std::runtime_error("Unknown operator");
      }
    }

    if (parameters.limit()) {
      query = query.Limit(static_cast<int32_t>(*parameters.limit()));
    }

    if (parameters.limit_to_last()) {
      query =
          query.LimitToLast(static_cast<int32_t>(*parameters.limit_to_last()));
    }

    if (parameters.order_by() == nullptr) {
      return query;
    }

    std::vector<std::vector<EncodableValue>> order_bys =
        ConvertToConditions(*parameters.order_by());

    for (const auto& order_by : order_bys) {
      const FieldPath& fieldPath =
          std::any_cast<FieldPath>(std::get<CustomEncodableValue>(order_by[0]));
      const bool& direction = std::get<bool>(order_by[1]);

      if (direction) {
        query = query.OrderBy(fieldPath, Query::Direction::kDescending);
      } else if (!direction) {
        query = query.OrderBy(fieldPath, Query::Direction::kAscending);
      } else {
        throw std::runtime_error("Unknown direction");
      }
    }

    if (parameters.start_at()) {
      query = query.StartAt(ConvertToFieldValueList(*parameters.start_at()));
    }
    if (parameters.start_after()) {
      query =
          query.StartAfter(ConvertToFieldValueList(*parameters.start_after()));
    }
    if (parameters.end_at()) {
      query = query.EndAt(ConvertToFieldValueList(*parameters.end_at()));
    }
    if (parameters.end_before()) {
      query =
          query.EndBefore(ConvertToFieldValueList(*parameters.end_before()));
    }

    return query;
  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    // Return a 'null' or 'empty' query based on your C++ Firestore API
    return firebase::firestore::Query();
  }
}

void CloudFirestorePlugin::QueryGet(
    const FirestorePigeonFirebaseApp& app, const std::string& path,
    bool is_collection_group, const PigeonQueryParameters& parameters,
    const PigeonGetOptions& options,
    std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  Query query = ParseQuery(firestore, path, is_collection_group, parameters);

  firebase::firestore::Source source = GetSourceFromPigeon(options.source());

  Future<firebase::firestore::QuerySnapshot> future = query.Get(source);

  future.OnCompletion(
      [result, options](
          const Future<firebase::firestore::QuerySnapshot>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          const firebase::firestore::QuerySnapshot* querySnapshot =
              completed_future.result();
          result(ParseQuerySnapshot(querySnapshot,
                                    GetServerTimestampBehaviorFromPigeon(
                                        options.server_timestamp_behavior())));
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
        }
      });
}

firebase::firestore::AggregateSource GetAggregateSourceFromPigeon(
    const AggregateSource& source) {
  switch (source) {
    case AggregateSource::server:
    default:
      return firebase::firestore::AggregateSource::kServer;
  }
}

void CloudFirestorePlugin::AggregateQuery(
    const FirestorePigeonFirebaseApp& app, const std::string& path,
    const PigeonQueryParameters& parameters, const AggregateSource& source,
    const flutter::EncodableList& queries, bool is_collection_group,
    std::function<void(ErrorOr<flutter::EncodableList> reply)> result) {
  Firestore* firestore = GetFirestoreFromPigeon(app);
  Query query = ParseQuery(firestore, path, is_collection_group, parameters);

  // C++ SDK does not support average and sum
  firebase::firestore::AggregateQuery aggregate_query;

  for (auto& queryRequest : queries) {
    const cloud_firestore_windows::AggregateQuery& queryRequestTyped =
        std::any_cast<cloud_firestore_windows::AggregateQuery>(
            std::get<CustomEncodableValue>(queryRequest));

    switch (queryRequestTyped.type()) {
      case AggregateType::count:
        aggregate_query = query.Count();
        break;
      case AggregateType::sum:
        std::cout << "Sum is not supported on C++" << std::endl;
        break;
      case AggregateType::average:
        std::cout << "Average is not supported on C++" << std::endl;
        break;
    }
  }

  Future<AggregateQuerySnapshot> future =
      aggregate_query.Get(GetAggregateSourceFromPigeon(source));

  future.OnCompletion(
      [result,
       queries](const Future<AggregateQuerySnapshot>& completed_future) {
        if (completed_future.error() == firebase::firestore::kErrorOk) {
          const AggregateQuerySnapshot* aggregateQuerySnapshot =
              completed_future.result();
          EncodableList aggregateResponses;

          for (auto& queryRequest : queries) {
            const cloud_firestore_windows::AggregateQuery& queryRequestTyped =
                std::any_cast<cloud_firestore_windows::AggregateQuery>(
                    std::get<CustomEncodableValue>(queryRequest));

            switch (queryRequestTyped.type()) {
              case AggregateType::count: {
                double doubleValue =
                    static_cast<double>(aggregateQuerySnapshot->count());
                AggregateQueryResponse aggregateResponse(AggregateType::count,
                                                         nullptr, &doubleValue);
                aggregateResponses.push_back(
                    CustomEncodableValue(aggregateResponse));
                break;
              }
              case AggregateType::sum: {
                std::cout << "Sum is not supported on C++" << std::endl;
                break;
              }
              case AggregateType::average: {
                std::cout << "Average is not supported on C++" << std::endl;
                break;
              }
            }
          }

          result(aggregateResponses);
        } else {
          result(CloudFirestorePlugin::ParseError(completed_future));
        }
      });
}

void CloudFirestorePlugin::WriteBatchCommit(
    const FirestorePigeonFirebaseApp& app, const flutter::EncodableList& writes,
    std::function<void(std::optional<FlutterError> reply)> result) {
  try {
    Firestore* firestore = GetFirestoreFromPigeon(app);
    firebase::firestore::WriteBatch batch = firestore->batch();

    for (const auto& write : writes) {
      const PigeonTransactionCommand& transaction =
          std::any_cast<PigeonTransactionCommand>(
              std::get<CustomEncodableValue>(write));

      PigeonTransactionType type = transaction.type();
      std::string path = transaction.path();
      auto data = transaction.data();

      firebase::firestore::DocumentReference documentReference =
          firestore->Document(path);

      switch (type) {
        case PigeonTransactionType::deleteType:
          batch.Delete(documentReference);
          break;
        case PigeonTransactionType::update:
          batch.Update(documentReference, ConvertToMapFieldValue(*data));
          break;
        case PigeonTransactionType::set:
          const PigeonDocumentOption* options = transaction.option();

          if (options->merge()) {
            batch.Set(documentReference, ConvertToMapFieldValue(*data),
                      firebase::firestore::SetOptions::Merge());
          } else if (options->merge_fields()) {
            batch.Set(documentReference, ConvertToMapFieldValue(*data),
                      SetOptions::MergeFieldPaths(
                          ConvertToFieldPathVector(*options->merge_fields())));
          } else {
            batch.Set(documentReference, ConvertToMapFieldValue(*data));
          }
          break;
      }
    }

    batch.Commit().OnCompletion([result](const Future<void>& completed_future) {
      if (completed_future.error() == firebase::firestore::kErrorOk) {
        result(std::nullopt);
      } else {
        result(CloudFirestorePlugin::ParseError(completed_future));
      }
    });

  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    result(FlutterError(e.what()));
  }
}

std::string METHOD_CHANNEL_NAME = "cloud_firestore";

using firebase::firestore::ListenerRegistration;

class QuerySnapshotStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  QuerySnapshotStreamHandler(
      std::unique_ptr<Query> query, bool includeMetadataChanges,
      firebase::firestore::DocumentSnapshot::ServerTimestampBehavior
          serverTimestampBehavior) {
    query_ = std::move(query);
    includeMetadataChanges_ = includeMetadataChanges;
    serverTimestampBehavior_ = serverTimestampBehavior;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    MetadataChanges metadataChanges = includeMetadataChanges_
                                          ? MetadataChanges::kInclude
                                          : MetadataChanges::kExclude;

    events_ = std::move(events);
    events.reset();

    listener_ = query_->AddSnapshotListener(
        metadataChanges,
        [this, serverTimestampBehavior = serverTimestampBehavior_,
         metadataChanges](const firebase::firestore::QuerySnapshot& snapshot,
                          firebase::firestore::Error error,
                          const std::string& errorMessage) mutable {
          if (error == firebase::firestore::kErrorOk) {
            flutter::EncodableList toListResult(3);
            std::vector<flutter::EncodableValue> documents;
            std::vector<flutter::EncodableValue> documentChanges;

            for (const auto& documentSnapshot : snapshot.documents()) {
              documents.push_back(ParseDocumentSnapshot(documentSnapshot,
                                                        serverTimestampBehavior)
                                      .ToEncodableList());
            }

            // Assuming querySnapshot.getDocumentChanges() returns an iterable
            // collection
            for (const auto& documentChange :
                 snapshot.DocumentChanges(metadataChanges)) {
              documentChanges.push_back(
                  ParseDocumentChange(documentChange, serverTimestampBehavior)
                      .ToEncodableList());
            }

            toListResult[0] = documents;
            toListResult[1] = documentChanges;
            toListResult[2] =
                ParseSnapshotMetadata(snapshot.metadata()).ToEncodableList();

            events_->Success(toListResult);
          } else {
            EncodableMap details;
            details[EncodableValue("code")] =
                EncodableValue(CloudFirestorePlugin::GetErrorCode(error));
            details[EncodableValue("message")] = EncodableValue(errorMessage);

            events_->Error("firebase_firestore", errorMessage, details);
            events_->EndOfStream();
          }
        });
    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    listener_.Remove();
    events_->EndOfStream();
    return nullptr;
  }

 private:
  ListenerRegistration listener_;
  std::unique_ptr<Query> query_;
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> events_;
  bool includeMetadataChanges_;
  firebase::firestore::DocumentSnapshot::ServerTimestampBehavior
      serverTimestampBehavior_;
};

void CloudFirestorePlugin::QuerySnapshot(
    const FirestorePigeonFirebaseApp& app, const std::string& path,
    bool is_collection_group, const PigeonQueryParameters& parameters,
    const PigeonGetOptions& options, bool include_metadata_changes,
    const ListenSource& source,
    std::function<void(ErrorOr<std::string> reply)> result) {
  if (source == ListenSource::cache) {
    result(FlutterError("Listening from cache isn't supported on Windows"));
    return;
  }

  Firestore* firestore = GetFirestoreFromPigeon(app);
  std::unique_ptr<Query> query_ptr = std::make_unique<Query>(
      ParseQuery(firestore, path, is_collection_group, parameters));

  auto query_snapshot_handler = std::make_unique<QuerySnapshotStreamHandler>(
      std::move(query_ptr), include_metadata_changes,
      GetServerTimestampBehaviorFromPigeon(
          options.server_timestamp_behavior()));

  std::string channelName =
      RegisterEventChannel("plugins.flutter.io/firebase_firestore/query/",
                           std::move(query_snapshot_handler));

  result(channelName);
}

class DocumentSnapshotStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  DocumentSnapshotStreamHandler(
      std::unique_ptr<DocumentReference> reference, bool includeMetadataChanges,
      firebase::firestore::DocumentSnapshot::ServerTimestampBehavior
          serverTimestampBehavior) {
    reference_ = std::move(reference);
    includeMetadataChanges_ = includeMetadataChanges;
    serverTimestampBehavior_ = serverTimestampBehavior;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    MetadataChanges metadataChanges = includeMetadataChanges_
                                          ? MetadataChanges::kInclude
                                          : MetadataChanges::kExclude;

    events_ = std::move(events);
    events.reset();

    listener_ = reference_->AddSnapshotListener(
        metadataChanges,
        [this, serverTimestampBehavior = serverTimestampBehavior_,
         metadataChanges](const firebase::firestore::DocumentSnapshot& snapshot,
                          firebase::firestore::Error error,
                          const std::string& errorMessage) mutable {
          if (error == firebase::firestore::kErrorOk) {
            events_->Success(
                ParseDocumentSnapshot(snapshot, serverTimestampBehavior)
                    .ToEncodableList());
          } else {
            EncodableMap details;
            details[EncodableValue("code")] =
                EncodableValue(CloudFirestorePlugin::GetErrorCode(error));
            details[EncodableValue("message")] = EncodableValue(errorMessage);

            events_->Error("firebase_firestore", errorMessage, details);
            events_->EndOfStream();
          }
        });
    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    listener_.Remove();
    events_->EndOfStream();
    return nullptr;
  }

 private:
  firebase::firestore::ListenerRegistration listener_;
  std::unique_ptr<DocumentReference> reference_;
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> events_;
  bool includeMetadataChanges_;
  firebase::firestore::DocumentSnapshot::ServerTimestampBehavior
      serverTimestampBehavior_;
};

void CloudFirestorePlugin::DocumentReferenceSnapshot(
    const FirestorePigeonFirebaseApp& app,
    const DocumentReferenceRequest& parameters, bool include_metadata_changes,
    const ListenSource& source,
    std::function<void(ErrorOr<std::string> reply)> result) {
  if (source == ListenSource::cache) {
    result(FlutterError("Listening from cache isn't supported on Windows"));
    return;
  }
  Firestore* firestore = GetFirestoreFromPigeon(app);
  std::unique_ptr<DocumentReference> documentReference =
      std::make_unique<DocumentReference>(
          firestore->Document(parameters.path()));

  auto document_snapshot_handler =
      std::make_unique<DocumentSnapshotStreamHandler>(
          std::move(documentReference), include_metadata_changes,
          GetServerTimestampBehaviorFromPigeon(
              *parameters.server_timestamp_behavior()));

  std::string channelName =
      RegisterEventChannel("plugins.flutter.io/firebase_firestore/document/",
                           std::move(document_snapshot_handler));
  result(channelName);
}

void CloudFirestorePlugin::PersistenceCacheIndexManagerRequest(
    const FirestorePigeonFirebaseApp& app,
    const PersistenceCacheIndexManagerRequestEnum& request,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError("Not implemented on Windows"));
}

}  // namespace cloud_firestore_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/cloud_firestore_plugin.h

**크기**: 7276 bytes | **라인 수**: 165 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_H_
#define FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_H_

#include <flutter/event_channel.h>
#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>

#include <memory>

#include "firebase/app.h"
#include "firebase/firestore.h"
#include "firebase/log.h"
#include "firebase_core/firebase_core_plugin_c_api.h"
#include "messages.g.h"

namespace cloud_firestore_windows {

class CloudFirestorePlugin : public flutter::Plugin,
                             public FirebaseFirestoreHostApi {
 public:
  static void RegisterWithRegistrar(flutter::PluginRegistrarWindows* registrar);
  static firebase::firestore::FieldValue ConvertToFieldValue(
      const flutter::EncodableValue& variant);

  CloudFirestorePlugin();

  virtual ~CloudFirestorePlugin();

  static std::string GetErrorCode(firebase::firestore::Error authError);

  static FlutterError ParseError(const firebase::FutureBase& completed_future);

  // Disallow copy and assign.
  CloudFirestorePlugin(const CloudFirestorePlugin&) = delete;
  CloudFirestorePlugin& operator=(const CloudFirestorePlugin&) = delete;

  // FirebaseFirestoreHostApi methods.

  // Inherited via FirebaseFirestoreHostApi
  virtual void LoadBundle(
      const FirestorePigeonFirebaseApp& app, const std::vector<uint8_t>& bundle,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void NamedQueryGet(
      const FirestorePigeonFirebaseApp& app, const std::string& name,
      const PigeonGetOptions& options,
      std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) override;
  virtual void ClearPersistence(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void DisableNetwork(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void EnableNetwork(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void Terminate(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void WaitForPendingWrites(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SetIndexConfiguration(
      const FirestorePigeonFirebaseApp& app,
      const std::string& index_configuration,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SetLoggingEnabled(
      bool logging_enabled,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SnapshotsInSyncSetup(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void TransactionCreate(
      const FirestorePigeonFirebaseApp& app, int64_t timeout,
      int64_t max_attempts,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void TransactionStoreResult(
      const std::string& transaction_id,
      const PigeonTransactionResult& result_type,
      const flutter::EncodableList* commands,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void TransactionGet(
      const FirestorePigeonFirebaseApp& app, const std::string& transaction_id,
      const std::string& path,
      std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result)
      override;
  virtual void DocumentReferenceSet(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void DocumentReferenceUpdate(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void DocumentReferenceGet(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result)
      override;
  virtual void DocumentReferenceDelete(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void QueryGet(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      bool is_collection_group, const PigeonQueryParameters& parameters,
      const PigeonGetOptions& options,
      std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) override;
  virtual void AggregateQuery(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      const PigeonQueryParameters& parameters, const AggregateSource& source,
      const flutter::EncodableList& queries, bool is_collection_group,
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result)
      override;
  virtual void WriteBatchCommit(
      const FirestorePigeonFirebaseApp& app,
      const flutter::EncodableList& writes,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void QuerySnapshot(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      bool is_collection_group, const PigeonQueryParameters& parameters,
      const PigeonGetOptions& options, bool include_metadata_changes,
      const ListenSource& source,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void DocumentReferenceSnapshot(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& parameters, bool include_metadata_changes,
      const ListenSource& source,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void PersistenceCacheIndexManagerRequest(
      const FirestorePigeonFirebaseApp& app,
      const PersistenceCacheIndexManagerRequestEnum& request,
      std::function<void(std::optional<FlutterError> reply)> result) override;

  static flutter::BinaryMessenger* messenger_;
  static std::map<
      std::string,
      std::unique_ptr<flutter::EventChannel<flutter::EncodableValue>>>
      event_channels_;
  static std::map<std::string, std::unique_ptr<flutter::StreamHandler<>>>
      stream_handlers_;
  static std::map<std::string, std::unique_ptr<flutter::StreamHandler<>>>
      transaction_handlers_;
  static std::map<std::string,
                  std::shared_ptr<firebase::firestore::Transaction>>
      transactions_;
  static std::map<std::string, std::unique_ptr<firebase::firestore::Firestore>>
      firestoreInstances_;
};

firebase::firestore::MapFieldValue ConvertToMapFieldValue(
    const flutter::EncodableMap& originalMap);

std::vector<firebase::firestore::FieldPath> ConvertToFieldPathVector(
    const flutter::EncodableList& encodableList);

}  // namespace cloud_firestore_windows

#endif  // FLUTTER_PLUGIN_CLOUD_FIRESTORE_PLUGIN_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/cloud_firestore_plugin_c_api.cpp

**크기**: 668 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "include/cloud_firestore/cloud_firestore_plugin_c_api.h"

#include <flutter/plugin_registrar_windows.h>

#include "cloud_firestore_plugin.h"

void CloudFirestorePluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar) {
  cloud_firestore_windows::CloudFirestorePlugin::RegisterWithRegistrar(
      flutter::PluginRegistrarManager::GetInstance()
          ->GetRegistrar<flutter::PluginRegistrarWindows>(registrar));
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/firestore_codec.cpp

**크기**: 10457 bytes | **라인 수**: 301 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "firestore_codec.h"

#include <map>
#include <memory>
#include <optional>
#include <string>

#include "cloud_firestore_plugin.h"
#include "firebase/app.h"
#include "firebase/firestore.h"
#include "firebase/firestore/field_path.h"
#include "firebase/firestore/field_value.h"
#include "firebase/firestore/geo_point.h"
#include "firebase/firestore/timestamp.h"

using firebase::Timestamp;
using firebase::firestore::DocumentReference;
using firebase::firestore::FieldPath;
using firebase::firestore::FieldValue;
using firebase::firestore::Firestore;
using firebase::firestore::GeoPoint;

using flutter::CustomEncodableValue;
using flutter::EncodableValue;

cloud_firestore_windows::FirestoreCodec::FirestoreCodec() {}

union DoubleToBytes {
  double value;
  uint8_t bytes[sizeof(double)];
};

void cloud_firestore_windows::FirestoreCodec::WriteValue(
    const flutter::EncodableValue& value,
    flutter::ByteStreamWriter* stream) const {
  if (std::holds_alternative<CustomEncodableValue>(value)) {
    const CustomEncodableValue& custom_value =
        std::get<CustomEncodableValue>(value);
    if (custom_value.type() == typeid(Timestamp)) {
      const Timestamp& timestamp = std::any_cast<Timestamp>(custom_value);
      stream->WriteByte(DATA_TYPE_TIMESTAMP);
      stream->WriteInt64(timestamp.seconds());
      stream->WriteInt32(timestamp.nanoseconds());
    } else if (custom_value.type() == typeid(GeoPoint)) {
      const GeoPoint& geopoint = std::any_cast<GeoPoint>(custom_value);
      stream->WriteByte(DATA_TYPE_GEO_POINT);
      stream->WriteAlignment(8);
      DoubleToBytes converterLatitude;
      converterLatitude.value = geopoint.latitude();
      stream->WriteBytes(converterLatitude.bytes, 8);
      DoubleToBytes converterLongitude;
      converterLongitude.value = geopoint.longitude();
      stream->WriteBytes(converterLongitude.bytes, 8);
    } else if (custom_value.type() == typeid(DocumentReference)) {
      const DocumentReference& reference =
          std::any_cast<DocumentReference>(custom_value);
      stream->WriteByte(DATA_TYPE_DOCUMENT_REFERENCE);
      const Firestore* firestore = reference.firestore();
      std::string appName = firestore->app()->name();
      std::string databaseUrl = "(default)";
      flutter::StandardCodecSerializer::WriteValue(appName, stream);
      flutter::StandardCodecSerializer::WriteValue(reference.path(), stream);
      flutter::StandardCodecSerializer::WriteValue(databaseUrl, stream);
    } else if (custom_value.type() ==
               typeid(double)) {  // Assuming Double is standard C++ double
      const double& myDouble = std::any_cast<double>(custom_value);
      if (std::isnan(myDouble)) {
        stream->WriteByte(DATA_TYPE_NAN);
      } else if (myDouble == std::numeric_limits<double>::infinity()) {
        stream->WriteByte(DATA_TYPE_INFINITY);
      } else if (myDouble == -std::numeric_limits<double>::infinity()) {
        stream->WriteByte(DATA_TYPE_NEGATIVE_INFINITY);
      } else {
        flutter::StandardCodecSerializer::WriteValue(custom_value, stream);
      }
    }
  } else {
    flutter::StandardCodecSerializer::WriteValue(value, stream);
  }
}

flutter::EncodableValue
cloud_firestore_windows::FirestoreCodec::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case DATA_TYPE_DATE_TIME: {
      int64_t value;
      stream->ReadBytes(reinterpret_cast<uint8_t*>(&value),
                        8);  // Read 8 bytes into value

      return CustomEncodableValue(
          FieldValue::Timestamp(Timestamp(value / 1000, 0)));
    }

    case DATA_TYPE_TIMESTAMP: {
      int64_t seconds;
      int nanoseconds;

      stream->ReadBytes(reinterpret_cast<uint8_t*>(&seconds), 8);
      stream->ReadBytes(reinterpret_cast<uint8_t*>(&nanoseconds), 4);

      return CustomEncodableValue(
          FieldValue::Timestamp(Timestamp(seconds, nanoseconds)));
    }
    case DATA_TYPE_DOCUMENT_REFERENCE: {
      auto customValue =
          std::get<CustomEncodableValue>(FirestoreCodec::ReadValue(stream));

      Firestore* firestoreRef = std::any_cast<Firestore*>(customValue);

      std::string path =
          std::get<std::string>(FirestoreCodec::ReadValue(stream));

      DocumentReference reference = firestoreRef->Document(path);
      return CustomEncodableValue(reference);
    }
    case DATA_TYPE_GEO_POINT: {
      double latitude;
      double longitude;

      stream->ReadAlignment(8);
      stream->ReadBytes(reinterpret_cast<uint8_t*>(&latitude), 8);
      stream->ReadBytes(reinterpret_cast<uint8_t*>(&longitude), 8);

      return CustomEncodableValue(
          FieldValue::GeoPoint(GeoPoint(latitude, longitude)));
    }

    case DATA_TYPE_FIELD_PATH: {
      size_t length = flutter::StandardCodecSerializer::ReadSize(stream);
      std::vector<std::string> array;

      for (uint32_t i = 0; i < length; ++i) {
        array.push_back(
            std::get<std::string>(FirestoreCodec::ReadValue(stream)));
      }

      FieldPath fieldPath(array);
      return CustomEncodableValue(fieldPath);
    }

    case DATA_TYPE_BLOB: {
      // Assume that readSize and ReadBytes are defined to read the blob's size
      // and data
      size_t length = flutter::StandardCodecSerializer::ReadSize(stream);
      std::vector<uint8_t> blobData(length);
      stream->ReadBytes(blobData.data(), length);

      return CustomEncodableValue(FieldValue::Blob(blobData.data(), length));
    }

    case DATA_TYPE_ARRAY_UNION: {
      auto customValue =
          std::get<flutter::EncodableList>(FirestoreCodec::ReadValue(stream));
      std::vector<FieldValue> arrayUnionValue;

      for (auto& value : customValue) {
        arrayUnionValue.push_back(
            cloud_firestore_windows::CloudFirestorePlugin::ConvertToFieldValue(
                value));
      }
      return CustomEncodableValue(FieldValue::ArrayUnion(arrayUnionValue));
    }

    case DATA_TYPE_ARRAY_REMOVE: {
      auto customValue =
          std::get<flutter::EncodableList>(FirestoreCodec::ReadValue(stream));
      std::vector<FieldValue> arrayRemoveValue;

      for (auto& value : customValue) {
        arrayRemoveValue.push_back(
            cloud_firestore_windows::CloudFirestorePlugin::ConvertToFieldValue(
                value));
      }
      return CustomEncodableValue(FieldValue::ArrayRemove(arrayRemoveValue));
    }

    case DATA_TYPE_DELETE: {
      return CustomEncodableValue(FieldValue::Delete());
    }

    case DATA_TYPE_SERVER_TIMESTAMP: {
      return CustomEncodableValue(FieldValue::ServerTimestamp());
    }

    case DATA_TYPE_INCREMENT_DOUBLE: {
      double incrementValue =
          std::get<double>(FirestoreCodec::ReadValue(stream));
      return CustomEncodableValue(FieldValue::Increment(incrementValue));
    }

    case DATA_TYPE_INCREMENT_INTEGER: {
      int incrementValue = std::get<int>(FirestoreCodec::ReadValue(stream));
      return CustomEncodableValue(FieldValue::Increment(incrementValue));
    }

    case DATA_TYPE_DOCUMENT_ID: {
      return CustomEncodableValue(FieldPath::DocumentId());
    }

    case DATA_TYPE_FIRESTORE_INSTANCE: {
      std::string appName =
          std::get<std::string>(FirestoreCodec::ReadValue(stream));
      std::string databaseUrl =
          std::get<std::string>(FirestoreCodec::ReadValue(stream));
      const firebase::firestore::Settings& settings =
          std::any_cast<firebase::firestore::Settings>(
              std::get<CustomEncodableValue>(
                  FirestoreCodec::ReadValue(stream)));

      if (CloudFirestorePlugin::firestoreInstances_.find(appName) !=
          CloudFirestorePlugin::firestoreInstances_.end()) {
        return CustomEncodableValue(
            CloudFirestorePlugin::firestoreInstances_[appName].get());
      }

      firebase::App* app = firebase::App::GetInstance(appName.c_str());

      Firestore* firestore = Firestore::GetInstance(app);
      firestore->set_settings(settings);

      CloudFirestorePlugin::firestoreInstances_[appName] =
          std::unique_ptr<firebase::firestore::Firestore>(firestore);

      return CustomEncodableValue(firestore);
    }

      // case DATA_TYPE_FIRESTORE_QUERY: {
      //   return CustomEncodableValue(ReadFirestoreQuery(stream));
      // }

    case DATA_TYPE_FIRESTORE_SETTINGS: {
      flutter::EncodableMap settingsMap =
          std::get<flutter::EncodableMap>(FirestoreCodec::ReadValue(stream));

      firebase::firestore::Settings settings;

      std::map<std::string, flutter::EncodableValue> map;

      for (const auto& kv : settingsMap) {
        if (std::holds_alternative<std::string>(kv.first)) {
          std::string key = std::get<std::string>(kv.first);

          if (!std::holds_alternative<std::monostate>(kv.second)) {
            map[key] = kv.second;
          }
        } else {
          // Handle or skip non-string keys
          // You may throw an exception or handle this some other way
          throw std::runtime_error("Unsupported key type");
        }
      }

      if (map.count("persistenceEnabled")) {
        bool persistEnabled = std::get<bool>(map["persistenceEnabled"]);

        // This is the maximum amount of cache allowed. We use the same number
        // on android.
        int64_t size = 104857600;

        if (map.count("cacheSizeBytes")) {
          int64_t cacheSizeBytes = std::get<int64_t>(map["cacheSizeBytes"]);
          if (cacheSizeBytes != -1) {
            size = cacheSizeBytes;
          }
        }

        if (persistEnabled) {
          settings.set_cache_size_bytes(size);
        }
      }

      if (map.count("host")) {
        settings.set_host(std::get<std::string>(map["host"]));

        settings.set_ssl_enabled(false);
      }

      return CustomEncodableValue(settings);
    }

    case DATA_TYPE_NAN: {
      double myNaN = std::nan("1");
      return CustomEncodableValue(myNaN);
    }

    case DATA_TYPE_INFINITY: {
      return CustomEncodableValue(std::numeric_limits<double>::infinity());
    }

    case DATA_TYPE_NEGATIVE_INFINITY: {
      return CustomEncodableValue(-std::numeric_limits<double>::infinity());
    }
  }
  return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/firestore_codec.h

**크기**: 2134 bytes | **라인 수**: 61 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FIRESTORE_CODEC_H_
#define FIRESTORE_CODEC_H_

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <memory>
#include <optional>
#include <string>

#include "firebase/firestore/field_value.h"

namespace cloud_firestore_windows {
class FirestoreCodec : public flutter::StandardCodecSerializer {
 public:
  static const uint8_t DATA_TYPE_DATE_TIME = 180;
  static const uint8_t DATA_TYPE_GEO_POINT = 181;
  static const uint8_t DATA_TYPE_DOCUMENT_REFERENCE = 182;
  static const uint8_t DATA_TYPE_BLOB = 183;
  static const uint8_t DATA_TYPE_ARRAY_UNION = 184;
  static const uint8_t DATA_TYPE_ARRAY_REMOVE = 185;
  static const uint8_t DATA_TYPE_DELETE = 186;
  static const uint8_t DATA_TYPE_SERVER_TIMESTAMP = 187;
  static const uint8_t DATA_TYPE_TIMESTAMP = 188;
  static const uint8_t DATA_TYPE_INCREMENT_DOUBLE = 189;
  static const uint8_t DATA_TYPE_INCREMENT_INTEGER = 190;
  static const uint8_t DATA_TYPE_DOCUMENT_ID = 191;
  static const uint8_t DATA_TYPE_FIELD_PATH = 192;
  static const uint8_t DATA_TYPE_NAN = 193;
  static const uint8_t DATA_TYPE_INFINITY = 194;
  static const uint8_t DATA_TYPE_NEGATIVE_INFINITY = 195;
  static const uint8_t DATA_TYPE_FIRESTORE_INSTANCE = 196;
  static const uint8_t DATA_TYPE_FIRESTORE_QUERY = 197;
  static const uint8_t DATA_TYPE_FIRESTORE_SETTINGS = 198;

  FirestoreCodec();
  inline static FirestoreCodec& GetInstance() {
    static FirestoreCodec sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};
}  // namespace cloud_firestore_windows

#endif  // FIRESTORE_CODEC_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/messages.g.cpp

**크기**: 90300 bytes | **라인 수**: 2331 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace cloud_firestore_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

// PigeonFirebaseSettings

PigeonFirebaseSettings::PigeonFirebaseSettings(bool ignore_undefined_properties)
    : ignore_undefined_properties_(ignore_undefined_properties) {}

PigeonFirebaseSettings::PigeonFirebaseSettings(const bool* persistence_enabled,
                                               const std::string* host,
                                               const bool* ssl_enabled,
                                               const int64_t* cache_size_bytes,
                                               bool ignore_undefined_properties)
    : persistence_enabled_(persistence_enabled
                               ? std::optional<bool>(*persistence_enabled)
                               : std::nullopt),
      host_(host ? std::optional<std::string>(*host) : std::nullopt),
      ssl_enabled_(ssl_enabled ? std::optional<bool>(*ssl_enabled)
                               : std::nullopt),
      cache_size_bytes_(cache_size_bytes
                            ? std::optional<int64_t>(*cache_size_bytes)
                            : std::nullopt),
      ignore_undefined_properties_(ignore_undefined_properties) {}

const bool* PigeonFirebaseSettings::persistence_enabled() const {
  return persistence_enabled_ ? &(*persistence_enabled_) : nullptr;
}

void PigeonFirebaseSettings::set_persistence_enabled(const bool* value_arg) {
  persistence_enabled_ =
      value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void PigeonFirebaseSettings::set_persistence_enabled(bool value_arg) {
  persistence_enabled_ = value_arg;
}

const std::string* PigeonFirebaseSettings::host() const {
  return host_ ? &(*host_) : nullptr;
}

void PigeonFirebaseSettings::set_host(const std::string_view* value_arg) {
  host_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonFirebaseSettings::set_host(std::string_view value_arg) {
  host_ = value_arg;
}

const bool* PigeonFirebaseSettings::ssl_enabled() const {
  return ssl_enabled_ ? &(*ssl_enabled_) : nullptr;
}

void PigeonFirebaseSettings::set_ssl_enabled(const bool* value_arg) {
  ssl_enabled_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void PigeonFirebaseSettings::set_ssl_enabled(bool value_arg) {
  ssl_enabled_ = value_arg;
}

const int64_t* PigeonFirebaseSettings::cache_size_bytes() const {
  return cache_size_bytes_ ? &(*cache_size_bytes_) : nullptr;
}

void PigeonFirebaseSettings::set_cache_size_bytes(const int64_t* value_arg) {
  cache_size_bytes_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonFirebaseSettings::set_cache_size_bytes(int64_t value_arg) {
  cache_size_bytes_ = value_arg;
}

bool PigeonFirebaseSettings::ignore_undefined_properties() const {
  return ignore_undefined_properties_;
}

void PigeonFirebaseSettings::set_ignore_undefined_properties(bool value_arg) {
  ignore_undefined_properties_ = value_arg;
}

EncodableList PigeonFirebaseSettings::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(persistence_enabled_ ? EncodableValue(*persistence_enabled_)
                                      : EncodableValue());
  list.push_back(host_ ? EncodableValue(*host_) : EncodableValue());
  list.push_back(ssl_enabled_ ? EncodableValue(*ssl_enabled_)
                              : EncodableValue());
  list.push_back(cache_size_bytes_ ? EncodableValue(*cache_size_bytes_)
                                   : EncodableValue());
  list.push_back(EncodableValue(ignore_undefined_properties_));
  return list;
}

PigeonFirebaseSettings PigeonFirebaseSettings::FromEncodableList(
    const EncodableList& list) {
  PigeonFirebaseSettings decoded(std::get<bool>(list[4]));
  auto& encodable_persistence_enabled = list[0];
  if (!encodable_persistence_enabled.IsNull()) {
    decoded.set_persistence_enabled(
        std::get<bool>(encodable_persistence_enabled));
  }
  auto& encodable_host = list[1];
  if (!encodable_host.IsNull()) {
    decoded.set_host(std::get<std::string>(encodable_host));
  }
  auto& encodable_ssl_enabled = list[2];
  if (!encodable_ssl_enabled.IsNull()) {
    decoded.set_ssl_enabled(std::get<bool>(encodable_ssl_enabled));
  }
  auto& encodable_cache_size_bytes = list[3];
  if (!encodable_cache_size_bytes.IsNull()) {
    decoded.set_cache_size_bytes(encodable_cache_size_bytes.LongValue());
  }
  return decoded;
}

// FirestorePigeonFirebaseApp

FirestorePigeonFirebaseApp::FirestorePigeonFirebaseApp(
    const std::string& app_name, const PigeonFirebaseSettings& settings,
    const std::string& database_u_r_l)
    : app_name_(app_name),
      settings_(settings),
      database_u_r_l_(database_u_r_l) {}

const std::string& FirestorePigeonFirebaseApp::app_name() const {
  return app_name_;
}

void FirestorePigeonFirebaseApp::set_app_name(std::string_view value_arg) {
  app_name_ = value_arg;
}

const PigeonFirebaseSettings& FirestorePigeonFirebaseApp::settings() const {
  return settings_;
}

void FirestorePigeonFirebaseApp::set_settings(
    const PigeonFirebaseSettings& value_arg) {
  settings_ = value_arg;
}

const std::string& FirestorePigeonFirebaseApp::database_u_r_l() const {
  return database_u_r_l_;
}

void FirestorePigeonFirebaseApp::set_database_u_r_l(
    std::string_view value_arg) {
  database_u_r_l_ = value_arg;
}

EncodableList FirestorePigeonFirebaseApp::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(app_name_));
  list.push_back(EncodableValue(settings_.ToEncodableList()));
  list.push_back(EncodableValue(database_u_r_l_));
  return list;
}

FirestorePigeonFirebaseApp FirestorePigeonFirebaseApp::FromEncodableList(
    const EncodableList& list) {
  FirestorePigeonFirebaseApp decoded(std::get<std::string>(list[0]),
                                     PigeonFirebaseSettings::FromEncodableList(
                                         std::get<EncodableList>(list[1])),
                                     std::get<std::string>(list[2]));
  return decoded;
}

// PigeonSnapshotMetadata

PigeonSnapshotMetadata::PigeonSnapshotMetadata(bool has_pending_writes,
                                               bool is_from_cache)
    : has_pending_writes_(has_pending_writes), is_from_cache_(is_from_cache) {}

bool PigeonSnapshotMetadata::has_pending_writes() const {
  return has_pending_writes_;
}

void PigeonSnapshotMetadata::set_has_pending_writes(bool value_arg) {
  has_pending_writes_ = value_arg;
}

bool PigeonSnapshotMetadata::is_from_cache() const { return is_from_cache_; }

void PigeonSnapshotMetadata::set_is_from_cache(bool value_arg) {
  is_from_cache_ = value_arg;
}

EncodableList PigeonSnapshotMetadata::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(has_pending_writes_));
  list.push_back(EncodableValue(is_from_cache_));
  return list;
}

PigeonSnapshotMetadata PigeonSnapshotMetadata::FromEncodableList(
    const EncodableList& list) {
  PigeonSnapshotMetadata decoded(std::get<bool>(list[0]),
                                 std::get<bool>(list[1]));
  return decoded;
}

// PigeonDocumentSnapshot

PigeonDocumentSnapshot::PigeonDocumentSnapshot(
    const std::string& path, const PigeonSnapshotMetadata& metadata)
    : path_(path), metadata_(metadata) {}

PigeonDocumentSnapshot::PigeonDocumentSnapshot(
    const std::string& path, const EncodableMap* data,
    const PigeonSnapshotMetadata& metadata)
    : path_(path),
      data_(data ? std::optional<EncodableMap>(*data) : std::nullopt),
      metadata_(metadata) {}

const std::string& PigeonDocumentSnapshot::path() const { return path_; }

void PigeonDocumentSnapshot::set_path(std::string_view value_arg) {
  path_ = value_arg;
}

const EncodableMap* PigeonDocumentSnapshot::data() const {
  return data_ ? &(*data_) : nullptr;
}

void PigeonDocumentSnapshot::set_data(const EncodableMap* value_arg) {
  data_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonDocumentSnapshot::set_data(const EncodableMap& value_arg) {
  data_ = value_arg;
}

const PigeonSnapshotMetadata& PigeonDocumentSnapshot::metadata() const {
  return metadata_;
}

void PigeonDocumentSnapshot::set_metadata(
    const PigeonSnapshotMetadata& value_arg) {
  metadata_ = value_arg;
}

EncodableList PigeonDocumentSnapshot::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(path_));
  list.push_back(data_ ? EncodableValue(*data_) : EncodableValue());
  list.push_back(EncodableValue(metadata_.ToEncodableList()));
  return list;
}

PigeonDocumentSnapshot PigeonDocumentSnapshot::FromEncodableList(
    const EncodableList& list) {
  PigeonDocumentSnapshot decoded(std::get<std::string>(list[0]),
                                 PigeonSnapshotMetadata::FromEncodableList(
                                     std::get<EncodableList>(list[2])));
  auto& encodable_data = list[1];
  if (!encodable_data.IsNull()) {
    decoded.set_data(std::get<EncodableMap>(encodable_data));
  }
  return decoded;
}

// PigeonDocumentChange

PigeonDocumentChange::PigeonDocumentChange(
    const DocumentChangeType& type, const PigeonDocumentSnapshot& document,
    int64_t old_index, int64_t new_index)
    : type_(type),
      document_(document),
      old_index_(old_index),
      new_index_(new_index) {}

const DocumentChangeType& PigeonDocumentChange::type() const { return type_; }

void PigeonDocumentChange::set_type(const DocumentChangeType& value_arg) {
  type_ = value_arg;
}

const PigeonDocumentSnapshot& PigeonDocumentChange::document() const {
  return document_;
}

void PigeonDocumentChange::set_document(
    const PigeonDocumentSnapshot& value_arg) {
  document_ = value_arg;
}

int64_t PigeonDocumentChange::old_index() const { return old_index_; }

void PigeonDocumentChange::set_old_index(int64_t value_arg) {
  old_index_ = value_arg;
}

int64_t PigeonDocumentChange::new_index() const { return new_index_; }

void PigeonDocumentChange::set_new_index(int64_t value_arg) {
  new_index_ = value_arg;
}

EncodableList PigeonDocumentChange::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue((int)type_));
  list.push_back(EncodableValue(document_.ToEncodableList()));
  list.push_back(EncodableValue(old_index_));
  list.push_back(EncodableValue(new_index_));
  return list;
}

PigeonDocumentChange PigeonDocumentChange::FromEncodableList(
    const EncodableList& list) {
  PigeonDocumentChange decoded((DocumentChangeType)(std::get<int32_t>(list[0])),
                               PigeonDocumentSnapshot::FromEncodableList(
                                   std::get<EncodableList>(list[1])),
                               list[2].LongValue(), list[3].LongValue());
  return decoded;
}

// PigeonQuerySnapshot

PigeonQuerySnapshot::PigeonQuerySnapshot(const EncodableList& documents,
                                         const EncodableList& document_changes,
                                         const PigeonSnapshotMetadata& metadata)
    : documents_(documents),
      document_changes_(document_changes),
      metadata_(metadata) {}

const EncodableList& PigeonQuerySnapshot::documents() const {
  return documents_;
}

void PigeonQuerySnapshot::set_documents(const EncodableList& value_arg) {
  documents_ = value_arg;
}

const EncodableList& PigeonQuerySnapshot::document_changes() const {
  return document_changes_;
}

void PigeonQuerySnapshot::set_document_changes(const EncodableList& value_arg) {
  document_changes_ = value_arg;
}

const PigeonSnapshotMetadata& PigeonQuerySnapshot::metadata() const {
  return metadata_;
}

void PigeonQuerySnapshot::set_metadata(
    const PigeonSnapshotMetadata& value_arg) {
  metadata_ = value_arg;
}

EncodableList PigeonQuerySnapshot::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(documents_));
  list.push_back(EncodableValue(document_changes_));
  list.push_back(EncodableValue(metadata_.ToEncodableList()));
  return list;
}

PigeonQuerySnapshot PigeonQuerySnapshot::FromEncodableList(
    const EncodableList& list) {
  PigeonQuerySnapshot decoded(std::get<EncodableList>(list[0]),
                              std::get<EncodableList>(list[1]),
                              PigeonSnapshotMetadata::FromEncodableList(
                                  std::get<EncodableList>(list[2])));
  return decoded;
}

// PigeonGetOptions

PigeonGetOptions::PigeonGetOptions(
    const Source& source,
    const ServerTimestampBehavior& server_timestamp_behavior)
    : source_(source), server_timestamp_behavior_(server_timestamp_behavior) {}

const Source& PigeonGetOptions::source() const { return source_; }

void PigeonGetOptions::set_source(const Source& value_arg) {
  source_ = value_arg;
}

const ServerTimestampBehavior& PigeonGetOptions::server_timestamp_behavior()
    const {
  return server_timestamp_behavior_;
}

void PigeonGetOptions::set_server_timestamp_behavior(
    const ServerTimestampBehavior& value_arg) {
  server_timestamp_behavior_ = value_arg;
}

EncodableList PigeonGetOptions::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue((int)source_));
  list.push_back(EncodableValue((int)server_timestamp_behavior_));
  return list;
}

PigeonGetOptions PigeonGetOptions::FromEncodableList(
    const EncodableList& list) {
  PigeonGetOptions decoded(
      (Source)(std::get<int32_t>(list[0])),
      (ServerTimestampBehavior)(std::get<int32_t>(list[1])));
  return decoded;
}

// PigeonDocumentOption

PigeonDocumentOption::PigeonDocumentOption() {}

PigeonDocumentOption::PigeonDocumentOption(const bool* merge,
                                           const EncodableList* merge_fields)
    : merge_(merge ? std::optional<bool>(*merge) : std::nullopt),
      merge_fields_(merge_fields ? std::optional<EncodableList>(*merge_fields)
                                 : std::nullopt) {}

const bool* PigeonDocumentOption::merge() const {
  return merge_ ? &(*merge_) : nullptr;
}

void PigeonDocumentOption::set_merge(const bool* value_arg) {
  merge_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void PigeonDocumentOption::set_merge(bool value_arg) { merge_ = value_arg; }

const EncodableList* PigeonDocumentOption::merge_fields() const {
  return merge_fields_ ? &(*merge_fields_) : nullptr;
}

void PigeonDocumentOption::set_merge_fields(const EncodableList* value_arg) {
  merge_fields_ =
      value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonDocumentOption::set_merge_fields(const EncodableList& value_arg) {
  merge_fields_ = value_arg;
}

EncodableList PigeonDocumentOption::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(merge_ ? EncodableValue(*merge_) : EncodableValue());
  list.push_back(merge_fields_ ? EncodableValue(*merge_fields_)
                               : EncodableValue());
  return list;
}

PigeonDocumentOption PigeonDocumentOption::FromEncodableList(
    const EncodableList& list) {
  PigeonDocumentOption decoded;
  auto& encodable_merge = list[0];
  if (!encodable_merge.IsNull()) {
    decoded.set_merge(std::get<bool>(encodable_merge));
  }
  auto& encodable_merge_fields = list[1];
  if (!encodable_merge_fields.IsNull()) {
    decoded.set_merge_fields(std::get<EncodableList>(encodable_merge_fields));
  }
  return decoded;
}

// PigeonTransactionCommand

PigeonTransactionCommand::PigeonTransactionCommand(
    const PigeonTransactionType& type, const std::string& path)
    : type_(type), path_(path) {}

PigeonTransactionCommand::PigeonTransactionCommand(
    const PigeonTransactionType& type, const std::string& path,
    const EncodableMap* data, const PigeonDocumentOption* option)
    : type_(type),
      path_(path),
      data_(data ? std::optional<EncodableMap>(*data) : std::nullopt),
      option_(option ? std::optional<PigeonDocumentOption>(*option)
                     : std::nullopt) {}

const PigeonTransactionType& PigeonTransactionCommand::type() const {
  return type_;
}

void PigeonTransactionCommand::set_type(
    const PigeonTransactionType& value_arg) {
  type_ = value_arg;
}

const std::string& PigeonTransactionCommand::path() const { return path_; }

void PigeonTransactionCommand::set_path(std::string_view value_arg) {
  path_ = value_arg;
}

const EncodableMap* PigeonTransactionCommand::data() const {
  return data_ ? &(*data_) : nullptr;
}

void PigeonTransactionCommand::set_data(const EncodableMap* value_arg) {
  data_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonTransactionCommand::set_data(const EncodableMap& value_arg) {
  data_ = value_arg;
}

const PigeonDocumentOption* PigeonTransactionCommand::option() const {
  return option_ ? &(*option_) : nullptr;
}

void PigeonTransactionCommand::set_option(
    const PigeonDocumentOption* value_arg) {
  option_ = value_arg ? std::optional<PigeonDocumentOption>(*value_arg)
                      : std::nullopt;
}

void PigeonTransactionCommand::set_option(
    const PigeonDocumentOption& value_arg) {
  option_ = value_arg;
}

EncodableList PigeonTransactionCommand::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue((int)type_));
  list.push_back(EncodableValue(path_));
  list.push_back(data_ ? EncodableValue(*data_) : EncodableValue());
  list.push_back(option_ ? EncodableValue(option_->ToEncodableList())
                         : EncodableValue());
  return list;
}

PigeonTransactionCommand PigeonTransactionCommand::FromEncodableList(
    const EncodableList& list) {
  PigeonTransactionCommand decoded(
      (PigeonTransactionType)(std::get<int32_t>(list[0])),
      std::get<std::string>(list[1]));
  auto& encodable_data = list[2];
  if (!encodable_data.IsNull()) {
    decoded.set_data(std::get<EncodableMap>(encodable_data));
  }
  auto& encodable_option = list[3];
  if (!encodable_option.IsNull()) {
    decoded.set_option(PigeonDocumentOption::FromEncodableList(
        std::get<EncodableList>(encodable_option)));
  }
  return decoded;
}

// DocumentReferenceRequest

DocumentReferenceRequest::DocumentReferenceRequest(const std::string& path)
    : path_(path) {}

DocumentReferenceRequest::DocumentReferenceRequest(
    const std::string& path, const EncodableMap* data,
    const PigeonDocumentOption* option, const Source* source,
    const ServerTimestampBehavior* server_timestamp_behavior)
    : path_(path),
      data_(data ? std::optional<EncodableMap>(*data) : std::nullopt),
      option_(option ? std::optional<PigeonDocumentOption>(*option)
                     : std::nullopt),
      source_(source ? std::optional<Source>(*source) : std::nullopt),
      server_timestamp_behavior_(server_timestamp_behavior
                                     ? std::optional<ServerTimestampBehavior>(
                                           *server_timestamp_behavior)
                                     : std::nullopt) {}

const std::string& DocumentReferenceRequest::path() const { return path_; }

void DocumentReferenceRequest::set_path(std::string_view value_arg) {
  path_ = value_arg;
}

const EncodableMap* DocumentReferenceRequest::data() const {
  return data_ ? &(*data_) : nullptr;
}

void DocumentReferenceRequest::set_data(const EncodableMap* value_arg) {
  data_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void DocumentReferenceRequest::set_data(const EncodableMap& value_arg) {
  data_ = value_arg;
}

const PigeonDocumentOption* DocumentReferenceRequest::option() const {
  return option_ ? &(*option_) : nullptr;
}

void DocumentReferenceRequest::set_option(
    const PigeonDocumentOption* value_arg) {
  option_ = value_arg ? std::optional<PigeonDocumentOption>(*value_arg)
                      : std::nullopt;
}

void DocumentReferenceRequest::set_option(
    const PigeonDocumentOption& value_arg) {
  option_ = value_arg;
}

const Source* DocumentReferenceRequest::source() const {
  return source_ ? &(*source_) : nullptr;
}

void DocumentReferenceRequest::set_source(const Source* value_arg) {
  source_ = value_arg ? std::optional<Source>(*value_arg) : std::nullopt;
}

void DocumentReferenceRequest::set_source(const Source& value_arg) {
  source_ = value_arg;
}

const ServerTimestampBehavior*
DocumentReferenceRequest::server_timestamp_behavior() const {
  return server_timestamp_behavior_ ? &(*server_timestamp_behavior_) : nullptr;
}

void DocumentReferenceRequest::set_server_timestamp_behavior(
    const ServerTimestampBehavior* value_arg) {
  server_timestamp_behavior_ =
      value_arg ? std::optional<ServerTimestampBehavior>(*value_arg)
                : std::nullopt;
}

void DocumentReferenceRequest::set_server_timestamp_behavior(
    const ServerTimestampBehavior& value_arg) {
  server_timestamp_behavior_ = value_arg;
}

EncodableList DocumentReferenceRequest::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(path_));
  list.push_back(data_ ? EncodableValue(*data_) : EncodableValue());
  list.push_back(option_ ? EncodableValue(option_->ToEncodableList())
                         : EncodableValue());
  list.push_back(source_ ? EncodableValue((int)(*source_)) : EncodableValue());
  list.push_back(server_timestamp_behavior_
                     ? EncodableValue((int)(*server_timestamp_behavior_))
                     : EncodableValue());
  return list;
}

DocumentReferenceRequest DocumentReferenceRequest::FromEncodableList(
    const EncodableList& list) {
  DocumentReferenceRequest decoded(std::get<std::string>(list[0]));
  auto& encodable_data = list[1];
  if (!encodable_data.IsNull()) {
    decoded.set_data(std::get<EncodableMap>(encodable_data));
  }
  auto& encodable_option = list[2];
  if (!encodable_option.IsNull()) {
    decoded.set_option(PigeonDocumentOption::FromEncodableList(
        std::get<EncodableList>(encodable_option)));
  }
  auto& encodable_source = list[3];
  if (!encodable_source.IsNull()) {
    decoded.set_source((Source)(std::get<int32_t>(encodable_source)));
  }
  auto& encodable_server_timestamp_behavior = list[4];
  if (!encodable_server_timestamp_behavior.IsNull()) {
    decoded.set_server_timestamp_behavior(
        (ServerTimestampBehavior)(std::get<int32_t>(
            encodable_server_timestamp_behavior)));
  }
  return decoded;
}

// PigeonQueryParameters

PigeonQueryParameters::PigeonQueryParameters() {}

PigeonQueryParameters::PigeonQueryParameters(
    const EncodableList* where, const EncodableList* order_by,
    const int64_t* limit, const int64_t* limit_to_last,
    const EncodableList* start_at, const EncodableList* start_after,
    const EncodableList* end_at, const EncodableList* end_before,
    const EncodableMap* filters)
    : where_(where ? std::optional<EncodableList>(*where) : std::nullopt),
      order_by_(order_by ? std::optional<EncodableList>(*order_by)
                         : std::nullopt),
      limit_(limit ? std::optional<int64_t>(*limit) : std::nullopt),
      limit_to_last_(limit_to_last ? std::optional<int64_t>(*limit_to_last)
                                   : std::nullopt),
      start_at_(start_at ? std::optional<EncodableList>(*start_at)
                         : std::nullopt),
      start_after_(start_after ? std::optional<EncodableList>(*start_after)
                               : std::nullopt),
      end_at_(end_at ? std::optional<EncodableList>(*end_at) : std::nullopt),
      end_before_(end_before ? std::optional<EncodableList>(*end_before)
                             : std::nullopt),
      filters_(filters ? std::optional<EncodableMap>(*filters) : std::nullopt) {
}

const EncodableList* PigeonQueryParameters::where() const {
  return where_ ? &(*where_) : nullptr;
}

void PigeonQueryParameters::set_where(const EncodableList* value_arg) {
  where_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_where(const EncodableList& value_arg) {
  where_ = value_arg;
}

const EncodableList* PigeonQueryParameters::order_by() const {
  return order_by_ ? &(*order_by_) : nullptr;
}

void PigeonQueryParameters::set_order_by(const EncodableList* value_arg) {
  order_by_ =
      value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_order_by(const EncodableList& value_arg) {
  order_by_ = value_arg;
}

const int64_t* PigeonQueryParameters::limit() const {
  return limit_ ? &(*limit_) : nullptr;
}

void PigeonQueryParameters::set_limit(const int64_t* value_arg) {
  limit_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_limit(int64_t value_arg) { limit_ = value_arg; }

const int64_t* PigeonQueryParameters::limit_to_last() const {
  return limit_to_last_ ? &(*limit_to_last_) : nullptr;
}

void PigeonQueryParameters::set_limit_to_last(const int64_t* value_arg) {
  limit_to_last_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_limit_to_last(int64_t value_arg) {
  limit_to_last_ = value_arg;
}

const EncodableList* PigeonQueryParameters::start_at() const {
  return start_at_ ? &(*start_at_) : nullptr;
}

void PigeonQueryParameters::set_start_at(const EncodableList* value_arg) {
  start_at_ =
      value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_start_at(const EncodableList& value_arg) {
  start_at_ = value_arg;
}

const EncodableList* PigeonQueryParameters::start_after() const {
  return start_after_ ? &(*start_after_) : nullptr;
}

void PigeonQueryParameters::set_start_after(const EncodableList* value_arg) {
  start_after_ =
      value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_start_after(const EncodableList& value_arg) {
  start_after_ = value_arg;
}

const EncodableList* PigeonQueryParameters::end_at() const {
  return end_at_ ? &(*end_at_) : nullptr;
}

void PigeonQueryParameters::set_end_at(const EncodableList* value_arg) {
  end_at_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_end_at(const EncodableList& value_arg) {
  end_at_ = value_arg;
}

const EncodableList* PigeonQueryParameters::end_before() const {
  return end_before_ ? &(*end_before_) : nullptr;
}

void PigeonQueryParameters::set_end_before(const EncodableList* value_arg) {
  end_before_ =
      value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_end_before(const EncodableList& value_arg) {
  end_before_ = value_arg;
}

const EncodableMap* PigeonQueryParameters::filters() const {
  return filters_ ? &(*filters_) : nullptr;
}

void PigeonQueryParameters::set_filters(const EncodableMap* value_arg) {
  filters_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonQueryParameters::set_filters(const EncodableMap& value_arg) {
  filters_ = value_arg;
}

EncodableList PigeonQueryParameters::ToEncodableList() const {
  EncodableList list;
  list.reserve(9);
  list.push_back(where_ ? EncodableValue(*where_) : EncodableValue());
  list.push_back(order_by_ ? EncodableValue(*order_by_) : EncodableValue());
  list.push_back(limit_ ? EncodableValue(*limit_) : EncodableValue());
  list.push_back(limit_to_last_ ? EncodableValue(*limit_to_last_)
                                : EncodableValue());
  list.push_back(start_at_ ? EncodableValue(*start_at_) : EncodableValue());
  list.push_back(start_after_ ? EncodableValue(*start_after_)
                              : EncodableValue());
  list.push_back(end_at_ ? EncodableValue(*end_at_) : EncodableValue());
  list.push_back(end_before_ ? EncodableValue(*end_before_) : EncodableValue());
  list.push_back(filters_ ? EncodableValue(*filters_) : EncodableValue());
  return list;
}

PigeonQueryParameters PigeonQueryParameters::FromEncodableList(
    const EncodableList& list) {
  PigeonQueryParameters decoded;
  auto& encodable_where = list[0];
  if (!encodable_where.IsNull()) {
    decoded.set_where(std::get<EncodableList>(encodable_where));
  }
  auto& encodable_order_by = list[1];
  if (!encodable_order_by.IsNull()) {
    decoded.set_order_by(std::get<EncodableList>(encodable_order_by));
  }
  auto& encodable_limit = list[2];
  if (!encodable_limit.IsNull()) {
    decoded.set_limit(encodable_limit.LongValue());
  }
  auto& encodable_limit_to_last = list[3];
  if (!encodable_limit_to_last.IsNull()) {
    decoded.set_limit_to_last(encodable_limit_to_last.LongValue());
  }
  auto& encodable_start_at = list[4];
  if (!encodable_start_at.IsNull()) {
    decoded.set_start_at(std::get<EncodableList>(encodable_start_at));
  }
  auto& encodable_start_after = list[5];
  if (!encodable_start_after.IsNull()) {
    decoded.set_start_after(std::get<EncodableList>(encodable_start_after));
  }
  auto& encodable_end_at = list[6];
  if (!encodable_end_at.IsNull()) {
    decoded.set_end_at(std::get<EncodableList>(encodable_end_at));
  }
  auto& encodable_end_before = list[7];
  if (!encodable_end_before.IsNull()) {
    decoded.set_end_before(std::get<EncodableList>(encodable_end_before));
  }
  auto& encodable_filters = list[8];
  if (!encodable_filters.IsNull()) {
    decoded.set_filters(std::get<EncodableMap>(encodable_filters));
  }
  return decoded;
}

// AggregateQuery

AggregateQuery::AggregateQuery(const AggregateType& type) : type_(type) {}

AggregateQuery::AggregateQuery(const AggregateType& type,
                               const std::string* field)
    : type_(type),
      field_(field ? std::optional<std::string>(*field) : std::nullopt) {}

const AggregateType& AggregateQuery::type() const { return type_; }

void AggregateQuery::set_type(const AggregateType& value_arg) {
  type_ = value_arg;
}

const std::string* AggregateQuery::field() const {
  return field_ ? &(*field_) : nullptr;
}

void AggregateQuery::set_field(const std::string_view* value_arg) {
  field_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AggregateQuery::set_field(std::string_view value_arg) {
  field_ = value_arg;
}

EncodableList AggregateQuery::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue((int)type_));
  list.push_back(field_ ? EncodableValue(*field_) : EncodableValue());
  return list;
}

AggregateQuery AggregateQuery::FromEncodableList(const EncodableList& list) {
  AggregateQuery decoded((AggregateType)(std::get<int32_t>(list[0])));
  auto& encodable_field = list[1];
  if (!encodable_field.IsNull()) {
    decoded.set_field(std::get<std::string>(encodable_field));
  }
  return decoded;
}

// AggregateQueryResponse

AggregateQueryResponse::AggregateQueryResponse(const AggregateType& type)
    : type_(type) {}

AggregateQueryResponse::AggregateQueryResponse(const AggregateType& type,
                                               const std::string* field,
                                               const double* value)
    : type_(type),
      field_(field ? std::optional<std::string>(*field) : std::nullopt),
      value_(value ? std::optional<double>(*value) : std::nullopt) {}

const AggregateType& AggregateQueryResponse::type() const { return type_; }

void AggregateQueryResponse::set_type(const AggregateType& value_arg) {
  type_ = value_arg;
}

const std::string* AggregateQueryResponse::field() const {
  return field_ ? &(*field_) : nullptr;
}

void AggregateQueryResponse::set_field(const std::string_view* value_arg) {
  field_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AggregateQueryResponse::set_field(std::string_view value_arg) {
  field_ = value_arg;
}

const double* AggregateQueryResponse::value() const {
  return value_ ? &(*value_) : nullptr;
}

void AggregateQueryResponse::set_value(const double* value_arg) {
  value_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void AggregateQueryResponse::set_value(double value_arg) { value_ = value_arg; }

EncodableList AggregateQueryResponse::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue((int)type_));
  list.push_back(field_ ? EncodableValue(*field_) : EncodableValue());
  list.push_back(value_ ? EncodableValue(*value_) : EncodableValue());
  return list;
}

AggregateQueryResponse AggregateQueryResponse::FromEncodableList(
    const EncodableList& list) {
  AggregateQueryResponse decoded((AggregateType)(std::get<int32_t>(list[0])));
  auto& encodable_field = list[1];
  if (!encodable_field.IsNull()) {
    decoded.set_field(std::get<std::string>(encodable_field));
  }
  auto& encodable_value = list[2];
  if (!encodable_value.IsNull()) {
    decoded.set_value(std::get<double>(encodable_value));
  }
  return decoded;
}

FirebaseFirestoreHostApiCodecSerializer::
    FirebaseFirestoreHostApiCodecSerializer() {}

EncodableValue FirebaseFirestoreHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AggregateQuery::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(AggregateQueryResponse::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(DocumentReferenceRequest::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(FirestorePigeonFirebaseApp::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(PigeonDocumentChange::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(PigeonDocumentOption::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(PigeonDocumentSnapshot::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(PigeonFirebaseSettings::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(PigeonGetOptions::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(PigeonQueryParameters::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(PigeonQuerySnapshot::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(PigeonSnapshotMetadata::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(PigeonTransactionCommand::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    default:
      return cloud_firestore_windows::FirestoreCodec::ReadValueOfType(type,
                                                                      stream);
  }
}

void FirebaseFirestoreHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AggregateQuery)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(
              std::any_cast<AggregateQuery>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(AggregateQueryResponse)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<AggregateQueryResponse>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(DocumentReferenceRequest)) {
      stream->WriteByte(130);
      WriteValue(
          EncodableValue(std::any_cast<DocumentReferenceRequest>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(FirestorePigeonFirebaseApp)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(
                     std::any_cast<FirestorePigeonFirebaseApp>(*custom_value)
                         .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonDocumentChange)) {
      stream->WriteByte(132);
      WriteValue(
          EncodableValue(std::any_cast<PigeonDocumentChange>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonDocumentOption)) {
      stream->WriteByte(133);
      WriteValue(
          EncodableValue(std::any_cast<PigeonDocumentOption>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonDocumentSnapshot)) {
      stream->WriteByte(134);
      WriteValue(
          EncodableValue(std::any_cast<PigeonDocumentSnapshot>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonFirebaseSettings)) {
      stream->WriteByte(135);
      WriteValue(
          EncodableValue(std::any_cast<PigeonFirebaseSettings>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonGetOptions)) {
      stream->WriteByte(136);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonGetOptions>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonQueryParameters)) {
      stream->WriteByte(137);
      WriteValue(
          EncodableValue(std::any_cast<PigeonQueryParameters>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonQuerySnapshot)) {
      stream->WriteByte(138);
      WriteValue(
          EncodableValue(std::any_cast<PigeonQuerySnapshot>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonSnapshotMetadata)) {
      stream->WriteByte(139);
      WriteValue(
          EncodableValue(std::any_cast<PigeonSnapshotMetadata>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonTransactionCommand)) {
      stream->WriteByte(140);
      WriteValue(
          EncodableValue(std::any_cast<PigeonTransactionCommand>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
  }
  cloud_firestore_windows::FirestoreCodec::WriteValue(value, stream);
}

/// The codec used by FirebaseFirestoreHostApi.
const flutter::StandardMessageCodec& FirebaseFirestoreHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &FirebaseFirestoreHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `FirebaseFirestoreHostApi` to handle messages through
// the `binary_messenger`.
void FirebaseFirestoreHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                     FirebaseFirestoreHostApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.loadBundle",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_bundle_arg = args.at(1);
              if (encodable_bundle_arg.IsNull()) {
                reply(WrapError("bundle_arg unexpectedly null."));
                return;
              }
              const auto& bundle_arg =
                  std::get<std::vector<uint8_t>>(encodable_bundle_arg);
              api->LoadBundle(
                  app_arg, bundle_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.namedQueryGet",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_name_arg = args.at(1);
              if (encodable_name_arg.IsNull()) {
                reply(WrapError("name_arg unexpectedly null."));
                return;
              }
              const auto& name_arg = std::get<std::string>(encodable_name_arg);
              const auto& encodable_options_arg = args.at(2);
              if (encodable_options_arg.IsNull()) {
                reply(WrapError("options_arg unexpectedly null."));
                return;
              }
              const auto& options_arg = std::any_cast<const PigeonGetOptions&>(
                  std::get<CustomEncodableValue>(encodable_options_arg));
              api->NamedQueryGet(
                  app_arg, name_arg, options_arg,
                  [reply](ErrorOr<PigeonQuerySnapshot>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.clearPersistence",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->ClearPersistence(
                  app_arg, [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.disableNetwork",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->DisableNetwork(
                  app_arg, [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.enableNetwork",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->EnableNetwork(app_arg,
                                 [reply](std::optional<FlutterError>&& output) {
                                   if (output.has_value()) {
                                     reply(WrapError(output.value()));
                                     return;
                                   }
                                   EncodableList wrapped;
                                   wrapped.push_back(EncodableValue());
                                   reply(EncodableValue(std::move(wrapped)));
                                 });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.terminate",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->Terminate(app_arg,
                             [reply](std::optional<FlutterError>&& output) {
                               if (output.has_value()) {
                                 reply(WrapError(output.value()));
                                 return;
                               }
                               EncodableList wrapped;
                               wrapped.push_back(EncodableValue());
                               reply(EncodableValue(std::move(wrapped)));
                             });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.waitForPendingWrites",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->WaitForPendingWrites(
                  app_arg, [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.setIndexConfiguration",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_index_configuration_arg = args.at(1);
              if (encodable_index_configuration_arg.IsNull()) {
                reply(WrapError("index_configuration_arg unexpectedly null."));
                return;
              }
              const auto& index_configuration_arg =
                  std::get<std::string>(encodable_index_configuration_arg);
              api->SetIndexConfiguration(
                  app_arg, index_configuration_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.setLoggingEnabled",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_logging_enabled_arg = args.at(0);
              if (encodable_logging_enabled_arg.IsNull()) {
                reply(WrapError("logging_enabled_arg unexpectedly null."));
                return;
              }
              const auto& logging_enabled_arg =
                  std::get<bool>(encodable_logging_enabled_arg);
              api->SetLoggingEnabled(
                  logging_enabled_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.snapshotsInSyncSetup",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              api->SnapshotsInSyncSetup(
                  app_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.transactionCreate",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_timeout_arg = args.at(1);
              if (encodable_timeout_arg.IsNull()) {
                reply(WrapError("timeout_arg unexpectedly null."));
                return;
              }
              const int64_t timeout_arg = encodable_timeout_arg.LongValue();
              const auto& encodable_max_attempts_arg = args.at(2);
              if (encodable_max_attempts_arg.IsNull()) {
                reply(WrapError("max_attempts_arg unexpectedly null."));
                return;
              }
              const int64_t max_attempts_arg =
                  encodable_max_attempts_arg.LongValue();
              api->TransactionCreate(
                  app_arg, timeout_arg, max_attempts_arg,
                  [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.transactionStoreResult",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_transaction_id_arg = args.at(0);
              if (encodable_transaction_id_arg.IsNull()) {
                reply(WrapError("transaction_id_arg unexpectedly null."));
                return;
              }
              const auto& transaction_id_arg =
                  std::get<std::string>(encodable_transaction_id_arg);
              const auto& encodable_result_type_arg = args.at(1);
              if (encodable_result_type_arg.IsNull()) {
                reply(WrapError("result_type_arg unexpectedly null."));
                return;
              }
              const PigeonTransactionResult& result_type_arg =
                  (PigeonTransactionResult)
                      encodable_result_type_arg.LongValue();
              const auto& encodable_commands_arg = args.at(2);
              const auto* commands_arg =
                  std::get_if<EncodableList>(&encodable_commands_arg);
              api->TransactionStoreResult(
                  transaction_id_arg, result_type_arg, commands_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.transactionGet",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_transaction_id_arg = args.at(1);
              if (encodable_transaction_id_arg.IsNull()) {
                reply(WrapError("transaction_id_arg unexpectedly null."));
                return;
              }
              const auto& transaction_id_arg =
                  std::get<std::string>(encodable_transaction_id_arg);
              const auto& encodable_path_arg = args.at(2);
              if (encodable_path_arg.IsNull()) {
                reply(WrapError("path_arg unexpectedly null."));
                return;
              }
              const auto& path_arg = std::get<std::string>(encodable_path_arg);
              api->TransactionGet(
                  app_arg, transaction_id_arg, path_arg,
                  [reply](ErrorOr<PigeonDocumentSnapshot>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.documentReferenceSet",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const auto& request_arg =
                  std::any_cast<const DocumentReferenceRequest&>(
                      std::get<CustomEncodableValue>(encodable_request_arg));
              api->DocumentReferenceSet(
                  app_arg, request_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.documentReferenceUpdate",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const auto& request_arg =
                  std::any_cast<const DocumentReferenceRequest&>(
                      std::get<CustomEncodableValue>(encodable_request_arg));
              api->DocumentReferenceUpdate(
                  app_arg, request_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.documentReferenceGet",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const auto& request_arg =
                  std::any_cast<const DocumentReferenceRequest&>(
                      std::get<CustomEncodableValue>(encodable_request_arg));
              api->DocumentReferenceGet(
                  app_arg, request_arg,
                  [reply](ErrorOr<PigeonDocumentSnapshot>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.documentReferenceDelete",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const auto& request_arg =
                  std::any_cast<const DocumentReferenceRequest&>(
                      std::get<CustomEncodableValue>(encodable_request_arg));
              api->DocumentReferenceDelete(
                  app_arg, request_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.queryGet",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_path_arg = args.at(1);
              if (encodable_path_arg.IsNull()) {
                reply(WrapError("path_arg unexpectedly null."));
                return;
              }
              const auto& path_arg = std::get<std::string>(encodable_path_arg);
              const auto& encodable_is_collection_group_arg = args.at(2);
              if (encodable_is_collection_group_arg.IsNull()) {
                reply(WrapError("is_collection_group_arg unexpectedly null."));
                return;
              }
              const auto& is_collection_group_arg =
                  std::get<bool>(encodable_is_collection_group_arg);
              const auto& encodable_parameters_arg = args.at(3);
              if (encodable_parameters_arg.IsNull()) {
                reply(WrapError("parameters_arg unexpectedly null."));
                return;
              }
              const auto& parameters_arg =
                  std::any_cast<const PigeonQueryParameters&>(
                      std::get<CustomEncodableValue>(encodable_parameters_arg));
              const auto& encodable_options_arg = args.at(4);
              if (encodable_options_arg.IsNull()) {
                reply(WrapError("options_arg unexpectedly null."));
                return;
              }
              const auto& options_arg = std::any_cast<const PigeonGetOptions&>(
                  std::get<CustomEncodableValue>(encodable_options_arg));
              api->QueryGet(
                  app_arg, path_arg, is_collection_group_arg, parameters_arg,
                  options_arg, [reply](ErrorOr<PigeonQuerySnapshot>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.aggregateQuery",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_path_arg = args.at(1);
              if (encodable_path_arg.IsNull()) {
                reply(WrapError("path_arg unexpectedly null."));
                return;
              }
              const auto& path_arg = std::get<std::string>(encodable_path_arg);
              const auto& encodable_parameters_arg = args.at(2);
              if (encodable_parameters_arg.IsNull()) {
                reply(WrapError("parameters_arg unexpectedly null."));
                return;
              }
              const auto& parameters_arg =
                  std::any_cast<const PigeonQueryParameters&>(
                      std::get<CustomEncodableValue>(encodable_parameters_arg));
              const auto& encodable_source_arg = args.at(3);
              if (encodable_source_arg.IsNull()) {
                reply(WrapError("source_arg unexpectedly null."));
                return;
              }
              const AggregateSource& source_arg =
                  (AggregateSource)encodable_source_arg.LongValue();
              const auto& encodable_queries_arg = args.at(4);
              if (encodable_queries_arg.IsNull()) {
                reply(WrapError("queries_arg unexpectedly null."));
                return;
              }
              const auto& queries_arg =
                  std::get<EncodableList>(encodable_queries_arg);
              const auto& encodable_is_collection_group_arg = args.at(5);
              if (encodable_is_collection_group_arg.IsNull()) {
                reply(WrapError("is_collection_group_arg unexpectedly null."));
                return;
              }
              const auto& is_collection_group_arg =
                  std::get<bool>(encodable_is_collection_group_arg);
              api->AggregateQuery(app_arg, path_arg, parameters_arg, source_arg,
                                  queries_arg, is_collection_group_arg,
                                  [reply](ErrorOr<EncodableList>&& output) {
                                    if (output.has_error()) {
                                      reply(WrapError(output.error()));
                                      return;
                                    }
                                    EncodableList wrapped;
                                    wrapped.push_back(EncodableValue(
                                        std::move(output).TakeValue()));
                                    reply(EncodableValue(std::move(wrapped)));
                                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.writeBatchCommit",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_writes_arg = args.at(1);
              if (encodable_writes_arg.IsNull()) {
                reply(WrapError("writes_arg unexpectedly null."));
                return;
              }
              const auto& writes_arg =
                  std::get<EncodableList>(encodable_writes_arg);
              api->WriteBatchCommit(
                  app_arg, writes_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.querySnapshot",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_path_arg = args.at(1);
              if (encodable_path_arg.IsNull()) {
                reply(WrapError("path_arg unexpectedly null."));
                return;
              }
              const auto& path_arg = std::get<std::string>(encodable_path_arg);
              const auto& encodable_is_collection_group_arg = args.at(2);
              if (encodable_is_collection_group_arg.IsNull()) {
                reply(WrapError("is_collection_group_arg unexpectedly null."));
                return;
              }
              const auto& is_collection_group_arg =
                  std::get<bool>(encodable_is_collection_group_arg);
              const auto& encodable_parameters_arg = args.at(3);
              if (encodable_parameters_arg.IsNull()) {
                reply(WrapError("parameters_arg unexpectedly null."));
                return;
              }
              const auto& parameters_arg =
                  std::any_cast<const PigeonQueryParameters&>(
                      std::get<CustomEncodableValue>(encodable_parameters_arg));
              const auto& encodable_options_arg = args.at(4);
              if (encodable_options_arg.IsNull()) {
                reply(WrapError("options_arg unexpectedly null."));
                return;
              }
              const auto& options_arg = std::any_cast<const PigeonGetOptions&>(
                  std::get<CustomEncodableValue>(encodable_options_arg));
              const auto& encodable_include_metadata_changes_arg = args.at(5);
              if (encodable_include_metadata_changes_arg.IsNull()) {
                reply(WrapError(
                    "include_metadata_changes_arg unexpectedly null."));
                return;
              }
              const auto& include_metadata_changes_arg =
                  std::get<bool>(encodable_include_metadata_changes_arg);
              const auto& encodable_source_arg = args.at(6);
              if (encodable_source_arg.IsNull()) {
                reply(WrapError("source_arg unexpectedly null."));
                return;
              }
              const ListenSource& source_arg =
                  (ListenSource)encodable_source_arg.LongValue();
              api->QuerySnapshot(
                  app_arg, path_arg, is_collection_group_arg, parameters_arg,
                  options_arg, include_metadata_changes_arg, source_arg,
                  [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.documentReferenceSnapshot",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_parameters_arg = args.at(1);
              if (encodable_parameters_arg.IsNull()) {
                reply(WrapError("parameters_arg unexpectedly null."));
                return;
              }
              const auto& parameters_arg =
                  std::any_cast<const DocumentReferenceRequest&>(
                      std::get<CustomEncodableValue>(encodable_parameters_arg));
              const auto& encodable_include_metadata_changes_arg = args.at(2);
              if (encodable_include_metadata_changes_arg.IsNull()) {
                reply(WrapError(
                    "include_metadata_changes_arg unexpectedly null."));
                return;
              }
              const auto& include_metadata_changes_arg =
                  std::get<bool>(encodable_include_metadata_changes_arg);
              const auto& encodable_source_arg = args.at(3);
              if (encodable_source_arg.IsNull()) {
                reply(WrapError("source_arg unexpectedly null."));
                return;
              }
              const ListenSource& source_arg =
                  (ListenSource)encodable_source_arg.LongValue();
              api->DocumentReferenceSnapshot(
                  app_arg, parameters_arg, include_metadata_changes_arg,
                  source_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.cloud_firestore_platform_interface."
        "FirebaseFirestoreHostApi.persistenceCacheIndexManagerRequest",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg =
                  std::any_cast<const FirestorePigeonFirebaseApp&>(
                      std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const PersistenceCacheIndexManagerRequestEnum& request_arg =
                  (PersistenceCacheIndexManagerRequestEnum)
                      encodable_request_arg.LongValue();
              api->PersistenceCacheIndexManagerRequest(
                  app_arg, request_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue FirebaseFirestoreHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue FirebaseFirestoreHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

}  // namespace cloud_firestore_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/windows/messages.g.h

**크기**: 28969 bytes | **라인 수**: 744 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#ifndef PIGEON_MESSAGES_G_H_
#define PIGEON_MESSAGES_G_H_
#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

#include "firestore_codec.h"

namespace cloud_firestore_windows {

// Generated class from Pigeon.

class FlutterError {
 public:
  explicit FlutterError(const std::string& code) : code_(code) {}
  explicit FlutterError(const std::string& code, const std::string& message)
      : code_(code), message_(message) {}
  explicit FlutterError(const std::string& code, const std::string& message,
                        const flutter::EncodableValue& details)
      : code_(code), message_(message), details_(details) {}

  const std::string& code() const { return code_; }
  const std::string& message() const { return message_; }
  const flutter::EncodableValue& details() const { return details_; }

 private:
  std::string code_;
  std::string message_;
  flutter::EncodableValue details_;
};

template <class T>
class ErrorOr {
 public:
  ErrorOr(const T& rhs) : v_(rhs) {}
  ErrorOr(const T&& rhs) : v_(std::move(rhs)) {}
  ErrorOr(const FlutterError& rhs) : v_(rhs) {}
  ErrorOr(const FlutterError&& rhs) : v_(std::move(rhs)) {}

  bool has_error() const { return std::holds_alternative<FlutterError>(v_); }
  const T& value() const { return std::get<T>(v_); };
  const FlutterError& error() const { return std::get<FlutterError>(v_); };

 private:
  friend class FirebaseFirestoreHostApi;
  ErrorOr() = default;
  T TakeValue() && { return std::get<T>(std::move(v_)); }

  std::variant<T, FlutterError> v_;
};

// An enumeration of document change types.
enum class DocumentChangeType {
  // Indicates a new document was added to the set of documents matching the
  // query.
  added = 0,
  // Indicates a document within the query was modified.
  modified = 1,
  // Indicates a document within the query was removed (either deleted or no
  // longer matches the query.
  removed = 2
};

// An enumeration of firestore source types.
enum class Source {
  // Causes Firestore to try to retrieve an up-to-date (server-retrieved)
  // snapshot, but fall back to
  // returning cached data if the server can't be reached.
  serverAndCache = 0,
  // Causes Firestore to avoid the cache, generating an error if the server
  // cannot be reached. Note
  // that the cache will still be updated if the server request succeeds. Also
  // note that
  // latency-compensation still takes effect, so any pending write operations
  // will be visible in the
  // returned data (merged into the server-provided data).
  server = 1,
  // Causes Firestore to immediately return a value from the cache, ignoring the
  // server completely
  // (implying that the returned value may be stale with respect to the value on
  // the server). If
  // there is no data in the cache to satisfy the `get` call,
  // [DocumentReference.get] will throw a [FirebaseException] and
  // [Query.get] will return an empty [QuerySnapshotPlatform] with no documents.
  cache = 2
};

// The listener retrieves data and listens to updates from the local Firestore
// cache only. If the cache is empty, an empty snapshot will be returned.
// Snapshot events will be triggered on cache updates, like local mutations or
// load bundles.
//
// Note that the data might be stale if the cache hasn't synchronized with
// recent server-side changes.
enum class ListenSource {
  // The default behavior. The listener attempts to return initial snapshot from
  // cache and retrieve up-to-date snapshots from the Firestore server.
  // Snapshot events will be triggered on local mutations and server side
  // updates.
  defaultSource = 0,
  // The listener retrieves data and listens to updates from the local Firestore
  // cache only.
  // If the cache is empty, an empty snapshot will be returned.
  // Snapshot events will be triggered on cache updates, like local mutations or
  // load bundles.
  cache = 1
};

enum class ServerTimestampBehavior {
  // Return null for [FieldValue.serverTimestamp()] values that have not yet
  none = 0,
  // Return local estimates for [FieldValue.serverTimestamp()] values that have
  // not yet been set to their final value.
  estimate = 1,
  // Return the previous value for [FieldValue.serverTimestamp()] values that
  // have not yet been set to their final value.
  previous = 2
};

// [AggregateSource] represents the source of data for an [AggregateQuery].
enum class AggregateSource {
  // Indicates that the data should be retrieved from the server.
  server = 0
};

// [PersistenceCacheIndexManagerRequest] represents the request types for the
// persistence cache index manager.
enum class PersistenceCacheIndexManagerRequestEnum {
  enableIndexAutoCreation = 0,
  disableIndexAutoCreation = 1,
  deleteAllIndexes = 2
};

enum class PigeonTransactionResult { success = 0, failure = 1 };

enum class PigeonTransactionType {
  get = 0,
  update = 1,
  set = 2,
  deleteType = 3
};

enum class AggregateType { count = 0, sum = 1, average = 2 };

// Generated class from Pigeon that represents data sent in messages.
class PigeonFirebaseSettings {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonFirebaseSettings(bool ignore_undefined_properties);

  // Constructs an object setting all fields.
  explicit PigeonFirebaseSettings(const bool* persistence_enabled,
                                  const std::string* host,
                                  const bool* ssl_enabled,
                                  const int64_t* cache_size_bytes,
                                  bool ignore_undefined_properties);

  const bool* persistence_enabled() const;
  void set_persistence_enabled(const bool* value_arg);
  void set_persistence_enabled(bool value_arg);

  const std::string* host() const;
  void set_host(const std::string_view* value_arg);
  void set_host(std::string_view value_arg);

  const bool* ssl_enabled() const;
  void set_ssl_enabled(const bool* value_arg);
  void set_ssl_enabled(bool value_arg);

  const int64_t* cache_size_bytes() const;
  void set_cache_size_bytes(const int64_t* value_arg);
  void set_cache_size_bytes(int64_t value_arg);

  bool ignore_undefined_properties() const;
  void set_ignore_undefined_properties(bool value_arg);

 private:
  static PigeonFirebaseSettings FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirestorePigeonFirebaseApp;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::optional<bool> persistence_enabled_;
  std::optional<std::string> host_;
  std::optional<bool> ssl_enabled_;
  std::optional<int64_t> cache_size_bytes_;
  bool ignore_undefined_properties_;
};

// Generated class from Pigeon that represents data sent in messages.
class FirestorePigeonFirebaseApp {
 public:
  // Constructs an object setting all fields.
  explicit FirestorePigeonFirebaseApp(const std::string& app_name,
                                      const PigeonFirebaseSettings& settings,
                                      const std::string& database_u_r_l);

  const std::string& app_name() const;
  void set_app_name(std::string_view value_arg);

  const PigeonFirebaseSettings& settings() const;
  void set_settings(const PigeonFirebaseSettings& value_arg);

  const std::string& database_u_r_l() const;
  void set_database_u_r_l(std::string_view value_arg);

 private:
  static FirestorePigeonFirebaseApp FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::string app_name_;
  PigeonFirebaseSettings settings_;
  std::string database_u_r_l_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonSnapshotMetadata {
 public:
  // Constructs an object setting all fields.
  explicit PigeonSnapshotMetadata(bool has_pending_writes, bool is_from_cache);

  bool has_pending_writes() const;
  void set_has_pending_writes(bool value_arg);

  bool is_from_cache() const;
  void set_is_from_cache(bool value_arg);

  static PigeonSnapshotMetadata FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;

 private:
  friend class PigeonDocumentSnapshot;
  friend class PigeonQuerySnapshot;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  bool has_pending_writes_;
  bool is_from_cache_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonDocumentSnapshot {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonDocumentSnapshot(const std::string& path,
                                  const PigeonSnapshotMetadata& metadata);

  // Constructs an object setting all fields.
  explicit PigeonDocumentSnapshot(const std::string& path,
                                  const flutter::EncodableMap* data,
                                  const PigeonSnapshotMetadata& metadata);

  const std::string& path() const;
  void set_path(std::string_view value_arg);

  const flutter::EncodableMap* data() const;
  void set_data(const flutter::EncodableMap* value_arg);
  void set_data(const flutter::EncodableMap& value_arg);

  const PigeonSnapshotMetadata& metadata() const;
  void set_metadata(const PigeonSnapshotMetadata& value_arg);

  static PigeonDocumentSnapshot FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;

 private:
  friend class PigeonDocumentChange;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::string path_;
  std::optional<flutter::EncodableMap> data_;
  PigeonSnapshotMetadata metadata_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonDocumentChange {
 public:
  // Constructs an object setting all fields.
  explicit PigeonDocumentChange(const DocumentChangeType& type,
                                const PigeonDocumentSnapshot& document,
                                int64_t old_index, int64_t new_index);

  const DocumentChangeType& type() const;
  void set_type(const DocumentChangeType& value_arg);

  const PigeonDocumentSnapshot& document() const;
  void set_document(const PigeonDocumentSnapshot& value_arg);

  int64_t old_index() const;
  void set_old_index(int64_t value_arg);

  int64_t new_index() const;
  void set_new_index(int64_t value_arg);

  static PigeonDocumentChange FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;

 private:
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  DocumentChangeType type_;
  PigeonDocumentSnapshot document_;
  int64_t old_index_;
  int64_t new_index_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonQuerySnapshot {
 public:
  // Constructs an object setting all fields.
  explicit PigeonQuerySnapshot(const flutter::EncodableList& documents,
                               const flutter::EncodableList& document_changes,
                               const PigeonSnapshotMetadata& metadata);

  const flutter::EncodableList& documents() const;
  void set_documents(const flutter::EncodableList& value_arg);

  const flutter::EncodableList& document_changes() const;
  void set_document_changes(const flutter::EncodableList& value_arg);

  const PigeonSnapshotMetadata& metadata() const;
  void set_metadata(const PigeonSnapshotMetadata& value_arg);

 private:
  static PigeonQuerySnapshot FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  flutter::EncodableList documents_;
  flutter::EncodableList document_changes_;
  PigeonSnapshotMetadata metadata_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonGetOptions {
 public:
  // Constructs an object setting all fields.
  explicit PigeonGetOptions(
      const Source& source,
      const ServerTimestampBehavior& server_timestamp_behavior);

  const Source& source() const;
  void set_source(const Source& value_arg);

  const ServerTimestampBehavior& server_timestamp_behavior() const;
  void set_server_timestamp_behavior(const ServerTimestampBehavior& value_arg);

 private:
  static PigeonGetOptions FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  Source source_;
  ServerTimestampBehavior server_timestamp_behavior_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonDocumentOption {
 public:
  // Constructs an object setting all non-nullable fields.
  PigeonDocumentOption();

  // Constructs an object setting all fields.
  explicit PigeonDocumentOption(const bool* merge,
                                const flutter::EncodableList* merge_fields);

  const bool* merge() const;
  void set_merge(const bool* value_arg);
  void set_merge(bool value_arg);

  const flutter::EncodableList* merge_fields() const;
  void set_merge_fields(const flutter::EncodableList* value_arg);
  void set_merge_fields(const flutter::EncodableList& value_arg);

 private:
  static PigeonDocumentOption FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class PigeonTransactionCommand;
  friend class DocumentReferenceRequest;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::optional<bool> merge_;
  std::optional<flutter::EncodableList> merge_fields_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonTransactionCommand {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonTransactionCommand(const PigeonTransactionType& type,
                                    const std::string& path);

  // Constructs an object setting all fields.
  explicit PigeonTransactionCommand(const PigeonTransactionType& type,
                                    const std::string& path,
                                    const flutter::EncodableMap* data,
                                    const PigeonDocumentOption* option);

  const PigeonTransactionType& type() const;
  void set_type(const PigeonTransactionType& value_arg);

  const std::string& path() const;
  void set_path(std::string_view value_arg);

  const flutter::EncodableMap* data() const;
  void set_data(const flutter::EncodableMap* value_arg);
  void set_data(const flutter::EncodableMap& value_arg);

  const PigeonDocumentOption* option() const;
  void set_option(const PigeonDocumentOption* value_arg);
  void set_option(const PigeonDocumentOption& value_arg);

 private:
  static PigeonTransactionCommand FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  PigeonTransactionType type_;
  std::string path_;
  std::optional<flutter::EncodableMap> data_;
  std::optional<PigeonDocumentOption> option_;
};

// Generated class from Pigeon that represents data sent in messages.
class DocumentReferenceRequest {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit DocumentReferenceRequest(const std::string& path);

  // Constructs an object setting all fields.
  explicit DocumentReferenceRequest(
      const std::string& path, const flutter::EncodableMap* data,
      const PigeonDocumentOption* option, const Source* source,
      const ServerTimestampBehavior* server_timestamp_behavior);

  const std::string& path() const;
  void set_path(std::string_view value_arg);

  const flutter::EncodableMap* data() const;
  void set_data(const flutter::EncodableMap* value_arg);
  void set_data(const flutter::EncodableMap& value_arg);

  const PigeonDocumentOption* option() const;
  void set_option(const PigeonDocumentOption* value_arg);
  void set_option(const PigeonDocumentOption& value_arg);

  const Source* source() const;
  void set_source(const Source* value_arg);
  void set_source(const Source& value_arg);

  const ServerTimestampBehavior* server_timestamp_behavior() const;
  void set_server_timestamp_behavior(const ServerTimestampBehavior* value_arg);
  void set_server_timestamp_behavior(const ServerTimestampBehavior& value_arg);

 private:
  static DocumentReferenceRequest FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::string path_;
  std::optional<flutter::EncodableMap> data_;
  std::optional<PigeonDocumentOption> option_;
  std::optional<Source> source_;
  std::optional<ServerTimestampBehavior> server_timestamp_behavior_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonQueryParameters {
 public:
  // Constructs an object setting all non-nullable fields.
  PigeonQueryParameters();

  // Constructs an object setting all fields.
  explicit PigeonQueryParameters(const flutter::EncodableList* where,
                                 const flutter::EncodableList* order_by,
                                 const int64_t* limit,
                                 const int64_t* limit_to_last,
                                 const flutter::EncodableList* start_at,
                                 const flutter::EncodableList* start_after,
                                 const flutter::EncodableList* end_at,
                                 const flutter::EncodableList* end_before,
                                 const flutter::EncodableMap* filters);

  const flutter::EncodableList* where() const;
  void set_where(const flutter::EncodableList* value_arg);
  void set_where(const flutter::EncodableList& value_arg);

  const flutter::EncodableList* order_by() const;
  void set_order_by(const flutter::EncodableList* value_arg);
  void set_order_by(const flutter::EncodableList& value_arg);

  const int64_t* limit() const;
  void set_limit(const int64_t* value_arg);
  void set_limit(int64_t value_arg);

  const int64_t* limit_to_last() const;
  void set_limit_to_last(const int64_t* value_arg);
  void set_limit_to_last(int64_t value_arg);

  const flutter::EncodableList* start_at() const;
  void set_start_at(const flutter::EncodableList* value_arg);
  void set_start_at(const flutter::EncodableList& value_arg);

  const flutter::EncodableList* start_after() const;
  void set_start_after(const flutter::EncodableList* value_arg);
  void set_start_after(const flutter::EncodableList& value_arg);

  const flutter::EncodableList* end_at() const;
  void set_end_at(const flutter::EncodableList* value_arg);
  void set_end_at(const flutter::EncodableList& value_arg);

  const flutter::EncodableList* end_before() const;
  void set_end_before(const flutter::EncodableList* value_arg);
  void set_end_before(const flutter::EncodableList& value_arg);

  const flutter::EncodableMap* filters() const;
  void set_filters(const flutter::EncodableMap* value_arg);
  void set_filters(const flutter::EncodableMap& value_arg);

 private:
  static PigeonQueryParameters FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  std::optional<flutter::EncodableList> where_;
  std::optional<flutter::EncodableList> order_by_;
  std::optional<int64_t> limit_;
  std::optional<int64_t> limit_to_last_;
  std::optional<flutter::EncodableList> start_at_;
  std::optional<flutter::EncodableList> start_after_;
  std::optional<flutter::EncodableList> end_at_;
  std::optional<flutter::EncodableList> end_before_;
  std::optional<flutter::EncodableMap> filters_;
};

// Generated class from Pigeon that represents data sent in messages.
class AggregateQuery {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit AggregateQuery(const AggregateType& type);

  // Constructs an object setting all fields.
  explicit AggregateQuery(const AggregateType& type, const std::string* field);

  const AggregateType& type() const;
  void set_type(const AggregateType& value_arg);

  const std::string* field() const;
  void set_field(const std::string_view* value_arg);
  void set_field(std::string_view value_arg);

 private:
  static AggregateQuery FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  AggregateType type_;
  std::optional<std::string> field_;
};

// Generated class from Pigeon that represents data sent in messages.
class AggregateQueryResponse {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit AggregateQueryResponse(const AggregateType& type);

  // Constructs an object setting all fields.
  explicit AggregateQueryResponse(const AggregateType& type,
                                  const std::string* field,
                                  const double* value);

  const AggregateType& type() const;
  void set_type(const AggregateType& value_arg);

  const std::string* field() const;
  void set_field(const std::string_view* value_arg);
  void set_field(std::string_view value_arg);

  const double* value() const;
  void set_value(const double* value_arg);
  void set_value(double value_arg);

 private:
  static AggregateQueryResponse FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseFirestoreHostApi;
  friend class FirebaseFirestoreHostApiCodecSerializer;
  AggregateType type_;
  std::optional<std::string> field_;
  std::optional<double> value_;
};

class FirebaseFirestoreHostApiCodecSerializer
    : public cloud_firestore_windows::FirestoreCodec {
 public:
  FirebaseFirestoreHostApiCodecSerializer();
  inline static FirebaseFirestoreHostApiCodecSerializer& GetInstance() {
    static FirebaseFirestoreHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class FirebaseFirestoreHostApi {
 public:
  FirebaseFirestoreHostApi(const FirebaseFirestoreHostApi&) = delete;
  FirebaseFirestoreHostApi& operator=(const FirebaseFirestoreHostApi&) = delete;
  virtual ~FirebaseFirestoreHostApi() {}
  virtual void LoadBundle(
      const FirestorePigeonFirebaseApp& app, const std::vector<uint8_t>& bundle,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void NamedQueryGet(
      const FirestorePigeonFirebaseApp& app, const std::string& name,
      const PigeonGetOptions& options,
      std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) = 0;
  virtual void ClearPersistence(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void DisableNetwork(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void EnableNetwork(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void Terminate(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void WaitForPendingWrites(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SetIndexConfiguration(
      const FirestorePigeonFirebaseApp& app,
      const std::string& index_configuration,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SetLoggingEnabled(
      bool logging_enabled,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SnapshotsInSyncSetup(
      const FirestorePigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void TransactionCreate(
      const FirestorePigeonFirebaseApp& app, int64_t timeout,
      int64_t max_attempts,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void TransactionStoreResult(
      const std::string& transaction_id,
      const PigeonTransactionResult& result_type,
      const flutter::EncodableList* commands,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void TransactionGet(
      const FirestorePigeonFirebaseApp& app, const std::string& transaction_id,
      const std::string& path,
      std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result) = 0;
  virtual void DocumentReferenceSet(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void DocumentReferenceUpdate(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void DocumentReferenceGet(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(ErrorOr<PigeonDocumentSnapshot> reply)> result) = 0;
  virtual void DocumentReferenceDelete(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& request,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void QueryGet(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      bool is_collection_group, const PigeonQueryParameters& parameters,
      const PigeonGetOptions& options,
      std::function<void(ErrorOr<PigeonQuerySnapshot> reply)> result) = 0;
  virtual void AggregateQuery(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      const PigeonQueryParameters& parameters, const AggregateSource& source,
      const flutter::EncodableList& queries, bool is_collection_group,
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;
  virtual void WriteBatchCommit(
      const FirestorePigeonFirebaseApp& app,
      const flutter::EncodableList& writes,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void QuerySnapshot(
      const FirestorePigeonFirebaseApp& app, const std::string& path,
      bool is_collection_group, const PigeonQueryParameters& parameters,
      const PigeonGetOptions& options, bool include_metadata_changes,
      const ListenSource& source,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void DocumentReferenceSnapshot(
      const FirestorePigeonFirebaseApp& app,
      const DocumentReferenceRequest& parameters, bool include_metadata_changes,
      const ListenSource& source,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void PersistenceCacheIndexManagerRequest(
      const FirestorePigeonFirebaseApp& app,
      const PersistenceCacheIndexManagerRequestEnum& request,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;

  // The codec used by FirebaseFirestoreHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `FirebaseFirestoreHostApi` to handle messages
  // through the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseFirestoreHostApi* api);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  FirebaseFirestoreHostApi() = default;
};
}  // namespace cloud_firestore_windows
#endif  // PIGEON_MESSAGES_G_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/CHANGELOG.md

**크기**: 63706 bytes | **라인 수**: 1484 | **타입**: text

```
## 6.0.2

 - Update a dependency to the latest release.

## 6.0.1

 - Update a dependency to the latest release.

## 6.0.0

> Note: This release has breaking changes.

 - **BREAKING** **FEAT**: bump iOS SDK to version 12.0.0 ([#17549](https://github.com/firebase/flutterfire/issues/17549)). ([b2619e68](https://github.com/firebase/flutterfire/commit/b2619e685fec897513483df1d7be347b64f95606))
 - **BREAKING** **FEAT**(firestore): remove deprecated functions ([#17559](https://github.com/firebase/flutterfire/issues/17559)). ([67017fd6](https://github.com/firebase/flutterfire/commit/67017fd6f139080cec7ecd1b4d75a05f13f238fa))
 - **BREAKING** **FEAT**: bump Android SDK to version 34.0.0 ([#17554](https://github.com/firebase/flutterfire/issues/17554)). ([a5bdc051](https://github.com/firebase/flutterfire/commit/a5bdc051d40ee44e39cf0b8d2a7801bc6f618b67))

## 5.6.12

 - Update a dependency to the latest release.

## 5.6.11

 - Update a dependency to the latest release.

## 5.6.10

 - Update a dependency to the latest release.

## 5.6.9

 - **FIX**(firestore,ios): fix an issue where unlimited cache wasn't properly set on iOS ([#17412](https://github.com/firebase/flutterfire/issues/17412)). ([cad28406](https://github.com/firebase/flutterfire/commit/cad28406d3baf8fa1087be35630c82a79b5c9d92))

## 5.6.8

 - Update a dependency to the latest release.

## 5.6.7

 - **FIX**(firestore): Change asserts to throw argumentError ([#17302](https://github.com/firebase/flutterfire/issues/17302)). ([ec1e6a5e](https://github.com/firebase/flutterfire/commit/ec1e6a5eef149680b2750900d1f16d8074e09b38))
 - **FIX**(cloud_firestore): correct nanoseconds calculation for pre-1970 dates ([#17195](https://github.com/firebase/flutterfire/issues/17195)). ([a13deae3](https://github.com/firebase/flutterfire/commit/a13deae3334045fb1a48817ff9300cbe0696d177))

## 5.6.6

 - Update a dependency to the latest release.

## 5.6.5

 - Update a dependency to the latest release.

## 5.6.4

 - **FIX**(firestore,macos): ensure Package.swift pulls firebase-ios-sdk version from local txt file ([#17097](https://github.com/firebase/flutterfire/issues/17097)). ([b7248e05](https://github.com/firebase/flutterfire/commit/b7248e05a0ab7689c1d634689fe660c9c7125713))

## 5.6.3

 - Update a dependency to the latest release.

## 5.6.2

 - **FIX**(cloud_firestore,android): suppress unchecked warning ([#16979](https://github.com/firebase/flutterfire/issues/16979)). ([684508da](https://github.com/firebase/flutterfire/commit/684508daf096acb50deb4c1d14c76f72fb52b8c5))

## 5.6.1

 - Update a dependency to the latest release.

## 5.6.0

 - **FEAT**(firestore): add support for VectorValue ([#16476](https://github.com/firebase/flutterfire/issues/16476)). ([cc23f179](https://github.com/firebase/flutterfire/commit/cc23f179082256fe9700f17e3856821b4a6d4240))

## 5.5.1

 - **FIX**(firestore,android): synchronize access to firestore instances ([#16675](https://github.com/firebase/flutterfire/issues/16675)). ([03e85ae6](https://github.com/firebase/flutterfire/commit/03e85ae63ece0924d376b98e35e8a73670b59fa8))

## 5.5.0

 - **FEAT**(firestore): Swift Package Manager support ([#13329](https://github.com/firebase/flutterfire/issues/13329)). ([0420eabb](https://github.com/firebase/flutterfire/commit/0420eabb3ab247e0e3998bedcb9779fe35c46920))

## 5.4.5

 - Update a dependency to the latest release.

## 5.4.4

 - **FIX**(cloud_firestore): remove single whereIn filter assertion ([#13436](https://github.com/firebase/flutterfire/issues/13436)). ([d770aa6a](https://github.com/firebase/flutterfire/commit/d770aa6a2616ed0535bbc2fbd2e9645da9ad18cd))

## 5.4.3

 - **FIX**(all,apple): use modular headers to import ([#13400](https://github.com/firebase/flutterfire/issues/13400)). ([d7d2d4b9](https://github.com/firebase/flutterfire/commit/d7d2d4b93e7c00226027fffde46699f3d5388a41))

## 5.4.2

 - Update a dependency to the latest release.

## 5.4.1

 - **FIX**(firestore,web): only set long polling options if it has a value ([#13295](https://github.com/firebase/flutterfire/issues/13295)). ([04b5002c](https://github.com/firebase/flutterfire/commit/04b5002c49904bae0b369f06147b5c2a90b978ee))

## 5.4.0

 - **FEAT**(firestore,web): expose `webExperimentalForceLongPolling`, `webExperimentalAutoDetectLongPolling` and `timeoutSeconds` on web ([#13201](https://github.com/firebase/flutterfire/issues/13201)). ([6ec2a103](https://github.com/firebase/flutterfire/commit/6ec2a103a3a325a73550bdfff4c0d524ae7e4068))

## 5.3.0

 - **FIX**(firestore): not passing correctly the ListenSource when listening to as single `DocumentReference` ([#13179](https://github.com/firebase/flutterfire/issues/13179)). ([ce6e1c97](https://github.com/firebase/flutterfire/commit/ce6e1c97efc1398bc3c209d7a522e3bb67db3d0f))
 - **FEAT**: bump iOS SDK to version 11.0.0 ([#13158](https://github.com/firebase/flutterfire/issues/13158)). ([c0e0c997](https://github.com/firebase/flutterfire/commit/c0e0c99703ea394d1bb873ac225c5fe3539b002d))
 - **DOCS**: remove reference to flutter.io and firebase.flutter.dev ([#13152](https://github.com/firebase/flutterfire/issues/13152)). ([5f0874b9](https://github.com/firebase/flutterfire/commit/5f0874b91e28a203dd62d37d391e5760c91f5729))

## 5.2.1

 - **FIX**: compilation issue on Windows ([#13135](https://github.com/firebase/flutterfire/issues/13135)). ([de8c9e0f](https://github.com/firebase/flutterfire/commit/de8c9e0f2d3117b3614ac8295b041fea7ed3ee7f))

## 5.2.0

 - **FIX**(firestore,web): stop cleaning up snapshot listeners in debug ([#13119](https://github.com/firebase/flutterfire/issues/13119)). ([82a63c8b](https://github.com/firebase/flutterfire/commit/82a63c8bf9bad0c262ed48d7829fb05110a9fe08))
 - **FEAT**(firestore): support for `PersistentCacheIndexManager` for firestore instances for managing cache indexes. ([#13070](https://github.com/firebase/flutterfire/issues/13070)). ([806c15d7](https://github.com/firebase/flutterfire/commit/806c15d7eadaf48b8dfb22586bea4ed684672a86))

## 5.1.0

 - **FEAT**(firestore,windows): support multiple databases ([#12998](https://github.com/firebase/flutterfire/issues/12998)). ([f80768a4](https://github.com/firebase/flutterfire/commit/f80768a4a4258932cac75dbd310589573bf14306))

## 5.0.2

 - Update a dependency to the latest release.

## 5.0.1

 - **FIX**(firestore,macos): add Nonull decorator to PigeonParser to remove warnings when building ([#12930](https://github.com/firebase/flutterfire/issues/12930)). ([264b7643](https://github.com/firebase/flutterfire/commit/264b764346e0f35cc11e0a2b1f8070a6036c6631))
 - **FIX**(firestore,web): ensure streams are removed on "hot restart" ([#12913](https://github.com/firebase/flutterfire/issues/12913)). ([c1a67e54](https://github.com/firebase/flutterfire/commit/c1a67e54894cbfb316b3445505b5803e2d041ed5))

## 5.0.0

> Note: This release has breaking changes.

 - **DOCS**(firestore): update documentation for `clearPersistence` ([#12843](https://github.com/firebase/flutterfire/issues/12843)). ([35b78f04](https://github.com/firebase/flutterfire/commit/35b78f04edd12f2319d3d6cce06c66bfdbd13d8c))
 - **BREAKING** **REFACTOR**: android plugins require `minSdk 21`, auth requires `minSdk 23` ahead of android BOM `>=33.0.0` ([#12873](https://github.com/firebase/flutterfire/issues/12873)). ([52accfc6](https://github.com/firebase/flutterfire/commit/52accfc6c39d6360d9c0f36efe369ede990b7362))
 - **BREAKING** **REFACTOR**: bump all iOS deployment targets to iOS 13 ahead of Firebase iOS SDK `v11` breaking change ([#12872](https://github.com/firebase/flutterfire/issues/12872)). ([de0cea2c](https://github.com/firebase/flutterfire/commit/de0cea2c3c36694a76361be784255986fac84a43))

## 4.17.5

 - Update a dependency to the latest release.

## 4.17.4

 - **FIX**(firestore,ios): fix document stream handler options. ([#12764](https://github.com/firebase/flutterfire/issues/12764)). ([786e73ca](https://github.com/firebase/flutterfire/commit/786e73ca17527493a47914c7ead1a12a4f0adde5))

## 4.17.3

 - **FIX**(firestore,ios): fix query stream handler options. ([#12739](https://github.com/firebase/flutterfire/issues/12739)). ([953bf929](https://github.com/firebase/flutterfire/commit/953bf929bf19e7bbb3564c69901f5a4fca5fc981))
 - **FIX**(web): fix test for Web on WASM ([#12697](https://github.com/firebase/flutterfire/issues/12697)). ([e343df58](https://github.com/firebase/flutterfire/commit/e343df585280e0ff088eb21a7a7accb727b150ed))

## 4.17.2

 - Update a dependency to the latest release.

## 4.17.1

 - Update a dependency to the latest release.

## 4.17.0

 - **FIX**(firestore): remove `nanopb` version constraints from podspec ([#12632](https://github.com/firebase/flutterfire/issues/12632)). ([c899a7bc](https://github.com/firebase/flutterfire/commit/c899a7bc9cdd7b552d3c10058f4899106a4c1994))
 - **FIX**(firestore): deprecate `databaseURL` in favor of `databaseId` ([#12593](https://github.com/firebase/flutterfire/issues/12593)). ([8966f483](https://github.com/firebase/flutterfire/commit/8966f4837afe7e32a3847b7b677d787b1398b682))
 - **FEAT**(firestore): add support for listening snapshot from cache ([#12585](https://github.com/firebase/flutterfire/issues/12585)). ([f2cef8c1](https://github.com/firebase/flutterfire/commit/f2cef8c13f590cdeda0cadbe3d85d6e246d5ad7f))

## 4.16.1

 - **FIX**(firestore,android): lint warnings and deprecated API ([#12577](https://github.com/firebase/flutterfire/issues/12577)). ([1b6ef739](https://github.com/firebase/flutterfire/commit/1b6ef73935062a4fa2c43bb4ef9b6d080a3ca5b4))
 - **FIX**(firestore,windows): improve memory management ([#12575](https://github.com/firebase/flutterfire/issues/12575)). ([7f10940b](https://github.com/firebase/flutterfire/commit/7f10940bef3ea17255c4e33663d152473874c25b))

## 4.16.0

 - **FEAT**(android): Bump `compileSdk` version of Android plugins to latest stable (34) ([#12566](https://github.com/firebase/flutterfire/issues/12566)). ([e891fab2](https://github.com/firebase/flutterfire/commit/e891fab291e9beebc223000b133a6097e066a7fc))
 - **FEAT**(firestore): allow query with range and inequality filters on multiple fields ([#12564](https://github.com/firebase/flutterfire/issues/12564)). ([00ae837f](https://github.com/firebase/flutterfire/commit/00ae837fecf893d8b1eda927fb7085a7d917e671))

## 4.15.10

 - Update a dependency to the latest release.

## 4.15.9

 - Update a dependency to the latest release.

## 4.15.8

 - **FIX**(firestore): fix an issue that would cause FieldValue.increment to be interpreted as double ([#12444](https://github.com/firebase/flutterfire/issues/12444)). ([e9823a41](https://github.com/firebase/flutterfire/commit/e9823a415bec0a46209608fdaf856c2413d46fbf))

## 4.15.7

 - **FIX**(firestore): fix an issue that would cause FieldValue.increment to not work for big int ([#12426](https://github.com/firebase/flutterfire/issues/12426)). ([a776dec5](https://github.com/firebase/flutterfire/commit/a776dec5e181b2656bfc659a23514d21930b5556))

## 4.15.6

 - **FIX**(firestore,windows): fix compilation issue on Windows ([#12375](https://github.com/firebase/flutterfire/issues/12375)). ([f24d0a76](https://github.com/firebase/flutterfire/commit/f24d0a76ff384cf40605ae59af705b2854e53ba7))

## 4.15.5

 - **FIX**(firestore,web): Propagate `FirebaseException` properly, fix `mergeFields` bug, fix `bytesLoaded` different type under different conditions ([#12334](https://github.com/firebase/flutterfire/issues/12334)). ([fdde75b0](https://github.com/firebase/flutterfire/commit/fdde75b02fe4bd4d40ce14798e7212eca7c8e557))
 - **FIX**(firestore): expose `AggregateField` type to users ([#12305](https://github.com/firebase/flutterfire/issues/12305)). ([2b83defa](https://github.com/firebase/flutterfire/commit/2b83defa84056e717bb230a7abd220f211c2e15e))
 - **FIX**(firestore): cannot use `not-in` & `in` filters in the same query ([#12307](https://github.com/firebase/flutterfire/issues/12307)). ([e538338c](https://github.com/firebase/flutterfire/commit/e538338c7e1bef38973ee43db37f3def20a3d4b0))
 - **FIX**(firestore): aggregate query `average()` is `null` when collection is empty or collection doesn't exist or the property doesn't exist on docs ([#12304](https://github.com/firebase/flutterfire/issues/12304)). ([4d3b578d](https://github.com/firebase/flutterfire/commit/4d3b578dbb88da441e308179f3656822c5612ef1))

## 4.15.4

 - **FIX**(firestore,web): fix an issue where nested object could be incorrectly decoded from JSObjects ([#12289](https://github.com/firebase/flutterfire/issues/12289)). ([991f5bd4](https://github.com/firebase/flutterfire/commit/991f5bd416880d0a5a49e1ff466f4769d6730e77))

## 4.15.3

 - **FIX**(firestore,web): fix an issue where nested object could be incorrectly decoded from JSObjects ([#12272](https://github.com/firebase/flutterfire/issues/12272)). ([bd27d1d9](https://github.com/firebase/flutterfire/commit/bd27d1d9763acdff88a6a5f42142986f8643fae9))

## 4.15.2

 - Update a dependency to the latest release.

## 4.15.1

 - Update a dependency to the latest release.

## 4.15.0

 - **FIX**(firestore): revert breaking change to where() API. `null` cannot be used for `isEqualTo` or `isNotEqualTo` in a query. ([#12164](https://github.com/firebase/flutterfire/issues/12164)). ([cff6f767](https://github.com/firebase/flutterfire/commit/cff6f7674014037688815bdbe3198dd903a4b08e))
 - **FIX**(firestore,web): update `setSettings` to allow usage of a up-to-date persistence on web ([#12041](https://github.com/firebase/flutterfire/issues/12041)). ([c9174334](https://github.com/firebase/flutterfire/commit/c917433452fb9125197c385cb121d8174cc56c20))
 - **FEAT**(firestore,web): migrate web to js_interop to be compatible with WASM ([#12169](https://github.com/firebase/flutterfire/issues/12169)). ([57ebd529](https://github.com/firebase/flutterfire/commit/57ebd529de5def2bab1557a1bd9967ee4267c08a))
 - **DOCS**: change old documentation links of packages in README files ([#12136](https://github.com/firebase/flutterfire/issues/12136)). ([24b9ac7e](https://github.com/firebase/flutterfire/commit/24b9ac7ec29fc9ca466c0941c2cff26d75b8568d))

## 4.14.0

 - **FIX**(firestore): `transaction.get()` should throw `FirebaseException` on exception. ([#12064](https://github.com/firebase/flutterfire/issues/12064)). ([3cfc5019](https://github.com/firebase/flutterfire/commit/3cfc5019d4f9a5f3c610a44ef370541bf22cd028))
 - **FIX**(firestore): export `LoadBundleTaskState` in `cloud_firestore` ([#12065](https://github.com/firebase/flutterfire/issues/12065)). ([97903034](https://github.com/firebase/flutterfire/commit/97903034b6bf720be141ded3eb74961323ec72f5))
 - **FEAT**(firestore): add support for `sum` and `average` aggregated queries ([#11757](https://github.com/firebase/flutterfire/issues/11757)). ([82af6c2f](https://github.com/firebase/flutterfire/commit/82af6c2f40160a9e2f74e2d48652003fa48bb161))
 - **FEAT**: allow users to disable automatic host mapping ([#11962](https://github.com/firebase/flutterfire/issues/11962)). ([13c1ce33](https://github.com/firebase/flutterfire/commit/13c1ce333b8cd113241a1f7ac07181c1c76194bc))

## 4.13.6

 - **FIX**(firestore): revert changes to `isLessThan`, `isLessThanOrEqualTo`,`isGreaterThan`, `isGreaterThanOrEqualTo` & `arrayContains`. `null` is not valid.. ([#12017](https://github.com/firebase/flutterfire/issues/12017)). ([2712ea4e](https://github.com/firebase/flutterfire/commit/2712ea4e73ab02cf2f4ac3719b41200efd2e8dc0))

## 4.13.5

 - Update a dependency to the latest release.

## 4.13.4

 - Update a dependency to the latest release.

## 4.13.3

 - Update a dependency to the latest release.

## 4.13.2

 - **FIX**(firestore): allow `null` value to `isEqualsTo` & `isNotEqualsTo` in `where()` query ([#11896](https://github.com/firebase/flutterfire/issues/11896)). ([3ee59a7c](https://github.com/firebase/flutterfire/commit/3ee59a7c4aff589cc5845107099cc012d7b19b53))
 - **FIX**(firestore,web): fix being able to use normal `where` conditions and `Filter.OR` together ([#11891](https://github.com/firebase/flutterfire/issues/11891)). ([c8410acd](https://github.com/firebase/flutterfire/commit/c8410acd79fe6f8f4cd36b4eacb384c5874d61d2))

## 4.13.1

 - **FIX**(firestore,android): fix a race condition that could cause a crash when adding event channels while closing the app ([#11881](https://github.com/firebase/flutterfire/issues/11881)). ([963c1b8d](https://github.com/firebase/flutterfire/commit/963c1b8d2d54e03f6d6edcb4b6a05f43c62b345c))
 - **FIX**(firestore): ensure `collectionGroup().count()` aggregate query works ([#11850](https://github.com/firebase/flutterfire/issues/11850)). ([85e71293](https://github.com/firebase/flutterfire/commit/85e712937cd609977a9681712b3afaf8f3018903))

## 4.13.0

 - **FIX**(firestore,ios): remove a warning that would be printed when using transactions ([#11783](https://github.com/firebase/flutterfire/issues/11783)). ([355ab9a5](https://github.com/firebase/flutterfire/commit/355ab9a515551afd5f01bbbc94341a85757e8c8c))
 - **FEAT**(windows): add platform logging for core, auth, firestore and storage ([#11790](https://github.com/firebase/flutterfire/issues/11790)). ([e7d428d1](https://github.com/firebase/flutterfire/commit/e7d428d14be1535a2d579d4b2d376fbb81f06742))

## 4.12.2

 - **FIX**(firestore,android): `cacheSizeBytes` value cannot be null when setting `persistenceEnabled` ([#11794](https://github.com/firebase/flutterfire/issues/11794)). ([a10399eb](https://github.com/firebase/flutterfire/commit/a10399eb1cad2207eba7d2efa64267c9d0176b4a))

## 4.12.1

 - **FIX**(firestore,ios): fix freeze when doing a get in transactions when auth is also installed ([#11773](https://github.com/firebase/flutterfire/issues/11773)). ([180c0918](https://github.com/firebase/flutterfire/commit/180c0918336cdee6efd95bb9926be931d69eedce))
 - **FIX**(firestore,android): fix hot reload freezing the app on Android ([#11776](https://github.com/firebase/flutterfire/issues/11776)). ([bd1ab457](https://github.com/firebase/flutterfire/commit/bd1ab457a4dde19e18457fe05413d1096565f45f))

## 4.12.0

 - **FIX**(firestore): cleaned up use of previous method channel ([#11758](https://github.com/firebase/flutterfire/issues/11758)). ([8cfc69bf](https://github.com/firebase/flutterfire/commit/8cfc69bf7c773fac26f12f01863e7853791fce8f))
 - **FEAT**: bump Firebase iOS SDK `10.16.0` ([#11698](https://github.com/firebase/flutterfire/issues/11698)). ([666f90ea](https://github.com/firebase/flutterfire/commit/666f90ea1eb090ee3f2397c9ffde8ddaf934f36c))

## 4.11.0

 - **FIX**(ios): fix clashing filenames between Auth and Firestore ([#11731](https://github.com/firebase/flutterfire/issues/11731)). ([8770cafc](https://github.com/firebase/flutterfire/commit/8770cafccccb11607b5530311e3150ac08cd172e))
 - **FEAT**(firestore,windows): add Filters to windows ([#11726](https://github.com/firebase/flutterfire/issues/11726)). ([dde59d46](https://github.com/firebase/flutterfire/commit/dde59d466e1b6cc483ba29654a35f198d6e8c9ae))

## 4.10.0

 - **FEAT**: Full support of AGP 8 ([#11699](https://github.com/firebase/flutterfire/issues/11699)). ([bdb5b270](https://github.com/firebase/flutterfire/commit/bdb5b27084d225809883bdaa6aa5954650551927))
 - **FEAT**(firestore,windows): add support to Windows ([#11516](https://github.com/firebase/flutterfire/issues/11516)). ([e51d2a2d](https://github.com/firebase/flutterfire/commit/e51d2a2d287f4162f5a67d8200f1bf57fc2afe14))

## 4.9.3

 - Update a dependency to the latest release.

## 4.9.2

 - **FIX**(firestore): allow `DocumentReference` to be used to in Filter queries ([#11593](https://github.com/firebase/flutterfire/issues/11593)). ([3f570c6d](https://github.com/firebase/flutterfire/commit/3f570c6d42305bef299e75de6053eb57d8520c8a))
 - **FIX**(firestore): Correct static property getter `serverTimestampMap` ([#11570](https://github.com/firebase/flutterfire/issues/11570)). ([251d15e9](https://github.com/firebase/flutterfire/commit/251d15e970c771f30bc03aeda319538e9b3b76fc))

## 4.9.1

 - **FIX**(cloud_firestore): Fix crashes on iOS/macOS ([#11501](https://github.com/firebase/flutterfire/issues/11501)). ([3ed53470](https://github.com/firebase/flutterfire/commit/3ed53470f0536294d4d1905c759c91aabf1d39ff))

## 4.9.0

 - **FEAT**(firestore): add support for multiple database instances ([#11310](https://github.com/firebase/flutterfire/issues/11310)). ([ce6efcc1](https://github.com/firebase/flutterfire/commit/ce6efcc16ced0317e86b0ad12aa02ff5795a8207))

## 4.8.5

 - **FIX**(firestore): allow `FieldPath.documentId` as a field argument in queries ([#11443](https://github.com/firebase/flutterfire/issues/11443)). ([4e01a9d8](https://github.com/firebase/flutterfire/commit/4e01a9d84ededf0e0ba74bdc2eba75492e1aa532))

## 4.8.4

 - **FIX**(firestore): remove assertion for `arrayContainsAny` & `whereIn` query combined ([#11342](https://github.com/firebase/flutterfire/issues/11342)). ([199e1fc4](https://github.com/firebase/flutterfire/commit/199e1fc43654b913ddb8257c4e3a3ceddcbb97d1))

## 4.8.3

 - **FIX**(firestore): allow 30 conjunctive & disjunctive queries for "in" & "array-contains-any" via where() API ([#11265](https://github.com/firebase/flutterfire/issues/11265)). ([f5477b1a](https://github.com/firebase/flutterfire/commit/f5477b1ae83c37d727f12dd6ed5440cac0bc0bcd))
 - **FIX**: null check error when using `withConverter` and returning null from `fromFirestore` ([#11224](https://github.com/firebase/flutterfire/issues/11224)). ([4dd0f3f0](https://github.com/firebase/flutterfire/commit/4dd0f3f0409d58c263d3af523611d2eb0fd79619))
 - **FIX**(firestore): allow up to 30 Filter queries within `Filter.or()` & `Filter.and()` ([#11140](https://github.com/firebase/flutterfire/issues/11140)). ([e1f0064d](https://github.com/firebase/flutterfire/commit/e1f0064db7f24b360da131b991e39020f47ffd1c))

## 4.8.2

 - **FIX**(firestore,apple): issue where setting persistence caused a crash. `kFIRFirestoreCacheSizeUnlimited` no longer usable. ([#11174](https://github.com/firebase/flutterfire/issues/11174)). ([536cbf07](https://github.com/firebase/flutterfire/commit/536cbf07f6b07c0539e0f31552ae15dfa56c6352))

## 4.8.1

 - **FIX**(firestore): update deprecated persistence API ([#11069](https://github.com/firebase/flutterfire/issues/11069)). ([076e7af8](https://github.com/firebase/flutterfire/commit/076e7af86ddc74ac63ec85078ea9c4077afd2e31))

## 4.8.0

 - **FEAT**(firestore): add the ability to enable debug logging ([#11019](https://github.com/firebase/flutterfire/issues/11019)). ([ec4c4474](https://github.com/firebase/flutterfire/commit/ec4c44742d33c5032075310efc2c567bf0a5fa35))
 - **DOCS**(firestore): improve wording of what `set()` API does ([#11038](https://github.com/firebase/flutterfire/issues/11038)). ([883cbff9](https://github.com/firebase/flutterfire/commit/883cbff92f1245d7e96b7f845e3f363d8dbb0441))

## 4.7.1

 - **FIX**(firestore): fix emulator reload on Flutter 3.10 ([#10965](https://github.com/firebase/flutterfire/issues/10965)). ([f099eb0b](https://github.com/firebase/flutterfire/commit/f099eb0bd010af6ba0fae1fdb5ea5cd6a2cb680f))
 - **FIX**(firestore,ios): tentative fix for a crash that could occur during Snapshot serialization ([#10728](https://github.com/firebase/flutterfire/issues/10728)). ([2f4ba33a](https://github.com/firebase/flutterfire/commit/2f4ba33ad31d431a9042c7dc179b768cb43e0d17))

## 4.7.0

 - **FEAT**: update dependency constraints to `sdk: '>=2.18.0 <4.0.0'` `flutter: '>=3.3.0'` ([#10946](https://github.com/firebase/flutterfire/issues/10946)). ([2772d10f](https://github.com/firebase/flutterfire/commit/2772d10fe510dcc28ec2d37a26b266c935699fa6))
 - **FEAT**: update libraries to be compatible with Flutter 3.10.0 ([#10944](https://github.com/firebase/flutterfire/issues/10944)). ([e1f5a5ea](https://github.com/firebase/flutterfire/commit/e1f5a5ea798c54f19d1d2f7b8f2250f8819f44b7))

## 4.6.0

 - **FIX**: add support for AGP 8.0 ([#10901](https://github.com/firebase/flutterfire/issues/10901)). ([a3b96735](https://github.com/firebase/flutterfire/commit/a3b967354294c295a9be8d699a6adb7f4b1dba7f))
 - **FEAT**: upgrade to dart 3 compatible dependencies ([#10890](https://github.com/firebase/flutterfire/issues/10890)). ([4bd7e59b](https://github.com/firebase/flutterfire/commit/4bd7e59b1f2b09a2230c49830159342dd4592041))

## 4.5.3

 - **FIX**(firestore,ios): clean up event listeners on engine detach only ([#10579](https://github.com/firebase/flutterfire/issues/10579)). ([0ac13b6f](https://github.com/firebase/flutterfire/commit/0ac13b6fc06f6839686437dc2d5b6feab179aa83))

## 4.5.2

 - Update a dependency to the latest release.

## 4.5.1

 - **FIX**(firestore): ensure all index URLs are captured and passed to the user ([#10674](https://github.com/firebase/flutterfire/issues/10674)). ([9800435a](https://github.com/firebase/flutterfire/commit/9800435abc562fadc67a945e771591186576c34d))

## 4.5.0

 - **FEAT**(firestore): add the `Filter` class and support for the OR query ([#10678](https://github.com/firebase/flutterfire/issues/10678)). ([ac434044](https://github.com/firebase/flutterfire/commit/ac434044bbfa91d0d8b33ff39736d8eb4062e824))
 - **FEAT**: bump dart sdk constraint to 2.18 ([#10618](https://github.com/firebase/flutterfire/issues/10618)). ([f80948a2](https://github.com/firebase/flutterfire/commit/f80948a28b62eead358bdb900d5a0dfb97cebb33))

## 4.4.5

 - Update a dependency to the latest release.

## 4.4.4

 - Update a dependency to the latest release.

## 4.4.3

 - Update a dependency to the latest release.

## 4.4.2

 - Update a dependency to the latest release.

## 4.4.1

 - Update a dependency to the latest release.

## 4.4.0

 - **FIX**: supports Iterable in queries instead of List ([#10411](https://github.com/firebase/flutterfire/issues/10411)). ([9d91d513](https://github.com/firebase/flutterfire/commit/9d91d513fad326f9c928d7d96d03e2c031875903))
 - **FEAT**: add support to `update` using FieldPath ([#10388](https://github.com/firebase/flutterfire/issues/10388)). ([538090fc](https://github.com/firebase/flutterfire/commit/538090fc49078b8d6c484d8db9049f06d05157dd))

## 4.3.2

 - **REFACTOR**: upgrade project to remove warnings from Flutter 3.7 ([#10344](https://github.com/firebase/flutterfire/issues/10344)). ([e0087c84](https://github.com/firebase/flutterfire/commit/e0087c845c7526c11a4241a26d39d4673b0ad29d))
 - **FIX**: fix an issue when removing a value that didn't exist in ServerTimestampBehavior map ([#10391](https://github.com/firebase/flutterfire/issues/10391)). ([2929ac9d](https://github.com/firebase/flutterfire/commit/2929ac9da037bc231d156425166422da380d5a2e))
 - **FIX**: fix an issue when removing a value that didn't exist in ServerTimestampBehavior map ([#10370](https://github.com/firebase/flutterfire/issues/10370)). ([6da87036](https://github.com/firebase/flutterfire/commit/6da870363a947110ebf80696a7ed3887c4f2c557))
 - **FIX**: startAfterDocument could throw when used with a DocumentReference ([#10339](https://github.com/firebase/flutterfire/issues/10339)). ([8224acbe](https://github.com/firebase/flutterfire/commit/8224acbee991e508b949c4dac11910df4d6fe323))

## 4.3.1

 - **FIX**: fix crash that could occur when using transactions ([#10184](https://github.com/firebase/flutterfire/issues/10184)). ([d14b545a](https://github.com/firebase/flutterfire/commit/d14b545adb6052f1e5acd7a0e679d790a4741122))

## 4.3.0

 - **FIX**: propagate COLLECTION_GROUP_ASC index error message ([#10130](https://github.com/firebase/flutterfire/issues/10130)). ([6b321cbe](https://github.com/firebase/flutterfire/commit/6b321cbec3a22e5899e61342b5163efa511bdd9b))
 - **FEAT**: add ServerTimestampBehavior to the GetOptions class.  ([#9590](https://github.com/firebase/flutterfire/issues/9590)). ([c25bd2fe](https://github.com/firebase/flutterfire/commit/c25bd2fe4c13bc9f13d93410842c00e25aaac2b2))

## 4.2.0

 - **FEAT**: `setIndexConfigurationFromJSON()` API. Allow users to pass JSON string ([#10029](https://github.com/firebase/flutterfire/issues/10029)). ([be4b42b1](https://github.com/firebase/flutterfire/commit/be4b42b11b6ceddf83d4fbc77a95a41879ec3c8d))

## 4.1.0

 - **FEAT**: experimental `setIndexConfiguration()` API ([#9928](https://github.com/firebase/flutterfire/issues/9928)). ([bf6eda18](https://github.com/firebase/flutterfire/commit/bf6eda1893a4f29c4b501c4aa31026548ad2b286))

## 4.0.5

 - Update a dependency to the latest release.

## 4.0.4

 - **FIX**: fix aggregated count to use the current query and not only the collection on Web ([#9824](https://github.com/firebase/flutterfire/issues/9824)). ([ada39355](https://github.com/firebase/flutterfire/commit/ada39355722e316217934ad8cf1dfa789e47f058))

## 4.0.3

 - **REFACTOR**: add `verify` to `QueryPlatform` and change internal `verifyToken` API to `verify` ([#9711](https://github.com/firebase/flutterfire/issues/9711)). ([c99a842f](https://github.com/firebase/flutterfire/commit/c99a842f3e3f5f10246e73f51530cc58c42b49a3))

## 4.0.2

 - Update a dependency to the latest release.

## 4.0.1

 - Update a dependency to the latest release.

## 4.0.0

> Note: This release has breaking changes.

 - **FEAT**: `count()` feature for counting documents without retrieving documents. ([#9699](https://github.com/firebase/flutterfire/issues/9699)). ([ac0bf733](https://github.com/firebase/flutterfire/commit/ac0bf7330d7de73d0ea36c740b79a426187291d2))
 - **FEAT**: Add namedQueryWithConverterGet ([#9715](https://github.com/firebase/flutterfire/issues/9715)). ([6d025fd4](https://github.com/firebase/flutterfire/commit/6d025fd4c89830d5975f4ed981aa0aa0777c13d8))
 - **BREAKING** **FEAT**: Firebase iOS SDK version: `10.0.0` ([#9708](https://github.com/firebase/flutterfire/issues/9708)). ([9627c56a](https://github.com/firebase/flutterfire/commit/9627c56a37d657d0250b6f6b87d0fec1c31d4ba3))

## 3.5.1

 - **FIX**: fix a query error in Flutter Web that was affecting the parsing of ancient dates ([#9633](https://github.com/firebase/flutterfire/issues/9633)). ([9250d45f](https://github.com/firebase/flutterfire/commit/9250d45f1d7ece9335b2c4c4795fecc728df3de5))

## 3.5.0

 - **FEAT**: add OAuth Access Token support to sign in with providers ([#9593](https://github.com/firebase/flutterfire/issues/9593)). ([cb6661bb](https://github.com/firebase/flutterfire/commit/cb6661bbc701031d6f920ace3a6efc8e8d56aa4c))
 - **FEAT**: Bump Firebase iOS SDK to `9.6.0` ([#9531](https://github.com/firebase/flutterfire/issues/9531)). ([2138f4aa](https://github.com/firebase/flutterfire/commit/2138f4aaaace51d5dce4809fb42e1e4ff20ed251))

## 3.4.9

 - Update a dependency to the latest release.

## 3.4.8

 - **FIX**: fix `queryGet()` & `namedQueryGet()`. Check if `query` is `[NSNull null]` value ([#9410](https://github.com/firebase/flutterfire/issues/9410)). ([ae035fe2](https://github.com/firebase/flutterfire/commit/ae035fe2b060264153386ae5c2a1eb90c22e90f3))

## 3.4.7

 - Update a dependency to the latest release.

## 3.4.6

 - Update a dependency to the latest release.

## 3.4.5

 - Update a dependency to the latest release.

## 3.4.4

 - **FIX**: stop `FirebaseError` appearing in console on hot restart & hot refresh ([#9321](https://github.com/firebase/flutterfire/issues/9321)). ([4ba0ff9d](https://github.com/firebase/flutterfire/commit/4ba0ff9d9c7d13f7e040d80375d6db3edb8d37d5))

## 3.4.3

 - Update a dependency to the latest release.

## 3.4.2

 - Update a dependency to the latest release.

## 3.4.1

 - Update a dependency to the latest release.

## 3.4.0

 - **FEAT**: add max attempts for Firestore transactions ([#9163](https://github.com/firebase/flutterfire/issues/9163)). ([9da7cc36](https://github.com/firebase/flutterfire/commit/9da7cc36cb266e4f5a0de26dfe727e0a4687f1a0))
 - **FEAT**: update to 9.3.0 ([#9137](https://github.com/firebase/flutterfire/issues/9137)). ([97f6417b](https://github.com/firebase/flutterfire/commit/97f6417bf66f88e6621afa177c73245b9a7d5c73))

## 3.3.0

 - **FEAT**: upgrade to support v9.8.1 Firebase JS SDK ([#8235](https://github.com/firebase/flutterfire/issues/8235)). ([4b417af5](https://github.com/firebase/flutterfire/commit/4b417af574bb8a32ca8e4b3ab2ff253a22be9903))

## 3.2.1

 - **FIX**: bump `firebase_core_platform_interface` version to fix previous release. ([bea70ea5](https://github.com/firebase/flutterfire/commit/bea70ea5cbbb62cbfd2a7a74ae3a07cb12b3ee5a))

## 3.2.0

 - **FEAT**: Bump Firebase iOS SDK to `9.2.0` (#8594). ([79610162](https://github.com/firebase/flutterfire/commit/79610162460b8877f3bc727464a7065106f08079))

## 3.1.18

 - **REFACTOR**: use `firebase.google.com` link for `homepage` in `pubspec.yaml` (#8724). ([fd3f3102](https://github.com/firebase/flutterfire/commit/fd3f3102a0614e0e155756239a57b54fab324c2c))
 - **REFACTOR**: migrate from hash* to Object.hash* (#8797). ([3dfc0997](https://github.com/firebase/flutterfire/commit/3dfc0997050ee4351207c355b2c22b46885f971f))
 - **REFACTOR**: use "firebase" instead of "FirebaseExtended" as organisation in all links for this repository (#8791). ([d90b8357](https://github.com/firebase/flutterfire/commit/d90b8357db01d65e753021358668f0b129713e6b))

## 3.1.17

 - Update a dependency to the latest release.

## 3.1.16

 - **REFACTOR**: remove deprecated `Tasks.call` for android and replace with `TaskCompletionSource`. (#8522). ([45e27201](https://github.com/firebase/flutterfire/commit/45e27201480088fab71af60963001baeae61d80d))

## 3.1.15

 - Update a dependency to the latest release.

## 3.1.14

 - Update a dependency to the latest release.

## 3.1.13

 - Update a dependency to the latest release.

## 3.1.12

 - Update a dependency to the latest release.

## 3.1.11

 - **REFACTOR**: recreate ios, android, web and macOS folders for example app (#8255). ([cdae0613](https://github.com/firebase/flutterfire/commit/cdae0613a359da41013721f601c20169807d214f))
 - **DOCS**: Fix method name typo in code documentation (#8291). ([7b4e06db](https://github.com/firebase/flutterfire/commit/7b4e06db305ff9f785a1bfcf1888fec1a53970c4))

## 3.1.10

 - **FIX**: update all Dart SDK version constraints to Dart >= 2.16.0 (#8184). ([df4a5bab](https://github.com/firebase/flutterfire/commit/df4a5bab3c029399b4f257a5dd658d302efe3908))

## 3.1.9

 - Update a dependency to the latest release.

## 3.1.8

 - Update a dependency to the latest release.

## 3.1.7

 - **FIX**: Fix Android Firestore transaction crash when running in background caused by `null` `Activity`. (#7627). ([8d60d474](https://github.com/firebase/flutterfire/commit/8d60d474438fccc5d6dcb41b840221ae385a853c))

## 3.1.6

 - Update a dependency to the latest release.

## 3.1.5

 - **REFACTOR**: fix all `unnecessary_import` analyzer issues introduced with Flutter 2.8. ([7f0e82c9](https://github.com/firebase/flutterfire/commit/7f0e82c978a3f5a707dd95c7e9136a3e106ff75e))

## 3.1.4

 - Update a dependency to the latest release.

## 3.1.3

 - **DOCS**: update firestore dartpad example.

## 3.1.2

 - Update a dependency to the latest release.

## 3.1.1

 - **REFACTOR**: migrate remaining examples & e2e tests to null-safety (#7393).
 - **FIX**: suppress Java unchecked cast lint warning in Android plugin (#7431).

## 3.1.0

 - **FEAT**: support initializing default `FirebaseApp` instances from Dart (#6549).

## 3.0.0

> Note: This release has breaking changes.

 - **BREAKING** **FEAT**: update Android `minSdk` version to 19 as this is required by Firebase Android SDK `29.0.0` (#7298).

## 2.5.4

 - **REFACTOR**: remove deprecated Flutter Android v1 Embedding usages, including in example app (#7147).
 - **STYLE**: macOS & iOS; explicitly include header that defines `TARGET_OS_OSX` (#7116).

## 2.5.3

 - **FIX**: value encoding fails when using `DocumentReference` & `withConverter` (#7020).
 - **FIX**: propagate query index link  to firebase console for user (#7087).
 - **FIX**: fixed a bug where `withConverter.endBeforeDocument` incorrectly behaved as `endAtDocument`.
 - **FIX**: an issue where `Query.==` throws when using `withConverter` (#6997).
 - **CHORE**: update gradle version across packages (#7054).

## 2.5.2

 - **REVERT**: Firestore cache snapshot connections with underlying native listener (#6819) (#6974).
 - **CHORE**: Reduce hash conflicts on objects (#6928).

## 2.5.1

 - Update a dependency to the latest release.

## 2.5.0

 - **STYLE**: enable additional lint rules (#6832).
 - **FIX**: transactionHandler was losing ref to self in blocks (#6791).
 - **FIX**: allow querying on 'is not null' properties (#6788).
 - **FIX**: improve query filter assertions (#6627).
 - **FEAT**: cache snapshot connections with underlying native listener (#6819).
 - **FEAT**: override ==/hashCode for Firestore Queries (#6797).
 - **DOCS**: Transaction timeout correction (#6761).

## 2.4.0

 - **FIX**: export PersistenceSettings (#6603).
 - **FIX**: Fixed variable name (#6564).
 - **FIX**: withConverter examples in docs (#6438).
 - **FIX**: DocumentReference @sealed annotation (#6436).
 - **FEAT**: useFirestoreEmulator(host, port) API for firestore (#6428).
 - **CHORE**: update v2 embedding support (#6506).
 - **CHORE**: rm deprecated jcenter repository (#6431).

## 2.3.0

 - **FIX**: withConverter examples in docs (#6438).
 - **FIX**: DocumentReference @sealed annotation (#6436).
 - **FEAT**: useFirestoreEmulator(host, port) API for firestore (#6428).
 - **CHORE**: rm deprecated jcenter repository (#6431).

## 2.2.2

 - Update a dependency to the latest release.

## 2.2.1

 - **TEST**: error handling for loadBundle() & namedQueryGet() (#6197).
 - **TEST**: improve query assertions (#6249).
 - **TEST**: update and assert documentId field & isNotEqualTo filter test (#6225).
 - **DOCS**: Add Flutter Favorite badge (#6190).

## 2.2.0

 - **FEAT**: support for `loadBundle()` & `namedQueryGet()` (#6037).
 - **FEAT**: upgrade Firebase JS SDK version to 8.6.1.
 - **FIX**: podspec osx version checking script should use a version range instead of a single fixed version.
 - **FIX**: pass GetOptions to web Query.get (#6132).

## 2.1.0

 - **FIX**: Fix FirebaseOptions hashCode (#3263).
 - **FEAT**: Add withConverter for Query (#6065).
 - **DOCS**: add QueryDocumentSnapshot to the list of classes that received a breaking change (#6092).
 - **CHORE**: publish packages (#6022).
 - **CHORE**: publish packages.

## 2.0.0

> Note: This release has breaking changes.

 - **FEAT**: Add withConverter function to CollectionReference, DocumentReference and Query (#6015).
    This new method allows interacting with collections/documents in a type-safe way:

    ```dart
    final modelsRef = FirebaseFirestore
        .instance
        .collection('models')
        .withConverter<Model>(
          fromFirestore: (snapshot, _) => Model.fromJson(snapshot.data()!),
          toFirestore: (model, _) => model.toJson(),
        );

    Future<void> main() async {
      // Writes now take a Model as parameter instead of a Map
      await modelsRef.add(Model());
      final Model model = await modelsRef.doc('123').get().then((s) => s.data());
    }
    ```

 - **BREAKING** **REFACTOR**: `DocumentReference`, `CollectionReference`, `Query`, `DocumentSnapshot`,
   `CollectionSnapshot`, `QuerySnapshot`, `QueryDocumentSnapshot`, `Transaction.get`, `Transaction.set`
   and `WriteBatch.set` now take an extra generic parameter.  (#6015).

   See the [migration guide](https://firebase.flutter.dev/docs/firestore/2.0.0_migration) for more
   information on how to update your code.

 - **BREAKING** **FEAT**: convert FieldPath parameters from dynamic to Object (#5997).

## 1.0.7

 - **FIX**: Clear event listeners when firebase core is reinitialised (#5852).

## 1.0.6

 - Update a dependency to the latest release.

## 1.0.5

 - Update a dependency to the latest release.

## 1.0.4

 - **FIX**: made QueryDocumentSnapshot.data() non-nullable (#5476).
 - **CHORE**: add repository urls to pubspecs (#5542).

## 1.0.3

 - **FIX**: cannot store null values in firestore on the web (#5335).
 - **DOCS**: remove incorrect ARCHS in ios examples (#5450).
 - **CHORE**: bump min Dart SDK constraint to 2.12.0 (#5430).
 - **CHORE**: publish packages (#5429).

## 1.0.2

 - **FIX**: cannot store null values in firestore on the web (#5335).

## 1.0.1

 - Update a dependency to the latest release.

## 1.0.0

 - Graduate package to a stable release. See pre-releases prior to this version for changelog entries.

## 1.0.0-1.0.nullsafety.0

 - Bump "cloud_firestore" to `1.0.0-1.0.nullsafety.0`.

## 0.17.0-1.0.nullsafety.2

 - **FIX**: Fix type issue. (#5081).
 - **FIX**: Fixed crashes due to null `Settings` (#5031).

## 0.17.0-1.0.nullsafety.1

 - Update a dependency to the latest release.

## 0.17.0-1.0.nullsafety.0

> Note: This release has breaking changes.

 - **BREAKING** **REFACTOR**: migrate to NNBD (#4780).

## 0.16.0

> Note: This release has breaking changes.

 - **FIX**: add missing symlinks (fixes #4628).
 - **FEAT**: add check on podspec to assist upgrading users deployment target.
 - **CHORE**: add missing file license headers.
 - **BUILD**: commit Podfiles with 10.12 deployment target.
 - **BUILD**: remove default sdk version, version should always come from firebase_core, or be user defined.
 - **BUILD**: set macOS deployment target to 10.12 (from 10.11).
 - **BREAKING** **BUILD**: set osx min supported platform version to 10.12.

## 0.15.0

> Note: This release has breaking changes.

 - **FIX**: Add missing sdk version constraints inside example pubspec.yaml (#4604).
 - **FIX**: ensure web FieldValue types are converted (#4247).
 - **FEAT**: Move Snapshot handling into a EventChannel (#4209).
 - **BREAKING** **REFACTOR**: remove all currently deprecated APIs.
 - **BREAKING** **FEAT**: forward port to firebase-ios-sdk v7.3.0.
   - Due to this SDK upgrade, iOS 10 is now the minimum supported version by FlutterFire. Please update your build target version.
 - **CHORE**: harmonize dependencies and version handling.

## 0.14.4

 - **FEAT**: bump android `com.android.tools.build` & `'com.google.gms:google-services` versions (#4269).
 - **CHORE**: Migrate iOS example projects (#4222).

## 0.14.3+1

 - Update a dependency to the latest release.

## 0.14.3

 - **FEAT**: migrate firebase interop files to local repository (#3973).
 - **FEAT**: add not-in & != query support (#3748).
 - **FEAT**: bump `compileSdkVersion` to 29 in preparation for upcoming Play Store requirement.
 - **FEAT** [WEB] `FirebaseFirestore.enablePersistence` now accepts `PersistenceSettings`
 - **FEAT** [WEB] adds `PersistenceSettings` class
 - **FEAT** [WEB] adds support for `FirebaseFirestore.clearPersistence`
 - **FEAT** [WEB] adds support for `FirebaseFirestore.terminate`
 - **FEAT** [WEB] adds support for `FirebaseFirestore.waitForPendingWrites`
 - **FEAT** [WEB] adds support for `SetOptions.mergeFields`
 - **FEAT** [WEB] adds `GetOptions` support for querying against server/cache
 - **FEAT** [WEB] adds support for `Query.limitToLast`
 - **FEAT** [WEB] adds support for `FirebaseFirestore.snapshotsInSync`

## 0.14.2

 - **FEAT**: bump compileSdkVersion to 29 (#3975).
 - **FEAT**: update Firebase iOS SDK version to 6.33.0 (from 6.26.0).
 - **CHORE**: update Firestore example app podfile.

## 0.14.1+3

 - **FIX**: remove unused dart:async import (#3611).
 - **FIX**: fix returning of transaction result (#3747).

## 0.14.1+2

 - Update a dependency to the latest release.

## 0.14.1+1

 - **FIX**: remove listener if available (#3452).
 - **DOCS**: remove `updateBlock` reference in Firestore docs (#3728).

## 0.14.1

 - **FIX**: local dependencies in example apps (#3319).
 - **FIX**: pub.dev score fixes (#3318).
 - **FIX**: add missing deprecated static methods (#3278).
 - **FEAT**: add a [] operator to DocumentSnapshot, acting as get() (#3387).
 - **DOCS**: Fixed docs typo (#3471).

## 0.14.0+2

* Added missing deprecated `Firestore` static methods.

## 0.14.0+1

* Fixed issue #3210 (`Query.orderBy(FieldPath.documentId)` throws exception).
* Fixed issue #3237 (`DocumentReference` not being parsed correctly).
* Bump `cloud_firestore_web` dependency.
* Bump `cloud_firestore_platform_interface` dependency to fix 2 race conditions. [(#3251)](https://github.com/firebase/flutterfire/pull/3251)

## 0.14.0

Along with the below changes, the plugin has undergone a quality of life update to better support exceptions thrown. Any Firestore specific errors now return a `FirebaseException`, allowing you to directly access the code (e.g. `permission-denied`) and message.

**`Firestore`**:
- **BREAKING**: `settings()` is now a synchronous setter that accepts a `Settings` instance.
  - **NEW**: This change allows us to support changing Firestore settings (such as using the Firestore emulator) without having to quit the application, e.g. Hot Restarts.
- **BREAKING**: `enablePersistence()` is now a Web only method, use `[Settings.persistenceEnabled]` instead for other platforms.
- **DEPRECATED**: Calling `document()` is deprecated in favor of `doc()`.
- **DEPRECATED**: Class `Firestore` is now deprecated. Use `FirebaseFirestore` instead.
- **DEPRECATED**: Calling `Firestore(app: app)` is now deprecated. Use `FirebaseFirestore.instance` or `FirebaseFirestore.instanceFor(app: app)` instead.
- **NEW**: Added `clearPersistence()` support.
- **NEW**: Added `disableNetwork()` support.
- **NEW**: Added `enableNetwork()` support.
- **NEW**: Added `snapshotInSync()` listener support.
- **NEW**: Added `terminate()` support.
- **NEW**: Added `waitForPendingWrites()` support.
- **FIX**: All document/query listeners & currently in progress transactions are now correctly torn down between Hot Restarts.

**`CollectionReference`**:
- **BREAKING**: Getting a collection parent document via `parent()` has been changed to a getter `parent`.
- **BREAKING**: Getting the collection `path` now always returns the `path` without leading and trailing slashes.
- **DEPRECATED**: Calling `document()` is deprecated in favor of `doc()`.
- **FIX**: Equality checking of `CollectionReference` now does not depend on the original path used to create the `CollectionReference`.

**`Query`**:
- **BREAKING**: The internal query logic has been overhauled to better assert invalid queries locally.
- **DEPRECATED**: Calling `getDocuments()` is deprecated in favor of `get()`.
- **BREAKING**: `getDocuments`/`get` has been updated to accept an instance of `GetOptions` (see below).
- **NEW**: Query methods can now be chained.
- **NEW**: It is now possible to call same-point cursor based queries without throwing (e.g. calling `endAt()` and then `endBefore()` will replace the "end" cursor query with the `endBefore`).
- **NEW**: Added support for the `limitToLast` query modifier.

**`QuerySnapshot`**:
- **DEPRECATED**: `documents` has been deprecated in favor of `docs`.
- **DEPRECATED**: `documentChanges` has been deprecated in favor of `docChanges`.
- **NEW**: `docs` now returns a `List<QueryDocumentSnapshot>` vs `List<DocumentSnapshot>`. This doesn't break existing functionality.

**`DocumentReference`**:
- **BREAKING**: `setData`/`set` has been updated to accept an instance of `SetOptions` (see below, supports `mergeFields`).
- **BREAKING**: `get()` has been updated to accept an instance of `GetOptions` (see below).
- **BREAKING**: Getting a document parent collection via `parent()` has been changed to a getter `parent`.
- **BREAKING**: Getting the document `path` now always returns the `path` without leading and trailing slashes.
- **DEPRECATED**: `documentID` has been deprecated in favor of `id`.
- **DEPRECATED**: `setData()` has been deprecated in favor of `set()`.
- **DEPRECATED**: `updateData()` has been deprecated in favor of `update()`.
- **FIX**: Equality checking of `DocumentReference` now does not depend on the original path used to create the `DocumentReference`.

**`DocumentChange`**:
- **DEPRECATED**: Calling `document()` is deprecated in favor of `doc()`.

**`DocumentSnapshot`**:
- **BREAKING**: The `get data` getter is now a `data()` method instead.
- **DEPRECATED**: `documentID` has been deprecated in favor of `id`.
- **NEW**: Added support for fetching nested snapshot data via the `get()` method. If no data exists at the given path, a `StateError` will be thrown.
- **FIX**: `NaN` values stored in your Firestore instance are now correctly parsed when reading & writing data.
- **FIX**: `INFINITY` values stored in your Firestore instance are now correctly parsed when reading & writing data.
- **FIX**: `-INFINITY` values stored in your Firestore instance are now correctly parsed when reading & writing data.

**`WriteBatch`**:
- **DEPRECATED**: `setData()` has been deprecated in favor of `set()`.
- **DEPRECATED**: `updateData()` has been deprecated in favor of `update()`.
- **BREAKING**: `setData`/`set` now supports `SetOptions` to merge data/fields (previously this accepted a `Map`).

**`Transaction`**:
- **BREAKING**: Transactions have been overhauled to address a number of critical issues:
  - Values returned from the transaction will now be returned from the Future. Previously, only JSON serializable values were supported. It is now possible to return any value from your transaction handler, e.g. a `DocumentSnapshot`.
  - When manually throwing an exception, the context was lost and a generic `PlatformException` was thrown. You can now throw & catch on any exceptions.
  - The modify methods on a transaction (`set`, `delete`, `update`) were previously Futures. These have been updated to better reflect how transactions should behave - they are now synchronous and are executed atomically once the transaction handler block has finished executing.
- **FIX**: Timeouts will now function correctly.
- **FIX**: iOS: transaction completion block incorrectly resolving a `FlutterResult` multiple times.

See the new [transactions documentation](https://firebase.flutter.dev/docs/firestore/usage#transactions) to learn more.

**`FieldPath`**:
- **NEW**: The constructor has now been made public to accept a `List` of `String` values. Previously field paths were accessible only via a dot-notated string path. This meant attempting to access a field in a document with a `.` in the name (e.g. `foo.bar@gmail.com`) was impossible.

**`GetOptions`**: New class created to support how data is fetched from Firestore (`server`, `cache`, `serverAndCache`).

**`SetOptions`**: New class created to both `merge` and `mergeFields` when setting data on documents.

**`GeoPoint`**:
- **BREAKING**: Add latitude and longitude validation when constructing a new `GeoPoint` instance.

## 0.13.7+1

* Fix crash where listeners are not removed when app quits.

## 0.13.7

* Clean up snapshot listeners when Android Activity is destroyed.

## 0.13.6

* Update lower bound of dart dependency to 2.0.0.

## 0.13.5

* Migrate cloud_firestore to android v2 embedding.

## 0.13.4+2

* Fix for missing UserAgent.h compilation failures.

## 0.13.4+1

* Fix crash with pagination with `DocumentReference` (#2044)
* Minor tweaks to integ tests.

## 0.13.4

* Support equality comparison on `FieldValue` instances.
* Updated version of endorsed web implementation.

## 0.13.3+1

* Make the pedantic dev_dependency explicit.

## 0.13.3

* Add macOS support

## 0.13.2+3

* Fixed decoding & encoding platform interface instances in nested maps

## 0.13.2+2

* Fixed crashes when using `FieldValue.arrayUnion` & `FieldValue.arrayRemove` with `DocumentReference` objects

## 0.13.2+1

* Add Web integration documentation to README.

## 0.13.2

* Add web support by default.
* Require Flutter SDK 1.12.13+hotfix.4 or later
* Add web support to the example app.

## 0.13.1+1

* Fixed crashes when using `Query#where` with `DocumentReference` objects

## 0.13.1

* Migrate to `cloud_firestore_platform_interface`.

## 0.13.0+2

* Fixed `persistenceEnabled`, `sslEnabled`, and `timestampsInSnapshotsEnabled` on iOS.

## 0.13.0+1

* Remove the deprecated `author:` field from pubspec.yaml
* Migrate the plugin to the pubspec platforms manifest.
* Bump the minimum Flutter version to 1.10.0.

## 0.13.0

* **Breaking change** Remove use of [deprecated](https://firebase.google.com/docs/reference/android/com/google/firebase/firestore/FirebaseFirestoreSettings.Builder.html#setTimestampsInSnapshotsEnabled(boolean))
  setting `setTimestampsInSnapshotsEnabled`. If you are already setting it to true, just remove the setting. If you are
  setting it to false, you should update your code to expect Timestamps.

## 0.12.11

* Added support for `in` and `array-contains-any` query operators.

## 0.12.10+5

* Moved `.gitignore` which was left behind in previous change.

## 0.12.10+4

* Moved package to `cloud_firestore/cloud_firestore` subdir, to allow for federated implementations.

## 0.12.10+3

* Fixed test that used `FirebaseApp.channel`.

## 0.12.10+2

* Fixed analyzer warnings about unused fields.

## 0.12.10+1

* Formatted method documentations.

## 0.12.10

* Added `FieldPath` class and `FieldPath.documentId` to refer to the document id in queries.
* Added assertions and exceptions that help you building correct queries.

## 0.12.9+8

* Updated README instructions for contributing for consistency with other Flutterfire plugins.

## 0.12.9+7

* Remove AndroidX warning.

## 0.12.9+6

* Cast error.code to long to avoid using NSInteger as %ld format warnings.

## 0.12.9+5

* Fixes a crash on Android when running a transaction without an internet connection.

## 0.12.9+4

* Fix integer conversion warnings on iOS.

## 0.12.9+3

* Updated error handling on Android for transactions to prevent crashes.

## 0.12.9+2

* Fix flaky integration test for `includeMetadataChanges`.

## 0.12.9+1

* Update documentation to reflect new repository location.
* Update unit tests to call `TestWidgetsFlutterBinding.ensureInitialized`.
* Remove executable bit on LICENSE file.

## 0.12.9

* New optional `includeMetadataChanges` parameter added to `DocumentReference.snapshots()`
 and `Query.snapshots()`
* Fix example app crash when the `message` field was not a string
* Internal renaming of method names.

## 0.12.8+1

* Add `metadata` to `QuerySnapshot`.

## 0.12.8

* Updated how document ids are generated to more closely match native implementations.

## 0.12.7+1

* Update google-services Android gradle plugin to 4.3.0 in documentation and examples.

## 0.12.7

* Methods of `Transaction` no longer require `await`.
* Added documentation to methods of `Transaction`.
* Removed an unnecessary log on Android.
* Added an integration test for rapidly incrementing field value.

## 0.12.6

* Support for `orderBy` on map fields (e.g. `orderBy('cake.flavor')`) for
  `startAtDocument`, `startAfterDocument`, `endAtDocument`, and `endBeforeDocument` added.

## 0.12.5+2

* Automatically use version from pubspec.yaml when reporting usage to Firebase.

## 0.12.5+1
* Added support for combining any of `Query.startAtDocument` and `Query.startAfterDocument`
  with any of `Query.endAtDocument` and `Query.endBeforeDocument`.

## 0.12.5

* Makes `startAtDocument`, `startAfterDocument`, `endAtDocument` and `endBeforeDocument` work
  with `Query.collectionGroup` queries.
* Fixes `startAtDocument`, `startAfterDocument`, `endAtDocument` and `endBeforeDocument` to
  also work with a descending order as the last explicit sort order.
* Fixed an integration test by increasing the value of `cacheSizeBytes` to a valid value.

## 0.12.4

* Added support for `Query.collectionGroup`.

## 0.12.3

* Added support for `cacheSizeBytes` to `Firestore.settings`.

## 0.12.2

* Ensure that all channel calls to the Dart side from the Java side are done
  on the UI thread. This change allows Transactions to work with upcoming
  Engine restrictions, which require channel calls be made on the UI thread.
  **Note** this is an Android only change, the iOS implementation was not impacted.
* Updated the Firebase reporting string to `flutter-fire-fst` to be consistent
  with other reporting libraries.

## 0.12.1

* Added support for `Source` to `Query.getDocuments()` and `DocumentReference.get()`.

## 0.12.0+2

* Bump the minimum Flutter version to 1.5.
* Replace invokeMethod with invokeMapMethod wherever necessary.

## 0.12.0+1

* Send user agent to Firebase.

## 0.12.0

* **Breaking change**. Fixed `CollectionReference.parent` to correctly return a `DocumentReference`.
  If you were using the method previously to obtain the parent
  document's id via `collectionReference.parent().id`,
  you will have to use `collectionReference.parent().documentID` now.
* Added `DocumentReference.parent`.

## 0.11.0+2

* Remove iOS dependency on Firebase/Database and Firebase/Auth CocoaPods.

## 0.11.0+1

* Update iOS CocoaPod dependencies to '~> 6.0' to ensure support for `FieldValue.increment`.

## 0.11.0

* Update Android dependencies to latest.

## 0.10.1

* Support for `startAtDocument`, `startAfterDocument`, `endAtDocument`, `endBeforeDocument`.
* Added additional unit and integration tests.

## 0.10.0

* Support for `FieldValue.increment`.
* Remove `FieldValue.type` and `FieldValue.value` from public API.
* Additional integration testing.

## 0.9.13+1

* Added an integration test for transactions.

## 0.9.13

* Remove Gradle BoM to avoid Gradle version issues.

## 0.9.12

* Move Android dependency to Gradle BoM to help maintain compatibility
  with other FlutterFire plugins.

## 0.9.11

* Bump Android dependencies to latest.

# 0.9.10

* Support for cloud_firestore running in the background on Android.
* Fixed a bug in cleanup for DocumentReference.snapshots().
* Additional integration testing.

## 0.9.9

* Remove `invokeMapMethod` calls to prevent crash.

## 0.9.8

* Add metadata field to DocumentSnapshot.

## 0.9.7+2

* Bump the minimum Flutter version to 1.2.0.
* Add template type parameter to `invokeMethod` calls.

## 0.9.7+1

* Update README with example of getting a document.

## 0.9.7

* Fixes a NoSuchMethodError when using getDocuments on iOS (introduced in 0.9.6).
* Adds a driver test for getDocuments.

## 0.9.6

* On iOS, update null checking to match the recommended pattern usage in the Firebase documentation.
* Fixes a case where snapshot errors might result in plugin crash.

## 0.9.5+2

* Fixing PlatformException(Error 0, null, null) which happened when a successful operation was performed.

## 0.9.5+1

* Log messages about automatic configuration of the default app are now less confusing.

## 0.9.5

* Fix an issue on some iOS devices that results in reading incorrect dates.

## 0.9.4

* No longer sends empty snapshot events on iOS when encountering errors.

## 0.9.3

* Fix transactions on iOS when getting snapshot that doesn't exist.

## 0.9.2

* Fix IllegalStateException errors when using transactions on Android.

## 0.9.1

* Fixed Firebase multiple app support in transactions and document snapshots.

## 0.9.0+2

* Remove categories.

## 0.9.0+1

* Log a more detailed warning at build time about the previous AndroidX
  migration.

## 0.9.0

* **Breaking change**. Migrate from the deprecated original Android Support
  Library to AndroidX. This shouldn't result in any functional changes, but it
  requires any Android apps using this plugin to [also
  migrate](https://developer.android.com/jetpack/androidx/migrate) if they're
  using the original support library.

## 0.8.2+3

* Resolved "explicit self reference" and "loses accuracy" compiler warnings.

## 0.8.2+2

* Clean up Android build logs. @SuppressWarnings("unchecked")

## 0.8.2+1

* Avoid crash in document snapshot callback.

## 0.8.2

* Added `Firestore.settings`
* Added `Timestamp` class

## 0.8.1+1

* Bump Android dependencies to latest.

## 0.8.1

* Fixed bug where updating arrays in with `FieldValue` always throws an Exception on Android.

## 0.8.0

Note: this version depends on features available in iOS SDK versions 5.5.0 or later.
To update iOS SDK in existing projects run `pod update Firebase/Firestore`.

* Added `Firestore.enablePersistence`
* Added `FieldValue` with all currently supported values: `arrayUnion`, `arrayRemove`, `delete` and
  `serverTimestamp`.
* Added `arrayContains` argument in `Query.where` method.

## 0.7.4

* Bump Android and Firebase dependency versions.

## 0.7.3

* Updated Gradle tooling to match Android Studio 3.1.2.

## 0.7.2

* Fixes crash on Android if a FirebaseFirestoreException happened.

## 0.7.1

* Updated iOS implementation to reflect Firebase API changes.
* Fixed bug in Transaction.get that would fail on no data.
* Fixed error in README.md code sample.

## 0.7.0+2

* Update transactions example in README to add `await`.

## 0.7.0+1

* Add transactions example to README.

## 0.7.0

* **Breaking change**. `snapshots` is now a method instead of a getter.
* **Breaking change**. `setData` uses named arguments instead of `SetOptions`.

## 0.6.3

* Updated Google Play Services dependencies to version 15.0.0.

## 0.6.2

* Support for BLOB data type.

## 0.6.1

* Simplified podspec for Cocoapods 1.5.0, avoiding link issues in app archives.

## 0.6.0

* **Breaking change**. Renamed 'getCollection()' to 'collection().'

## 0.5.1

* Expose the Firebase app corresponding to a Firestore
* Expose a constructor for a Firestore with a non-default Firebase app

## 0.5.0

* **Breaking change**. Move path getter to CollectionReference
* Add id getter to CollectionReference

## 0.4.0

* **Breaking change**. Hide Firestore codec class from public API.
* Adjusted Flutter SDK constraint to match Flutter release with extensible
  platform message codec, required already by version 0.3.1.
* Move each class into separate files

## 0.3.2

* Support for batched writes.

## 0.3.1

* Add GeoPoint class
* Allow for reading and writing DocumentReference, DateTime, and GeoPoint
  values from and to Documents.

## 0.3.0

* **Breaking change**. Set SDK constraints to match the Flutter beta release.

## 0.2.12

* Fix handling of `null` document snapshots (document not exists).
* Add `DocumentSnapshot.exists`.

## 0.2.11
* Fix Dart 2 type errors.

## 0.2.10
* Fix Dart 2 type errors.

## 0.2.9
* Relax sdk upper bound constraint to  '<2.0.0' to allow 'edge' dart sdk use.

## 0.2.8
* Support for Query.getDocuments

## 0.2.7

* Add transaction support.

## 0.2.6

* Build fixes for iOS
* Null checking in newly added Query methods

## 0.2.5

* Query can now have more than one orderBy field.
* startAt, startAfter, endAt, and endBefore support
* limit support

## 0.2.4

* Support for DocumentReference.documentID
* Support for CollectionReference.add

## 0.2.3

* Simplified and upgraded Android project template to Android SDK 27.
* Updated package description.

## 0.2.2

* Add `get` to DocumentReference.

## 0.2.1

* Fix bug on Android where removeListener is sometimes called without a handle

## 0.2.0

* **Breaking change**. Upgraded to Gradle 4.1 and Android Studio Gradle plugin
  3.0.1. Older Flutter projects need to upgrade their Gradle setup as well in
  order to use this version of the plugin. Instructions can be found
  [here](https://github.com/flutter/flutter/wiki/Updating-Flutter-projects-to-Gradle-4.1-and-Android-Studio-Gradle-plugin-3.0.1).
* Relaxed GMS dependency to [11.4.0,12.0[

## 0.1.2

* Support for `DocumentReference` update and merge writes
* Suppress unchecked warnings and package name warnings on Android

## 0.1.1

* Added FLT prefix to iOS types.

## 0.1.0

* Added reference to DocumentSnapshot
* Breaking: removed path from DocumentSnapshot
* Additional test coverage for reading collections and documents
* Fixed typo in DocumentChange documentation

## 0.0.6

* Support for getCollection

## 0.0.5

* Support `isNull` filtering in `Query.where`
* Fixed `DocumentChange.oldIndex` and `DocumentChange.newIndex` to be signed
  integers (iOS)

## 0.0.4

* Support for where clauses
* Support for deletion

## 0.0.3

* Renamed package to cloud_firestore

## 0.0.2

* Add path property to DocumentSnapshot

## 0.0.1+1

* Update project homepage

## 0.0.1

* Initial Release

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/README.md

**크기**: 1403 bytes | **라인 수**: 28 | **타입**: text

```
[<img src="https://raw.githubusercontent.com/firebase/flutterfire/main/.github/images/flutter_favorite.png" width="200" />](https://flutter.dev/docs/development/packages-and-plugins/favorites)

# Cloud Firestore Plugin for Flutter

A Flutter plugin to use the [Cloud Firestore API](https://firebase.google.com/docs/firestore/).

To learn more about Firebase Cloud Firestore, please visit the [Firebase website](https://firebase.google.com/products/firestore)

[![pub package](https://img.shields.io/pub/v/cloud_firestore.svg)](https://pub.dev/packages/cloud_firestore)

## Getting Started

To get started with Cloud Firestore for Flutter, please [see the documentation](https://firebase.google.com/docs/firestore/quickstart).

## Usage

To use this plugin, please visit the [Firestore Usage documentation](https://firebase.google.com/docs/firestore/manage-data/add-data)

## Issues and feedback

Please file FlutterFire specific issues, bugs, or feature requests in our [issue tracker](https://github.com/firebase/flutterfire/issues/new).

Plugin issues that are not specific to FlutterFire can be filed in the [Flutter issue tracker](https://github.com/flutter/flutter/issues/new).

To contribute a change to this plugin,
please review our [contribution guide](https://github.com/firebase/flutterfire/blob/main/CONTRIBUTING.md)
and open a [pull request](https://github.com/firebase/flutterfire/pulls).

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/cloud_firestore/pubspec.yaml

**크기**: 1195 bytes | **라인 수**: 52 | **타입**: text

```
name: cloud_firestore
description:
  Flutter plugin for Cloud Firestore, a cloud-hosted, noSQL database with
  live synchronization and offline support on Android and iOS.
homepage: https://firebase.google.com/docs/firestore
repository: https://github.com/firebase/flutterfire/tree/main/packages/cloud_firestore/cloud_firestore
version: 6.0.2
topics:
  - firebase
  - firestore
  - realtime
  - database

false_secrets:
  - example/**
  - dartpad/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.3.0'

dependencies:
  cloud_firestore_platform_interface: ^7.0.2
  cloud_firestore_web: ^5.0.2
  collection: ^1.0.0
  firebase_core: ^4.1.1
  firebase_core_platform_interface: ^6.0.1
  flutter:
    sdk: flutter
  meta: ^1.8.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.firestore
        pluginClass: FlutterFirebaseFirestorePlugin
      ios:
        pluginClass: FLTFirebaseFirestorePlugin
      macos:
        pluginClass: FLTFirebaseFirestorePlugin
      web:
        default_package: cloud_firestore_web
      windows:
        pluginClass: CloudFirestorePluginCApi


```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/AuthStateChannelStreamHandler.java

**크기**: 1918 bytes | **라인 수**: 64 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuth.AuthStateListener;
import com.google.firebase.auth.FirebaseUser;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class AuthStateChannelStreamHandler implements StreamHandler {

  private final FirebaseAuth firebaseAuth;
  private AuthStateListener authStateListener;

  public AuthStateChannelStreamHandler(FirebaseAuth firebaseAuth) {
    this.firebaseAuth = firebaseAuth;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    Map<String, Object> event = new HashMap<>();
    event.put(Constants.APP_NAME, firebaseAuth.getApp().getName());

    final AtomicBoolean initialAuthState = new AtomicBoolean(true);

    authStateListener =
        auth -> {
          if (initialAuthState.get()) {
            initialAuthState.set(false);
            return;
          }

          FirebaseUser user = auth.getCurrentUser();

          if (user == null) {
            event.put(Constants.USER, null);
          } else {
            event.put(
                Constants.USER, PigeonParser.manuallyToList(PigeonParser.parseFirebaseUser(user)));
          }

          events.success(event);
        };

    firebaseAuth.addAuthStateListener(authStateListener);
  }

  @Override
  public void onCancel(Object arguments) {
    if (authStateListener != null) {
      firebaseAuth.removeAuthStateListener(authStateListener);
      authStateListener = null;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/Constants.java

**크기**: 2114 bytes | **라인 수**: 47 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

public class Constants {

  public static final String APP_NAME = "appName";

  // Providers
  public static final String SIGN_IN_METHOD_PASSWORD = "password";
  public static final String SIGN_IN_METHOD_EMAIL_LINK = "emailLink";
  public static final String SIGN_IN_METHOD_FACEBOOK = "facebook.com";
  public static final String SIGN_IN_METHOD_GOOGLE = "google.com";
  public static final String SIGN_IN_METHOD_TWITTER = "twitter.com";
  public static final String SIGN_IN_METHOD_GITHUB = "github.com";
  public static final String SIGN_IN_METHOD_PHONE = "phone";
  public static final String SIGN_IN_METHOD_OAUTH = "oauth";
  public static final String SIGN_IN_METHOD_PLAY_GAMES = "playgames.google.com";
  // User
  public static final String USER = "user";
  public static final String EMAIL = "email";

  public static final String PROVIDER_ID = "providerId";
  public static final String CREDENTIAL = "credential";
  public static final String SECRET = "secret";
  public static final String ID_TOKEN = "idToken";
  public static final String TOKEN = "token";
  public static final String ACCESS_TOKEN = "accessToken";
  public static final String RAW_NONCE = "rawNonce";
  public static final String EMAIL_LINK = "emailLink";
  public static final String VERIFICATION_ID = "verificationId";
  public static final String SMS_CODE = "smsCode";
  public static final String SIGN_IN_METHOD = "signInMethod";
  public static final String FORCE_RESENDING_TOKEN = "forceResendingToken";
  public static final String NAME = "name";
  public static final String SERVER_AUTH_CODE = "serverAuthCode";

  // MultiFactor
  public static final String MULTI_FACTOR_HINTS = "multiFactorHints";
  public static final String MULTI_FACTOR_SESSION_ID = "multiFactorSessionId";
  public static final String MULTI_FACTOR_RESOLVER_ID = "multiFactorResolverId";
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseAuthPlugin.java

**크기**: 27413 bytes | **라인 수**: 761 | **타입**: text

```
// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.auth;

import static io.flutter.plugins.firebase.auth.FlutterFirebaseMultiFactor.multiFactorUserMap;
import static io.flutter.plugins.firebase.core.FlutterFirebasePluginRegistry.registerPlugin;

import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.TaskCompletionSource;
import com.google.firebase.FirebaseApp;
import com.google.firebase.auth.ActionCodeResult;
import com.google.firebase.auth.AuthCredential;
import com.google.firebase.auth.AuthResult;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.auth.MultiFactor;
import com.google.firebase.auth.MultiFactorInfo;
import com.google.firebase.auth.MultiFactorSession;
import com.google.firebase.auth.OAuthProvider;
import com.google.firebase.auth.PhoneMultiFactorInfo;
import com.google.firebase.auth.SignInMethodQueryResult;
import io.flutter.embedding.engine.plugins.FlutterPlugin;
import io.flutter.embedding.engine.plugins.activity.ActivityAware;
import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.EventChannel;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import io.flutter.plugin.common.MethodChannel;
import io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin;
import io.flutter.plugins.firebase.core.FlutterFirebasePlugin;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/** Flutter plugin for Firebase Auth. */
public class FlutterFirebaseAuthPlugin
    implements FlutterFirebasePlugin,
        FlutterPlugin,
        ActivityAware,
        GeneratedAndroidFirebaseAuth.FirebaseAuthHostApi {

  private static final String METHOD_CHANNEL_NAME = "plugins.flutter.io/firebase_auth";

  // Stores the instances of native AuthCredentials by their hashCode
  static final HashMap<Integer, AuthCredential> authCredentials = new HashMap<>();

  @Nullable private BinaryMessenger messenger;

  private MethodChannel channel;
  private Activity activity;

  private final Map<EventChannel, StreamHandler> streamHandlers = new HashMap<>();

  private final FlutterFirebaseAuthUser firebaseAuthUser = new FlutterFirebaseAuthUser();
  private final FlutterFirebaseMultiFactor firebaseMultiFactor = new FlutterFirebaseMultiFactor();

  private final FlutterFirebaseTotpMultiFactor firebaseTotpMultiFactor =
      new FlutterFirebaseTotpMultiFactor();
  private final FlutterFirebaseTotpSecret firebaseTotpSecret = new FlutterFirebaseTotpSecret();

  private void initInstance(BinaryMessenger messenger) {
    registerPlugin(METHOD_CHANNEL_NAME, this);
    channel = new MethodChannel(messenger, METHOD_CHANNEL_NAME);
    GeneratedAndroidFirebaseAuth.FirebaseAuthHostApi.setUp(messenger, this);
    GeneratedAndroidFirebaseAuth.FirebaseAuthUserHostApi.setUp(messenger, firebaseAuthUser);
    GeneratedAndroidFirebaseAuth.MultiFactorUserHostApi.setUp(messenger, firebaseMultiFactor);
    GeneratedAndroidFirebaseAuth.MultiFactoResolverHostApi.setUp(messenger, firebaseMultiFactor);
    GeneratedAndroidFirebaseAuth.MultiFactorTotpHostApi.setUp(messenger, firebaseTotpMultiFactor);
    GeneratedAndroidFirebaseAuth.MultiFactorTotpSecretHostApi.setUp(messenger, firebaseTotpSecret);

    this.messenger = messenger;
  }

  @Override
  public void onAttachedToEngine(@NonNull FlutterPluginBinding binding) {
    initInstance(binding.getBinaryMessenger());
  }

  @Override
  public void onDetachedFromEngine(@NonNull FlutterPluginBinding binding) {
    channel.setMethodCallHandler(null);

    assert messenger != null;
    GeneratedAndroidFirebaseAuth.FirebaseAuthHostApi.setUp(messenger, null);
    GeneratedAndroidFirebaseAuth.FirebaseAuthUserHostApi.setUp(messenger, null);
    GeneratedAndroidFirebaseAuth.MultiFactorUserHostApi.setUp(messenger, null);
    GeneratedAndroidFirebaseAuth.MultiFactoResolverHostApi.setUp(messenger, null);
    GeneratedAndroidFirebaseAuth.MultiFactorTotpHostApi.setUp(messenger, null);
    GeneratedAndroidFirebaseAuth.MultiFactorTotpSecretHostApi.setUp(messenger, null);

    channel = null;
    messenger = null;

    removeEventListeners();
  }

  @Override
  public void onAttachedToActivity(ActivityPluginBinding activityPluginBinding) {
    activity = activityPluginBinding.getActivity();
    firebaseAuthUser.setActivity(activity);
  }

  @Override
  public void onDetachedFromActivityForConfigChanges() {
    activity = null;
    firebaseAuthUser.setActivity(null);
  }

  @Override
  public void onReattachedToActivityForConfigChanges(ActivityPluginBinding activityPluginBinding) {
    activity = activityPluginBinding.getActivity();
    firebaseAuthUser.setActivity(activity);
  }

  @Override
  public void onDetachedFromActivity() {
    activity = null;
    firebaseAuthUser.setActivity(null);
  }

  // Only access activity with this method.
  @Nullable
  private Activity getActivity() {
    return activity;
  }

  static FirebaseAuth getAuthFromPigeon(
      GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp pigeonApp) {
    FirebaseApp app = FirebaseApp.getInstance(pigeonApp.getAppName());
    FirebaseAuth auth = FirebaseAuth.getInstance(app);
    if (pigeonApp.getTenantId() != null) {
      auth.setTenantId(pigeonApp.getTenantId());
    }
    String customDomain = FlutterFirebaseCorePlugin.customAuthDomain.get(pigeonApp.getAppName());
    if (customDomain != null) {
      auth.setCustomAuthDomain(customDomain);
    }

    // Auth's `getCustomAuthDomain` supersedes value from `customAuthDomain` map set by `initializeApp`
    if (pigeonApp.getCustomAuthDomain() != null) {
      auth.setCustomAuthDomain(pigeonApp.getCustomAuthDomain());
    }

    return auth;
  }

  @Override
  public void registerIdTokenListener(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    try {
      final FirebaseAuth auth = getAuthFromPigeon(app);
      final IdTokenChannelStreamHandler handler = new IdTokenChannelStreamHandler(auth);
      final String name = METHOD_CHANNEL_NAME + "/id-token/" + auth.getApp().getName();
      final EventChannel channel = new EventChannel(messenger, name);
      channel.setStreamHandler(handler);
      streamHandlers.put(channel, handler);
      result.success(name);
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void registerAuthStateListener(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    try {
      final FirebaseAuth auth = getAuthFromPigeon(app);
      final AuthStateChannelStreamHandler handler = new AuthStateChannelStreamHandler(auth);
      final String name = METHOD_CHANNEL_NAME + "/auth-state/" + auth.getApp().getName();
      final EventChannel channel = new EventChannel(messenger, name);
      channel.setStreamHandler(handler);
      streamHandlers.put(channel, handler);
      result.success(name);
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void useEmulator(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String host,
      @NonNull Long port,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    try {
      FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
      firebaseAuth.useEmulator(host, port.intValue());
      result.success();
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void applyActionCode(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String code,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .applyActionCode(code)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void checkActionCode(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String code,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonActionCodeInfo>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .checkActionCode(code)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                ActionCodeResult actionCodeInfo = task.getResult();
                result.success(PigeonParser.parseActionCodeResult(actionCodeInfo));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void confirmPasswordReset(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String code,
      @NonNull String newPassword,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .confirmPasswordReset(code, newPassword)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void createUserWithEmailAndPassword(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @NonNull String password,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .createUserWithEmailAndPassword(email, password)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInAnonymously(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .signInAnonymously()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInWithCredential(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull Map<String, Object> input,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    AuthCredential credential = PigeonParser.getCredential(input);

    if (credential == null) {
      throw FlutterFirebaseAuthPluginException.invalidCredential();
    }
    firebaseAuth
        .signInWithCredential(credential)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInWithCustomToken(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String token,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .signInWithCustomToken(token)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInWithEmailAndPassword(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @NonNull String password,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .signInWithEmailAndPassword(email, password)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInWithEmailLink(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @NonNull String emailLink,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .signInWithEmailLink(email, emailLink)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signInWithProvider(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonSignInProvider signInProvider,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    OAuthProvider.Builder provider =
        OAuthProvider.newBuilder(signInProvider.getProviderId(), firebaseAuth);
    if (signInProvider.getScopes() != null) {
      provider.setScopes(signInProvider.getScopes());
    }
    if (signInProvider.getCustomParameters() != null) {
      provider.addCustomParameters(signInProvider.getCustomParameters());
    }

    firebaseAuth
        .startActivityForSignInWithProvider(getActivity(), provider.build())
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void signOut(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    try {
      FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
      if (firebaseAuth.getCurrentUser() != null) {
        final Map<String, MultiFactor> appMultiFactorUser =
            multiFactorUserMap.get(app.getAppName());
        if (appMultiFactorUser != null) {
          appMultiFactorUser.remove(firebaseAuth.getCurrentUser().getUid());
        }
      }
      firebaseAuth.signOut();
      result.success();
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void fetchSignInMethodsForEmail(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @NonNull GeneratedAndroidFirebaseAuth.Result<List<String>> result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .fetchSignInMethodsForEmail(email)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                SignInMethodQueryResult signInMethodQueryResult = task.getResult();
                result.success(signInMethodQueryResult.getSignInMethods());
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void sendPasswordResetEmail(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @Nullable GeneratedAndroidFirebaseAuth.PigeonActionCodeSettings actionCodeSettings,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    if (actionCodeSettings == null) {
      firebaseAuth
          .sendPasswordResetEmail(email)
          .addOnCompleteListener(
              task -> {
                if (task.isSuccessful()) {
                  result.success();
                } else {
                  result.error(
                      FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                          task.getException()));
                }
              });
      return;
    }

    firebaseAuth
        .sendPasswordResetEmail(email, PigeonParser.getActionCodeSettings(actionCodeSettings))
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void sendSignInLinkToEmail(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String email,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonActionCodeSettings actionCodeSettings,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .sendSignInLinkToEmail(email, PigeonParser.getActionCodeSettings(actionCodeSettings))
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void setLanguageCode(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @Nullable String languageCode,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    try {
      FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

      if (languageCode == null) {
        firebaseAuth.useAppLanguage();
      } else {
        firebaseAuth.setLanguageCode(languageCode);
      }

      result.success(firebaseAuth.getLanguageCode());
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void setSettings(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonFirebaseAuthSettings settings,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    try {
      FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

      firebaseAuth
          .getFirebaseAuthSettings()
          .setAppVerificationDisabledForTesting(settings.getAppVerificationDisabledForTesting());

      if (settings.getForceRecaptchaFlow() != null) {
        firebaseAuth
            .getFirebaseAuthSettings()
            .forceRecaptchaFlowForTesting(settings.getForceRecaptchaFlow());
      }

      if (settings.getPhoneNumber() != null && settings.getSmsCode() != null) {
        firebaseAuth
            .getFirebaseAuthSettings()
            .setAutoRetrievedSmsCodeForPhoneNumber(
                settings.getPhoneNumber(), settings.getSmsCode());
      }

      result.success();
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void verifyPasswordResetCode(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String code,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);

    firebaseAuth
        .verifyPasswordResetCode(code)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(task.getResult());
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void verifyPhoneNumber(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonVerifyPhoneNumberRequest request,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    try {
      String eventChannelName = METHOD_CHANNEL_NAME + "/phone/" + UUID.randomUUID().toString();
      EventChannel channel = new EventChannel(messenger, eventChannelName);

      MultiFactorSession multiFactorSession = null;

      if (request.getMultiFactorSessionId() != null) {
        multiFactorSession =
            FlutterFirebaseMultiFactor.multiFactorSessionMap.get(request.getMultiFactorSessionId());
      }

      final String multiFactorInfoId = request.getMultiFactorInfoId();
      PhoneMultiFactorInfo multiFactorInfo = null;

      if (multiFactorInfoId != null) {
        for (String resolverId : FlutterFirebaseMultiFactor.multiFactorResolverMap.keySet()) {
          for (MultiFactorInfo info :
              FlutterFirebaseMultiFactor.multiFactorResolverMap.get(resolverId).getHints()) {
            if (info.getUid().equals(multiFactorInfoId) && info instanceof PhoneMultiFactorInfo) {
              multiFactorInfo = (PhoneMultiFactorInfo) info;
              break;
            }
          }
        }
      }

      PhoneNumberVerificationStreamHandler handler =
          new PhoneNumberVerificationStreamHandler(
              getActivity(),
              app,
              request,
              multiFactorSession,
              multiFactorInfo,
              credential -> {
                int hashCode = credential.hashCode();
                authCredentials.put(hashCode, credential);
              });

      channel.setStreamHandler(handler);
      streamHandlers.put(channel, handler);

      result.success(eventChannelName);
    } catch (Exception e) {
      result.error(e);
    }
  }

  @Override
  public void revokeTokenWithAuthorizationCode(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String authorizationCode,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    // Should never get here as we throw Exception on Dart side.
    result.success();
  }

  @Override
  public void initializeRecaptchaConfig(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseAuth firebaseAuth = getAuthFromPigeon(app);
    firebaseAuth
        .initializeRecaptchaConfig()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public Task<Map<String, Object>> getPluginConstantsForFirebaseApp(FirebaseApp firebaseApp) {
    TaskCompletionSource<Map<String, Object>> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            Map<String, Object> constants = new HashMap<>();
            FirebaseAuth firebaseAuth = FirebaseAuth.getInstance(firebaseApp);
            FirebaseUser firebaseUser = firebaseAuth.getCurrentUser();
            String languageCode = firebaseAuth.getLanguageCode();

            GeneratedAndroidFirebaseAuth.PigeonUserDetails user =
                firebaseUser == null ? null : PigeonParser.parseFirebaseUser(firebaseUser);

            if (languageCode != null) {
              constants.put("APP_LANGUAGE_CODE", languageCode);
            }

            if (user != null) {
              constants.put("APP_CURRENT_USER", PigeonParser.manuallyToList(user));
            }

            taskCompletionSource.setResult(constants);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  @Override
  public Task<Void> didReinitializeFirebaseCore() {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            removeEventListeners();
            authCredentials.clear();
            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  private void removeEventListeners() {
    for (EventChannel eventChannel : streamHandlers.keySet()) {
      StreamHandler streamHandler = streamHandlers.get(eventChannel);
      if (streamHandler != null) {
        streamHandler.onCancel(null);
      }
      eventChannel.setStreamHandler(null);
    }
    streamHandlers.clear();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseAuthPluginException.java

**크기**: 6521 bytes | **라인 수**: 157 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import androidx.annotation.Nullable;
import com.google.firebase.FirebaseApiNotAvailableException;
import com.google.firebase.FirebaseNetworkException;
import com.google.firebase.FirebaseTooManyRequestsException;
import com.google.firebase.auth.AuthCredential;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.FirebaseAuthMultiFactorException;
import com.google.firebase.auth.FirebaseAuthUserCollisionException;
import com.google.firebase.auth.FirebaseAuthWeakPasswordException;
import com.google.firebase.auth.MultiFactorInfo;
import com.google.firebase.auth.MultiFactorResolver;
import com.google.firebase.auth.MultiFactorSession;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class FlutterFirebaseAuthPluginException {

  static GeneratedAndroidFirebaseAuth.FlutterError parserExceptionToFlutter(
      @Nullable Exception nativeException) {
    if (nativeException == null) {
      return new GeneratedAndroidFirebaseAuth.FlutterError("UNKNOWN", null, null);
    }
    String code = "UNKNOWN";

    String message = nativeException.getMessage();
    Map<String, Object> additionalData = new HashMap<>();

    if (nativeException instanceof FirebaseAuthMultiFactorException) {
      final FirebaseAuthMultiFactorException multiFactorException =
          (FirebaseAuthMultiFactorException) nativeException;
      Map<String, Object> output = new HashMap<>();

      MultiFactorResolver multiFactorResolver = multiFactorException.getResolver();
      final List<MultiFactorInfo> hints = multiFactorResolver.getHints();

      final MultiFactorSession session = multiFactorResolver.getSession();
      final String sessionId = UUID.randomUUID().toString();
      FlutterFirebaseMultiFactor.multiFactorSessionMap.put(sessionId, session);

      final String resolverId = UUID.randomUUID().toString();
      FlutterFirebaseMultiFactor.multiFactorResolverMap.put(resolverId, multiFactorResolver);

      final List<List<Object>> pigeonHints = PigeonParser.multiFactorInfoToMap(hints);

      output.put(
          Constants.APP_NAME,
          multiFactorException.getResolver().getFirebaseAuth().getApp().getName());

      output.put(Constants.MULTI_FACTOR_HINTS, pigeonHints);

      output.put(Constants.MULTI_FACTOR_SESSION_ID, sessionId);
      output.put(Constants.MULTI_FACTOR_RESOLVER_ID, resolverId);

      return new GeneratedAndroidFirebaseAuth.FlutterError(
          multiFactorException.getErrorCode(), multiFactorException.getLocalizedMessage(), output);
    }

    if (nativeException instanceof FirebaseNetworkException
        || (nativeException.getCause() != null
            && nativeException.getCause() instanceof FirebaseNetworkException)) {
      return new GeneratedAndroidFirebaseAuth.FlutterError(
          "network-request-failed",
          "A network error (such as timeout, interrupted connection or unreachable host) has occurred.",
          null);
    }

    if (nativeException instanceof FirebaseApiNotAvailableException
        || (nativeException.getCause() != null
            && nativeException.getCause() instanceof FirebaseApiNotAvailableException)) {
      return new GeneratedAndroidFirebaseAuth.FlutterError(
          "api-not-available", "The requested API is not available.", null);
    }

    if (nativeException instanceof FirebaseTooManyRequestsException
        || (nativeException.getCause() != null
            && nativeException.getCause() instanceof FirebaseTooManyRequestsException)) {
      return new GeneratedAndroidFirebaseAuth.FlutterError(
          "too-many-requests",
          "We have blocked all requests from this device due to unusual activity. Try again later.",
          null);
    }

    // Manual message overrides to match other platforms.
    if (nativeException.getMessage() != null
        && nativeException
            .getMessage()
            .startsWith("Cannot create PhoneAuthCredential without either verificationProof")) {
      return new GeneratedAndroidFirebaseAuth.FlutterError(
          "invalid-verification-code",
          "The verification ID used to create the phone auth credential is invalid.",
          null);
    }

    if (message != null
        && message.contains("User has already been linked to the given provider.")) {
      return FlutterFirebaseAuthPluginException.alreadyLinkedProvider();
    }

    if (nativeException instanceof FirebaseAuthException) {
      code = ((FirebaseAuthException) nativeException).getErrorCode();
    }

    if (nativeException instanceof FirebaseAuthWeakPasswordException) {
      message = ((FirebaseAuthWeakPasswordException) nativeException).getReason();
    }

    if (nativeException instanceof FirebaseAuthUserCollisionException) {
      String email = ((FirebaseAuthUserCollisionException) nativeException).getEmail();

      if (email != null) {
        additionalData.put("email", email);
      }

      AuthCredential authCredential =
          ((FirebaseAuthUserCollisionException) nativeException).getUpdatedCredential();

      if (authCredential != null) {
        additionalData.put("authCredential", PigeonParser.parseAuthCredential(authCredential));
      }
    }

    return new GeneratedAndroidFirebaseAuth.FlutterError(code, message, additionalData);
  }

  static GeneratedAndroidFirebaseAuth.FlutterError noUser() {
    return new GeneratedAndroidFirebaseAuth.FlutterError(
        "NO_CURRENT_USER", "No user currently signed in.", null);
  }

  static GeneratedAndroidFirebaseAuth.FlutterError invalidCredential() {
    return new GeneratedAndroidFirebaseAuth.FlutterError(
        "INVALID_CREDENTIAL",
        "The supplied auth credential is malformed, has expired or is not currently supported.",
        null);
  }

  static GeneratedAndroidFirebaseAuth.FlutterError noSuchProvider() {
    return new GeneratedAndroidFirebaseAuth.FlutterError(
        "NO_SUCH_PROVIDER", "User was not linked to an account with the given provider.", null);
  }

  static GeneratedAndroidFirebaseAuth.FlutterError alreadyLinkedProvider() {
    return new GeneratedAndroidFirebaseAuth.FlutterError(
        "PROVIDER_ALREADY_LINKED", "User has already been linked to the given provider.", null);
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseAuthRegistrar.java

**크기**: 760 bytes | **라인 수**: 22 | **타입**: text

```
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.auth;

import androidx.annotation.Keep;
import com.google.firebase.components.Component;
import com.google.firebase.components.ComponentRegistrar;
import com.google.firebase.platforminfo.LibraryVersionComponent;
import java.util.Collections;
import java.util.List;

@Keep
public class FlutterFirebaseAuthRegistrar implements ComponentRegistrar {
  @Override
  public List<Component<?>> getComponents() {
    return Collections.<Component<?>>singletonList(
        LibraryVersionComponent.create(BuildConfig.LIBRARY_NAME, BuildConfig.LIBRARY_VERSION));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseAuthUser.java

**크기**: 19109 bytes | **라인 수**: 549 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import static io.flutter.plugins.firebase.core.FlutterFirebasePlugin.cachedThreadPool;

import android.app.Activity;
import android.net.Uri;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.FirebaseApp;
import com.google.firebase.auth.AuthCredential;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.auth.GetTokenResult;
import com.google.firebase.auth.OAuthProvider;
import com.google.firebase.auth.PhoneAuthCredential;
import com.google.firebase.auth.UserProfileChangeRequest;
import java.util.Map;

public class FlutterFirebaseAuthUser
    implements GeneratedAndroidFirebaseAuth.FirebaseAuthUserHostApi {

  private Activity activity;

  public void setActivity(Activity activity) {
    this.activity = activity;
  }

  public static FirebaseUser getCurrentUserFromPigeon(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp pigeonApp) {
    FirebaseApp app = FirebaseApp.getInstance(pigeonApp.getAppName());
    FirebaseAuth auth = FirebaseAuth.getInstance(app);
    if (pigeonApp.getTenantId() != null) {
      auth.setTenantId(pigeonApp.getTenantId());
    }

    return auth.getCurrentUser();
  }

  @Override
  public void delete(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    firebaseUser
        .delete()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void getIdToken(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull Boolean forceRefresh,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonIdTokenResult>
              result) {
    cachedThreadPool.execute(
        () -> {
          FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

          if (firebaseUser == null) {
            result.error(FlutterFirebaseAuthPluginException.noUser());
            return;
          }
          try {
            GetTokenResult response = Tasks.await(firebaseUser.getIdToken(forceRefresh));
            result.success(PigeonParser.parseTokenResult(response));
          } catch (Exception exception) {
            result.error(FlutterFirebaseAuthPluginException.parserExceptionToFlutter(exception));
          }
        });
  }

  @Override
  public void linkWithCredential(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull Map<String, Object> input,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);
    AuthCredential credential = PigeonParser.getCredential(input);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    if (credential == null) {
      result.error(FlutterFirebaseAuthPluginException.invalidCredential());
      return;
    }

    firebaseUser
        .linkWithCredential(credential)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void linkWithProvider(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonSignInProvider signInProvider,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    OAuthProvider.Builder provider = OAuthProvider.newBuilder(signInProvider.getProviderId());
    if (signInProvider.getScopes() != null) {
      provider.setScopes(signInProvider.getScopes());
    }
    if (signInProvider.getCustomParameters() != null) {
      provider.addCustomParameters(signInProvider.getCustomParameters());
    }

    firebaseUser
        .startActivityForLinkWithProvider(activity, provider.build())
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void reauthenticateWithCredential(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull Map<String, Object> input,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);
    AuthCredential credential = PigeonParser.getCredential(input);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    if (credential == null) {
      result.error(FlutterFirebaseAuthPluginException.invalidCredential());
      return;
    }

    firebaseUser
        .reauthenticateAndRetrieveData(credential)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void reauthenticateWithProvider(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonSignInProvider signInProvider,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    OAuthProvider.Builder provider = OAuthProvider.newBuilder(signInProvider.getProviderId());
    if (signInProvider.getScopes() != null) {
      provider.setScopes(signInProvider.getScopes());
    }
    if (signInProvider.getCustomParameters() != null) {
      provider.addCustomParameters(signInProvider.getCustomParameters());
    }

    firebaseUser
        .startActivityForReauthenticateWithProvider(activity, provider.build())
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void reload(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserDetails>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    firebaseUser
        .reload()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseFirebaseUser(firebaseUser));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void sendEmailVerification(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @Nullable GeneratedAndroidFirebaseAuth.PigeonActionCodeSettings actionCodeSettings,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    if (actionCodeSettings == null) {
      firebaseUser
          .sendEmailVerification()
          .addOnCompleteListener(
              task -> {
                if (task.isSuccessful()) {
                  result.success();
                } else {
                  result.error(
                      FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                          task.getException()));
                }
              });
      return;
    }

    firebaseUser
        .sendEmailVerification(PigeonParser.getActionCodeSettings(actionCodeSettings))
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void unlink(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String providerId,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    firebaseUser
        .unlink(providerId)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(PigeonParser.parseAuthResult(task.getResult()));
              } else {
                Exception exception = task.getException();
                if (exception
                    .getMessage()
                    .contains("User was not linked to an account with the given provider.")) {
                  result.error(FlutterFirebaseAuthPluginException.noSuchProvider());
                } else {
                  result.error(
                      FlutterFirebaseAuthPluginException.parserExceptionToFlutter(exception));
                }
              }
            });
  }

  @Override
  public void updateEmail(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String newEmail,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserDetails>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    firebaseUser
        .updateEmail(newEmail)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                firebaseUser
                    .reload()
                    .addOnCompleteListener(
                        reloadTask -> {
                          if (reloadTask.isSuccessful()) {
                            result.success(PigeonParser.parseFirebaseUser(firebaseUser));
                          } else {
                            result.error(
                                FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                                    reloadTask.getException()));
                          }
                        });
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void updatePassword(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String newPassword,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserDetails>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    firebaseUser
        .updatePassword(newPassword)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                firebaseUser
                    .reload()
                    .addOnCompleteListener(
                        reloadTask -> {
                          if (reloadTask.isSuccessful()) {
                            result.success(PigeonParser.parseFirebaseUser(firebaseUser));
                          } else {
                            result.error(
                                FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                                    reloadTask.getException()));
                          }
                        });
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void updatePhoneNumber(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull Map<String, Object> input,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserDetails>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    PhoneAuthCredential phoneAuthCredential =
        (PhoneAuthCredential) PigeonParser.getCredential(input);

    if (phoneAuthCredential == null) {
      result.error(FlutterFirebaseAuthPluginException.invalidCredential());
      return;
    }

    firebaseUser
        .updatePhoneNumber(phoneAuthCredential)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                firebaseUser
                    .reload()
                    .addOnCompleteListener(
                        reloadTask -> {
                          if (reloadTask.isSuccessful()) {
                            result.success(PigeonParser.parseFirebaseUser(firebaseUser));
                          } else {
                            result.error(
                                FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                                    reloadTask.getException()));
                          }
                        });
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void updateProfile(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonUserProfile profile,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserDetails>
              result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    UserProfileChangeRequest.Builder builder = new UserProfileChangeRequest.Builder();

    if (profile.getDisplayNameChanged()) {
      builder.setDisplayName(profile.getDisplayName());
    }

    if (profile.getPhotoUrlChanged()) {
      if (profile.getPhotoUrl() != null) {
        builder.setPhotoUri(Uri.parse(profile.getPhotoUrl()));
      } else {
        builder.setPhotoUri(null);
      }
    }

    firebaseUser
        .updateProfile(builder.build())
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                firebaseUser
                    .reload()
                    .addOnCompleteListener(
                        reloadTask -> {
                          if (reloadTask.isSuccessful()) {
                            result.success(PigeonParser.parseFirebaseUser(firebaseUser));
                          } else {
                            result.error(
                                FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                                    reloadTask.getException()));
                          }
                        });
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void verifyBeforeUpdateEmail(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String newEmail,
      @Nullable GeneratedAndroidFirebaseAuth.PigeonActionCodeSettings actionCodeSettings,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    FirebaseUser firebaseUser = getCurrentUserFromPigeon(app);

    if (firebaseUser == null) {
      result.error(FlutterFirebaseAuthPluginException.noUser());
      return;
    }

    if (actionCodeSettings == null) {
      firebaseUser
          .verifyBeforeUpdateEmail(newEmail)
          .addOnCompleteListener(
              task -> {
                if (task.isSuccessful()) {
                  result.success();
                } else {
                  result.error(
                      FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                          task.getException()));
                }
              });
      return;
    }

    firebaseUser
        .verifyBeforeUpdateEmail(newEmail, PigeonParser.getActionCodeSettings(actionCodeSettings))
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseMultiFactor.java

**크기**: 8910 bytes | **라인 수**: 252 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.firebase.auth.AuthResult;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.auth.MultiFactor;
import com.google.firebase.auth.MultiFactorAssertion;
import com.google.firebase.auth.MultiFactorInfo;
import com.google.firebase.auth.MultiFactorResolver;
import com.google.firebase.auth.MultiFactorSession;
import com.google.firebase.auth.PhoneAuthCredential;
import com.google.firebase.auth.PhoneAuthProvider;
import com.google.firebase.auth.PhoneMultiFactorGenerator;
import com.google.firebase.internal.api.FirebaseNoSignedInUserException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class FlutterFirebaseMultiFactor
    implements GeneratedAndroidFirebaseAuth.MultiFactorUserHostApi,
        GeneratedAndroidFirebaseAuth.MultiFactoResolverHostApi {

  // Map an app id to a map of user id to a MultiFactorUser object.
  static final Map<String, Map<String, MultiFactor>> multiFactorUserMap = new HashMap<>();

  // Map an id to a MultiFactorSession object.
  static final Map<String, MultiFactorSession> multiFactorSessionMap = new HashMap<>();

  // Map an id to a MultiFactorResolver object.
  static final Map<String, MultiFactorResolver> multiFactorResolverMap = new HashMap<>();

  static final Map<String, MultiFactorAssertion> multiFactorAssertionMap = new HashMap<>();

  MultiFactor getAppMultiFactor(@NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app)
      throws FirebaseNoSignedInUserException {
    final FirebaseUser currentUser = FlutterFirebaseAuthUser.getCurrentUserFromPigeon(app);
    if (currentUser == null) {
      throw new FirebaseNoSignedInUserException("No user is signed in");
    }
    if (multiFactorUserMap.get(app.getAppName()) == null) {
      multiFactorUserMap.put(app.getAppName(), new HashMap<>());
    }

    final Map<String, MultiFactor> appMultiFactorUser = multiFactorUserMap.get(app.getAppName());
    if (appMultiFactorUser.get(currentUser.getUid()) == null) {
      appMultiFactorUser.put(currentUser.getUid(), currentUser.getMultiFactor());
    }

    return appMultiFactorUser.get(currentUser.getUid());
  }

  @Override
  public void enrollPhone(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonPhoneMultiFactorAssertion assertion,
      @Nullable String displayName,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    final MultiFactor multiFactor;
    try {
      multiFactor = getAppMultiFactor(app);
    } catch (FirebaseNoSignedInUserException e) {
      result.error(e);
      return;
    }

    PhoneAuthCredential credential =
        PhoneAuthProvider.getCredential(
            assertion.getVerificationId(), assertion.getVerificationCode());

    MultiFactorAssertion multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential);

    multiFactor
        .enroll(multiFactorAssertion, displayName)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void enrollTotp(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String assertionId,
      @Nullable String displayName,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    final MultiFactor multiFactor;
    try {
      multiFactor = getAppMultiFactor(app);
    } catch (FirebaseNoSignedInUserException e) {
      result.error(e);
      return;
    }

    final MultiFactorAssertion multiFactorAssertion = multiFactorAssertionMap.get(assertionId);

    assert multiFactorAssertion != null;
    multiFactor
        .enroll(multiFactorAssertion, displayName)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void getSession(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonMultiFactorSession>
              result) {
    final MultiFactor multiFactor;
    try {
      multiFactor = getAppMultiFactor(app);
    } catch (FirebaseNoSignedInUserException e) {
      result.error(e);
      return;
    }

    multiFactor
        .getSession()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                final MultiFactorSession sessionResult = task.getResult();
                final String id = UUID.randomUUID().toString();
                multiFactorSessionMap.put(id, sessionResult);
                result.success(
                    new GeneratedAndroidFirebaseAuth.PigeonMultiFactorSession.Builder()
                        .setId(id)
                        .build());
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void unenroll(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull String factorUid,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    final MultiFactor multiFactor;
    try {
      multiFactor = getAppMultiFactor(app);
    } catch (FirebaseNoSignedInUserException e) {
      result.error(FlutterFirebaseAuthPluginException.parserExceptionToFlutter(e));
      return;
    }

    multiFactor
        .unenroll(factorUid)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void getEnrolledFactors(
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<
                  List<GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo>>
              result) {
    final MultiFactor multiFactor;
    try {
      multiFactor = getAppMultiFactor(app);
    } catch (FirebaseNoSignedInUserException e) {
      result.error(e);
      return;
    }

    final List<MultiFactorInfo> factors = multiFactor.getEnrolledFactors();

    final List<GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo> resultFactors =
        PigeonParser.multiFactorInfoToPigeon(factors);

    result.success(resultFactors);
  }

  @Override
  public void resolveSignIn(
      @NonNull String resolverId,
      @Nullable GeneratedAndroidFirebaseAuth.PigeonPhoneMultiFactorAssertion assertion,
      @Nullable String totpAssertionId,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonUserCredential>
              result) {
    final MultiFactorResolver resolver = multiFactorResolverMap.get(resolverId);

    if (resolver == null) {
      result.error(
          FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
              new Exception("Resolver not found")));
      return;
    }

    MultiFactorAssertion multiFactorAssertion;

    if (assertion != null) {
      PhoneAuthCredential credential =
          PhoneAuthProvider.getCredential(
              assertion.getVerificationId(), assertion.getVerificationCode());
      multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential);
    } else {
      multiFactorAssertion = multiFactorAssertionMap.get(totpAssertionId);
    }

    resolver
        .resolveSignIn(multiFactorAssertion)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                final AuthResult authResult = task.getResult();
                result.success(PigeonParser.parseAuthResult(authResult));
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseTotpMultiFactor.java

**크기**: 3343 bytes | **라인 수**: 83 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import androidx.annotation.NonNull;
import com.google.firebase.auth.MultiFactorSession;
import com.google.firebase.auth.TotpMultiFactorAssertion;
import com.google.firebase.auth.TotpMultiFactorGenerator;
import com.google.firebase.auth.TotpSecret;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class FlutterFirebaseTotpMultiFactor
    implements GeneratedAndroidFirebaseAuth.MultiFactorTotpHostApi {

  // Map an app id to a map of user id to a TotpSecret object.
  static final Map<String, TotpSecret> multiFactorSecret = new HashMap<>();

  @Override
  public void generateSecret(
      @NonNull String sessionId,
      @NonNull
          GeneratedAndroidFirebaseAuth.Result<GeneratedAndroidFirebaseAuth.PigeonTotpSecret>
              result) {
    MultiFactorSession multiFactorSession =
        FlutterFirebaseMultiFactor.multiFactorSessionMap.get(sessionId);

    assert multiFactorSession != null;
    TotpMultiFactorGenerator.generateSecret(multiFactorSession)
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                TotpSecret secret = task.getResult();
                multiFactorSecret.put(secret.getSharedSecretKey(), secret);
                result.success(
                    new GeneratedAndroidFirebaseAuth.PigeonTotpSecret.Builder()
                        .setCodeIntervalSeconds((long) secret.getCodeIntervalSeconds())
                        .setCodeLength((long) secret.getCodeLength())
                        .setSecretKey(secret.getSharedSecretKey())
                        .setHashingAlgorithm(secret.getHashAlgorithm())
                        .setEnrollmentCompletionDeadline(secret.getEnrollmentCompletionDeadline())
                        .build());
              } else {
                result.error(
                    FlutterFirebaseAuthPluginException.parserExceptionToFlutter(
                        task.getException()));
              }
            });
  }

  @Override
  public void getAssertionForEnrollment(
      @NonNull String secretKey,
      @NonNull String oneTimePassword,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    final TotpSecret secret = multiFactorSecret.get(secretKey);

    assert secret != null;
    TotpMultiFactorAssertion assertion =
        TotpMultiFactorGenerator.getAssertionForEnrollment(secret, oneTimePassword);
    String assertionId = UUID.randomUUID().toString();
    FlutterFirebaseMultiFactor.multiFactorAssertionMap.put(assertionId, assertion);
    result.success(assertionId);
  }

  @Override
  public void getAssertionForSignIn(
      @NonNull String enrollmentId,
      @NonNull String oneTimePassword,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    TotpMultiFactorAssertion assertion =
        TotpMultiFactorGenerator.getAssertionForSignIn(enrollmentId, oneTimePassword);
    String assertionId = UUID.randomUUID().toString();
    FlutterFirebaseMultiFactor.multiFactorAssertionMap.put(assertionId, assertion);
    result.success(assertionId);
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/FlutterFirebaseTotpSecret.java

**크기**: 1385 bytes | **라인 수**: 43 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.firebase.auth.TotpSecret;

public class FlutterFirebaseTotpSecret
    implements GeneratedAndroidFirebaseAuth.MultiFactorTotpSecretHostApi {

  @Override
  public void generateQrCodeUrl(
      @NonNull String secretKey,
      @Nullable String accountName,
      @Nullable String issuer,
      @NonNull GeneratedAndroidFirebaseAuth.Result<String> result) {
    final TotpSecret secret = FlutterFirebaseTotpMultiFactor.multiFactorSecret.get(secretKey);

    assert secret != null;
    if (accountName == null || issuer == null) {
      result.success(secret.generateQrCodeUrl());
      return;
    }
    result.success(secret.generateQrCodeUrl(accountName, issuer));
  }

  @Override
  public void openInOtpApp(
      @NonNull String secretKey,
      @NonNull String qrCodeUrl,
      @NonNull GeneratedAndroidFirebaseAuth.VoidResult result) {
    final TotpSecret secret = FlutterFirebaseTotpMultiFactor.multiFactorSecret.get(secretKey);
    assert secret != null;
    secret.openInOtpApp(qrCodeUrl);
    result.success();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/GeneratedAndroidFirebaseAuth.java

**크기**: 174458 bytes | **라인 수**: 4805 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package io.flutter.plugins.firebase.auth;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class GeneratedAndroidFirebaseAuth {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
          "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  @Target(METHOD)
  @Retention(CLASS)
  @interface CanIgnoreReturnValue {}

  /** The type of operation that generated the action code from calling [checkActionCode]. */
  public enum ActionCodeInfoOperation {
    /** Unknown operation. */
    UNKNOWN(0),
    /** Password reset code generated via [sendPasswordResetEmail]. */
    PASSWORD_RESET(1),
    /** Email verification code generated via [User.sendEmailVerification]. */
    VERIFY_EMAIL(2),
    /** Email change revocation code generated via [User.updateEmail]. */
    RECOVER_EMAIL(3),
    /** Email sign in code generated via [sendSignInLinkToEmail]. */
    EMAIL_SIGN_IN(4),
    /** Verify and change email code generated via [User.verifyBeforeUpdateEmail]. */
    VERIFY_AND_CHANGE_EMAIL(5),
    /** Action code for reverting second factor addition. */
    REVERT_SECOND_FACTOR_ADDITION(6);

    final int index;

    private ActionCodeInfoOperation(final int index) {
      this.index = index;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonMultiFactorSession {
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonMultiFactorSession() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      public @NonNull PigeonMultiFactorSession build() {
        PigeonMultiFactorSession pigeonReturn = new PigeonMultiFactorSession();
        pigeonReturn.setId(id);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(id);
      return toListResult;
    }

    static @NonNull PigeonMultiFactorSession fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonMultiFactorSession pigeonResult = new PigeonMultiFactorSession();
      Object id = __pigeon_list.get(0);
      pigeonResult.setId((String) id);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonPhoneMultiFactorAssertion {
    private @NonNull String verificationId;

    public @NonNull String getVerificationId() {
      return verificationId;
    }

    public void setVerificationId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"verificationId\" is null.");
      }
      this.verificationId = setterArg;
    }

    private @NonNull String verificationCode;

    public @NonNull String getVerificationCode() {
      return verificationCode;
    }

    public void setVerificationCode(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"verificationCode\" is null.");
      }
      this.verificationCode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonPhoneMultiFactorAssertion() {}

    public static final class Builder {

      private @Nullable String verificationId;

      @CanIgnoreReturnValue
      public @NonNull Builder setVerificationId(@NonNull String setterArg) {
        this.verificationId = setterArg;
        return this;
      }

      private @Nullable String verificationCode;

      @CanIgnoreReturnValue
      public @NonNull Builder setVerificationCode(@NonNull String setterArg) {
        this.verificationCode = setterArg;
        return this;
      }

      public @NonNull PigeonPhoneMultiFactorAssertion build() {
        PigeonPhoneMultiFactorAssertion pigeonReturn = new PigeonPhoneMultiFactorAssertion();
        pigeonReturn.setVerificationId(verificationId);
        pigeonReturn.setVerificationCode(verificationCode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(verificationId);
      toListResult.add(verificationCode);
      return toListResult;
    }

    static @NonNull PigeonPhoneMultiFactorAssertion fromList(
        @NonNull ArrayList<Object> __pigeon_list) {
      PigeonPhoneMultiFactorAssertion pigeonResult = new PigeonPhoneMultiFactorAssertion();
      Object verificationId = __pigeon_list.get(0);
      pigeonResult.setVerificationId((String) verificationId);
      Object verificationCode = __pigeon_list.get(1);
      pigeonResult.setVerificationCode((String) verificationCode);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonMultiFactorInfo {
    private @Nullable String displayName;

    public @Nullable String getDisplayName() {
      return displayName;
    }

    public void setDisplayName(@Nullable String setterArg) {
      this.displayName = setterArg;
    }

    private @NonNull Double enrollmentTimestamp;

    public @NonNull Double getEnrollmentTimestamp() {
      return enrollmentTimestamp;
    }

    public void setEnrollmentTimestamp(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"enrollmentTimestamp\" is null.");
      }
      this.enrollmentTimestamp = setterArg;
    }

    private @Nullable String factorId;

    public @Nullable String getFactorId() {
      return factorId;
    }

    public void setFactorId(@Nullable String setterArg) {
      this.factorId = setterArg;
    }

    private @NonNull String uid;

    public @NonNull String getUid() {
      return uid;
    }

    public void setUid(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"uid\" is null.");
      }
      this.uid = setterArg;
    }

    private @Nullable String phoneNumber;

    public @Nullable String getPhoneNumber() {
      return phoneNumber;
    }

    public void setPhoneNumber(@Nullable String setterArg) {
      this.phoneNumber = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonMultiFactorInfo() {}

    public static final class Builder {

      private @Nullable String displayName;

      @CanIgnoreReturnValue
      public @NonNull Builder setDisplayName(@Nullable String setterArg) {
        this.displayName = setterArg;
        return this;
      }

      private @Nullable Double enrollmentTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnrollmentTimestamp(@NonNull Double setterArg) {
        this.enrollmentTimestamp = setterArg;
        return this;
      }

      private @Nullable String factorId;

      @CanIgnoreReturnValue
      public @NonNull Builder setFactorId(@Nullable String setterArg) {
        this.factorId = setterArg;
        return this;
      }

      private @Nullable String uid;

      @CanIgnoreReturnValue
      public @NonNull Builder setUid(@NonNull String setterArg) {
        this.uid = setterArg;
        return this;
      }

      private @Nullable String phoneNumber;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhoneNumber(@Nullable String setterArg) {
        this.phoneNumber = setterArg;
        return this;
      }

      public @NonNull PigeonMultiFactorInfo build() {
        PigeonMultiFactorInfo pigeonReturn = new PigeonMultiFactorInfo();
        pigeonReturn.setDisplayName(displayName);
        pigeonReturn.setEnrollmentTimestamp(enrollmentTimestamp);
        pigeonReturn.setFactorId(factorId);
        pigeonReturn.setUid(uid);
        pigeonReturn.setPhoneNumber(phoneNumber);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(displayName);
      toListResult.add(enrollmentTimestamp);
      toListResult.add(factorId);
      toListResult.add(uid);
      toListResult.add(phoneNumber);
      return toListResult;
    }

    static @NonNull PigeonMultiFactorInfo fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonMultiFactorInfo pigeonResult = new PigeonMultiFactorInfo();
      Object displayName = __pigeon_list.get(0);
      pigeonResult.setDisplayName((String) displayName);
      Object enrollmentTimestamp = __pigeon_list.get(1);
      pigeonResult.setEnrollmentTimestamp((Double) enrollmentTimestamp);
      Object factorId = __pigeon_list.get(2);
      pigeonResult.setFactorId((String) factorId);
      Object uid = __pigeon_list.get(3);
      pigeonResult.setUid((String) uid);
      Object phoneNumber = __pigeon_list.get(4);
      pigeonResult.setPhoneNumber((String) phoneNumber);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class AuthPigeonFirebaseApp {
    private @NonNull String appName;

    public @NonNull String getAppName() {
      return appName;
    }

    public void setAppName(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"appName\" is null.");
      }
      this.appName = setterArg;
    }

    private @Nullable String tenantId;

    public @Nullable String getTenantId() {
      return tenantId;
    }

    public void setTenantId(@Nullable String setterArg) {
      this.tenantId = setterArg;
    }

    private @Nullable String customAuthDomain;

    public @Nullable String getCustomAuthDomain() {
      return customAuthDomain;
    }

    public void setCustomAuthDomain(@Nullable String setterArg) {
      this.customAuthDomain = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    AuthPigeonFirebaseApp() {}

    public static final class Builder {

      private @Nullable String appName;

      @CanIgnoreReturnValue
      public @NonNull Builder setAppName(@NonNull String setterArg) {
        this.appName = setterArg;
        return this;
      }

      private @Nullable String tenantId;

      @CanIgnoreReturnValue
      public @NonNull Builder setTenantId(@Nullable String setterArg) {
        this.tenantId = setterArg;
        return this;
      }

      private @Nullable String customAuthDomain;

      @CanIgnoreReturnValue
      public @NonNull Builder setCustomAuthDomain(@Nullable String setterArg) {
        this.customAuthDomain = setterArg;
        return this;
      }

      public @NonNull AuthPigeonFirebaseApp build() {
        AuthPigeonFirebaseApp pigeonReturn = new AuthPigeonFirebaseApp();
        pigeonReturn.setAppName(appName);
        pigeonReturn.setTenantId(tenantId);
        pigeonReturn.setCustomAuthDomain(customAuthDomain);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(appName);
      toListResult.add(tenantId);
      toListResult.add(customAuthDomain);
      return toListResult;
    }

    static @NonNull AuthPigeonFirebaseApp fromList(@NonNull ArrayList<Object> __pigeon_list) {
      AuthPigeonFirebaseApp pigeonResult = new AuthPigeonFirebaseApp();
      Object appName = __pigeon_list.get(0);
      pigeonResult.setAppName((String) appName);
      Object tenantId = __pigeon_list.get(1);
      pigeonResult.setTenantId((String) tenantId);
      Object customAuthDomain = __pigeon_list.get(2);
      pigeonResult.setCustomAuthDomain((String) customAuthDomain);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonActionCodeInfoData {
    private @Nullable String email;

    public @Nullable String getEmail() {
      return email;
    }

    public void setEmail(@Nullable String setterArg) {
      this.email = setterArg;
    }

    private @Nullable String previousEmail;

    public @Nullable String getPreviousEmail() {
      return previousEmail;
    }

    public void setPreviousEmail(@Nullable String setterArg) {
      this.previousEmail = setterArg;
    }

    public static final class Builder {

      private @Nullable String email;

      @CanIgnoreReturnValue
      public @NonNull Builder setEmail(@Nullable String setterArg) {
        this.email = setterArg;
        return this;
      }

      private @Nullable String previousEmail;

      @CanIgnoreReturnValue
      public @NonNull Builder setPreviousEmail(@Nullable String setterArg) {
        this.previousEmail = setterArg;
        return this;
      }

      public @NonNull PigeonActionCodeInfoData build() {
        PigeonActionCodeInfoData pigeonReturn = new PigeonActionCodeInfoData();
        pigeonReturn.setEmail(email);
        pigeonReturn.setPreviousEmail(previousEmail);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(email);
      toListResult.add(previousEmail);
      return toListResult;
    }

    static @NonNull PigeonActionCodeInfoData fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonActionCodeInfoData pigeonResult = new PigeonActionCodeInfoData();
      Object email = __pigeon_list.get(0);
      pigeonResult.setEmail((String) email);
      Object previousEmail = __pigeon_list.get(1);
      pigeonResult.setPreviousEmail((String) previousEmail);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonActionCodeInfo {
    private @NonNull ActionCodeInfoOperation operation;

    public @NonNull ActionCodeInfoOperation getOperation() {
      return operation;
    }

    public void setOperation(@NonNull ActionCodeInfoOperation setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"operation\" is null.");
      }
      this.operation = setterArg;
    }

    private @NonNull PigeonActionCodeInfoData data;

    public @NonNull PigeonActionCodeInfoData getData() {
      return data;
    }

    public void setData(@NonNull PigeonActionCodeInfoData setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"data\" is null.");
      }
      this.data = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonActionCodeInfo() {}

    public static final class Builder {

      private @Nullable ActionCodeInfoOperation operation;

      @CanIgnoreReturnValue
      public @NonNull Builder setOperation(@NonNull ActionCodeInfoOperation setterArg) {
        this.operation = setterArg;
        return this;
      }

      private @Nullable PigeonActionCodeInfoData data;

      @CanIgnoreReturnValue
      public @NonNull Builder setData(@NonNull PigeonActionCodeInfoData setterArg) {
        this.data = setterArg;
        return this;
      }

      public @NonNull PigeonActionCodeInfo build() {
        PigeonActionCodeInfo pigeonReturn = new PigeonActionCodeInfo();
        pigeonReturn.setOperation(operation);
        pigeonReturn.setData(data);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(operation == null ? null : operation.index);
      toListResult.add(data);
      return toListResult;
    }

    static @NonNull PigeonActionCodeInfo fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonActionCodeInfo pigeonResult = new PigeonActionCodeInfo();
      Object operation = __pigeon_list.get(0);
      pigeonResult.setOperation(ActionCodeInfoOperation.values()[(int) operation]);
      Object data = __pigeon_list.get(1);
      pigeonResult.setData((PigeonActionCodeInfoData) data);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonAdditionalUserInfo {
    private @NonNull Boolean isNewUser;

    public @NonNull Boolean getIsNewUser() {
      return isNewUser;
    }

    public void setIsNewUser(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"isNewUser\" is null.");
      }
      this.isNewUser = setterArg;
    }

    private @Nullable String providerId;

    public @Nullable String getProviderId() {
      return providerId;
    }

    public void setProviderId(@Nullable String setterArg) {
      this.providerId = setterArg;
    }

    private @Nullable String username;

    public @Nullable String getUsername() {
      return username;
    }

    public void setUsername(@Nullable String setterArg) {
      this.username = setterArg;
    }

    private @Nullable String authorizationCode;

    public @Nullable String getAuthorizationCode() {
      return authorizationCode;
    }

    public void setAuthorizationCode(@Nullable String setterArg) {
      this.authorizationCode = setterArg;
    }

    private @Nullable Map<String, Object> profile;

    public @Nullable Map<String, Object> getProfile() {
      return profile;
    }

    public void setProfile(@Nullable Map<String, Object> setterArg) {
      this.profile = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonAdditionalUserInfo() {}

    public static final class Builder {

      private @Nullable Boolean isNewUser;

      @CanIgnoreReturnValue
      public @NonNull Builder setIsNewUser(@NonNull Boolean setterArg) {
        this.isNewUser = setterArg;
        return this;
      }

      private @Nullable String providerId;

      @CanIgnoreReturnValue
      public @NonNull Builder setProviderId(@Nullable String setterArg) {
        this.providerId = setterArg;
        return this;
      }

      private @Nullable String username;

      @CanIgnoreReturnValue
      public @NonNull Builder setUsername(@Nullable String setterArg) {
        this.username = setterArg;
        return this;
      }

      private @Nullable String authorizationCode;

      @CanIgnoreReturnValue
      public @NonNull Builder setAuthorizationCode(@Nullable String setterArg) {
        this.authorizationCode = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> profile;

      @CanIgnoreReturnValue
      public @NonNull Builder setProfile(@Nullable Map<String, Object> setterArg) {
        this.profile = setterArg;
        return this;
      }

      public @NonNull PigeonAdditionalUserInfo build() {
        PigeonAdditionalUserInfo pigeonReturn = new PigeonAdditionalUserInfo();
        pigeonReturn.setIsNewUser(isNewUser);
        pigeonReturn.setProviderId(providerId);
        pigeonReturn.setUsername(username);
        pigeonReturn.setAuthorizationCode(authorizationCode);
        pigeonReturn.setProfile(profile);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(isNewUser);
      toListResult.add(providerId);
      toListResult.add(username);
      toListResult.add(authorizationCode);
      toListResult.add(profile);
      return toListResult;
    }

    static @NonNull PigeonAdditionalUserInfo fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonAdditionalUserInfo pigeonResult = new PigeonAdditionalUserInfo();
      Object isNewUser = __pigeon_list.get(0);
      pigeonResult.setIsNewUser((Boolean) isNewUser);
      Object providerId = __pigeon_list.get(1);
      pigeonResult.setProviderId((String) providerId);
      Object username = __pigeon_list.get(2);
      pigeonResult.setUsername((String) username);
      Object authorizationCode = __pigeon_list.get(3);
      pigeonResult.setAuthorizationCode((String) authorizationCode);
      Object profile = __pigeon_list.get(4);
      pigeonResult.setProfile((Map<String, Object>) profile);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonAuthCredential {
    private @NonNull String providerId;

    public @NonNull String getProviderId() {
      return providerId;
    }

    public void setProviderId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"providerId\" is null.");
      }
      this.providerId = setterArg;
    }

    private @NonNull String signInMethod;

    public @NonNull String getSignInMethod() {
      return signInMethod;
    }

    public void setSignInMethod(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"signInMethod\" is null.");
      }
      this.signInMethod = setterArg;
    }

    private @NonNull Long nativeId;

    public @NonNull Long getNativeId() {
      return nativeId;
    }

    public void setNativeId(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"nativeId\" is null.");
      }
      this.nativeId = setterArg;
    }

    private @Nullable String accessToken;

    public @Nullable String getAccessToken() {
      return accessToken;
    }

    public void setAccessToken(@Nullable String setterArg) {
      this.accessToken = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonAuthCredential() {}

    public static final class Builder {

      private @Nullable String providerId;

      @CanIgnoreReturnValue
      public @NonNull Builder setProviderId(@NonNull String setterArg) {
        this.providerId = setterArg;
        return this;
      }

      private @Nullable String signInMethod;

      @CanIgnoreReturnValue
      public @NonNull Builder setSignInMethod(@NonNull String setterArg) {
        this.signInMethod = setterArg;
        return this;
      }

      private @Nullable Long nativeId;

      @CanIgnoreReturnValue
      public @NonNull Builder setNativeId(@NonNull Long setterArg) {
        this.nativeId = setterArg;
        return this;
      }

      private @Nullable String accessToken;

      @CanIgnoreReturnValue
      public @NonNull Builder setAccessToken(@Nullable String setterArg) {
        this.accessToken = setterArg;
        return this;
      }

      public @NonNull PigeonAuthCredential build() {
        PigeonAuthCredential pigeonReturn = new PigeonAuthCredential();
        pigeonReturn.setProviderId(providerId);
        pigeonReturn.setSignInMethod(signInMethod);
        pigeonReturn.setNativeId(nativeId);
        pigeonReturn.setAccessToken(accessToken);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(providerId);
      toListResult.add(signInMethod);
      toListResult.add(nativeId);
      toListResult.add(accessToken);
      return toListResult;
    }

    static @NonNull PigeonAuthCredential fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonAuthCredential pigeonResult = new PigeonAuthCredential();
      Object providerId = __pigeon_list.get(0);
      pigeonResult.setProviderId((String) providerId);
      Object signInMethod = __pigeon_list.get(1);
      pigeonResult.setSignInMethod((String) signInMethod);
      Object nativeId = __pigeon_list.get(2);
      pigeonResult.setNativeId(
          (nativeId == null)
              ? null
              : ((nativeId instanceof Integer) ? (Integer) nativeId : (Long) nativeId));
      Object accessToken = __pigeon_list.get(3);
      pigeonResult.setAccessToken((String) accessToken);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonUserInfo {
    private @NonNull String uid;

    public @NonNull String getUid() {
      return uid;
    }

    public void setUid(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"uid\" is null.");
      }
      this.uid = setterArg;
    }

    private @Nullable String email;

    public @Nullable String getEmail() {
      return email;
    }

    public void setEmail(@Nullable String setterArg) {
      this.email = setterArg;
    }

    private @Nullable String displayName;

    public @Nullable String getDisplayName() {
      return displayName;
    }

    public void setDisplayName(@Nullable String setterArg) {
      this.displayName = setterArg;
    }

    private @Nullable String photoUrl;

    public @Nullable String getPhotoUrl() {
      return photoUrl;
    }

    public void setPhotoUrl(@Nullable String setterArg) {
      this.photoUrl = setterArg;
    }

    private @Nullable String phoneNumber;

    public @Nullable String getPhoneNumber() {
      return phoneNumber;
    }

    public void setPhoneNumber(@Nullable String setterArg) {
      this.phoneNumber = setterArg;
    }

    private @NonNull Boolean isAnonymous;

    public @NonNull Boolean getIsAnonymous() {
      return isAnonymous;
    }

    public void setIsAnonymous(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"isAnonymous\" is null.");
      }
      this.isAnonymous = setterArg;
    }

    private @NonNull Boolean isEmailVerified;

    public @NonNull Boolean getIsEmailVerified() {
      return isEmailVerified;
    }

    public void setIsEmailVerified(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"isEmailVerified\" is null.");
      }
      this.isEmailVerified = setterArg;
    }

    private @Nullable String providerId;

    public @Nullable String getProviderId() {
      return providerId;
    }

    public void setProviderId(@Nullable String setterArg) {
      this.providerId = setterArg;
    }

    private @Nullable String tenantId;

    public @Nullable String getTenantId() {
      return tenantId;
    }

    public void setTenantId(@Nullable String setterArg) {
      this.tenantId = setterArg;
    }

    private @Nullable String refreshToken;

    public @Nullable String getRefreshToken() {
      return refreshToken;
    }

    public void setRefreshToken(@Nullable String setterArg) {
      this.refreshToken = setterArg;
    }

    private @Nullable Long creationTimestamp;

    public @Nullable Long getCreationTimestamp() {
      return creationTimestamp;
    }

    public void setCreationTimestamp(@Nullable Long setterArg) {
      this.creationTimestamp = setterArg;
    }

    private @Nullable Long lastSignInTimestamp;

    public @Nullable Long getLastSignInTimestamp() {
      return lastSignInTimestamp;
    }

    public void setLastSignInTimestamp(@Nullable Long setterArg) {
      this.lastSignInTimestamp = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonUserInfo() {}

    public static final class Builder {

      private @Nullable String uid;

      @CanIgnoreReturnValue
      public @NonNull Builder setUid(@NonNull String setterArg) {
        this.uid = setterArg;
        return this;
      }

      private @Nullable String email;

      @CanIgnoreReturnValue
      public @NonNull Builder setEmail(@Nullable String setterArg) {
        this.email = setterArg;
        return this;
      }

      private @Nullable String displayName;

      @CanIgnoreReturnValue
      public @NonNull Builder setDisplayName(@Nullable String setterArg) {
        this.displayName = setterArg;
        return this;
      }

      private @Nullable String photoUrl;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhotoUrl(@Nullable String setterArg) {
        this.photoUrl = setterArg;
        return this;
      }

      private @Nullable String phoneNumber;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhoneNumber(@Nullable String setterArg) {
        this.phoneNumber = setterArg;
        return this;
      }

      private @Nullable Boolean isAnonymous;

      @CanIgnoreReturnValue
      public @NonNull Builder setIsAnonymous(@NonNull Boolean setterArg) {
        this.isAnonymous = setterArg;
        return this;
      }

      private @Nullable Boolean isEmailVerified;

      @CanIgnoreReturnValue
      public @NonNull Builder setIsEmailVerified(@NonNull Boolean setterArg) {
        this.isEmailVerified = setterArg;
        return this;
      }

      private @Nullable String providerId;

      @CanIgnoreReturnValue
      public @NonNull Builder setProviderId(@Nullable String setterArg) {
        this.providerId = setterArg;
        return this;
      }

      private @Nullable String tenantId;

      @CanIgnoreReturnValue
      public @NonNull Builder setTenantId(@Nullable String setterArg) {
        this.tenantId = setterArg;
        return this;
      }

      private @Nullable String refreshToken;

      @CanIgnoreReturnValue
      public @NonNull Builder setRefreshToken(@Nullable String setterArg) {
        this.refreshToken = setterArg;
        return this;
      }

      private @Nullable Long creationTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setCreationTimestamp(@Nullable Long setterArg) {
        this.creationTimestamp = setterArg;
        return this;
      }

      private @Nullable Long lastSignInTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setLastSignInTimestamp(@Nullable Long setterArg) {
        this.lastSignInTimestamp = setterArg;
        return this;
      }

      public @NonNull PigeonUserInfo build() {
        PigeonUserInfo pigeonReturn = new PigeonUserInfo();
        pigeonReturn.setUid(uid);
        pigeonReturn.setEmail(email);
        pigeonReturn.setDisplayName(displayName);
        pigeonReturn.setPhotoUrl(photoUrl);
        pigeonReturn.setPhoneNumber(phoneNumber);
        pigeonReturn.setIsAnonymous(isAnonymous);
        pigeonReturn.setIsEmailVerified(isEmailVerified);
        pigeonReturn.setProviderId(providerId);
        pigeonReturn.setTenantId(tenantId);
        pigeonReturn.setRefreshToken(refreshToken);
        pigeonReturn.setCreationTimestamp(creationTimestamp);
        pigeonReturn.setLastSignInTimestamp(lastSignInTimestamp);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(12);
      toListResult.add(uid);
      toListResult.add(email);
      toListResult.add(displayName);
      toListResult.add(photoUrl);
      toListResult.add(phoneNumber);
      toListResult.add(isAnonymous);
      toListResult.add(isEmailVerified);
      toListResult.add(providerId);
      toListResult.add(tenantId);
      toListResult.add(refreshToken);
      toListResult.add(creationTimestamp);
      toListResult.add(lastSignInTimestamp);
      return toListResult;
    }

    static @NonNull PigeonUserInfo fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonUserInfo pigeonResult = new PigeonUserInfo();
      Object uid = __pigeon_list.get(0);
      pigeonResult.setUid((String) uid);
      Object email = __pigeon_list.get(1);
      pigeonResult.setEmail((String) email);
      Object displayName = __pigeon_list.get(2);
      pigeonResult.setDisplayName((String) displayName);
      Object photoUrl = __pigeon_list.get(3);
      pigeonResult.setPhotoUrl((String) photoUrl);
      Object phoneNumber = __pigeon_list.get(4);
      pigeonResult.setPhoneNumber((String) phoneNumber);
      Object isAnonymous = __pigeon_list.get(5);
      pigeonResult.setIsAnonymous((Boolean) isAnonymous);
      Object isEmailVerified = __pigeon_list.get(6);
      pigeonResult.setIsEmailVerified((Boolean) isEmailVerified);
      Object providerId = __pigeon_list.get(7);
      pigeonResult.setProviderId((String) providerId);
      Object tenantId = __pigeon_list.get(8);
      pigeonResult.setTenantId((String) tenantId);
      Object refreshToken = __pigeon_list.get(9);
      pigeonResult.setRefreshToken((String) refreshToken);
      Object creationTimestamp = __pigeon_list.get(10);
      pigeonResult.setCreationTimestamp(
          (creationTimestamp == null)
              ? null
              : ((creationTimestamp instanceof Integer)
                  ? (Integer) creationTimestamp
                  : (Long) creationTimestamp));
      Object lastSignInTimestamp = __pigeon_list.get(11);
      pigeonResult.setLastSignInTimestamp(
          (lastSignInTimestamp == null)
              ? null
              : ((lastSignInTimestamp instanceof Integer)
                  ? (Integer) lastSignInTimestamp
                  : (Long) lastSignInTimestamp));
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonUserDetails {
    private @NonNull PigeonUserInfo userInfo;

    public @NonNull PigeonUserInfo getUserInfo() {
      return userInfo;
    }

    public void setUserInfo(@NonNull PigeonUserInfo setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"userInfo\" is null.");
      }
      this.userInfo = setterArg;
    }

    private @NonNull List<Map<Object, Object>> providerData;

    public @NonNull List<Map<Object, Object>> getProviderData() {
      return providerData;
    }

    public void setProviderData(@NonNull List<Map<Object, Object>> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"providerData\" is null.");
      }
      this.providerData = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonUserDetails() {}

    public static final class Builder {

      private @Nullable PigeonUserInfo userInfo;

      @CanIgnoreReturnValue
      public @NonNull Builder setUserInfo(@NonNull PigeonUserInfo setterArg) {
        this.userInfo = setterArg;
        return this;
      }

      private @Nullable List<Map<Object, Object>> providerData;

      @CanIgnoreReturnValue
      public @NonNull Builder setProviderData(@NonNull List<Map<Object, Object>> setterArg) {
        this.providerData = setterArg;
        return this;
      }

      public @NonNull PigeonUserDetails build() {
        PigeonUserDetails pigeonReturn = new PigeonUserDetails();
        pigeonReturn.setUserInfo(userInfo);
        pigeonReturn.setProviderData(providerData);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(userInfo);
      toListResult.add(providerData);
      return toListResult;
    }

    static @NonNull PigeonUserDetails fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonUserDetails pigeonResult = new PigeonUserDetails();
      Object userInfo = __pigeon_list.get(0);
      pigeonResult.setUserInfo((PigeonUserInfo) userInfo);
      Object providerData = __pigeon_list.get(1);
      pigeonResult.setProviderData((List<Map<Object, Object>>) providerData);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonUserCredential {
    private @Nullable PigeonUserDetails user;

    public @Nullable PigeonUserDetails getUser() {
      return user;
    }

    public void setUser(@Nullable PigeonUserDetails setterArg) {
      this.user = setterArg;
    }

    private @Nullable PigeonAdditionalUserInfo additionalUserInfo;

    public @Nullable PigeonAdditionalUserInfo getAdditionalUserInfo() {
      return additionalUserInfo;
    }

    public void setAdditionalUserInfo(@Nullable PigeonAdditionalUserInfo setterArg) {
      this.additionalUserInfo = setterArg;
    }

    private @Nullable PigeonAuthCredential credential;

    public @Nullable PigeonAuthCredential getCredential() {
      return credential;
    }

    public void setCredential(@Nullable PigeonAuthCredential setterArg) {
      this.credential = setterArg;
    }

    public static final class Builder {

      private @Nullable PigeonUserDetails user;

      @CanIgnoreReturnValue
      public @NonNull Builder setUser(@Nullable PigeonUserDetails setterArg) {
        this.user = setterArg;
        return this;
      }

      private @Nullable PigeonAdditionalUserInfo additionalUserInfo;

      @CanIgnoreReturnValue
      public @NonNull Builder setAdditionalUserInfo(@Nullable PigeonAdditionalUserInfo setterArg) {
        this.additionalUserInfo = setterArg;
        return this;
      }

      private @Nullable PigeonAuthCredential credential;

      @CanIgnoreReturnValue
      public @NonNull Builder setCredential(@Nullable PigeonAuthCredential setterArg) {
        this.credential = setterArg;
        return this;
      }

      public @NonNull PigeonUserCredential build() {
        PigeonUserCredential pigeonReturn = new PigeonUserCredential();
        pigeonReturn.setUser(user);
        pigeonReturn.setAdditionalUserInfo(additionalUserInfo);
        pigeonReturn.setCredential(credential);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(user);
      toListResult.add(additionalUserInfo);
      toListResult.add(credential);
      return toListResult;
    }

    static @NonNull PigeonUserCredential fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonUserCredential pigeonResult = new PigeonUserCredential();
      Object user = __pigeon_list.get(0);
      pigeonResult.setUser((PigeonUserDetails) user);
      Object additionalUserInfo = __pigeon_list.get(1);
      pigeonResult.setAdditionalUserInfo((PigeonAdditionalUserInfo) additionalUserInfo);
      Object credential = __pigeon_list.get(2);
      pigeonResult.setCredential((PigeonAuthCredential) credential);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonActionCodeSettings {
    private @NonNull String url;

    public @NonNull String getUrl() {
      return url;
    }

    public void setUrl(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"url\" is null.");
      }
      this.url = setterArg;
    }

    private @Nullable String dynamicLinkDomain;

    public @Nullable String getDynamicLinkDomain() {
      return dynamicLinkDomain;
    }

    public void setDynamicLinkDomain(@Nullable String setterArg) {
      this.dynamicLinkDomain = setterArg;
    }

    private @NonNull Boolean handleCodeInApp;

    public @NonNull Boolean getHandleCodeInApp() {
      return handleCodeInApp;
    }

    public void setHandleCodeInApp(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"handleCodeInApp\" is null.");
      }
      this.handleCodeInApp = setterArg;
    }

    private @Nullable String iOSBundleId;

    public @Nullable String getIOSBundleId() {
      return iOSBundleId;
    }

    public void setIOSBundleId(@Nullable String setterArg) {
      this.iOSBundleId = setterArg;
    }

    private @Nullable String androidPackageName;

    public @Nullable String getAndroidPackageName() {
      return androidPackageName;
    }

    public void setAndroidPackageName(@Nullable String setterArg) {
      this.androidPackageName = setterArg;
    }

    private @NonNull Boolean androidInstallApp;

    public @NonNull Boolean getAndroidInstallApp() {
      return androidInstallApp;
    }

    public void setAndroidInstallApp(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"androidInstallApp\" is null.");
      }
      this.androidInstallApp = setterArg;
    }

    private @Nullable String androidMinimumVersion;

    public @Nullable String getAndroidMinimumVersion() {
      return androidMinimumVersion;
    }

    public void setAndroidMinimumVersion(@Nullable String setterArg) {
      this.androidMinimumVersion = setterArg;
    }

    private @Nullable String linkDomain;

    public @Nullable String getLinkDomain() {
      return linkDomain;
    }

    public void setLinkDomain(@Nullable String setterArg) {
      this.linkDomain = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonActionCodeSettings() {}

    public static final class Builder {

      private @Nullable String url;

      @CanIgnoreReturnValue
      public @NonNull Builder setUrl(@NonNull String setterArg) {
        this.url = setterArg;
        return this;
      }

      private @Nullable String dynamicLinkDomain;

      @CanIgnoreReturnValue
      public @NonNull Builder setDynamicLinkDomain(@Nullable String setterArg) {
        this.dynamicLinkDomain = setterArg;
        return this;
      }

      private @Nullable Boolean handleCodeInApp;

      @CanIgnoreReturnValue
      public @NonNull Builder setHandleCodeInApp(@NonNull Boolean setterArg) {
        this.handleCodeInApp = setterArg;
        return this;
      }

      private @Nullable String iOSBundleId;

      @CanIgnoreReturnValue
      public @NonNull Builder setIOSBundleId(@Nullable String setterArg) {
        this.iOSBundleId = setterArg;
        return this;
      }

      private @Nullable String androidPackageName;

      @CanIgnoreReturnValue
      public @NonNull Builder setAndroidPackageName(@Nullable String setterArg) {
        this.androidPackageName = setterArg;
        return this;
      }

      private @Nullable Boolean androidInstallApp;

      @CanIgnoreReturnValue
      public @NonNull Builder setAndroidInstallApp(@NonNull Boolean setterArg) {
        this.androidInstallApp = setterArg;
        return this;
      }

      private @Nullable String androidMinimumVersion;

      @CanIgnoreReturnValue
      public @NonNull Builder setAndroidMinimumVersion(@Nullable String setterArg) {
        this.androidMinimumVersion = setterArg;
        return this;
      }

      private @Nullable String linkDomain;

      @CanIgnoreReturnValue
      public @NonNull Builder setLinkDomain(@Nullable String setterArg) {
        this.linkDomain = setterArg;
        return this;
      }

      public @NonNull PigeonActionCodeSettings build() {
        PigeonActionCodeSettings pigeonReturn = new PigeonActionCodeSettings();
        pigeonReturn.setUrl(url);
        pigeonReturn.setDynamicLinkDomain(dynamicLinkDomain);
        pigeonReturn.setHandleCodeInApp(handleCodeInApp);
        pigeonReturn.setIOSBundleId(iOSBundleId);
        pigeonReturn.setAndroidPackageName(androidPackageName);
        pigeonReturn.setAndroidInstallApp(androidInstallApp);
        pigeonReturn.setAndroidMinimumVersion(androidMinimumVersion);
        pigeonReturn.setLinkDomain(linkDomain);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(8);
      toListResult.add(url);
      toListResult.add(dynamicLinkDomain);
      toListResult.add(handleCodeInApp);
      toListResult.add(iOSBundleId);
      toListResult.add(androidPackageName);
      toListResult.add(androidInstallApp);
      toListResult.add(androidMinimumVersion);
      toListResult.add(linkDomain);
      return toListResult;
    }

    static @NonNull PigeonActionCodeSettings fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonActionCodeSettings pigeonResult = new PigeonActionCodeSettings();
      Object url = __pigeon_list.get(0);
      pigeonResult.setUrl((String) url);
      Object dynamicLinkDomain = __pigeon_list.get(1);
      pigeonResult.setDynamicLinkDomain((String) dynamicLinkDomain);
      Object handleCodeInApp = __pigeon_list.get(2);
      pigeonResult.setHandleCodeInApp((Boolean) handleCodeInApp);
      Object iOSBundleId = __pigeon_list.get(3);
      pigeonResult.setIOSBundleId((String) iOSBundleId);
      Object androidPackageName = __pigeon_list.get(4);
      pigeonResult.setAndroidPackageName((String) androidPackageName);
      Object androidInstallApp = __pigeon_list.get(5);
      pigeonResult.setAndroidInstallApp((Boolean) androidInstallApp);
      Object androidMinimumVersion = __pigeon_list.get(6);
      pigeonResult.setAndroidMinimumVersion((String) androidMinimumVersion);
      Object linkDomain = __pigeon_list.get(7);
      pigeonResult.setLinkDomain((String) linkDomain);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonFirebaseAuthSettings {
    private @NonNull Boolean appVerificationDisabledForTesting;

    public @NonNull Boolean getAppVerificationDisabledForTesting() {
      return appVerificationDisabledForTesting;
    }

    public void setAppVerificationDisabledForTesting(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException(
            "Nonnull field \"appVerificationDisabledForTesting\" is null.");
      }
      this.appVerificationDisabledForTesting = setterArg;
    }

    private @Nullable String userAccessGroup;

    public @Nullable String getUserAccessGroup() {
      return userAccessGroup;
    }

    public void setUserAccessGroup(@Nullable String setterArg) {
      this.userAccessGroup = setterArg;
    }

    private @Nullable String phoneNumber;

    public @Nullable String getPhoneNumber() {
      return phoneNumber;
    }

    public void setPhoneNumber(@Nullable String setterArg) {
      this.phoneNumber = setterArg;
    }

    private @Nullable String smsCode;

    public @Nullable String getSmsCode() {
      return smsCode;
    }

    public void setSmsCode(@Nullable String setterArg) {
      this.smsCode = setterArg;
    }

    private @Nullable Boolean forceRecaptchaFlow;

    public @Nullable Boolean getForceRecaptchaFlow() {
      return forceRecaptchaFlow;
    }

    public void setForceRecaptchaFlow(@Nullable Boolean setterArg) {
      this.forceRecaptchaFlow = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonFirebaseAuthSettings() {}

    public static final class Builder {

      private @Nullable Boolean appVerificationDisabledForTesting;

      @CanIgnoreReturnValue
      public @NonNull Builder setAppVerificationDisabledForTesting(@NonNull Boolean setterArg) {
        this.appVerificationDisabledForTesting = setterArg;
        return this;
      }

      private @Nullable String userAccessGroup;

      @CanIgnoreReturnValue
      public @NonNull Builder setUserAccessGroup(@Nullable String setterArg) {
        this.userAccessGroup = setterArg;
        return this;
      }

      private @Nullable String phoneNumber;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhoneNumber(@Nullable String setterArg) {
        this.phoneNumber = setterArg;
        return this;
      }

      private @Nullable String smsCode;

      @CanIgnoreReturnValue
      public @NonNull Builder setSmsCode(@Nullable String setterArg) {
        this.smsCode = setterArg;
        return this;
      }

      private @Nullable Boolean forceRecaptchaFlow;

      @CanIgnoreReturnValue
      public @NonNull Builder setForceRecaptchaFlow(@Nullable Boolean setterArg) {
        this.forceRecaptchaFlow = setterArg;
        return this;
      }

      public @NonNull PigeonFirebaseAuthSettings build() {
        PigeonFirebaseAuthSettings pigeonReturn = new PigeonFirebaseAuthSettings();
        pigeonReturn.setAppVerificationDisabledForTesting(appVerificationDisabledForTesting);
        pigeonReturn.setUserAccessGroup(userAccessGroup);
        pigeonReturn.setPhoneNumber(phoneNumber);
        pigeonReturn.setSmsCode(smsCode);
        pigeonReturn.setForceRecaptchaFlow(forceRecaptchaFlow);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(appVerificationDisabledForTesting);
      toListResult.add(userAccessGroup);
      toListResult.add(phoneNumber);
      toListResult.add(smsCode);
      toListResult.add(forceRecaptchaFlow);
      return toListResult;
    }

    static @NonNull PigeonFirebaseAuthSettings fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonFirebaseAuthSettings pigeonResult = new PigeonFirebaseAuthSettings();
      Object appVerificationDisabledForTesting = __pigeon_list.get(0);
      pigeonResult.setAppVerificationDisabledForTesting(
          (Boolean) appVerificationDisabledForTesting);
      Object userAccessGroup = __pigeon_list.get(1);
      pigeonResult.setUserAccessGroup((String) userAccessGroup);
      Object phoneNumber = __pigeon_list.get(2);
      pigeonResult.setPhoneNumber((String) phoneNumber);
      Object smsCode = __pigeon_list.get(3);
      pigeonResult.setSmsCode((String) smsCode);
      Object forceRecaptchaFlow = __pigeon_list.get(4);
      pigeonResult.setForceRecaptchaFlow((Boolean) forceRecaptchaFlow);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonSignInProvider {
    private @NonNull String providerId;

    public @NonNull String getProviderId() {
      return providerId;
    }

    public void setProviderId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"providerId\" is null.");
      }
      this.providerId = setterArg;
    }

    private @Nullable List<String> scopes;

    public @Nullable List<String> getScopes() {
      return scopes;
    }

    public void setScopes(@Nullable List<String> setterArg) {
      this.scopes = setterArg;
    }

    private @Nullable Map<String, String> customParameters;

    public @Nullable Map<String, String> getCustomParameters() {
      return customParameters;
    }

    public void setCustomParameters(@Nullable Map<String, String> setterArg) {
      this.customParameters = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonSignInProvider() {}

    public static final class Builder {

      private @Nullable String providerId;

      @CanIgnoreReturnValue
      public @NonNull Builder setProviderId(@NonNull String setterArg) {
        this.providerId = setterArg;
        return this;
      }

      private @Nullable List<String> scopes;

      @CanIgnoreReturnValue
      public @NonNull Builder setScopes(@Nullable List<String> setterArg) {
        this.scopes = setterArg;
        return this;
      }

      private @Nullable Map<String, String> customParameters;

      @CanIgnoreReturnValue
      public @NonNull Builder setCustomParameters(@Nullable Map<String, String> setterArg) {
        this.customParameters = setterArg;
        return this;
      }

      public @NonNull PigeonSignInProvider build() {
        PigeonSignInProvider pigeonReturn = new PigeonSignInProvider();
        pigeonReturn.setProviderId(providerId);
        pigeonReturn.setScopes(scopes);
        pigeonReturn.setCustomParameters(customParameters);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(providerId);
      toListResult.add(scopes);
      toListResult.add(customParameters);
      return toListResult;
    }

    static @NonNull PigeonSignInProvider fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonSignInProvider pigeonResult = new PigeonSignInProvider();
      Object providerId = __pigeon_list.get(0);
      pigeonResult.setProviderId((String) providerId);
      Object scopes = __pigeon_list.get(1);
      pigeonResult.setScopes((List<String>) scopes);
      Object customParameters = __pigeon_list.get(2);
      pigeonResult.setCustomParameters((Map<String, String>) customParameters);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonVerifyPhoneNumberRequest {
    private @Nullable String phoneNumber;

    public @Nullable String getPhoneNumber() {
      return phoneNumber;
    }

    public void setPhoneNumber(@Nullable String setterArg) {
      this.phoneNumber = setterArg;
    }

    private @NonNull Long timeout;

    public @NonNull Long getTimeout() {
      return timeout;
    }

    public void setTimeout(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"timeout\" is null.");
      }
      this.timeout = setterArg;
    }

    private @Nullable Long forceResendingToken;

    public @Nullable Long getForceResendingToken() {
      return forceResendingToken;
    }

    public void setForceResendingToken(@Nullable Long setterArg) {
      this.forceResendingToken = setterArg;
    }

    private @Nullable String autoRetrievedSmsCodeForTesting;

    public @Nullable String getAutoRetrievedSmsCodeForTesting() {
      return autoRetrievedSmsCodeForTesting;
    }

    public void setAutoRetrievedSmsCodeForTesting(@Nullable String setterArg) {
      this.autoRetrievedSmsCodeForTesting = setterArg;
    }

    private @Nullable String multiFactorInfoId;

    public @Nullable String getMultiFactorInfoId() {
      return multiFactorInfoId;
    }

    public void setMultiFactorInfoId(@Nullable String setterArg) {
      this.multiFactorInfoId = setterArg;
    }

    private @Nullable String multiFactorSessionId;

    public @Nullable String getMultiFactorSessionId() {
      return multiFactorSessionId;
    }

    public void setMultiFactorSessionId(@Nullable String setterArg) {
      this.multiFactorSessionId = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonVerifyPhoneNumberRequest() {}

    public static final class Builder {

      private @Nullable String phoneNumber;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhoneNumber(@Nullable String setterArg) {
        this.phoneNumber = setterArg;
        return this;
      }

      private @Nullable Long timeout;

      @CanIgnoreReturnValue
      public @NonNull Builder setTimeout(@NonNull Long setterArg) {
        this.timeout = setterArg;
        return this;
      }

      private @Nullable Long forceResendingToken;

      @CanIgnoreReturnValue
      public @NonNull Builder setForceResendingToken(@Nullable Long setterArg) {
        this.forceResendingToken = setterArg;
        return this;
      }

      private @Nullable String autoRetrievedSmsCodeForTesting;

      @CanIgnoreReturnValue
      public @NonNull Builder setAutoRetrievedSmsCodeForTesting(@Nullable String setterArg) {
        this.autoRetrievedSmsCodeForTesting = setterArg;
        return this;
      }

      private @Nullable String multiFactorInfoId;

      @CanIgnoreReturnValue
      public @NonNull Builder setMultiFactorInfoId(@Nullable String setterArg) {
        this.multiFactorInfoId = setterArg;
        return this;
      }

      private @Nullable String multiFactorSessionId;

      @CanIgnoreReturnValue
      public @NonNull Builder setMultiFactorSessionId(@Nullable String setterArg) {
        this.multiFactorSessionId = setterArg;
        return this;
      }

      public @NonNull PigeonVerifyPhoneNumberRequest build() {
        PigeonVerifyPhoneNumberRequest pigeonReturn = new PigeonVerifyPhoneNumberRequest();
        pigeonReturn.setPhoneNumber(phoneNumber);
        pigeonReturn.setTimeout(timeout);
        pigeonReturn.setForceResendingToken(forceResendingToken);
        pigeonReturn.setAutoRetrievedSmsCodeForTesting(autoRetrievedSmsCodeForTesting);
        pigeonReturn.setMultiFactorInfoId(multiFactorInfoId);
        pigeonReturn.setMultiFactorSessionId(multiFactorSessionId);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(phoneNumber);
      toListResult.add(timeout);
      toListResult.add(forceResendingToken);
      toListResult.add(autoRetrievedSmsCodeForTesting);
      toListResult.add(multiFactorInfoId);
      toListResult.add(multiFactorSessionId);
      return toListResult;
    }

    static @NonNull PigeonVerifyPhoneNumberRequest fromList(
        @NonNull ArrayList<Object> __pigeon_list) {
      PigeonVerifyPhoneNumberRequest pigeonResult = new PigeonVerifyPhoneNumberRequest();
      Object phoneNumber = __pigeon_list.get(0);
      pigeonResult.setPhoneNumber((String) phoneNumber);
      Object timeout = __pigeon_list.get(1);
      pigeonResult.setTimeout(
          (timeout == null)
              ? null
              : ((timeout instanceof Integer) ? (Integer) timeout : (Long) timeout));
      Object forceResendingToken = __pigeon_list.get(2);
      pigeonResult.setForceResendingToken(
          (forceResendingToken == null)
              ? null
              : ((forceResendingToken instanceof Integer)
                  ? (Integer) forceResendingToken
                  : (Long) forceResendingToken));
      Object autoRetrievedSmsCodeForTesting = __pigeon_list.get(3);
      pigeonResult.setAutoRetrievedSmsCodeForTesting((String) autoRetrievedSmsCodeForTesting);
      Object multiFactorInfoId = __pigeon_list.get(4);
      pigeonResult.setMultiFactorInfoId((String) multiFactorInfoId);
      Object multiFactorSessionId = __pigeon_list.get(5);
      pigeonResult.setMultiFactorSessionId((String) multiFactorSessionId);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonIdTokenResult {
    private @Nullable String token;

    public @Nullable String getToken() {
      return token;
    }

    public void setToken(@Nullable String setterArg) {
      this.token = setterArg;
    }

    private @Nullable Long expirationTimestamp;

    public @Nullable Long getExpirationTimestamp() {
      return expirationTimestamp;
    }

    public void setExpirationTimestamp(@Nullable Long setterArg) {
      this.expirationTimestamp = setterArg;
    }

    private @Nullable Long authTimestamp;

    public @Nullable Long getAuthTimestamp() {
      return authTimestamp;
    }

    public void setAuthTimestamp(@Nullable Long setterArg) {
      this.authTimestamp = setterArg;
    }

    private @Nullable Long issuedAtTimestamp;

    public @Nullable Long getIssuedAtTimestamp() {
      return issuedAtTimestamp;
    }

    public void setIssuedAtTimestamp(@Nullable Long setterArg) {
      this.issuedAtTimestamp = setterArg;
    }

    private @Nullable String signInProvider;

    public @Nullable String getSignInProvider() {
      return signInProvider;
    }

    public void setSignInProvider(@Nullable String setterArg) {
      this.signInProvider = setterArg;
    }

    private @Nullable Map<String, Object> claims;

    public @Nullable Map<String, Object> getClaims() {
      return claims;
    }

    public void setClaims(@Nullable Map<String, Object> setterArg) {
      this.claims = setterArg;
    }

    private @Nullable String signInSecondFactor;

    public @Nullable String getSignInSecondFactor() {
      return signInSecondFactor;
    }

    public void setSignInSecondFactor(@Nullable String setterArg) {
      this.signInSecondFactor = setterArg;
    }

    public static final class Builder {

      private @Nullable String token;

      @CanIgnoreReturnValue
      public @NonNull Builder setToken(@Nullable String setterArg) {
        this.token = setterArg;
        return this;
      }

      private @Nullable Long expirationTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setExpirationTimestamp(@Nullable Long setterArg) {
        this.expirationTimestamp = setterArg;
        return this;
      }

      private @Nullable Long authTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setAuthTimestamp(@Nullable Long setterArg) {
        this.authTimestamp = setterArg;
        return this;
      }

      private @Nullable Long issuedAtTimestamp;

      @CanIgnoreReturnValue
      public @NonNull Builder setIssuedAtTimestamp(@Nullable Long setterArg) {
        this.issuedAtTimestamp = setterArg;
        return this;
      }

      private @Nullable String signInProvider;

      @CanIgnoreReturnValue
      public @NonNull Builder setSignInProvider(@Nullable String setterArg) {
        this.signInProvider = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> claims;

      @CanIgnoreReturnValue
      public @NonNull Builder setClaims(@Nullable Map<String, Object> setterArg) {
        this.claims = setterArg;
        return this;
      }

      private @Nullable String signInSecondFactor;

      @CanIgnoreReturnValue
      public @NonNull Builder setSignInSecondFactor(@Nullable String setterArg) {
        this.signInSecondFactor = setterArg;
        return this;
      }

      public @NonNull PigeonIdTokenResult build() {
        PigeonIdTokenResult pigeonReturn = new PigeonIdTokenResult();
        pigeonReturn.setToken(token);
        pigeonReturn.setExpirationTimestamp(expirationTimestamp);
        pigeonReturn.setAuthTimestamp(authTimestamp);
        pigeonReturn.setIssuedAtTimestamp(issuedAtTimestamp);
        pigeonReturn.setSignInProvider(signInProvider);
        pigeonReturn.setClaims(claims);
        pigeonReturn.setSignInSecondFactor(signInSecondFactor);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(7);
      toListResult.add(token);
      toListResult.add(expirationTimestamp);
      toListResult.add(authTimestamp);
      toListResult.add(issuedAtTimestamp);
      toListResult.add(signInProvider);
      toListResult.add(claims);
      toListResult.add(signInSecondFactor);
      return toListResult;
    }

    static @NonNull PigeonIdTokenResult fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonIdTokenResult pigeonResult = new PigeonIdTokenResult();
      Object token = __pigeon_list.get(0);
      pigeonResult.setToken((String) token);
      Object expirationTimestamp = __pigeon_list.get(1);
      pigeonResult.setExpirationTimestamp(
          (expirationTimestamp == null)
              ? null
              : ((expirationTimestamp instanceof Integer)
                  ? (Integer) expirationTimestamp
                  : (Long) expirationTimestamp));
      Object authTimestamp = __pigeon_list.get(2);
      pigeonResult.setAuthTimestamp(
          (authTimestamp == null)
              ? null
              : ((authTimestamp instanceof Integer)
                  ? (Integer) authTimestamp
                  : (Long) authTimestamp));
      Object issuedAtTimestamp = __pigeon_list.get(3);
      pigeonResult.setIssuedAtTimestamp(
          (issuedAtTimestamp == null)
              ? null
              : ((issuedAtTimestamp instanceof Integer)
                  ? (Integer) issuedAtTimestamp
                  : (Long) issuedAtTimestamp));
      Object signInProvider = __pigeon_list.get(4);
      pigeonResult.setSignInProvider((String) signInProvider);
      Object claims = __pigeon_list.get(5);
      pigeonResult.setClaims((Map<String, Object>) claims);
      Object signInSecondFactor = __pigeon_list.get(6);
      pigeonResult.setSignInSecondFactor((String) signInSecondFactor);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonUserProfile {
    private @Nullable String displayName;

    public @Nullable String getDisplayName() {
      return displayName;
    }

    public void setDisplayName(@Nullable String setterArg) {
      this.displayName = setterArg;
    }

    private @Nullable String photoUrl;

    public @Nullable String getPhotoUrl() {
      return photoUrl;
    }

    public void setPhotoUrl(@Nullable String setterArg) {
      this.photoUrl = setterArg;
    }

    private @NonNull Boolean displayNameChanged;

    public @NonNull Boolean getDisplayNameChanged() {
      return displayNameChanged;
    }

    public void setDisplayNameChanged(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"displayNameChanged\" is null.");
      }
      this.displayNameChanged = setterArg;
    }

    private @NonNull Boolean photoUrlChanged;

    public @NonNull Boolean getPhotoUrlChanged() {
      return photoUrlChanged;
    }

    public void setPhotoUrlChanged(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"photoUrlChanged\" is null.");
      }
      this.photoUrlChanged = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonUserProfile() {}

    public static final class Builder {

      private @Nullable String displayName;

      @CanIgnoreReturnValue
      public @NonNull Builder setDisplayName(@Nullable String setterArg) {
        this.displayName = setterArg;
        return this;
      }

      private @Nullable String photoUrl;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhotoUrl(@Nullable String setterArg) {
        this.photoUrl = setterArg;
        return this;
      }

      private @Nullable Boolean displayNameChanged;

      @CanIgnoreReturnValue
      public @NonNull Builder setDisplayNameChanged(@NonNull Boolean setterArg) {
        this.displayNameChanged = setterArg;
        return this;
      }

      private @Nullable Boolean photoUrlChanged;

      @CanIgnoreReturnValue
      public @NonNull Builder setPhotoUrlChanged(@NonNull Boolean setterArg) {
        this.photoUrlChanged = setterArg;
        return this;
      }

      public @NonNull PigeonUserProfile build() {
        PigeonUserProfile pigeonReturn = new PigeonUserProfile();
        pigeonReturn.setDisplayName(displayName);
        pigeonReturn.setPhotoUrl(photoUrl);
        pigeonReturn.setDisplayNameChanged(displayNameChanged);
        pigeonReturn.setPhotoUrlChanged(photoUrlChanged);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(displayName);
      toListResult.add(photoUrl);
      toListResult.add(displayNameChanged);
      toListResult.add(photoUrlChanged);
      return toListResult;
    }

    static @NonNull PigeonUserProfile fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonUserProfile pigeonResult = new PigeonUserProfile();
      Object displayName = __pigeon_list.get(0);
      pigeonResult.setDisplayName((String) displayName);
      Object photoUrl = __pigeon_list.get(1);
      pigeonResult.setPhotoUrl((String) photoUrl);
      Object displayNameChanged = __pigeon_list.get(2);
      pigeonResult.setDisplayNameChanged((Boolean) displayNameChanged);
      Object photoUrlChanged = __pigeon_list.get(3);
      pigeonResult.setPhotoUrlChanged((Boolean) photoUrlChanged);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PigeonTotpSecret {
    private @Nullable Long codeIntervalSeconds;

    public @Nullable Long getCodeIntervalSeconds() {
      return codeIntervalSeconds;
    }

    public void setCodeIntervalSeconds(@Nullable Long setterArg) {
      this.codeIntervalSeconds = setterArg;
    }

    private @Nullable Long codeLength;

    public @Nullable Long getCodeLength() {
      return codeLength;
    }

    public void setCodeLength(@Nullable Long setterArg) {
      this.codeLength = setterArg;
    }

    private @Nullable Long enrollmentCompletionDeadline;

    public @Nullable Long getEnrollmentCompletionDeadline() {
      return enrollmentCompletionDeadline;
    }

    public void setEnrollmentCompletionDeadline(@Nullable Long setterArg) {
      this.enrollmentCompletionDeadline = setterArg;
    }

    private @Nullable String hashingAlgorithm;

    public @Nullable String getHashingAlgorithm() {
      return hashingAlgorithm;
    }

    public void setHashingAlgorithm(@Nullable String setterArg) {
      this.hashingAlgorithm = setterArg;
    }

    private @NonNull String secretKey;

    public @NonNull String getSecretKey() {
      return secretKey;
    }

    public void setSecretKey(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"secretKey\" is null.");
      }
      this.secretKey = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PigeonTotpSecret() {}

    public static final class Builder {

      private @Nullable Long codeIntervalSeconds;

      @CanIgnoreReturnValue
      public @NonNull Builder setCodeIntervalSeconds(@Nullable Long setterArg) {
        this.codeIntervalSeconds = setterArg;
        return this;
      }

      private @Nullable Long codeLength;

      @CanIgnoreReturnValue
      public @NonNull Builder setCodeLength(@Nullable Long setterArg) {
        this.codeLength = setterArg;
        return this;
      }

      private @Nullable Long enrollmentCompletionDeadline;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnrollmentCompletionDeadline(@Nullable Long setterArg) {
        this.enrollmentCompletionDeadline = setterArg;
        return this;
      }

      private @Nullable String hashingAlgorithm;

      @CanIgnoreReturnValue
      public @NonNull Builder setHashingAlgorithm(@Nullable String setterArg) {
        this.hashingAlgorithm = setterArg;
        return this;
      }

      private @Nullable String secretKey;

      @CanIgnoreReturnValue
      public @NonNull Builder setSecretKey(@NonNull String setterArg) {
        this.secretKey = setterArg;
        return this;
      }

      public @NonNull PigeonTotpSecret build() {
        PigeonTotpSecret pigeonReturn = new PigeonTotpSecret();
        pigeonReturn.setCodeIntervalSeconds(codeIntervalSeconds);
        pigeonReturn.setCodeLength(codeLength);
        pigeonReturn.setEnrollmentCompletionDeadline(enrollmentCompletionDeadline);
        pigeonReturn.setHashingAlgorithm(hashingAlgorithm);
        pigeonReturn.setSecretKey(secretKey);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(codeIntervalSeconds);
      toListResult.add(codeLength);
      toListResult.add(enrollmentCompletionDeadline);
      toListResult.add(hashingAlgorithm);
      toListResult.add(secretKey);
      return toListResult;
    }

    static @NonNull PigeonTotpSecret fromList(@NonNull ArrayList<Object> __pigeon_list) {
      PigeonTotpSecret pigeonResult = new PigeonTotpSecret();
      Object codeIntervalSeconds = __pigeon_list.get(0);
      pigeonResult.setCodeIntervalSeconds(
          (codeIntervalSeconds == null)
              ? null
              : ((codeIntervalSeconds instanceof Integer)
                  ? (Integer) codeIntervalSeconds
                  : (Long) codeIntervalSeconds));
      Object codeLength = __pigeon_list.get(1);
      pigeonResult.setCodeLength(
          (codeLength == null)
              ? null
              : ((codeLength instanceof Integer) ? (Integer) codeLength : (Long) codeLength));
      Object enrollmentCompletionDeadline = __pigeon_list.get(2);
      pigeonResult.setEnrollmentCompletionDeadline(
          (enrollmentCompletionDeadline == null)
              ? null
              : ((enrollmentCompletionDeadline instanceof Integer)
                  ? (Integer) enrollmentCompletionDeadline
                  : (Long) enrollmentCompletionDeadline));
      Object hashingAlgorithm = __pigeon_list.get(3);
      pigeonResult.setHashingAlgorithm((String) hashingAlgorithm);
      Object secretKey = __pigeon_list.get(4);
      pigeonResult.setSecretKey((String) secretKey);
      return pigeonResult;
    }
  }

  /** Asynchronous error handling return type for non-nullable API method returns. */
  public interface Result<T> {
    /** Success case callback method for handling returns. */
    void success(@NonNull T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for nullable API method returns. */
  public interface NullableResult<T> {
    /** Success case callback method for handling returns. */
    void success(@Nullable T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for void API method returns. */
  public interface VoidResult {
    /** Success case callback method for handling returns. */
    void success();

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }

  private static class FirebaseAuthHostApiCodec extends StandardMessageCodec {
    public static final FirebaseAuthHostApiCodec INSTANCE = new FirebaseAuthHostApiCodec();

    private FirebaseAuthHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AuthPigeonFirebaseApp.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PigeonActionCodeInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return PigeonActionCodeInfoData.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return PigeonActionCodeSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return PigeonAdditionalUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return PigeonAuthCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return PigeonFirebaseAuthSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return PigeonIdTokenResult.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return PigeonMultiFactorInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return PigeonMultiFactorSession.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return PigeonPhoneMultiFactorAssertion.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return PigeonSignInProvider.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return PigeonTotpSecret.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return PigeonUserCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return PigeonUserDetails.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return PigeonUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return PigeonUserProfile.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return PigeonVerifyPhoneNumberRequest.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AuthPigeonFirebaseApp) {
        stream.write(128);
        writeValue(stream, ((AuthPigeonFirebaseApp) value).toList());
      } else if (value instanceof PigeonActionCodeInfo) {
        stream.write(129);
        writeValue(stream, ((PigeonActionCodeInfo) value).toList());
      } else if (value instanceof PigeonActionCodeInfoData) {
        stream.write(130);
        writeValue(stream, ((PigeonActionCodeInfoData) value).toList());
      } else if (value instanceof PigeonActionCodeSettings) {
        stream.write(131);
        writeValue(stream, ((PigeonActionCodeSettings) value).toList());
      } else if (value instanceof PigeonAdditionalUserInfo) {
        stream.write(132);
        writeValue(stream, ((PigeonAdditionalUserInfo) value).toList());
      } else if (value instanceof PigeonAuthCredential) {
        stream.write(133);
        writeValue(stream, ((PigeonAuthCredential) value).toList());
      } else if (value instanceof PigeonFirebaseAuthSettings) {
        stream.write(134);
        writeValue(stream, ((PigeonFirebaseAuthSettings) value).toList());
      } else if (value instanceof PigeonIdTokenResult) {
        stream.write(135);
        writeValue(stream, ((PigeonIdTokenResult) value).toList());
      } else if (value instanceof PigeonMultiFactorInfo) {
        stream.write(136);
        writeValue(stream, ((PigeonMultiFactorInfo) value).toList());
      } else if (value instanceof PigeonMultiFactorSession) {
        stream.write(137);
        writeValue(stream, ((PigeonMultiFactorSession) value).toList());
      } else if (value instanceof PigeonPhoneMultiFactorAssertion) {
        stream.write(138);
        writeValue(stream, ((PigeonPhoneMultiFactorAssertion) value).toList());
      } else if (value instanceof PigeonSignInProvider) {
        stream.write(139);
        writeValue(stream, ((PigeonSignInProvider) value).toList());
      } else if (value instanceof PigeonTotpSecret) {
        stream.write(140);
        writeValue(stream, ((PigeonTotpSecret) value).toList());
      } else if (value instanceof PigeonUserCredential) {
        stream.write(141);
        writeValue(stream, ((PigeonUserCredential) value).toList());
      } else if (value instanceof PigeonUserDetails) {
        stream.write(142);
        writeValue(stream, ((PigeonUserDetails) value).toList());
      } else if (value instanceof PigeonUserInfo) {
        stream.write(143);
        writeValue(stream, ((PigeonUserInfo) value).toList());
      } else if (value instanceof PigeonUserProfile) {
        stream.write(144);
        writeValue(stream, ((PigeonUserProfile) value).toList());
      } else if (value instanceof PigeonVerifyPhoneNumberRequest) {
        stream.write(145);
        writeValue(stream, ((PigeonVerifyPhoneNumberRequest) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface FirebaseAuthHostApi {

    void registerIdTokenListener(
        @NonNull AuthPigeonFirebaseApp app, @NonNull Result<String> result);

    void registerAuthStateListener(
        @NonNull AuthPigeonFirebaseApp app, @NonNull Result<String> result);

    void useEmulator(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String host,
        @NonNull Long port,
        @NonNull VoidResult result);

    void applyActionCode(
        @NonNull AuthPigeonFirebaseApp app, @NonNull String code, @NonNull VoidResult result);

    void checkActionCode(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String code,
        @NonNull Result<PigeonActionCodeInfo> result);

    void confirmPasswordReset(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String code,
        @NonNull String newPassword,
        @NonNull VoidResult result);

    void createUserWithEmailAndPassword(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @NonNull String password,
        @NonNull Result<PigeonUserCredential> result);

    void signInAnonymously(
        @NonNull AuthPigeonFirebaseApp app, @NonNull Result<PigeonUserCredential> result);

    void signInWithCredential(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull Map<String, Object> input,
        @NonNull Result<PigeonUserCredential> result);

    void signInWithCustomToken(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String token,
        @NonNull Result<PigeonUserCredential> result);

    void signInWithEmailAndPassword(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @NonNull String password,
        @NonNull Result<PigeonUserCredential> result);

    void signInWithEmailLink(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @NonNull String emailLink,
        @NonNull Result<PigeonUserCredential> result);

    void signInWithProvider(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonSignInProvider signInProvider,
        @NonNull Result<PigeonUserCredential> result);

    void signOut(@NonNull AuthPigeonFirebaseApp app, @NonNull VoidResult result);

    void fetchSignInMethodsForEmail(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @NonNull Result<List<String>> result);

    void sendPasswordResetEmail(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @Nullable PigeonActionCodeSettings actionCodeSettings,
        @NonNull VoidResult result);

    void sendSignInLinkToEmail(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String email,
        @NonNull PigeonActionCodeSettings actionCodeSettings,
        @NonNull VoidResult result);

    void setLanguageCode(
        @NonNull AuthPigeonFirebaseApp app,
        @Nullable String languageCode,
        @NonNull Result<String> result);

    void setSettings(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonFirebaseAuthSettings settings,
        @NonNull VoidResult result);

    void verifyPasswordResetCode(
        @NonNull AuthPigeonFirebaseApp app, @NonNull String code, @NonNull Result<String> result);

    void verifyPhoneNumber(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonVerifyPhoneNumberRequest request,
        @NonNull Result<String> result);

    void revokeTokenWithAuthorizationCode(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String authorizationCode,
        @NonNull VoidResult result);

    void initializeRecaptchaConfig(@NonNull AuthPigeonFirebaseApp app, @NonNull VoidResult result);

    /** The codec used by FirebaseAuthHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return FirebaseAuthHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `FirebaseAuthHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable FirebaseAuthHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable FirebaseAuthHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.registerIdTokenListener"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.registerIdTokenListener(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.registerAuthStateListener"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.registerAuthStateListener(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.useEmulator"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String hostArg = (String) args.get(1);
                Number portArg = (Number) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.useEmulator(
                    appArg,
                    hostArg,
                    (portArg == null) ? null : portArg.longValue(),
                    resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.applyActionCode"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String codeArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.applyActionCode(appArg, codeArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.checkActionCode"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String codeArg = (String) args.get(1);
                Result<PigeonActionCodeInfo> resultCallback =
                    new Result<PigeonActionCodeInfo>() {
                      public void success(PigeonActionCodeInfo result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.checkActionCode(appArg, codeArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.confirmPasswordReset"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String codeArg = (String) args.get(1);
                String newPasswordArg = (String) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.confirmPasswordReset(appArg, codeArg, newPasswordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.createUserWithEmailAndPassword"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                String passwordArg = (String) args.get(2);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.createUserWithEmailAndPassword(appArg, emailArg, passwordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInAnonymously"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInAnonymously(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInWithCredential"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Map<String, Object> inputArg = (Map<String, Object>) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInWithCredential(appArg, inputArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInWithCustomToken"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String tokenArg = (String) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInWithCustomToken(appArg, tokenArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInWithEmailAndPassword"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                String passwordArg = (String) args.get(2);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInWithEmailAndPassword(appArg, emailArg, passwordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInWithEmailLink"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                String emailLinkArg = (String) args.get(2);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInWithEmailLink(appArg, emailArg, emailLinkArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signInWithProvider"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonSignInProvider signInProviderArg = (PigeonSignInProvider) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signInWithProvider(appArg, signInProviderArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.signOut"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.signOut(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.fetchSignInMethodsForEmail"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                Result<List<String>> resultCallback =
                    new Result<List<String>>() {
                      public void success(List<String> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.fetchSignInMethodsForEmail(appArg, emailArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.sendPasswordResetEmail"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                PigeonActionCodeSettings actionCodeSettingsArg =
                    (PigeonActionCodeSettings) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.sendPasswordResetEmail(appArg, emailArg, actionCodeSettingsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.sendSignInLinkToEmail"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String emailArg = (String) args.get(1);
                PigeonActionCodeSettings actionCodeSettingsArg =
                    (PigeonActionCodeSettings) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.sendSignInLinkToEmail(appArg, emailArg, actionCodeSettingsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.setLanguageCode"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String languageCodeArg = (String) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setLanguageCode(appArg, languageCodeArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.setSettings"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonFirebaseAuthSettings settingsArg = (PigeonFirebaseAuthSettings) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSettings(appArg, settingsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.verifyPasswordResetCode"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String codeArg = (String) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.verifyPasswordResetCode(appArg, codeArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.verifyPhoneNumber"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonVerifyPhoneNumberRequest requestArg =
                    (PigeonVerifyPhoneNumberRequest) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.verifyPhoneNumber(appArg, requestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.revokeTokenWithAuthorizationCode"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String authorizationCodeArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.revokeTokenWithAuthorizationCode(appArg, authorizationCodeArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthHostApi.initializeRecaptchaConfig"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.initializeRecaptchaConfig(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class FirebaseAuthUserHostApiCodec extends StandardMessageCodec {
    public static final FirebaseAuthUserHostApiCodec INSTANCE = new FirebaseAuthUserHostApiCodec();

    private FirebaseAuthUserHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AuthPigeonFirebaseApp.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PigeonActionCodeInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return PigeonActionCodeInfoData.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return PigeonActionCodeSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return PigeonAdditionalUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return PigeonAuthCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return PigeonFirebaseAuthSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return PigeonIdTokenResult.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return PigeonMultiFactorInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return PigeonMultiFactorSession.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return PigeonPhoneMultiFactorAssertion.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return PigeonSignInProvider.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return PigeonTotpSecret.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return PigeonUserCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return PigeonUserDetails.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return PigeonUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return PigeonUserProfile.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return PigeonVerifyPhoneNumberRequest.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AuthPigeonFirebaseApp) {
        stream.write(128);
        writeValue(stream, ((AuthPigeonFirebaseApp) value).toList());
      } else if (value instanceof PigeonActionCodeInfo) {
        stream.write(129);
        writeValue(stream, ((PigeonActionCodeInfo) value).toList());
      } else if (value instanceof PigeonActionCodeInfoData) {
        stream.write(130);
        writeValue(stream, ((PigeonActionCodeInfoData) value).toList());
      } else if (value instanceof PigeonActionCodeSettings) {
        stream.write(131);
        writeValue(stream, ((PigeonActionCodeSettings) value).toList());
      } else if (value instanceof PigeonAdditionalUserInfo) {
        stream.write(132);
        writeValue(stream, ((PigeonAdditionalUserInfo) value).toList());
      } else if (value instanceof PigeonAuthCredential) {
        stream.write(133);
        writeValue(stream, ((PigeonAuthCredential) value).toList());
      } else if (value instanceof PigeonFirebaseAuthSettings) {
        stream.write(134);
        writeValue(stream, ((PigeonFirebaseAuthSettings) value).toList());
      } else if (value instanceof PigeonIdTokenResult) {
        stream.write(135);
        writeValue(stream, ((PigeonIdTokenResult) value).toList());
      } else if (value instanceof PigeonMultiFactorInfo) {
        stream.write(136);
        writeValue(stream, ((PigeonMultiFactorInfo) value).toList());
      } else if (value instanceof PigeonMultiFactorSession) {
        stream.write(137);
        writeValue(stream, ((PigeonMultiFactorSession) value).toList());
      } else if (value instanceof PigeonPhoneMultiFactorAssertion) {
        stream.write(138);
        writeValue(stream, ((PigeonPhoneMultiFactorAssertion) value).toList());
      } else if (value instanceof PigeonSignInProvider) {
        stream.write(139);
        writeValue(stream, ((PigeonSignInProvider) value).toList());
      } else if (value instanceof PigeonTotpSecret) {
        stream.write(140);
        writeValue(stream, ((PigeonTotpSecret) value).toList());
      } else if (value instanceof PigeonUserCredential) {
        stream.write(141);
        writeValue(stream, ((PigeonUserCredential) value).toList());
      } else if (value instanceof PigeonUserDetails) {
        stream.write(142);
        writeValue(stream, ((PigeonUserDetails) value).toList());
      } else if (value instanceof PigeonUserInfo) {
        stream.write(143);
        writeValue(stream, ((PigeonUserInfo) value).toList());
      } else if (value instanceof PigeonUserProfile) {
        stream.write(144);
        writeValue(stream, ((PigeonUserProfile) value).toList());
      } else if (value instanceof PigeonVerifyPhoneNumberRequest) {
        stream.write(145);
        writeValue(stream, ((PigeonVerifyPhoneNumberRequest) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface FirebaseAuthUserHostApi {

    void delete(@NonNull AuthPigeonFirebaseApp app, @NonNull VoidResult result);

    void getIdToken(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull Boolean forceRefresh,
        @NonNull Result<PigeonIdTokenResult> result);

    void linkWithCredential(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull Map<String, Object> input,
        @NonNull Result<PigeonUserCredential> result);

    void linkWithProvider(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonSignInProvider signInProvider,
        @NonNull Result<PigeonUserCredential> result);

    void reauthenticateWithCredential(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull Map<String, Object> input,
        @NonNull Result<PigeonUserCredential> result);

    void reauthenticateWithProvider(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonSignInProvider signInProvider,
        @NonNull Result<PigeonUserCredential> result);

    void reload(@NonNull AuthPigeonFirebaseApp app, @NonNull Result<PigeonUserDetails> result);

    void sendEmailVerification(
        @NonNull AuthPigeonFirebaseApp app,
        @Nullable PigeonActionCodeSettings actionCodeSettings,
        @NonNull VoidResult result);

    void unlink(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String providerId,
        @NonNull Result<PigeonUserCredential> result);

    void updateEmail(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String newEmail,
        @NonNull Result<PigeonUserDetails> result);

    void updatePassword(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String newPassword,
        @NonNull Result<PigeonUserDetails> result);

    void updatePhoneNumber(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull Map<String, Object> input,
        @NonNull Result<PigeonUserDetails> result);

    void updateProfile(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonUserProfile profile,
        @NonNull Result<PigeonUserDetails> result);

    void verifyBeforeUpdateEmail(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String newEmail,
        @Nullable PigeonActionCodeSettings actionCodeSettings,
        @NonNull VoidResult result);

    /** The codec used by FirebaseAuthUserHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return FirebaseAuthUserHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `FirebaseAuthUserHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(
        @NonNull BinaryMessenger binaryMessenger, @Nullable FirebaseAuthUserHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable FirebaseAuthUserHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.delete"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.delete(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.getIdToken"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Boolean forceRefreshArg = (Boolean) args.get(1);
                Result<PigeonIdTokenResult> resultCallback =
                    new Result<PigeonIdTokenResult>() {
                      public void success(PigeonIdTokenResult result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIdToken(appArg, forceRefreshArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.linkWithCredential"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Map<String, Object> inputArg = (Map<String, Object>) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.linkWithCredential(appArg, inputArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.linkWithProvider"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonSignInProvider signInProviderArg = (PigeonSignInProvider) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.linkWithProvider(appArg, signInProviderArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.reauthenticateWithCredential"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Map<String, Object> inputArg = (Map<String, Object>) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.reauthenticateWithCredential(appArg, inputArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.reauthenticateWithProvider"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonSignInProvider signInProviderArg = (PigeonSignInProvider) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.reauthenticateWithProvider(appArg, signInProviderArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.reload"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<PigeonUserDetails> resultCallback =
                    new Result<PigeonUserDetails>() {
                      public void success(PigeonUserDetails result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.reload(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.sendEmailVerification"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonActionCodeSettings actionCodeSettingsArg =
                    (PigeonActionCodeSettings) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.sendEmailVerification(appArg, actionCodeSettingsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.unlink"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String providerIdArg = (String) args.get(1);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.unlink(appArg, providerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.updateEmail"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String newEmailArg = (String) args.get(1);
                Result<PigeonUserDetails> resultCallback =
                    new Result<PigeonUserDetails>() {
                      public void success(PigeonUserDetails result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updateEmail(appArg, newEmailArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.updatePassword"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String newPasswordArg = (String) args.get(1);
                Result<PigeonUserDetails> resultCallback =
                    new Result<PigeonUserDetails>() {
                      public void success(PigeonUserDetails result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updatePassword(appArg, newPasswordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.updatePhoneNumber"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Map<String, Object> inputArg = (Map<String, Object>) args.get(1);
                Result<PigeonUserDetails> resultCallback =
                    new Result<PigeonUserDetails>() {
                      public void success(PigeonUserDetails result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updatePhoneNumber(appArg, inputArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.updateProfile"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonUserProfile profileArg = (PigeonUserProfile) args.get(1);
                Result<PigeonUserDetails> resultCallback =
                    new Result<PigeonUserDetails>() {
                      public void success(PigeonUserDetails result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updateProfile(appArg, profileArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.FirebaseAuthUserHostApi.verifyBeforeUpdateEmail"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String newEmailArg = (String) args.get(1);
                PigeonActionCodeSettings actionCodeSettingsArg =
                    (PigeonActionCodeSettings) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.verifyBeforeUpdateEmail(
                    appArg, newEmailArg, actionCodeSettingsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MultiFactorUserHostApiCodec extends StandardMessageCodec {
    public static final MultiFactorUserHostApiCodec INSTANCE = new MultiFactorUserHostApiCodec();

    private MultiFactorUserHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AuthPigeonFirebaseApp.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PigeonMultiFactorInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return PigeonMultiFactorSession.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return PigeonPhoneMultiFactorAssertion.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AuthPigeonFirebaseApp) {
        stream.write(128);
        writeValue(stream, ((AuthPigeonFirebaseApp) value).toList());
      } else if (value instanceof PigeonMultiFactorInfo) {
        stream.write(129);
        writeValue(stream, ((PigeonMultiFactorInfo) value).toList());
      } else if (value instanceof PigeonMultiFactorSession) {
        stream.write(130);
        writeValue(stream, ((PigeonMultiFactorSession) value).toList());
      } else if (value instanceof PigeonPhoneMultiFactorAssertion) {
        stream.write(131);
        writeValue(stream, ((PigeonPhoneMultiFactorAssertion) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface MultiFactorUserHostApi {

    void enrollPhone(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull PigeonPhoneMultiFactorAssertion assertion,
        @Nullable String displayName,
        @NonNull VoidResult result);

    void enrollTotp(
        @NonNull AuthPigeonFirebaseApp app,
        @NonNull String assertionId,
        @Nullable String displayName,
        @NonNull VoidResult result);

    void getSession(
        @NonNull AuthPigeonFirebaseApp app, @NonNull Result<PigeonMultiFactorSession> result);

    void unenroll(
        @NonNull AuthPigeonFirebaseApp app, @NonNull String factorUid, @NonNull VoidResult result);

    void getEnrolledFactors(
        @NonNull AuthPigeonFirebaseApp app, @NonNull Result<List<PigeonMultiFactorInfo>> result);

    /** The codec used by MultiFactorUserHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MultiFactorUserHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `MultiFactorUserHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(
        @NonNull BinaryMessenger binaryMessenger, @Nullable MultiFactorUserHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable MultiFactorUserHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorUserHostApi.enrollPhone"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                PigeonPhoneMultiFactorAssertion assertionArg =
                    (PigeonPhoneMultiFactorAssertion) args.get(1);
                String displayNameArg = (String) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.enrollPhone(appArg, assertionArg, displayNameArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorUserHostApi.enrollTotp"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String assertionIdArg = (String) args.get(1);
                String displayNameArg = (String) args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.enrollTotp(appArg, assertionIdArg, displayNameArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorUserHostApi.getSession"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<PigeonMultiFactorSession> resultCallback =
                    new Result<PigeonMultiFactorSession>() {
                      public void success(PigeonMultiFactorSession result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSession(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorUserHostApi.unenroll"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                String factorUidArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.unenroll(appArg, factorUidArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorUserHostApi.getEnrolledFactors"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AuthPigeonFirebaseApp appArg = (AuthPigeonFirebaseApp) args.get(0);
                Result<List<PigeonMultiFactorInfo>> resultCallback =
                    new Result<List<PigeonMultiFactorInfo>>() {
                      public void success(List<PigeonMultiFactorInfo> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getEnrolledFactors(appArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MultiFactoResolverHostApiCodec extends StandardMessageCodec {
    public static final MultiFactoResolverHostApiCodec INSTANCE =
        new MultiFactoResolverHostApiCodec();

    private MultiFactoResolverHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PigeonAdditionalUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PigeonAuthCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return PigeonPhoneMultiFactorAssertion.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return PigeonUserCredential.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return PigeonUserDetails.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return PigeonUserInfo.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PigeonAdditionalUserInfo) {
        stream.write(128);
        writeValue(stream, ((PigeonAdditionalUserInfo) value).toList());
      } else if (value instanceof PigeonAuthCredential) {
        stream.write(129);
        writeValue(stream, ((PigeonAuthCredential) value).toList());
      } else if (value instanceof PigeonPhoneMultiFactorAssertion) {
        stream.write(130);
        writeValue(stream, ((PigeonPhoneMultiFactorAssertion) value).toList());
      } else if (value instanceof PigeonUserCredential) {
        stream.write(131);
        writeValue(stream, ((PigeonUserCredential) value).toList());
      } else if (value instanceof PigeonUserDetails) {
        stream.write(132);
        writeValue(stream, ((PigeonUserDetails) value).toList());
      } else if (value instanceof PigeonUserInfo) {
        stream.write(133);
        writeValue(stream, ((PigeonUserInfo) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface MultiFactoResolverHostApi {

    void resolveSignIn(
        @NonNull String resolverId,
        @Nullable PigeonPhoneMultiFactorAssertion assertion,
        @Nullable String totpAssertionId,
        @NonNull Result<PigeonUserCredential> result);

    /** The codec used by MultiFactoResolverHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MultiFactoResolverHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `MultiFactoResolverHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(
        @NonNull BinaryMessenger binaryMessenger, @Nullable MultiFactoResolverHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable MultiFactoResolverHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactoResolverHostApi.resolveSignIn"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String resolverIdArg = (String) args.get(0);
                PigeonPhoneMultiFactorAssertion assertionArg =
                    (PigeonPhoneMultiFactorAssertion) args.get(1);
                String totpAssertionIdArg = (String) args.get(2);
                Result<PigeonUserCredential> resultCallback =
                    new Result<PigeonUserCredential>() {
                      public void success(PigeonUserCredential result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.resolveSignIn(resolverIdArg, assertionArg, totpAssertionIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MultiFactorTotpHostApiCodec extends StandardMessageCodec {
    public static final MultiFactorTotpHostApiCodec INSTANCE = new MultiFactorTotpHostApiCodec();

    private MultiFactorTotpHostApiCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PigeonTotpSecret.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PigeonTotpSecret) {
        stream.write(128);
        writeValue(stream, ((PigeonTotpSecret) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface MultiFactorTotpHostApi {

    void generateSecret(@NonNull String sessionId, @NonNull Result<PigeonTotpSecret> result);

    void getAssertionForEnrollment(
        @NonNull String secretKey, @NonNull String oneTimePassword, @NonNull Result<String> result);

    void getAssertionForSignIn(
        @NonNull String enrollmentId,
        @NonNull String oneTimePassword,
        @NonNull Result<String> result);

    /** The codec used by MultiFactorTotpHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MultiFactorTotpHostApiCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `MultiFactorTotpHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(
        @NonNull BinaryMessenger binaryMessenger, @Nullable MultiFactorTotpHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable MultiFactorTotpHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorTotpHostApi.generateSecret"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sessionIdArg = (String) args.get(0);
                Result<PigeonTotpSecret> resultCallback =
                    new Result<PigeonTotpSecret>() {
                      public void success(PigeonTotpSecret result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.generateSecret(sessionIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorTotpHostApi.getAssertionForEnrollment"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String secretKeyArg = (String) args.get(0);
                String oneTimePasswordArg = (String) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getAssertionForEnrollment(secretKeyArg, oneTimePasswordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorTotpHostApi.getAssertionForSignIn"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String enrollmentIdArg = (String) args.get(0);
                String oneTimePasswordArg = (String) args.get(1);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getAssertionForSignIn(enrollmentIdArg, oneTimePasswordArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface MultiFactorTotpSecretHostApi {

    void generateQrCodeUrl(
        @NonNull String secretKey,
        @Nullable String accountName,
        @Nullable String issuer,
        @NonNull Result<String> result);

    void openInOtpApp(
        @NonNull String secretKey, @NonNull String qrCodeUrl, @NonNull VoidResult result);

    /** The codec used by MultiFactorTotpSecretHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**
     * Sets up an instance of `MultiFactorTotpSecretHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(
        @NonNull BinaryMessenger binaryMessenger, @Nullable MultiFactorTotpSecretHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable MultiFactorTotpSecretHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorTotpSecretHostApi.generateQrCodeUrl"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String secretKeyArg = (String) args.get(0);
                String accountNameArg = (String) args.get(1);
                String issuerArg = (String) args.get(2);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.generateQrCodeUrl(secretKeyArg, accountNameArg, issuerArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.MultiFactorTotpSecretHostApi.openInOtpApp"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String secretKeyArg = (String) args.get(0);
                String qrCodeUrlArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.openInOtpApp(secretKeyArg, qrCodeUrlArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class GenerateInterfacesCodec extends StandardMessageCodec {
    public static final GenerateInterfacesCodec INSTANCE = new GenerateInterfacesCodec();

    private GenerateInterfacesCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PigeonMultiFactorInfo.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PigeonMultiFactorInfo) {
        stream.write(128);
        writeValue(stream, ((PigeonMultiFactorInfo) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Only used to generate the object interface that are use outside of the Pigeon interface
   *
   * <p>Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface GenerateInterfaces {

    void pigeonInterface(@NonNull PigeonMultiFactorInfo info);

    /** The codec used by GenerateInterfaces. */
    static @NonNull MessageCodec<Object> getCodec() {
      return GenerateInterfacesCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `GenerateInterfaces` to handle messages through the `binaryMessenger`.
     */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable GenerateInterfaces api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable GenerateInterfaces api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_auth_platform_interface.GenerateInterfaces.pigeonInterface"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                PigeonMultiFactorInfo infoArg = (PigeonMultiFactorInfo) args.get(0);
                try {
                  api.pigeonInterface(infoArg);
                  wrapped.add(0, null);
                } catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/IdTokenChannelStreamHandler.java

**크기**: 1894 bytes | **라인 수**: 64 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuth.IdTokenListener;
import com.google.firebase.auth.FirebaseUser;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class IdTokenChannelStreamHandler implements StreamHandler {

  private final FirebaseAuth firebaseAuth;
  private IdTokenListener idTokenListener;

  public IdTokenChannelStreamHandler(FirebaseAuth firebaseAuth) {
    this.firebaseAuth = firebaseAuth;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    Map<String, Object> event = new HashMap<>();
    event.put(Constants.APP_NAME, firebaseAuth.getApp().getName());

    final AtomicBoolean initialAuthState = new AtomicBoolean(true);

    idTokenListener =
        auth -> {
          if (initialAuthState.get()) {
            initialAuthState.set(false);
            return;
          }

          FirebaseUser user = auth.getCurrentUser();

          if (user == null) {
            event.put(Constants.USER, null);
          } else {
            event.put(
                Constants.USER, PigeonParser.manuallyToList(PigeonParser.parseFirebaseUser(user)));
          }

          events.success(event);
        };

    firebaseAuth.addIdTokenListener(idTokenListener);
  }

  @Override
  public void onCancel(Object arguments) {
    if (idTokenListener != null) {
      firebaseAuth.removeIdTokenListener(idTokenListener);
      idTokenListener = null;
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/PhoneNumberVerificationStreamHandler.java

**크기**: 7280 bytes | **라인 수**: 198 | **타입**: text

```
/*
 * Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.firebase.FirebaseException;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.MultiFactorSession;
import com.google.firebase.auth.PhoneAuthCredential;
import com.google.firebase.auth.PhoneAuthOptions;
import com.google.firebase.auth.PhoneAuthProvider;
import com.google.firebase.auth.PhoneAuthProvider.ForceResendingToken;
import com.google.firebase.auth.PhoneMultiFactorInfo;
import io.flutter.plugin.common.EventChannel.EventSink;
import io.flutter.plugin.common.EventChannel.StreamHandler;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class PhoneNumberVerificationStreamHandler implements StreamHandler {

  interface OnCredentialsListener {
    void onCredentialsReceived(PhoneAuthCredential credential);
  }

  final AtomicReference<Activity> activityRef = new AtomicReference<>(null);
  final FirebaseAuth firebaseAuth;
  final String phoneNumber;
  final PhoneMultiFactorInfo multiFactorInfo;
  final int timeout;
  final OnCredentialsListener onCredentialsListener;

  final MultiFactorSession multiFactorSession;

  String autoRetrievedSmsCodeForTesting;
  Integer forceResendingToken;

  private static final HashMap<Integer, ForceResendingToken> forceResendingTokens = new HashMap<>();

  @Nullable private EventSink eventSink;

  public PhoneNumberVerificationStreamHandler(
      Activity activity,
      @NonNull GeneratedAndroidFirebaseAuth.AuthPigeonFirebaseApp app,
      @NonNull GeneratedAndroidFirebaseAuth.PigeonVerifyPhoneNumberRequest request,
      @Nullable MultiFactorSession multiFactorSession,
      @Nullable PhoneMultiFactorInfo multiFactorInfo,
      OnCredentialsListener onCredentialsListener) {
    this.activityRef.set(activity);

    this.multiFactorSession = multiFactorSession;
    this.multiFactorInfo = multiFactorInfo;
    firebaseAuth = FlutterFirebaseAuthPlugin.getAuthFromPigeon(app);
    phoneNumber = request.getPhoneNumber();
    timeout = Math.toIntExact(request.getTimeout());

    if (request.getAutoRetrievedSmsCodeForTesting() != null) {
      autoRetrievedSmsCodeForTesting = request.getAutoRetrievedSmsCodeForTesting();
    }

    if (request.getForceResendingToken() != null) {
      forceResendingToken = Math.toIntExact(request.getForceResendingToken());
    }

    this.onCredentialsListener = onCredentialsListener;
  }

  @Override
  public void onListen(Object arguments, EventSink events) {
    eventSink = events;

    PhoneAuthProvider.OnVerificationStateChangedCallbacks callbacks =
        new PhoneAuthProvider.OnVerificationStateChangedCallbacks() {
          @Override
          public void onVerificationCompleted(@NonNull PhoneAuthCredential phoneAuthCredential) {
            int phoneAuthCredentialHashCode = phoneAuthCredential.hashCode();
            onCredentialsListener.onCredentialsReceived(phoneAuthCredential);

            Map<String, Object> event = new HashMap<>();
            event.put(Constants.TOKEN, phoneAuthCredentialHashCode);

            if (phoneAuthCredential.getSmsCode() != null) {
              event.put(Constants.SMS_CODE, phoneAuthCredential.getSmsCode());
            }

            event.put(Constants.NAME, "Auth#phoneVerificationCompleted");

            if (eventSink != null) {
              eventSink.success(event);
            }
          }

          @Override
          public void onVerificationFailed(@NonNull FirebaseException e) {
            Map<String, Object> event = new HashMap<>();
            Map<String, Object> error = new HashMap<>();
            GeneratedAndroidFirebaseAuth.FlutterError flutterError =
                FlutterFirebaseAuthPluginException.parserExceptionToFlutter(e);
            error.put(
                "code",
                flutterError
                    .code
                    .replaceAll("ERROR_", "")
                    .toLowerCase(Locale.ROOT)
                    .replaceAll("_", "-"));
            error.put("message", flutterError.getMessage());
            error.put("details", flutterError.details);
            event.put("error", error);

            event.put(Constants.NAME, "Auth#phoneVerificationFailed");

            if (eventSink != null) {
              eventSink.success(event);
            }
          }

          @Override
          public void onCodeSent(
              @NonNull String verificationId,
              @NonNull PhoneAuthProvider.ForceResendingToken token) {
            int forceResendingTokenHashCode = token.hashCode();
            forceResendingTokens.put(forceResendingTokenHashCode, token);

            Map<String, Object> event = new HashMap<>();
            event.put(Constants.VERIFICATION_ID, verificationId);
            event.put(Constants.FORCE_RESENDING_TOKEN, forceResendingTokenHashCode);

            event.put(Constants.NAME, "Auth#phoneCodeSent");

            if (eventSink != null) {
              eventSink.success(event);
            }
          }

          @Override
          public void onCodeAutoRetrievalTimeOut(@NonNull String verificationId) {
            Map<String, Object> event = new HashMap<>();
            event.put(Constants.VERIFICATION_ID, verificationId);

            event.put(Constants.NAME, "Auth#phoneCodeAutoRetrievalTimeout");

            if (eventSink != null) {
              eventSink.success(event);
            }
          }
        };

    // Allows the auto-retrieval flow to be tested.
    // See https://firebase.google.com/docs/auth/android/phone-auth#integration-testing
    if (autoRetrievedSmsCodeForTesting != null) {
      firebaseAuth
          .getFirebaseAuthSettings()
          .setAutoRetrievedSmsCodeForPhoneNumber(phoneNumber, autoRetrievedSmsCodeForTesting);
    }

    PhoneAuthOptions.Builder phoneAuthOptionsBuilder = new PhoneAuthOptions.Builder(firebaseAuth);
    phoneAuthOptionsBuilder.setActivity(activityRef.get());
    phoneAuthOptionsBuilder.setCallbacks(callbacks);

    if (phoneNumber != null) {
      phoneAuthOptionsBuilder.setPhoneNumber(phoneNumber);
    }
    if (multiFactorSession != null) {
      phoneAuthOptionsBuilder.setMultiFactorSession(multiFactorSession);
    }
    if (multiFactorInfo != null) {
      phoneAuthOptionsBuilder.setMultiFactorHint(multiFactorInfo);
    }
    phoneAuthOptionsBuilder.setTimeout((long) timeout, TimeUnit.MILLISECONDS);

    if (forceResendingToken != null) {
      PhoneAuthProvider.ForceResendingToken forceResendingToken =
          forceResendingTokens.get(this.forceResendingToken);

      if (forceResendingToken != null) {
        phoneAuthOptionsBuilder.setForceResendingToken(forceResendingToken);
      }
    }

    PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptionsBuilder.build());
  }

  @Override
  public void onCancel(Object arguments) {
    eventSink = null;

    activityRef.set(null);
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/java/io/flutter/plugins/firebase/auth/PigeonParser.java

**크기**: 15687 bytes | **라인 수**: 382 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

package io.flutter.plugins.firebase.auth;

import android.net.Uri;
import androidx.annotation.NonNull;
import com.google.firebase.auth.ActionCodeEmailInfo;
import com.google.firebase.auth.ActionCodeInfo;
import com.google.firebase.auth.ActionCodeResult;
import com.google.firebase.auth.ActionCodeSettings;
import com.google.firebase.auth.AdditionalUserInfo;
import com.google.firebase.auth.AuthCredential;
import com.google.firebase.auth.AuthResult;
import com.google.firebase.auth.EmailAuthProvider;
import com.google.firebase.auth.FacebookAuthProvider;
import com.google.firebase.auth.FirebaseAuthProvider;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.auth.FirebaseUserMetadata;
import com.google.firebase.auth.GetTokenResult;
import com.google.firebase.auth.GithubAuthProvider;
import com.google.firebase.auth.GoogleAuthProvider;
import com.google.firebase.auth.MultiFactorInfo;
import com.google.firebase.auth.OAuthCredential;
import com.google.firebase.auth.OAuthProvider;
import com.google.firebase.auth.PhoneAuthProvider;
import com.google.firebase.auth.PhoneMultiFactorInfo;
import com.google.firebase.auth.PlayGamesAuthProvider;
import com.google.firebase.auth.TwitterAuthProvider;
import com.google.firebase.auth.UserInfo;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class PigeonParser {
  static List<Object> manuallyToList(
      GeneratedAndroidFirebaseAuth.PigeonUserDetails pigeonUserDetails) {
    List<Object> output = new ArrayList<>();
    output.add(pigeonUserDetails.getUserInfo().toList());
    output.add(pigeonUserDetails.getProviderData());
    return output;
  }

  static GeneratedAndroidFirebaseAuth.PigeonUserCredential parseAuthResult(
      @NonNull AuthResult authResult) {
    GeneratedAndroidFirebaseAuth.PigeonUserCredential.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonUserCredential.Builder();

    builder.setAdditionalUserInfo(parseAdditionalUserInfo(authResult.getAdditionalUserInfo()));
    builder.setCredential(parseAuthCredential(authResult.getCredential()));
    builder.setUser(parseFirebaseUser(authResult.getUser()));

    return builder.build();
  }

  private static GeneratedAndroidFirebaseAuth.PigeonAdditionalUserInfo parseAdditionalUserInfo(
      AdditionalUserInfo additionalUserInfo) {
    if (additionalUserInfo == null) {
      return null;
    }

    GeneratedAndroidFirebaseAuth.PigeonAdditionalUserInfo.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonAdditionalUserInfo.Builder();

    builder.setIsNewUser(additionalUserInfo.isNewUser());
    builder.setProfile(additionalUserInfo.getProfile());
    builder.setProviderId(additionalUserInfo.getProviderId());
    builder.setUsername(additionalUserInfo.getUsername());

    return builder.build();
  }

  static GeneratedAndroidFirebaseAuth.PigeonAuthCredential parseAuthCredential(
      AuthCredential authCredential) {
    if (authCredential == null) {
      return null;
    }

    int authCredentialHashCode = authCredential.hashCode();
    FlutterFirebaseAuthPlugin.authCredentials.put(authCredentialHashCode, authCredential);

    GeneratedAndroidFirebaseAuth.PigeonAuthCredential.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonAuthCredential.Builder();

    builder.setProviderId(authCredential.getProvider());
    builder.setSignInMethod(authCredential.getSignInMethod());
    builder.setNativeId((long) authCredentialHashCode);
    if (authCredential instanceof OAuthCredential) {
      builder.setAccessToken(((OAuthCredential) authCredential).getAccessToken());
    }

    return builder.build();
  }

  static GeneratedAndroidFirebaseAuth.PigeonUserDetails parseFirebaseUser(
      FirebaseUser firebaseUser) {
    if (firebaseUser == null) {
      return null;
    }

    GeneratedAndroidFirebaseAuth.PigeonUserDetails.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonUserDetails.Builder();

    GeneratedAndroidFirebaseAuth.PigeonUserInfo.Builder builderInfo =
        new GeneratedAndroidFirebaseAuth.PigeonUserInfo.Builder();

    builderInfo.setDisplayName(firebaseUser.getDisplayName());
    builderInfo.setEmail(firebaseUser.getEmail());
    builderInfo.setIsEmailVerified(firebaseUser.isEmailVerified());
    builderInfo.setIsAnonymous(firebaseUser.isAnonymous());

    final FirebaseUserMetadata userMetadata = firebaseUser.getMetadata();
    if (userMetadata != null) {
      builderInfo.setCreationTimestamp(firebaseUser.getMetadata().getCreationTimestamp());
      builderInfo.setLastSignInTimestamp(firebaseUser.getMetadata().getLastSignInTimestamp());
    }
    builderInfo.setPhoneNumber(firebaseUser.getPhoneNumber());
    builderInfo.setPhotoUrl(parsePhotoUrl(firebaseUser.getPhotoUrl()));
    builderInfo.setUid(firebaseUser.getUid());
    builderInfo.setTenantId(firebaseUser.getTenantId());

    builder.setUserInfo(builderInfo.build());
    builder.setProviderData(parseUserInfoList(firebaseUser.getProviderData()));

    return builder.build();
  }

  private static List<Map<Object, Object>> parseUserInfoList(
      List<? extends UserInfo> userInfoList) {
    List<Map<Object, Object>> output = new ArrayList<>();

    if (userInfoList == null) {
      return null;
    }

    for (UserInfo userInfo : new ArrayList<UserInfo>(userInfoList)) {
      if (userInfo == null) {
        continue;
      }
      if (!FirebaseAuthProvider.PROVIDER_ID.equals(userInfo.getProviderId())) {
        output.add(parseUserInfoToMap(userInfo));
      }
    }

    return output;
  }

  private static Map<Object, Object> parseUserInfoToMap(UserInfo userInfo) {
    Map<Object, Object> output = new HashMap<>();
    output.put("displayName", userInfo.getDisplayName());
    output.put("email", userInfo.getEmail());
    output.put("isEmailVerified", userInfo.isEmailVerified());
    output.put("phoneNumber", userInfo.getPhoneNumber());
    output.put("photoUrl", parsePhotoUrl(userInfo.getPhotoUrl()));
    // Can be null on Emulator
    output.put("uid", userInfo.getUid() == null ? "" : userInfo.getUid());
    output.put("providerId", userInfo.getProviderId());
    output.put("isAnonymous", false);
    return output;
  }

  private static String parsePhotoUrl(Uri photoUri) {
    if (photoUri == null) {
      return null;
    }

    String photoUrl = photoUri.toString();

    // Return null if the URL is an empty string
    return "".equals(photoUrl) ? null : photoUrl;
  }

  @SuppressWarnings("ConstantConditions")
  static AuthCredential getCredential(Map<String, Object> credentialMap) {
    // If the credential map contains a token, it means a native one has been stored
    if (credentialMap.get(Constants.TOKEN) != null) {
      int token = (int) credentialMap.get(Constants.TOKEN);
      AuthCredential credential = FlutterFirebaseAuthPlugin.authCredentials.get(token);

      if (credential == null) {
        throw FlutterFirebaseAuthPluginException.invalidCredential();
      }

      return credential;
    }

    String signInMethod =
        (String) Objects.requireNonNull(credentialMap.get(Constants.SIGN_IN_METHOD));
    String secret = (String) credentialMap.get(Constants.SECRET);
    String idToken = (String) credentialMap.get(Constants.ID_TOKEN);
    String accessToken = (String) credentialMap.get(Constants.ACCESS_TOKEN);
    String rawNonce = (String) credentialMap.get(Constants.RAW_NONCE);

    switch (signInMethod) {
      case Constants.SIGN_IN_METHOD_PASSWORD:
        return EmailAuthProvider.getCredential(
            (String) Objects.requireNonNull(credentialMap.get(Constants.EMAIL)),
            Objects.requireNonNull(secret));
      case Constants.SIGN_IN_METHOD_EMAIL_LINK:
        return EmailAuthProvider.getCredentialWithLink(
            (String) Objects.requireNonNull(credentialMap.get(Constants.EMAIL)),
            (String) Objects.requireNonNull(credentialMap.get(Constants.EMAIL_LINK)));
      case Constants.SIGN_IN_METHOD_FACEBOOK:
        return FacebookAuthProvider.getCredential(Objects.requireNonNull(accessToken));
      case Constants.SIGN_IN_METHOD_GOOGLE:
        return GoogleAuthProvider.getCredential(idToken, accessToken);
      case Constants.SIGN_IN_METHOD_TWITTER:
        return TwitterAuthProvider.getCredential(
            Objects.requireNonNull(accessToken), Objects.requireNonNull(secret));
      case Constants.SIGN_IN_METHOD_GITHUB:
        return GithubAuthProvider.getCredential(Objects.requireNonNull(accessToken));
      case Constants.SIGN_IN_METHOD_PHONE:
        {
          String verificationId =
              (String) Objects.requireNonNull(credentialMap.get(Constants.VERIFICATION_ID));
          String smsCode = (String) Objects.requireNonNull(credentialMap.get(Constants.SMS_CODE));
          return PhoneAuthProvider.getCredential(verificationId, smsCode);
        }
      case Constants.SIGN_IN_METHOD_OAUTH:
        {
          String providerId =
              (String) Objects.requireNonNull(credentialMap.get(Constants.PROVIDER_ID));
          OAuthProvider.CredentialBuilder builder = OAuthProvider.newCredentialBuilder(providerId);
          if (accessToken != null) {
            builder.setAccessToken(accessToken);
          }
          if (rawNonce == null) {
            builder.setIdToken(Objects.requireNonNull(idToken));
          } else {
            builder.setIdTokenWithRawNonce(Objects.requireNonNull(idToken), rawNonce);
          }

          return builder.build();
        }
      case Constants.SIGN_IN_METHOD_PLAY_GAMES:
        {
          String serverAuthCode =
              (String) Objects.requireNonNull(credentialMap.get(Constants.SERVER_AUTH_CODE));
          return PlayGamesAuthProvider.getCredential(serverAuthCode);
        }
      default:
        return null;
    }
  }

  static ActionCodeSettings getActionCodeSettings(
      @NonNull GeneratedAndroidFirebaseAuth.PigeonActionCodeSettings pigeonActionCodeSettings) {
    ActionCodeSettings.Builder builder = ActionCodeSettings.newBuilder();

    builder.setUrl(pigeonActionCodeSettings.getUrl());

    if (pigeonActionCodeSettings.getDynamicLinkDomain() != null) {
      builder.setDynamicLinkDomain(pigeonActionCodeSettings.getDynamicLinkDomain());
    }

    if (pigeonActionCodeSettings.getLinkDomain() != null) {
      builder.setLinkDomain(pigeonActionCodeSettings.getLinkDomain());
    }

    builder.setHandleCodeInApp(pigeonActionCodeSettings.getHandleCodeInApp());

    if (pigeonActionCodeSettings.getAndroidPackageName() != null) {
      builder.setAndroidPackageName(
          pigeonActionCodeSettings.getAndroidPackageName(),
          pigeonActionCodeSettings.getAndroidInstallApp(),
          pigeonActionCodeSettings.getAndroidMinimumVersion());
    }

    if (pigeonActionCodeSettings.getIOSBundleId() != null) {
      builder.setIOSBundleId(pigeonActionCodeSettings.getIOSBundleId());
    }

    return builder.build();
  }

  static List<GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo> multiFactorInfoToPigeon(
      List<MultiFactorInfo> hints) {
    List<GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo> pigeonHints = new ArrayList<>();
    for (MultiFactorInfo info : hints) {
      if (info instanceof PhoneMultiFactorInfo) {
        pigeonHints.add(
            new GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo.Builder()
                .setPhoneNumber(((PhoneMultiFactorInfo) info).getPhoneNumber())
                .setDisplayName(info.getDisplayName())
                .setEnrollmentTimestamp((double) info.getEnrollmentTimestamp())
                .setUid(info.getUid())
                .setFactorId(info.getFactorId())
                .build());

      } else {
        pigeonHints.add(
            new GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo.Builder()
                .setDisplayName(info.getDisplayName())
                .setEnrollmentTimestamp((double) info.getEnrollmentTimestamp())
                .setUid(info.getUid())
                .setFactorId(info.getFactorId())
                .build());
      }
    }
    return pigeonHints;
  }

  static List<List<Object>> multiFactorInfoToMap(List<MultiFactorInfo> hints) {
    List<List<Object>> pigeonHints = new ArrayList<>();
    for (GeneratedAndroidFirebaseAuth.PigeonMultiFactorInfo info : multiFactorInfoToPigeon(hints)) {
      pigeonHints.add(info.toList());
    }
    return pigeonHints;
  }

  static GeneratedAndroidFirebaseAuth.PigeonActionCodeInfo parseActionCodeResult(
      @NonNull ActionCodeResult actionCodeResult) {
    GeneratedAndroidFirebaseAuth.PigeonActionCodeInfo.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonActionCodeInfo.Builder();
    GeneratedAndroidFirebaseAuth.PigeonActionCodeInfoData.Builder builderData =
        new GeneratedAndroidFirebaseAuth.PigeonActionCodeInfoData.Builder();

    int operation = actionCodeResult.getOperation();

    switch (operation) {
      case ActionCodeResult.PASSWORD_RESET:
        builder.setOperation(GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.PASSWORD_RESET);
        break;
      case ActionCodeResult.VERIFY_EMAIL:
        builder.setOperation(GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.VERIFY_EMAIL);
        break;
      case ActionCodeResult.RECOVER_EMAIL:
        builder.setOperation(GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.RECOVER_EMAIL);
        break;
      case ActionCodeResult.SIGN_IN_WITH_EMAIL_LINK:
        builder.setOperation(GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.EMAIL_SIGN_IN);
        break;
      case ActionCodeResult.VERIFY_BEFORE_CHANGE_EMAIL:
        builder.setOperation(
            GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.VERIFY_AND_CHANGE_EMAIL);
        break;
      case ActionCodeResult.REVERT_SECOND_FACTOR_ADDITION:
        builder.setOperation(
            GeneratedAndroidFirebaseAuth.ActionCodeInfoOperation.REVERT_SECOND_FACTOR_ADDITION);
        break;
    }

    ActionCodeInfo actionCodeInfo = actionCodeResult.getInfo();

    if (actionCodeInfo != null && operation == ActionCodeResult.VERIFY_EMAIL
        || operation == ActionCodeResult.PASSWORD_RESET) {
      builderData.setEmail(actionCodeInfo.getEmail());
    } else if (operation == ActionCodeResult.RECOVER_EMAIL
        || operation == ActionCodeResult.VERIFY_BEFORE_CHANGE_EMAIL) {
      ActionCodeEmailInfo actionCodeEmailInfo =
          (ActionCodeEmailInfo) Objects.requireNonNull(actionCodeInfo);
      builderData.setEmail(actionCodeEmailInfo.getEmail());
      builderData.setPreviousEmail(actionCodeEmailInfo.getPreviousEmail());
    }

    builder.setData(builderData.build());

    return builder.build();
  }

  static GeneratedAndroidFirebaseAuth.PigeonIdTokenResult parseTokenResult(
      @NonNull GetTokenResult tokenResult) {
    final GeneratedAndroidFirebaseAuth.PigeonIdTokenResult.Builder builder =
        new GeneratedAndroidFirebaseAuth.PigeonIdTokenResult.Builder();

    builder.setToken(tokenResult.getToken());
    builder.setSignInProvider(tokenResult.getSignInProvider());
    builder.setAuthTimestamp(tokenResult.getAuthTimestamp() * 1000);
    builder.setExpirationTimestamp(tokenResult.getExpirationTimestamp() * 1000);
    builder.setIssuedAtTimestamp(tokenResult.getIssuedAtTimestamp() * 1000);
    builder.setClaims(tokenResult.getClaims());
    builder.setSignInSecondFactor(tokenResult.getSignInSecondFactor());

    return builder.build();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/android/src/main/AndroidManifest.xml

**크기**: 496 bytes | **라인 수**: 10 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="io.flutter.plugins.firebase.auth">
    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data android:name="com.google.firebase.components:io.flutter.plugins.firebase.auth.FlutterFirebaseAuthRegistrar"
                       android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/debug/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/kotlin/io/flutter/plugins/firebase/auth/example/MainActivity.kt

**크기**: 141 bytes | **라인 수**: 6 | **타입**: text

```
package io.flutter.plugins.firebase.auth.example

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/res/drawable/launch_background.xml

**크기**: 434 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/res/drawable-v21/launch_background.xml

**크기**: 438 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/res/values/styles.xml

**크기**: 996 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/res/values-night/styles.xml

**크기**: 995 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/main/AndroidManifest.xml

**크기**: 2195 bytes | **라인 수**: 46 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/src/profile/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/android/app/google-services.json

**크기**: 19379 bytes | **라인 수**: 615 | **타입**: text

```
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dataconnect.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 2519 bytes | **라인 수**: 123 | **타입**: text

```
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json

**크기**: 391 bytes | **라인 수**: 24 | **타입**: text

```
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md

**크기**: 336 bytes | **라인 수**: 5 | **타입**: text

```
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/AppDelegate.h

**크기**: 103 bytes | **라인 수**: 7 | **타입**: text

```
#import <Flutter/Flutter.h>
#import <UIKit/UIKit.h>

@interface AppDelegate : FlutterAppDelegate

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/AppDelegate.m

**크기**: 422 bytes | **라인 수**: 14 | **타입**: text

```
#import "AppDelegate.h"
#import "GeneratedPluginRegistrant.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  [GeneratedPluginRegistrant registerWithRegistry:self];
  // Override point for customization after application launch.
  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/AppDelegate.swift

**크기**: 391 bytes | **라인 수**: 14 | **타입**: text

```
import UIKit
import Flutter

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/Runner-Bridging-Header.h

**크기**: 38 bytes | **라인 수**: 2 | **타입**: text

```
#import "GeneratedPluginRegistrant.h"

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/Runner/main.m

**크기**: 226 bytes | **라인 수**: 10 | **타입**: text

```
#import <Flutter/Flutter.h>
#import <UIKit/UIKit.h>
#import "AppDelegate.h"

int main(int argc, char* argv[]) {
  @autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/ios/firebase_app_id_file.json

**크기**: 275 bytes | **라인 수**: 7 | **타입**: text

```
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:58cbc26aca8e5cf83574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/lib/auth.dart

**크기**: 25238 bytes | **라인 수**: 749 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

import 'package:barcode_widget/barcode_widget.dart';
import 'package:collection/collection.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_example/main.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_facebook_auth/flutter_facebook_auth.dart';
import 'package:flutter_signin_button/flutter_signin_button.dart';
import 'package:google_sign_in/google_sign_in.dart';

typedef OAuthSignIn = void Function();

// If set to true, the app will request notification permissions to use
// silent verification for SMS MFA instead of Recaptcha.
const withSilentVerificationSMSMFA = true;

/// Helper class to show a snackbar using the passed context.
class ScaffoldSnackbar {
  // ignore: public_member_api_docs
  ScaffoldSnackbar(this._context);

  /// The scaffold of current context.
  factory ScaffoldSnackbar.of(BuildContext context) {
    return ScaffoldSnackbar(context);
  }

  final BuildContext _context;

  /// Helper method to show a SnackBar.
  void show(String message) {
    ScaffoldMessenger.of(_context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(
          content: Text(message),
          behavior: SnackBarBehavior.floating,
        ),
      );
  }
}

/// The mode of the current auth session, either [AuthMode.login] or [AuthMode.register].
// ignore: public_member_api_docs
enum AuthMode { login, register, phone }

extension on AuthMode {
  String get label => this == AuthMode.login
      ? 'Sign in'
      : this == AuthMode.phone
          ? 'Sign in'
          : 'Register';
}

/// Entrypoint example for various sign-in flows with Firebase.
class AuthGate extends StatefulWidget {
  // ignore: public_member_api_docs
  const AuthGate({Key? key}) : super(key: key);
  static String? appleAuthorizationCode;
  @override
  State<StatefulWidget> createState() => _AuthGateState();
}

class _AuthGateState extends State<AuthGate> {
  TextEditingController emailController = TextEditingController();
  TextEditingController passwordController = TextEditingController();
  TextEditingController phoneController = TextEditingController();

  GlobalKey<FormState> formKey = GlobalKey<FormState>();
  String error = '';
  String verificationId = '';

  AuthMode mode = AuthMode.login;

  bool isLoading = false;

  void setIsLoading() {
    setState(() {
      isLoading = !isLoading;
    });
  }

  late Map<Buttons, OAuthSignIn> authButtons;

  @override
  void initState() {
    super.initState();

    if (withSilentVerificationSMSMFA && !kIsWeb) {
      FirebaseMessaging messaging = FirebaseMessaging.instance;
      messaging.requestPermission();
    }

    if (!kIsWeb && Platform.isMacOS) {
      authButtons = {
        Buttons.Apple: () => _handleMultiFactorException(
              _signInWithApple,
            ),
      };
    } else {
      authButtons = {
        Buttons.Apple: () => _handleMultiFactorException(
              _signInWithApple,
            ),
        Buttons.Google: () => _handleMultiFactorException(
              _signInWithGoogle,
            ),
        Buttons.GitHub: () => _handleMultiFactorException(
              _signInWithGitHub,
            ),
        Buttons.Microsoft: () => _handleMultiFactorException(
              _signInWithMicrosoft,
            ),
        Buttons.Twitter: () => _handleMultiFactorException(
              _signInWithTwitter,
            ),
        Buttons.Yahoo: () => _handleMultiFactorException(
              _signInWithYahoo,
            ),
        Buttons.Facebook: () => _handleMultiFactorException(
              _signInWithFacebook,
            ),
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: FocusScope.of(context).unfocus,
      child: Scaffold(
        body: Center(
          child: SingleChildScrollView(
            child: Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: SafeArea(
                  child: Form(
                    key: formKey,
                    autovalidateMode: AutovalidateMode.onUserInteraction,
                    child: ConstrainedBox(
                      constraints: const BoxConstraints(maxWidth: 400),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Visibility(
                            visible: error.isNotEmpty,
                            child: MaterialBanner(
                              backgroundColor:
                                  Theme.of(context).colorScheme.error,
                              content: SelectableText(error),
                              actions: [
                                TextButton(
                                  onPressed: () {
                                    setState(() {
                                      error = '';
                                    });
                                  },
                                  child: const Text(
                                    'dismiss',
                                    style: TextStyle(color: Colors.white),
                                  ),
                                ),
                              ],
                              contentTextStyle:
                                  const TextStyle(color: Colors.white),
                              padding: const EdgeInsets.all(10),
                            ),
                          ),
                          const SizedBox(height: 20),
                          if (mode != AuthMode.phone)
                            Column(
                              children: [
                                TextFormField(
                                  controller: emailController,
                                  decoration: const InputDecoration(
                                    hintText: 'Email',
                                    border: OutlineInputBorder(),
                                  ),
                                  keyboardType: TextInputType.emailAddress,
                                  autofillHints: const [AutofillHints.email],
                                  validator: (value) =>
                                      value != null && value.isNotEmpty
                                          ? null
                                          : 'Required',
                                ),
                                const SizedBox(height: 20),
                                TextFormField(
                                  controller: passwordController,
                                  obscureText: true,
                                  decoration: const InputDecoration(
                                    hintText: 'Password',
                                    border: OutlineInputBorder(),
                                  ),
                                  validator: (value) =>
                                      value != null && value.isNotEmpty
                                          ? null
                                          : 'Required',
                                ),
                              ],
                            ),
                          if (mode == AuthMode.phone)
                            TextFormField(
                              controller: phoneController,
                              decoration: const InputDecoration(
                                hintText: '+12345678910',
                                labelText: 'Phone number',
                                border: OutlineInputBorder(),
                              ),
                              validator: (value) =>
                                  value != null && value.isNotEmpty
                                      ? null
                                      : 'Required',
                            ),
                          const SizedBox(height: 20),
                          SizedBox(
                            width: double.infinity,
                            height: 50,
                            child: ElevatedButton(
                              onPressed: isLoading
                                  ? null
                                  : () => _handleMultiFactorException(
                                        _emailAndPassword,
                                      ),
                              child: isLoading
                                  ? const CircularProgressIndicator.adaptive()
                                  : Text(mode.label),
                            ),
                          ),
                          TextButton(
                            onPressed: _resetPassword,
                            child: const Text('Forgot password?'),
                          ),
                          ...authButtons.keys
                              .map(
                                (button) => Padding(
                                  padding:
                                      const EdgeInsets.symmetric(vertical: 5),
                                  child: AnimatedSwitcher(
                                    duration: const Duration(milliseconds: 200),
                                    child: isLoading
                                        ? Container(
                                            color: Colors.grey[200],
                                            height: 50,
                                            width: double.infinity,
                                          )
                                        : SizedBox(
                                            width: double.infinity,
                                            height: 50,
                                            child: SignInButton(
                                              button,
                                              onPressed: authButtons[button],
                                            ),
                                          ),
                                  ),
                                ),
                              )
                              .toList(),
                          SizedBox(
                            width: double.infinity,
                            height: 50,
                            child: OutlinedButton(
                              onPressed: isLoading
                                  ? null
                                  : () {
                                      if (mode != AuthMode.phone) {
                                        setState(() {
                                          mode = AuthMode.phone;
                                        });
                                      } else {
                                        setState(() {
                                          mode = AuthMode.login;
                                        });
                                      }
                                    },
                              child: isLoading
                                  ? const CircularProgressIndicator.adaptive()
                                  : Text(
                                      mode != AuthMode.phone
                                          ? 'Sign in with Phone Number'
                                          : 'Sign in with Email and Password',
                                    ),
                            ),
                          ),
                          const SizedBox(height: 20),
                          if (mode != AuthMode.phone)
                            RichText(
                              text: TextSpan(
                                style: Theme.of(context).textTheme.bodyLarge,
                                children: [
                                  TextSpan(
                                    text: mode == AuthMode.login
                                        ? "Don't have an account? "
                                        : 'You have an account? ',
                                  ),
                                  TextSpan(
                                    text: mode == AuthMode.login
                                        ? 'Register now'
                                        : 'Click to login',
                                    style: const TextStyle(color: Colors.blue),
                                    recognizer: TapGestureRecognizer()
                                      ..onTap = () {
                                        setState(() {
                                          mode = mode == AuthMode.login
                                              ? AuthMode.register
                                              : AuthMode.login;
                                        });
                                      },
                                  ),
                                ],
                              ),
                            ),
                          const SizedBox(height: 10),
                          RichText(
                            text: TextSpan(
                              style: Theme.of(context).textTheme.bodyLarge,
                              children: [
                                const TextSpan(text: 'Or '),
                                TextSpan(
                                  text: 'continue as guest',
                                  style: const TextStyle(color: Colors.blue),
                                  recognizer: TapGestureRecognizer()
                                    ..onTap = _anonymousAuth,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future _resetPassword() async {
    String? email;
    await showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Send'),
            ),
          ],
          content: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Enter your email'),
              const SizedBox(height: 20),
              TextFormField(
                onChanged: (value) {
                  email = value;
                },
              ),
            ],
          ),
        );
      },
    );

    if (email != null) {
      try {
        await auth.sendPasswordResetEmail(email: email!);
        ScaffoldSnackbar.of(context).show('Password reset email is sent');
      } catch (e) {
        ScaffoldSnackbar.of(context).show('Error resetting');
      }
    }
  }

  Future<void> _anonymousAuth() async {
    setIsLoading();

    try {
      await auth.signInAnonymously();
    } on FirebaseAuthException catch (e) {
      setState(() {
        error = '${e.message}';
      });
    } catch (e) {
      setState(() {
        error = '$e';
      });
    } finally {
      setIsLoading();
    }
  }

  Future<void> _handleMultiFactorException(
    Future<void> Function() authFunction,
  ) async {
    setIsLoading();
    try {
      await authFunction();
    } on FirebaseAuthMultiFactorException catch (e) {
      setState(() {
        error = '${e.message}';
      });
      final firstTotpHint = e.resolver.hints
          .firstWhereOrNull((element) => element is TotpMultiFactorInfo);
      if (firstTotpHint != null) {
        final code = await getSmsCodeFromUser(context);
        final assertion = await TotpMultiFactorGenerator.getAssertionForSignIn(
          firstTotpHint.uid,
          code!,
        );
        await e.resolver.resolveSignIn(assertion);
        return;
      }

      final firstPhoneHint = e.resolver.hints
          .firstWhereOrNull((element) => element is PhoneMultiFactorInfo);

      if (firstPhoneHint is! PhoneMultiFactorInfo) {
        return;
      }
      await auth.verifyPhoneNumber(
        multiFactorSession: e.resolver.session,
        multiFactorInfo: firstPhoneHint,
        verificationCompleted: (_) {},
        verificationFailed: print,
        codeSent: (String verificationId, int? resendToken) async {
          final smsCode = await getSmsCodeFromUser(context);

          if (smsCode != null) {
            // Create a PhoneAuthCredential with the code
            final credential = PhoneAuthProvider.credential(
              verificationId: verificationId,
              smsCode: smsCode,
            );

            try {
              await e.resolver.resolveSignIn(
                PhoneMultiFactorGenerator.getAssertion(
                  credential,
                ),
              );
            } on FirebaseAuthException catch (e) {
              print(e.message);
            }
          }
        },
        codeAutoRetrievalTimeout: print,
      );
    } on FirebaseAuthException catch (e) {
      setState(() {
        error = '${e.message}';
      });
    } catch (e) {
      setState(() {
        error = '$e';
      });
    }
    setIsLoading();
  }

  Future<void> _emailAndPassword() async {
    if (formKey.currentState?.validate() ?? false) {
      if (mode == AuthMode.login) {
        await auth.signInWithEmailAndPassword(
          email: emailController.text,
          password: passwordController.text,
        );
      } else if (mode == AuthMode.register) {
        await auth.createUserWithEmailAndPassword(
          email: emailController.text,
          password: passwordController.text,
        );
      } else {
        await _phoneAuth();
      }
    }
  }

  Future<void> _phoneAuth() async {
    if (mode != AuthMode.phone) {
      setState(() {
        mode = AuthMode.phone;
      });
    } else {
      if (kIsWeb) {
        final confirmationResult =
            await auth.signInWithPhoneNumber(phoneController.text);
        final smsCode = await getSmsCodeFromUser(context);

        if (smsCode != null) {
          await confirmationResult.confirm(smsCode);
        }
      } else {
        await auth.verifyPhoneNumber(
          phoneNumber: phoneController.text,
          verificationCompleted: (_) {},
          verificationFailed: (e) {
            setState(() {
              error = '${e.message}';
            });
          },
          codeSent: (String verificationId, int? resendToken) async {
            final smsCode = await getSmsCodeFromUser(context);

            if (smsCode != null) {
              // Create a PhoneAuthCredential with the code
              final credential = PhoneAuthProvider.credential(
                verificationId: verificationId,
                smsCode: smsCode,
              );

              try {
                // Sign the user in (or link) with the credential
                await auth.signInWithCredential(credential);
              } on FirebaseAuthException catch (e) {
                setState(() {
                  error = e.message ?? '';
                });
              }
            }
          },
          codeAutoRetrievalTimeout: (e) {
            setState(() {
              error = e;
            });
          },
        );
      }
    }
  }

  Future<void> _signInWithGoogle() async {
    // Trigger the authentication flow
    final googleUser = await GoogleSignIn().signIn();

    // Obtain the auth details from the request
    final googleAuth = await googleUser?.authentication;

    if (googleAuth != null) {
      // Create a new credential
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      // Once signed in, return the UserCredential
      await auth.signInWithCredential(credential);
    }
  }

  Future<void> _signInWithFacebook() async {
    // Trigger the authentication flow
    // by default we request the email and the public profile
    final LoginResult result = await FacebookAuth.instance.login();

    if (result.status == LoginStatus.success) {
      // Get access token
      final AccessToken accessToken = result.accessToken!;

      // Login with token
      await auth.signInWithCredential(
        FacebookAuthProvider.credential(accessToken.tokenString),
      );
    } else {
      print('Facebook login did not succeed');
      print(result.status);
      print(result.message);
    }
  }
}

Future<void> _signInWithTwitter() async {
  TwitterAuthProvider twitterProvider = TwitterAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(twitterProvider);
  } else {
    await auth.signInWithProvider(twitterProvider);
  }
}

Future<void> _signInWithApple() async {
  final appleProvider = AppleAuthProvider();
  appleProvider.addScope('email');

  if (kIsWeb) {
    // Once signed in, return the UserCredential
    await auth.signInWithPopup(appleProvider);
  } else {
    final userCred = await auth.signInWithProvider(appleProvider);
    AuthGate.appleAuthorizationCode =
        userCred.additionalUserInfo?.authorizationCode;
  }
}

Future<void> _signInWithYahoo() async {
  final yahooProvider = YahooAuthProvider();

  if (kIsWeb) {
    // Once signed in, return the UserCredential
    await auth.signInWithPopup(yahooProvider);
  } else {
    await auth.signInWithProvider(yahooProvider);
  }
}

Future<void> _signInWithGitHub() async {
  final githubProvider = GithubAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(githubProvider);
  } else {
    await auth.signInWithProvider(githubProvider);
  }
}

Future<void> _signInWithMicrosoft() async {
  final microsoftProvider = MicrosoftAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(microsoftProvider);
  } else {
    await auth.signInWithProvider(microsoftProvider);
  }
}

Future<String?> getSmsCodeFromUser(BuildContext context) async {
  String? smsCode;

  // Update the UI - wait for the user to enter the SMS code
  await showDialog<String>(
    context: context,
    barrierDismissible: false,
    builder: (context) {
      return AlertDialog(
        title: const Text('SMS code:'),
        actions: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Sign in'),
          ),
          OutlinedButton(
            onPressed: () {
              smsCode = null;
              Navigator.of(context).pop();
            },
            child: const Text('Cancel'),
          ),
        ],
        content: Container(
          padding: const EdgeInsets.all(20),
          child: TextField(
            onChanged: (value) {
              smsCode = value;
            },
            textAlign: TextAlign.center,
            autofocus: true,
          ),
        ),
      );
    },
  );

  return smsCode;
}

Future<String?> getTotpFromUser(
  BuildContext context,
  TotpSecret totpSecret,
) async {
  String? smsCode;

  final qrCodeUrl = await totpSecret.generateQrCodeUrl(
    accountName: FirebaseAuth.instance.currentUser!.email,
    issuer: 'Firebase',
  );

  // Update the UI - wait for the user to enter the SMS code
  await showDialog<String>(
    context: context,
    barrierDismissible: false,
    builder: (context) {
      return AlertDialog(
        title: const Text('TOTP code:'),
        content: Container(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              BarcodeWidget(
                barcode: Barcode.qrCode(),
                data: qrCodeUrl,
                width: 150,
                height: 150,
              ),
              TextField(
                onChanged: (value) {
                  smsCode = value;
                },
                textAlign: TextAlign.center,
                autofocus: true,
              ),
              ElevatedButton(
                onPressed: () {
                  totpSecret.openInOtpApp(qrCodeUrl);
                },
                child: const Text('Open in OTP App'),
              ),
            ],
          ),
        ),
        actions: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Sign in'),
          ),
          OutlinedButton(
            onPressed: () {
              smsCode = null;
              Navigator.of(context).pop();
            },
            child: const Text('Cancel'),
          ),
        ],
      );
    },
  );

  return smsCode;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/lib/firebase_options.dart

**크기**: 3782 bytes | **라인 수**: 99 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return macos;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:21d5142deea38dda3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:58cbc26aca8e5cf83574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-134k3722m01rtrsklhf3b7k8sqa5r7in.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.auth.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:58cbc26aca8e5cf83574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-134k3722m01rtrsklhf3b7k8sqa5r7in.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.auth.example',
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/lib/main.dart

**크기**: 3694 bytes | **라인 수**: 109 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:google_sign_in_dartio/google_sign_in_dartio.dart';

import 'auth.dart';
import 'firebase_options.dart';
import 'profile.dart';

/// Requires that a Firebase local emulator is running locally.
/// See https://firebase.google.com/docs/auth/flutter/start#optional_prototype_and_test_with_firebase_local_emulator_suite
bool shouldUseFirebaseEmulator = false;

late final FirebaseApp app;
late final FirebaseAuth auth;

// Requires that the Firebase Auth emulator is running locally
// e.g via `melos run firebase:emulator`.
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // We're using the manual installation on non-web platforms since Google sign in plugin doesn't yet support Dart initialization.
  // See related issue: https://github.com/flutter/flutter/issues/96391

  // We store the app and auth to make testing with a named instance easier.
  app = await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  auth = FirebaseAuth.instanceFor(app: app);

  if (shouldUseFirebaseEmulator) {
    await auth.useAuthEmulator('localhost', 9099);
  }

  if (!kIsWeb && Platform.isWindows) {
    await GoogleSignInDart.register(
      clientId:
          '406099696497-g5o9l0blii9970bgmfcfv14pioj90djd.apps.googleusercontent.com',
    );
  }

  runApp(const AuthExampleApp());
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class AuthExampleApp extends StatelessWidget {
  const AuthExampleApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firebase Example App',
      theme: ThemeData(primarySwatch: Colors.amber),
      home: Scaffold(
        body: LayoutBuilder(
          builder: (context, constraints) {
            return Row(
              children: [
                Visibility(
                  visible: constraints.maxWidth >= 1200,
                  child: Expanded(
                    child: Container(
                      height: double.infinity,
                      color: Theme.of(context).colorScheme.primary,
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              'Firebase Auth Desktop',
                              style: Theme.of(context).textTheme.headlineMedium,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                SizedBox(
                  width: constraints.maxWidth >= 1200
                      ? constraints.maxWidth / 2
                      : constraints.maxWidth,
                  child: StreamBuilder<User?>(
                    stream: auth.authStateChanges(),
                    builder: (context, snapshot) {
                      if (snapshot.hasData) {
                        return const ProfilePage();
                      }
                      return const AuthGate();
                    },
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/lib/profile.dart

**크기**: 14687 bytes | **라인 수**: 392 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:developer';

import 'package:collection/collection.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_example/main.dart';
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';

import 'auth.dart';

/// Displayed as a profile image if the user doesn't have one.
const placeholderImage =
    'https://upload.wikimedia.org/wikipedia/commons/c/cd/Portrait_Placeholder_Square.png';

/// Profile page shows after sign in or registration.
class ProfilePage extends StatefulWidget {
  // ignore: public_member_api_docs
  const ProfilePage({Key? key}) : super(key: key);

  @override
  // ignore: library_private_types_in_public_api
  _ProfilePageState createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  late User user;
  late TextEditingController controller;
  final phoneController = TextEditingController();

  String? photoURL;

  bool showSaveButton = false;
  bool isLoading = false;

  @override
  void initState() {
    user = auth.currentUser!;
    controller = TextEditingController(text: user.displayName);

    controller.addListener(_onNameChanged);

    auth.userChanges().listen((event) {
      if (event != null && mounted) {
        setState(() {
          user = event;
        });
      }
    });

    log(user.toString());

    super.initState();
  }

  @override
  void dispose() {
    controller.removeListener(_onNameChanged);

    super.dispose();
  }

  void setIsLoading() {
    setState(() {
      isLoading = !isLoading;
    });
  }

  void _onNameChanged() {
    setState(() {
      if (controller.text == user.displayName || controller.text.isEmpty) {
        showSaveButton = false;
      } else {
        showSaveButton = true;
      }
    });
  }

  /// Map User provider data into a list of Provider Ids.
  List get userProviders => user.providerData.map((e) => e.providerId).toList();

  Future updateDisplayName() async {
    await user.updateDisplayName(controller.text);

    setState(() {
      showSaveButton = false;
    });

    // ignore: use_build_context_synchronously
    ScaffoldSnackbar.of(context).show('Name updated');
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: FocusScope.of(context).unfocus,
      child: Scaffold(
        body: Stack(
          children: [
            Center(
              child: SizedBox(
                width: 400,
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Stack(
                        children: [
                          CircleAvatar(
                            maxRadius: 60,
                            backgroundImage: NetworkImage(
                              user.photoURL ?? placeholderImage,
                            ),
                          ),
                          Positioned.directional(
                            textDirection: Directionality.of(context),
                            end: 0,
                            bottom: 0,
                            child: Material(
                              clipBehavior: Clip.antiAlias,
                              color: Theme.of(context).colorScheme.secondary,
                              borderRadius: BorderRadius.circular(40),
                              child: InkWell(
                                onTap: () async {
                                  final photoURL = await getPhotoURLFromUser();

                                  if (photoURL != null) {
                                    await user.updatePhotoURL(photoURL);
                                  }
                                },
                                radius: 50,
                                child: const SizedBox(
                                  width: 35,
                                  height: 35,
                                  child: Icon(Icons.edit),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 10),
                      TextField(
                        textAlign: TextAlign.center,
                        controller: controller,
                        decoration: const InputDecoration(
                          border: InputBorder.none,
                          floatingLabelBehavior: FloatingLabelBehavior.never,
                          alignLabelWithHint: true,
                          label: Center(
                            child: Text(
                              'Click to add a display name',
                            ),
                          ),
                        ),
                      ),
                      Text(user.email ?? user.phoneNumber ?? 'User'),
                      const SizedBox(height: 10),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          if (userProviders.contains('phone'))
                            const Icon(Icons.phone),
                          if (userProviders.contains('password'))
                            const Icon(Icons.mail),
                          if (userProviders.contains('google.com'))
                            SizedBox(
                              width: 24,
                              child: Image.network(
                                'https://upload.wikimedia.org/wikipedia/commons/0/09/IOS_Google_icon.png',
                              ),
                            ),
                        ],
                      ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () {
                          user.sendEmailVerification();
                        },
                        child: const Text('Verify Email'),
                      ),
                      TextButton(
                        onPressed: () async {
                          final a = await user.multiFactor.getEnrolledFactors();
                          print(a);
                        },
                        child: const Text('Get enrolled factors'),
                      ),
                      TextButton(
                        onPressed: () async {
                          if (AuthGate.appleAuthorizationCode != null) {
                            // The `authorizationCode` is on the user credential.
                            // e.g. final authorizationCode = userCredential.additionalUserInfo?.authorizationCode;
                            await FirebaseAuth.instance
                                .revokeTokenWithAuthorizationCode(
                              AuthGate.appleAuthorizationCode!,
                            );
                            // You may wish to delete the user at this point
                            AuthGate.appleAuthorizationCode = null;
                          } else {
                            print(
                              'Apple `authorizationCode` is null, cannot revoke token.',
                            );
                          }
                        },
                        child: const Text('Revoke Apple auth token'),
                      ),
                      TextFormField(
                        controller: phoneController,
                        decoration: const InputDecoration(
                          icon: Icon(Icons.phone),
                          hintText: '+33612345678',
                          labelText: 'Phone number',
                        ),
                      ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () async {
                          final session = await user.multiFactor.getSession();
                          await auth.verifyPhoneNumber(
                            multiFactorSession: session,
                            phoneNumber: phoneController.text,
                            verificationCompleted: (_) {},
                            verificationFailed: print,
                            codeSent: (
                              String verificationId,
                              int? resendToken,
                            ) async {
                              final smsCode = await getSmsCodeFromUser(context);

                              if (smsCode != null) {
                                // Create a PhoneAuthCredential with the code
                                final credential = PhoneAuthProvider.credential(
                                  verificationId: verificationId,
                                  smsCode: smsCode,
                                );

                                try {
                                  await user.multiFactor.enroll(
                                    PhoneMultiFactorGenerator.getAssertion(
                                      credential,
                                    ),
                                  );
                                } on FirebaseAuthException catch (e) {
                                  print(e.message);
                                }
                              }
                            },
                            codeAutoRetrievalTimeout: print,
                          );
                        },
                        child: const Text('Verify Number For MFA'),
                      ),
                      TextButton(
                        onPressed: () async {
                          final totp =
                              (await user.multiFactor.getEnrolledFactors())
                                  .firstWhereOrNull(
                            (element) => element.factorId == 'totp',
                          );
                          if (totp != null) {
                            await user.multiFactor.unenroll(
                              factorUid:
                                  (await user.multiFactor.getEnrolledFactors())
                                      .firstWhere(
                                        (element) => element.factorId == 'totp',
                                      )
                                      .uid,
                            );
                          }
                          final session = await user.multiFactor.getSession();
                          final totpSecret =
                              await TotpMultiFactorGenerator.generateSecret(
                            session,
                          );
                          print(totpSecret);
                          final code =
                              await getTotpFromUser(context, totpSecret);
                          print('code: $code');
                          if (code == null) {
                            return;
                          }
                          await user.multiFactor.enroll(
                            await TotpMultiFactorGenerator
                                .getAssertionForEnrollment(
                              totpSecret,
                              code,
                            ),
                            displayName: 'TOTP',
                          );
                        },
                        child: const Text('Enroll TOTP'),
                      ),
                      TextButton(
                        onPressed: () async {
                          try {
                            final enrolledFactors =
                                await user.multiFactor.getEnrolledFactors();

                            await user.multiFactor.unenroll(
                              factorUid: enrolledFactors.first.uid,
                            );
                            // Show snackbar
                            ScaffoldSnackbar.of(context).show('MFA unenrolled');
                          } catch (e) {
                            print(e);
                          }
                        },
                        child: const Text('Unenroll MFA'),
                      ),
                      const Divider(),
                      TextButton(
                        onPressed: _signOut,
                        child: const Text('Sign out'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            Positioned.directional(
              textDirection: Directionality.of(context),
              end: 40,
              top: 40,
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 200),
                child: !showSaveButton
                    ? SizedBox(key: UniqueKey())
                    : TextButton(
                        onPressed: isLoading ? null : updateDisplayName,
                        child: const Text('Save changes'),
                      ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<String?> getPhotoURLFromUser() async {
    String? photoURL;

    // Update the UI - wait for the user to enter the SMS code
    await showDialog<String>(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return AlertDialog(
          title: const Text('New image Url:'),
          actions: [
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Update'),
            ),
            OutlinedButton(
              onPressed: () {
                photoURL = null;
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
          ],
          content: Container(
            padding: const EdgeInsets.all(20),
            child: TextField(
              onChanged: (value) {
                photoURL = value;
              },
              textAlign: TextAlign.center,
              autofocus: true,
            ),
          ),
        );
      },
    );

    return photoURL;
  }

  /// Example code for sign out.
  Future<void> _signOut() async {
    await auth.signOut();
    await GoogleSignIn().signOut();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 1291 bytes | **라인 수**: 69 | **타입**: text

```
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/macos/Runner/AppDelegate.swift

**크기**: 311 bytes | **라인 수**: 14 | **타입**: text

```
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/macos/Runner/MainFlutterWindow.swift

**크기**: 393 bytes | **라인 수**: 16 | **타입**: text

```
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController.init()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/macos/firebase_app_id_file.json

**크기**: 275 bytes | **라인 수**: 7 | **타입**: text

```
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:58cbc26aca8e5cf83574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/web/index.html

**크기**: 1236 bytes | **라인 수**: 39 | **타입**: text

```
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="flutterfire_auth">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>flutterfire_auth</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/web/manifest.json

**크기**: 928 bytes | **라인 수**: 36 | **타입**: text

```
{
    "name": "flutterfire_auth",
    "short_name": "flutterfire_auth",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/flutter/CMakeLists.txt

**크기**: 3742 bytes | **라인 수**: 110 | **타입**: text

```
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/CMakeLists.txt

**크기**: 1796 bytes | **라인 수**: 41 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/flutter_window.cpp

**크기**: 2061 bytes | **라인 수**: 69 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() { this->Show(); });

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/flutter_window.h

**크기**: 1152 bytes | **라인 수**: 40 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/main.cpp

**크기**: 1471 bytes | **라인 수**: 47 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t* command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments = GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/resource.h

**크기**: 604 bytes | **라인 수**: 23 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON 101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE 102
#define _APS_NEXT_COMMAND_VALUE 40001
#define _APS_NEXT_CONTROL_VALUE 1001
#define _APS_NEXT_SYMED_VALUE 101
#endif
#endif

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/utils.cpp

**크기**: 2030 bytes | **라인 수**: 70 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE* unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length =
      ::WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, -1,
                            nullptr, 0, nullptr, nullptr) -
      1;  // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length <= 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, input_length,
      utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/utils.h

**크기**: 896 bytes | **라인 수**: 26 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/win32_window.cpp

**크기**: 8585 bytes | **라인 수**: 285 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See:
/// https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
    L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] =
    L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() { ++g_active_window_count; }

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title, const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() { return ShowWindow(window_handle_, SW_SHOWNORMAL); }

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window, UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd, UINT const message, WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() { return window_handle_; }

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result =
      RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                  kGetPreferredBrightnessRegValue, RRF_RT_REG_DWORD, nullptr,
                  &light_mode, &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/runner/win32_window.h

**크기**: 3679 bytes | **라인 수**: 107 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window, UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window, UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/windows/CMakeLists.txt

**크기**: 3900 bytes | **라인 수**: 103 | **타입**: text

```
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/README.md

**크기**: 3362 bytes | **라인 수**: 59 | **타입**: text

```
# Firebase Auth Example

[![pub package](https://img.shields.io/pub/v/firebase_auth.svg)](https://pub.dev/packages/firebase_auth)

Demonstrates how to use the `firebase_auth` plugin and enable multiple auth providers.

## Phone Auth

1. Enable phone authentication in the [Firebase console]((https://console.firebase.google.com/u/0/project/_/authentication/providers)).
2. Add test phone number and verification code to the Firebase console.
  - For this sample the number `+1 408-555-6969` and verification code `888888` are used.
3. For iOS set the `URL Schemes` to the `REVERSE_CLIENT_ID` from the `GoogleServices-Info.plist` file.
4. Enter the phone number `+1 408-555-6969` and press the `Verify phone number` button.
5. Once the phone number is verified the app displays the test
   verification code.
6. Enter the verficication code `888888` and press "Sign in with phone number"
7. Signed in user ID is now displayed in the UI.

## Google Sign-In

1. Enable Google authentication in the [Firebase console](https://console.firebase.google.com/u/0/project/_/authentication/providers).
2. For Android, add your app's package name and SHA-1 fingerprint to the [Settings page](https://console.firebase.google.com/project/_/settings/general) of the Firebase console. Refer to [Authenticating Your Client]('https://developers.google.com/android/guides/client-auth') for details on how to get your app's SHA-1 fingerprint.
3. For iOS set the `URL Schemes` to the `REVERSE_CLIENT_ID` from the `GoogleServices-Info.plist` file (same step for `Phone Auth` above).
4. Select `Google` under `Social Authentication` and click the `Sign In With Google` button.
5. Signed in user's details are displayed in the UI.

### Running on Web

Make sure you run the example app on port 5000, since `localhost:5000` is
whitelisted for Google authentication. To do so, run:

```
flutter run -d web-server --web-port 5000
```

## GitHub Sign-In
To get your `clientId` and `clientSecret`: 
1. Visit https://github.com/settings/developers.
2. Create a new OAuth application.
3. Set **Home Page URL** to `https://react-native-firebase-testing.firebaseapp.com`.
4. Set **Authorization callback URL** to `https://react-native-firebase-testing.firebaseapp.com/__/auth/handler`.
5. After you register your app, add the `clientId` and `clientSecret` to the example app config in [`lib/config.dart`](./lib/config.dart).

## Twitter Sign-In
Twitter sign in requires you to add keys from Twitter Developer API to Firebase Console, which means you cannot use the provided configurations with the example app, instead, **please create a new Firebase project**, then enable Twitter as an Auth provider (*optionally you can enable the rest of providers supported in this example*).

To get your `apiKey` and `apiSecretKey` for Twitter:
1. Sign up for a developer account on [Twitter Developer](https://developer.twitter.com).
2. Create a new app and copy your keys.
3. From the dashboard, go to your app settings, then go to OAuth settings and turn on OAuth 1.0a, then add 2 callback URLs:
   1. `flutterfireauth://`
   2. `https://react-native-firebase-testing.firebaseapp.com/__/auth/handler`
4. Add your keys to the example app config in [`lib/config.dart`](./lib/config.dart).

## Getting Started

For help getting started with Flutter, view the online
[documentation](https://flutter.dev/).

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/analysis_options.yaml

**크기**: 172 bytes | **라인 수**: 8 | **타입**: text

```
include: ../../../../analysis_options.yaml

linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/example/pubspec.yaml

**크기**: 469 bytes | **라인 수**: 24 | **타입**: text

```
name: firebase_auth_example
description: Demonstrates how to use the firebase_auth plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  barcode_widget: ^2.0.4
  firebase_auth: ^6.1.0
  firebase_core: ^4.1.1
  firebase_messaging: ^16.0.2
  flutter:
    sdk: flutter
  flutter_facebook_auth: ^7.0.1
  flutter_signin_button: ^2.0.0
  google_sign_in: ^6.1.0
  google_sign_in_dartio: ^0.3.0

dev_dependencies:
  http: ^1.0.0

flutter:
  uses-material-design: true

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Private/FLTAuthStateChannelStreamHandler.h

**크기**: 568 bytes | **라인 수**: 27 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>
#import "../Public/CustomPigeonHeader.h"

@class FIRAuth;

NS_ASSUME_NONNULL_BEGIN

@interface FLTAuthStateChannelStreamHandler : NSObject <FlutterStreamHandler>

- (instancetype)initWithAuth:(FIRAuth *)auth;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Private/FLTIdTokenChannelStreamHandler.h

**크기**: 567 bytes | **라인 수**: 28 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "../Public/CustomPigeonHeader.h"

#import <Foundation/Foundation.h>

@class FIRAuth;

NS_ASSUME_NONNULL_BEGIN

@interface FLTIdTokenChannelStreamHandler : NSObject <FlutterStreamHandler>

- (instancetype)initWithAuth:(FIRAuth *)auth;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Private/FLTPhoneNumberVerificationStreamHandler.h

**크기**: 957 bytes | **라인 수**: 37 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "../Public/firebase_auth_messages.g.h"

#import <Foundation/Foundation.h>

@class FIRAuth;
@class FIRMultiFactorSession;
@class FIRPhoneMultiFactorInfo;

NS_ASSUME_NONNULL_BEGIN

@interface FLTPhoneNumberVerificationStreamHandler : NSObject <FlutterStreamHandler>

#if TARGET_OS_OSX
- (instancetype)initWithAuth:(FIRAuth *)auth arguments:(NSDictionary *)arguments;
#else
- (instancetype)initWithAuth:(FIRAuth *)auth
                     request:(PigeonVerifyPhoneNumberRequest *)request
                     session:(FIRMultiFactorSession *)session
                  factorInfo:(FIRPhoneMultiFactorInfo *)factorInfo;
#endif

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Private/PigeonParser.h

**크기**: 1539 bytes | **라인 수**: 34 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#import <Foundation/Foundation.h>
#import "../Public/firebase_auth_messages.g.h"

@class FIRAuthDataResult;
@class FIRUser;
@class FIRActionCodeSettings;
@class FIRAuthTokenResult;
@class FIRTOTPSecret;
@class FIRAuthCredential;

@interface PigeonParser : NSObject

+ (NSArray *_Nonnull)getManualList:(nonnull PigeonUserDetails *)userDetails;
+ (PigeonUserCredential *_Nullable)
    getPigeonUserCredentialFromAuthResult:(nonnull FIRAuthDataResult *)authResult
                        authorizationCode:(nullable NSString *)authorizationCode;
+ (PigeonUserDetails *_Nullable)getPigeonDetails:(nonnull FIRUser *)user;
+ (PigeonUserInfo *_Nullable)getPigeonUserInfo:(nonnull FIRUser *)user;
+ (FIRActionCodeSettings *_Nullable)parseActionCodeSettings:
    (nullable PigeonActionCodeSettings *)settings;
+ (PigeonUserCredential *_Nullable)getPigeonUserCredentialFromFIRUser:(nonnull FIRUser *)user;
+ (PigeonIdTokenResult *_Nonnull)parseIdTokenResult:(nonnull FIRAuthTokenResult *)tokenResult;
+ (PigeonTotpSecret *_Nonnull)getPigeonTotpSecret:(nonnull FIRTOTPSecret *)secret;
+ (PigeonAuthCredential *_Nullable)getPigeonAuthCredential:
                                       (FIRAuthCredential *_Nullable)authCredentialToken
                                                     token:(NSNumber *_Nullable)token;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Public/CustomPigeonHeader.h

**크기**: 404 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import "firebase_auth_messages.g.h"

@interface PigeonMultiFactorInfo (Map)
- (NSDictionary *)toList;
@end

@interface PigeonUserDetails (Map)
- (NSDictionary *)toList;
@end

@interface PigeonUserInfo (Map)
- (NSDictionary *)toList;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Public/FLTFirebaseAuthPlugin.h

**크기**: 1146 bytes | **라인 수**: 35 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <AuthenticationServices/AuthenticationServices.h>
#import <Foundation/Foundation.h>
#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "firebase_auth_messages.g.h"

@interface FLTFirebaseAuthPlugin
    : FLTFirebasePlugin <FlutterPlugin,
                         FirebaseAuthHostApi,
                         FirebaseAuthUserHostApi,
                         MultiFactorUserHostApi,
                         MultiFactoResolverHostApi,
                         MultiFactorTotpHostApi,
                         MultiFactorTotpSecretHostApi,
                         ASAuthorizationControllerDelegate,
                         ASAuthorizationControllerPresentationContextProviding>

+ (FlutterError *)convertToFlutterError:(NSError *)error;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/include/Public/firebase_auth_messages.g.h

**크기**: 30697 bytes | **라인 수**: 571 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

/// The type of operation that generated the action code from calling
/// [checkActionCode].
typedef NS_ENUM(NSUInteger, ActionCodeInfoOperation) {
  /// Unknown operation.
  ActionCodeInfoOperationUnknown = 0,
  /// Password reset code generated via [sendPasswordResetEmail].
  ActionCodeInfoOperationPasswordReset = 1,
  /// Email verification code generated via [User.sendEmailVerification].
  ActionCodeInfoOperationVerifyEmail = 2,
  /// Email change revocation code generated via [User.updateEmail].
  ActionCodeInfoOperationRecoverEmail = 3,
  /// Email sign in code generated via [sendSignInLinkToEmail].
  ActionCodeInfoOperationEmailSignIn = 4,
  /// Verify and change email code generated via [User.verifyBeforeUpdateEmail].
  ActionCodeInfoOperationVerifyAndChangeEmail = 5,
  /// Action code for reverting second factor addition.
  ActionCodeInfoOperationRevertSecondFactorAddition = 6,
};

/// Wrapper for ActionCodeInfoOperation to allow for nullability.
@interface ActionCodeInfoOperationBox : NSObject
@property(nonatomic, assign) ActionCodeInfoOperation value;
- (instancetype)initWithValue:(ActionCodeInfoOperation)value;
@end

@class PigeonMultiFactorSession;
@class PigeonPhoneMultiFactorAssertion;
@class PigeonMultiFactorInfo;
@class AuthPigeonFirebaseApp;
@class PigeonActionCodeInfoData;
@class PigeonActionCodeInfo;
@class PigeonAdditionalUserInfo;
@class PigeonAuthCredential;
@class PigeonUserInfo;
@class PigeonUserDetails;
@class PigeonUserCredential;
@class PigeonActionCodeSettings;
@class PigeonFirebaseAuthSettings;
@class PigeonSignInProvider;
@class PigeonVerifyPhoneNumberRequest;
@class PigeonIdTokenResult;
@class PigeonUserProfile;
@class PigeonTotpSecret;

@interface PigeonMultiFactorSession : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithId:(NSString *)id;
@property(nonatomic, copy) NSString *id;
@end

@interface PigeonPhoneMultiFactorAssertion : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithVerificationId:(NSString *)verificationId
                      verificationCode:(NSString *)verificationCode;
@property(nonatomic, copy) NSString *verificationId;
@property(nonatomic, copy) NSString *verificationCode;
@end

@interface PigeonMultiFactorInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                enrollmentTimestamp:(double)enrollmentTimestamp
                           factorId:(nullable NSString *)factorId
                                uid:(NSString *)uid
                        phoneNumber:(nullable NSString *)phoneNumber;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, assign) double enrollmentTimestamp;
@property(nonatomic, copy, nullable) NSString *factorId;
@property(nonatomic, copy) NSString *uid;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@end

@interface AuthPigeonFirebaseApp : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppName:(NSString *)appName
                       tenantId:(nullable NSString *)tenantId
               customAuthDomain:(nullable NSString *)customAuthDomain;
@property(nonatomic, copy) NSString *appName;
@property(nonatomic, copy, nullable) NSString *tenantId;
@property(nonatomic, copy, nullable) NSString *customAuthDomain;
@end

@interface PigeonActionCodeInfoData : NSObject
+ (instancetype)makeWithEmail:(nullable NSString *)email
                previousEmail:(nullable NSString *)previousEmail;
@property(nonatomic, copy, nullable) NSString *email;
@property(nonatomic, copy, nullable) NSString *previousEmail;
@end

@interface PigeonActionCodeInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithOperation:(ActionCodeInfoOperation)operation
                             data:(PigeonActionCodeInfoData *)data;
@property(nonatomic, assign) ActionCodeInfoOperation operation;
@property(nonatomic, strong) PigeonActionCodeInfoData *data;
@end

@interface PigeonAdditionalUserInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithIsNewUser:(BOOL)isNewUser
                       providerId:(nullable NSString *)providerId
                         username:(nullable NSString *)username
                authorizationCode:(nullable NSString *)authorizationCode
                          profile:(nullable NSDictionary<NSString *, id> *)profile;
@property(nonatomic, assign) BOOL isNewUser;
@property(nonatomic, copy, nullable) NSString *providerId;
@property(nonatomic, copy, nullable) NSString *username;
@property(nonatomic, copy, nullable) NSString *authorizationCode;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, id> *profile;
@end

@interface PigeonAuthCredential : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithProviderId:(NSString *)providerId
                      signInMethod:(NSString *)signInMethod
                          nativeId:(NSInteger)nativeId
                       accessToken:(nullable NSString *)accessToken;
@property(nonatomic, copy) NSString *providerId;
@property(nonatomic, copy) NSString *signInMethod;
@property(nonatomic, assign) NSInteger nativeId;
@property(nonatomic, copy, nullable) NSString *accessToken;
@end

@interface PigeonUserInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUid:(NSString *)uid
                      email:(nullable NSString *)email
                displayName:(nullable NSString *)displayName
                   photoUrl:(nullable NSString *)photoUrl
                phoneNumber:(nullable NSString *)phoneNumber
                isAnonymous:(BOOL)isAnonymous
            isEmailVerified:(BOOL)isEmailVerified
                 providerId:(nullable NSString *)providerId
                   tenantId:(nullable NSString *)tenantId
               refreshToken:(nullable NSString *)refreshToken
          creationTimestamp:(nullable NSNumber *)creationTimestamp
        lastSignInTimestamp:(nullable NSNumber *)lastSignInTimestamp;
@property(nonatomic, copy) NSString *uid;
@property(nonatomic, copy, nullable) NSString *email;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, copy, nullable) NSString *photoUrl;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, assign) BOOL isAnonymous;
@property(nonatomic, assign) BOOL isEmailVerified;
@property(nonatomic, copy, nullable) NSString *providerId;
@property(nonatomic, copy, nullable) NSString *tenantId;
@property(nonatomic, copy, nullable) NSString *refreshToken;
@property(nonatomic, strong, nullable) NSNumber *creationTimestamp;
@property(nonatomic, strong, nullable) NSNumber *lastSignInTimestamp;
@end

@interface PigeonUserDetails : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUserInfo:(PigeonUserInfo *)userInfo
                    providerData:(NSArray<NSDictionary<id, id> *> *)providerData;
@property(nonatomic, strong) PigeonUserInfo *userInfo;
@property(nonatomic, copy) NSArray<NSDictionary<id, id> *> *providerData;
@end

@interface PigeonUserCredential : NSObject
+ (instancetype)makeWithUser:(nullable PigeonUserDetails *)user
          additionalUserInfo:(nullable PigeonAdditionalUserInfo *)additionalUserInfo
                  credential:(nullable PigeonAuthCredential *)credential;
@property(nonatomic, strong, nullable) PigeonUserDetails *user;
@property(nonatomic, strong, nullable) PigeonAdditionalUserInfo *additionalUserInfo;
@property(nonatomic, strong, nullable) PigeonAuthCredential *credential;
@end

@interface PigeonActionCodeSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUrl:(NSString *)url
          dynamicLinkDomain:(nullable NSString *)dynamicLinkDomain
            handleCodeInApp:(BOOL)handleCodeInApp
                iOSBundleId:(nullable NSString *)iOSBundleId
         androidPackageName:(nullable NSString *)androidPackageName
          androidInstallApp:(BOOL)androidInstallApp
      androidMinimumVersion:(nullable NSString *)androidMinimumVersion
                 linkDomain:(nullable NSString *)linkDomain;
@property(nonatomic, copy) NSString *url;
@property(nonatomic, copy, nullable) NSString *dynamicLinkDomain;
@property(nonatomic, assign) BOOL handleCodeInApp;
@property(nonatomic, copy, nullable) NSString *iOSBundleId;
@property(nonatomic, copy, nullable) NSString *androidPackageName;
@property(nonatomic, assign) BOOL androidInstallApp;
@property(nonatomic, copy, nullable) NSString *androidMinimumVersion;
@property(nonatomic, copy, nullable) NSString *linkDomain;
@end

@interface PigeonFirebaseAuthSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppVerificationDisabledForTesting:(BOOL)appVerificationDisabledForTesting
                                          userAccessGroup:(nullable NSString *)userAccessGroup
                                              phoneNumber:(nullable NSString *)phoneNumber
                                                  smsCode:(nullable NSString *)smsCode
                                       forceRecaptchaFlow:(nullable NSNumber *)forceRecaptchaFlow;
@property(nonatomic, assign) BOOL appVerificationDisabledForTesting;
@property(nonatomic, copy, nullable) NSString *userAccessGroup;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, copy, nullable) NSString *smsCode;
@property(nonatomic, strong, nullable) NSNumber *forceRecaptchaFlow;
@end

@interface PigeonSignInProvider : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithProviderId:(NSString *)providerId
                            scopes:(nullable NSArray<NSString *> *)scopes
                  customParameters:
                      (nullable NSDictionary<NSString *, NSString *> *)customParameters;
@property(nonatomic, copy) NSString *providerId;
@property(nonatomic, copy, nullable) NSArray<NSString *> *scopes;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, NSString *> *customParameters;
@end

@interface PigeonVerifyPhoneNumberRequest : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPhoneNumber:(nullable NSString *)phoneNumber
                            timeout:(NSInteger)timeout
                forceResendingToken:(nullable NSNumber *)forceResendingToken
     autoRetrievedSmsCodeForTesting:(nullable NSString *)autoRetrievedSmsCodeForTesting
                  multiFactorInfoId:(nullable NSString *)multiFactorInfoId
               multiFactorSessionId:(nullable NSString *)multiFactorSessionId;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, assign) NSInteger timeout;
@property(nonatomic, strong, nullable) NSNumber *forceResendingToken;
@property(nonatomic, copy, nullable) NSString *autoRetrievedSmsCodeForTesting;
@property(nonatomic, copy, nullable) NSString *multiFactorInfoId;
@property(nonatomic, copy, nullable) NSString *multiFactorSessionId;
@end

@interface PigeonIdTokenResult : NSObject
+ (instancetype)makeWithToken:(nullable NSString *)token
          expirationTimestamp:(nullable NSNumber *)expirationTimestamp
                authTimestamp:(nullable NSNumber *)authTimestamp
            issuedAtTimestamp:(nullable NSNumber *)issuedAtTimestamp
               signInProvider:(nullable NSString *)signInProvider
                       claims:(nullable NSDictionary<NSString *, id> *)claims
           signInSecondFactor:(nullable NSString *)signInSecondFactor;
@property(nonatomic, copy, nullable) NSString *token;
@property(nonatomic, strong, nullable) NSNumber *expirationTimestamp;
@property(nonatomic, strong, nullable) NSNumber *authTimestamp;
@property(nonatomic, strong, nullable) NSNumber *issuedAtTimestamp;
@property(nonatomic, copy, nullable) NSString *signInProvider;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, id> *claims;
@property(nonatomic, copy, nullable) NSString *signInSecondFactor;
@end

@interface PigeonUserProfile : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                           photoUrl:(nullable NSString *)photoUrl
                 displayNameChanged:(BOOL)displayNameChanged
                    photoUrlChanged:(BOOL)photoUrlChanged;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, copy, nullable) NSString *photoUrl;
@property(nonatomic, assign) BOOL displayNameChanged;
@property(nonatomic, assign) BOOL photoUrlChanged;
@end

@interface PigeonTotpSecret : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithCodeIntervalSeconds:(nullable NSNumber *)codeIntervalSeconds
                                 codeLength:(nullable NSNumber *)codeLength
               enrollmentCompletionDeadline:(nullable NSNumber *)enrollmentCompletionDeadline
                           hashingAlgorithm:(nullable NSString *)hashingAlgorithm
                                  secretKey:(NSString *)secretKey;
@property(nonatomic, strong, nullable) NSNumber *codeIntervalSeconds;
@property(nonatomic, strong, nullable) NSNumber *codeLength;
@property(nonatomic, strong, nullable) NSNumber *enrollmentCompletionDeadline;
@property(nonatomic, copy, nullable) NSString *hashingAlgorithm;
@property(nonatomic, copy) NSString *secretKey;
@end

/// The codec used by FirebaseAuthHostApi.
NSObject<FlutterMessageCodec> *FirebaseAuthHostApiGetCodec(void);

@protocol FirebaseAuthHostApi
- (void)registerIdTokenListenerApp:(AuthPigeonFirebaseApp *)app
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)registerAuthStateListenerApp:(AuthPigeonFirebaseApp *)app
                          completion:
                              (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)useEmulatorApp:(AuthPigeonFirebaseApp *)app
                  host:(NSString *)host
                  port:(NSInteger)port
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)applyActionCodeApp:(AuthPigeonFirebaseApp *)app
                      code:(NSString *)code
                completion:(void (^)(FlutterError *_Nullable))completion;
- (void)checkActionCodeApp:(AuthPigeonFirebaseApp *)app
                      code:(NSString *)code
                completion:
                    (void (^)(PigeonActionCodeInfo *_Nullable, FlutterError *_Nullable))completion;
- (void)confirmPasswordResetApp:(AuthPigeonFirebaseApp *)app
                           code:(NSString *)code
                    newPassword:(NSString *)newPassword
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)createUserWithEmailAndPasswordApp:(AuthPigeonFirebaseApp *)app
                                    email:(NSString *)email
                                 password:(NSString *)password
                               completion:(void (^)(PigeonUserCredential *_Nullable,
                                                    FlutterError *_Nullable))completion;
- (void)signInAnonymouslyApp:(AuthPigeonFirebaseApp *)app
                  completion:(void (^)(PigeonUserCredential *_Nullable,
                                       FlutterError *_Nullable))completion;
- (void)signInWithCredentialApp:(AuthPigeonFirebaseApp *)app
                          input:(NSDictionary<NSString *, id> *)input
                     completion:(void (^)(PigeonUserCredential *_Nullable,
                                          FlutterError *_Nullable))completion;
- (void)signInWithCustomTokenApp:(AuthPigeonFirebaseApp *)app
                           token:(NSString *)token
                      completion:(void (^)(PigeonUserCredential *_Nullable,
                                           FlutterError *_Nullable))completion;
- (void)signInWithEmailAndPasswordApp:(AuthPigeonFirebaseApp *)app
                                email:(NSString *)email
                             password:(NSString *)password
                           completion:(void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)signInWithEmailLinkApp:(AuthPigeonFirebaseApp *)app
                         email:(NSString *)email
                     emailLink:(NSString *)emailLink
                    completion:(void (^)(PigeonUserCredential *_Nullable,
                                         FlutterError *_Nullable))completion;
- (void)signInWithProviderApp:(AuthPigeonFirebaseApp *)app
               signInProvider:(PigeonSignInProvider *)signInProvider
                   completion:(void (^)(PigeonUserCredential *_Nullable,
                                        FlutterError *_Nullable))completion;
- (void)signOutApp:(AuthPigeonFirebaseApp *)app
        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)fetchSignInMethodsForEmailApp:(AuthPigeonFirebaseApp *)app
                                email:(NSString *)email
                           completion:(void (^)(NSArray<NSString *> *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)sendPasswordResetEmailApp:(AuthPigeonFirebaseApp *)app
                            email:(NSString *)email
               actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                       completion:(void (^)(FlutterError *_Nullable))completion;
- (void)sendSignInLinkToEmailApp:(AuthPigeonFirebaseApp *)app
                           email:(NSString *)email
              actionCodeSettings:(PigeonActionCodeSettings *)actionCodeSettings
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setLanguageCodeApp:(AuthPigeonFirebaseApp *)app
              languageCode:(nullable NSString *)languageCode
                completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)setSettingsApp:(AuthPigeonFirebaseApp *)app
              settings:(PigeonFirebaseAuthSettings *)settings
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)verifyPasswordResetCodeApp:(AuthPigeonFirebaseApp *)app
                              code:(NSString *)code
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)verifyPhoneNumberApp:(AuthPigeonFirebaseApp *)app
                     request:(PigeonVerifyPhoneNumberRequest *)request
                  completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)revokeTokenWithAuthorizationCodeApp:(AuthPigeonFirebaseApp *)app
                          authorizationCode:(NSString *)authorizationCode
                                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)initializeRecaptchaConfigApp:(AuthPigeonFirebaseApp *)app
                          completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAuthHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                     NSObject<FirebaseAuthHostApi> *_Nullable api);

extern void SetUpFirebaseAuthHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                               NSObject<FirebaseAuthHostApi> *_Nullable api,
                                               NSString *messageChannelSuffix);

/// The codec used by FirebaseAuthUserHostApi.
NSObject<FlutterMessageCodec> *FirebaseAuthUserHostApiGetCodec(void);

@protocol FirebaseAuthUserHostApi
- (void)deleteApp:(AuthPigeonFirebaseApp *)app
       completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getIdTokenApp:(AuthPigeonFirebaseApp *)app
         forceRefresh:(BOOL)forceRefresh
           completion:(void (^)(PigeonIdTokenResult *_Nullable, FlutterError *_Nullable))completion;
- (void)linkWithCredentialApp:(AuthPigeonFirebaseApp *)app
                        input:(NSDictionary<NSString *, id> *)input
                   completion:(void (^)(PigeonUserCredential *_Nullable,
                                        FlutterError *_Nullable))completion;
- (void)linkWithProviderApp:(AuthPigeonFirebaseApp *)app
             signInProvider:(PigeonSignInProvider *)signInProvider
                 completion:
                     (void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion;
- (void)reauthenticateWithCredentialApp:(AuthPigeonFirebaseApp *)app
                                  input:(NSDictionary<NSString *, id> *)input
                             completion:(void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion;
- (void)reauthenticateWithProviderApp:(AuthPigeonFirebaseApp *)app
                       signInProvider:(PigeonSignInProvider *)signInProvider
                           completion:(void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)reloadApp:(AuthPigeonFirebaseApp *)app
       completion:(void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)sendEmailVerificationApp:(AuthPigeonFirebaseApp *)app
              actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)unlinkApp:(AuthPigeonFirebaseApp *)app
       providerId:(NSString *)providerId
       completion:(void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion;
- (void)updateEmailApp:(AuthPigeonFirebaseApp *)app
              newEmail:(NSString *)newEmail
            completion:(void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updatePasswordApp:(AuthPigeonFirebaseApp *)app
              newPassword:(NSString *)newPassword
               completion:
                   (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updatePhoneNumberApp:(AuthPigeonFirebaseApp *)app
                       input:(NSDictionary<NSString *, id> *)input
                  completion:
                      (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updateProfileApp:(AuthPigeonFirebaseApp *)app
                 profile:(PigeonUserProfile *)profile
              completion:
                  (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)verifyBeforeUpdateEmailApp:(AuthPigeonFirebaseApp *)app
                          newEmail:(NSString *)newEmail
                actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                        completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAuthUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                         NSObject<FirebaseAuthUserHostApi> *_Nullable api);

extern void SetUpFirebaseAuthUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                   NSObject<FirebaseAuthUserHostApi> *_Nullable api,
                                                   NSString *messageChannelSuffix);

/// The codec used by MultiFactorUserHostApi.
NSObject<FlutterMessageCodec> *MultiFactorUserHostApiGetCodec(void);

@protocol MultiFactorUserHostApi
- (void)enrollPhoneApp:(AuthPigeonFirebaseApp *)app
             assertion:(PigeonPhoneMultiFactorAssertion *)assertion
           displayName:(nullable NSString *)displayName
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)enrollTotpApp:(AuthPigeonFirebaseApp *)app
          assertionId:(NSString *)assertionId
          displayName:(nullable NSString *)displayName
           completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getSessionApp:(AuthPigeonFirebaseApp *)app
           completion:
               (void (^)(PigeonMultiFactorSession *_Nullable, FlutterError *_Nullable))completion;
- (void)unenrollApp:(AuthPigeonFirebaseApp *)app
          factorUid:(NSString *)factorUid
         completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getEnrolledFactorsApp:(AuthPigeonFirebaseApp *)app
                   completion:(void (^)(NSArray<PigeonMultiFactorInfo *> *_Nullable,
                                        FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<MultiFactorUserHostApi> *_Nullable api);

extern void SetUpMultiFactorUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                  NSObject<MultiFactorUserHostApi> *_Nullable api,
                                                  NSString *messageChannelSuffix);

/// The codec used by MultiFactoResolverHostApi.
NSObject<FlutterMessageCodec> *MultiFactoResolverHostApiGetCodec(void);

@protocol MultiFactoResolverHostApi
- (void)resolveSignInResolverId:(NSString *)resolverId
                      assertion:(nullable PigeonPhoneMultiFactorAssertion *)assertion
                totpAssertionId:(nullable NSString *)totpAssertionId
                     completion:(void (^)(PigeonUserCredential *_Nullable,
                                          FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactoResolverHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactoResolverHostApi> *_Nullable api);

extern void SetUpMultiFactoResolverHostApiWithSuffix(
    id<FlutterBinaryMessenger> binaryMessenger, NSObject<MultiFactoResolverHostApi> *_Nullable api,
    NSString *messageChannelSuffix);

/// The codec used by MultiFactorTotpHostApi.
NSObject<FlutterMessageCodec> *MultiFactorTotpHostApiGetCodec(void);

@protocol MultiFactorTotpHostApi
- (void)generateSecretSessionId:(NSString *)sessionId
                     completion:
                         (void (^)(PigeonTotpSecret *_Nullable, FlutterError *_Nullable))completion;
- (void)getAssertionForEnrollmentSecretKey:(NSString *)secretKey
                           oneTimePassword:(NSString *)oneTimePassword
                                completion:(void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion;
- (void)getAssertionForSignInEnrollmentId:(NSString *)enrollmentId
                          oneTimePassword:(NSString *)oneTimePassword
                               completion:(void (^)(NSString *_Nullable,
                                                    FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorTotpHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<MultiFactorTotpHostApi> *_Nullable api);

extern void SetUpMultiFactorTotpHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                  NSObject<MultiFactorTotpHostApi> *_Nullable api,
                                                  NSString *messageChannelSuffix);

/// The codec used by MultiFactorTotpSecretHostApi.
NSObject<FlutterMessageCodec> *MultiFactorTotpSecretHostApiGetCodec(void);

@protocol MultiFactorTotpSecretHostApi
- (void)generateQrCodeUrlSecretKey:(NSString *)secretKey
                       accountName:(nullable NSString *)accountName
                            issuer:(nullable NSString *)issuer
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)openInOtpAppSecretKey:(NSString *)secretKey
                    qrCodeUrl:(NSString *)qrCodeUrl
                   completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorTotpSecretHostApi(
    id<FlutterBinaryMessenger> binaryMessenger,
    NSObject<MultiFactorTotpSecretHostApi> *_Nullable api);

extern void SetUpMultiFactorTotpSecretHostApiWithSuffix(
    id<FlutterBinaryMessenger> binaryMessenger,
    NSObject<MultiFactorTotpSecretHostApi> *_Nullable api, NSString *messageChannelSuffix);

/// The codec used by GenerateInterfaces.
NSObject<FlutterMessageCodec> *GenerateInterfacesGetCodec(void);

/// Only used to generate the object interface that are use outside of the Pigeon interface
@protocol GenerateInterfaces
- (void)pigeonInterfaceInfo:(PigeonMultiFactorInfo *)info
                      error:(FlutterError *_Nullable *_Nonnull)error;
@end

extern void SetUpGenerateInterfaces(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<GenerateInterfaces> *_Nullable api);

extern void SetUpGenerateInterfacesWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<GenerateInterfaces> *_Nullable api,
                                              NSString *messageChannelSuffix);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/FLTAuthStateChannelStreamHandler.m

**크기**: 1407 bytes | **라인 수**: 57 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseAuth;
#import "include/Private/FLTAuthStateChannelStreamHandler.h"
#import <FirebaseAuth/FirebaseAuth.h>
#import "include/Private/PigeonParser.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTAuthStateChannelStreamHandler {
  FIRAuth *_auth;
  FIRAuthStateDidChangeListenerHandle _listener;
}

- (instancetype)initWithAuth:(FIRAuth *)auth {
  self = [super init];
  if (self) {
    _auth = auth;
  }
  return self;
}

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
  bool __block initialAuthState = YES;

  _listener = [_auth addAuthStateDidChangeListener:^(FIRAuth *_Nonnull auth,
                                                     FIRUser *_Nullable user) {
    if (initialAuthState) {
      initialAuthState = NO;
      return;
    }

    if (user) {
      events(@{
        @"user" : [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
      });
    } else {
      events(@{
        @"user" : [NSNull null],
      });
    }
  }];

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  if (_listener) {
    [_auth removeAuthStateDidChangeListener:_listener];
  }
  _listener = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/FLTFirebaseAuthPlugin.m

**크기**: 99462 bytes | **라인 수**: 2176 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseAuth;
#import <FirebaseAuth/FirebaseAuth.h>
#import <TargetConditionals.h>
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/Private/FLTAuthStateChannelStreamHandler.h"
#import "include/Private/FLTIdTokenChannelStreamHandler.h"
#import "include/Private/FLTPhoneNumberVerificationStreamHandler.h"
#import "include/Private/PigeonParser.h"

#import "include/Public/CustomPigeonHeader.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"
@import CommonCrypto;
#import <AuthenticationServices/AuthenticationServices.h>

#if __has_include(<firebase_core/FLTFirebaseCorePlugin.h>)
#import <firebase_core/FLTFirebaseCorePlugin.h>
#else
#import <FLTFirebaseCorePlugin.h>
#endif

NSString *const kFLTFirebaseAuthChannelName = @"plugins.flutter.io/firebase_auth";

// Argument Keys
NSString *const kAppName = @"appName";

// Provider type keys.
NSString *const kSignInMethodPassword = @"password";
NSString *const kSignInMethodEmailLink = @"emailLink";
NSString *const kSignInMethodFacebook = @"facebook.com";
NSString *const kSignInMethodGoogle = @"google.com";
NSString *const kSignInMethodGameCenter = @"gc.apple.com";
NSString *const kSignInMethodTwitter = @"twitter.com";
NSString *const kSignInMethodGithub = @"github.com";
NSString *const kSignInMethodApple = @"apple.com";
NSString *const kSignInMethodPhone = @"phone";
NSString *const kSignInMethodOAuth = @"oauth";

// Credential argument keys.
NSString *const kArgumentCredential = @"credential";
NSString *const kArgumentProviderId = @"providerId";
NSString *const kArgumentProviderScope = @"scopes";
NSString *const kArgumentProviderCustomParameters = @"customParameters";
NSString *const kArgumentSignInMethod = @"signInMethod";
NSString *const kArgumentSecret = @"secret";
NSString *const kArgumentIdToken = @"idToken";
NSString *const kArgumentAccessToken = @"accessToken";
NSString *const kArgumentRawNonce = @"rawNonce";
NSString *const kArgumentEmail = @"email";
NSString *const kArgumentCode = @"code";
NSString *const kArgumentNewEmail = @"newEmail";
NSString *const kArgumentEmailLink = kSignInMethodEmailLink;
NSString *const kArgumentToken = @"token";
NSString *const kArgumentVerificationId = @"verificationId";
NSString *const kArgumentSmsCode = @"smsCode";
NSString *const kArgumentActionCodeSettings = @"actionCodeSettings";
NSString *const kArgumentFamilyName = @"familyName";
NSString *const kArgumentGivenName = @"givenName";
NSString *const kArgumentMiddleName = @"middleName";
NSString *const kArgumentNickname = @"nickname";
NSString *const kArgumentNamePrefix = @"namePrefix";
NSString *const kArgumentNameSuffix = @"nameSuffix";

// MultiFactor
NSString *const kArgumentMultiFactorHints = @"multiFactorHints";
NSString *const kArgumentMultiFactorSessionId = @"multiFactorSessionId";
NSString *const kArgumentMultiFactorResolverId = @"multiFactorResolverId";
NSString *const kArgumentMultiFactorInfo = @"multiFactorInfo";

// Manual error codes & messages.
NSString *const kErrCodeNoCurrentUser = @"no-current-user";
NSString *const kErrMsgNoCurrentUser = @"No user currently signed in.";
NSString *const kErrCodeInvalidCredential = @"invalid-credential";
NSString *const kErrMsgInvalidCredential =
    @"The supplied auth credential is malformed, has expired or is not "
    @"currently supported.";

// Used for caching credentials between Method Channel method calls.
static NSMutableDictionary<NSNumber *, FIRAuthCredential *> *credentialsMap;

@interface FLTFirebaseAuthPlugin ()
@property(nonatomic, retain) NSObject<FlutterBinaryMessenger> *messenger;
@property(strong, nonatomic) FIROAuthProvider *authProvider;
// Used to keep the user who wants to link with Apple Sign In
@property(strong, nonatomic) FIRUser *linkWithAppleUser;
@property(strong, nonatomic) FIRAuth *signInWithAppleAuth;
@property BOOL isReauthenticatingWithApple;
@property(strong, nonatomic) NSString *currentNonce;
@property(strong, nonatomic) void (^appleCompletion)
    (PigeonUserCredential *_Nullable, FlutterError *_Nullable);
@property(strong, nonatomic) AuthPigeonFirebaseApp *appleArguments;

@end

@implementation FLTFirebaseAuthPlugin {
  // Map an id to a MultiFactorSession object.
  NSMutableDictionary<NSString *, FIRMultiFactorSession *> *_multiFactorSessionMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRMultiFactorResolver *> *_multiFactorResolverMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRMultiFactorAssertion *> *_multiFactorAssertionMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRTOTPSecret *> *_multiFactorTotpSecretMap;

  NSObject<FlutterBinaryMessenger> *_binaryMessenger;
  NSMutableDictionary<NSString *, FlutterEventChannel *> *_eventChannels;
  NSMutableDictionary<NSString *, NSObject<FlutterStreamHandler> *> *_streamHandlers;
  NSData *_apnsToken;
}

#pragma mark - FlutterPlugin

- (instancetype)init:(NSObject<FlutterBinaryMessenger> *)messenger {
  self = [super init];
  if (self) {
    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:self];
    credentialsMap = [NSMutableDictionary<NSNumber *, FIRAuthCredential *> dictionary];
    _binaryMessenger = messenger;
    _eventChannels = [NSMutableDictionary dictionary];
    _streamHandlers = [NSMutableDictionary dictionary];

    _multiFactorSessionMap = [NSMutableDictionary dictionary];
    _multiFactorResolverMap = [NSMutableDictionary dictionary];
    _multiFactorAssertionMap = [NSMutableDictionary dictionary];
    _multiFactorTotpSecretMap = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FlutterMethodChannel *channel =
      [FlutterMethodChannel methodChannelWithName:kFLTFirebaseAuthChannelName
                                  binaryMessenger:[registrar messenger]];
  FLTFirebaseAuthPlugin *instance = [[FLTFirebaseAuthPlugin alloc] init:registrar.messenger];

  [registrar addMethodCallDelegate:instance channel:channel];

  [registrar publish:instance];
  [registrar addApplicationDelegate:instance];
  SetUpFirebaseAuthHostApi(registrar.messenger, instance);
  SetUpFirebaseAuthUserHostApi(registrar.messenger, instance);
  SetUpMultiFactorUserHostApi(registrar.messenger, instance);
  SetUpMultiFactoResolverHostApi(registrar.messenger, instance);
  SetUpMultiFactorTotpHostApi(registrar.messenger, instance);
  SetUpMultiFactorTotpSecretHostApi(registrar.messenger, instance);
}

+ (FlutterError *)convertToFlutterError:(NSError *)error {
  NSString *code = @"unknown";
  NSString *message = @"An unknown error has occurred.";

  if (error == nil) {
    return [FlutterError errorWithCode:code message:message details:@{}];
  }

  // code
  if ([error userInfo][FIRAuthErrorUserInfoNameKey] != nil) {
    // See [FIRAuthErrorCodeString] for list of codes.
    // Codes are in the format "ERROR_SOME_NAME", converting below to the format
    // required in Dart. ERROR_SOME_NAME -> SOME_NAME
    NSString *firebaseErrorCode = [error userInfo][FIRAuthErrorUserInfoNameKey];
    code = [firebaseErrorCode stringByReplacingOccurrencesOfString:@"ERROR_" withString:@""];
    // SOME_NAME -> SOME-NAME
    code = [code stringByReplacingOccurrencesOfString:@"_" withString:@"-"];
    // SOME-NAME -> some-name
    code = [code lowercaseString];
  }

  // message
  if ([error userInfo][NSLocalizedDescriptionKey] != nil) {
    message = [error userInfo][NSLocalizedDescriptionKey];
  }

  NSMutableDictionary *additionalData = [NSMutableDictionary dictionary];
  // additionalData.email
  if ([error userInfo][FIRAuthErrorUserInfoEmailKey] != nil) {
    additionalData[kArgumentEmail] = [error userInfo][FIRAuthErrorUserInfoEmailKey];
  }
  // We want to store the credential if present for future sign in if the exception contains a
  // credential, we pass a token back to Flutter to allow retrieval of the credential.
  NSNumber *token = [FLTFirebaseAuthPlugin storeAuthCredentialIfPresent:error];

  // additionalData.authCredential
  if ([error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey] != nil) {
    FIRAuthCredential *authCredential = [error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey];
    additionalData[@"authCredential"] = [PigeonParser getPigeonAuthCredential:authCredential
                                                                        token:token];
  }

  // Manual message overrides to ensure messages/codes matches other platforms.
  if ([message isEqual:@"The password must be 6 characters long or more."]) {
    message = @"Password should be at least 6 characters";
  }

  return [FlutterError errorWithCode:code message:message details:additionalData];
}

+ (id)getNSDictionaryFromAuthCredential:(FIRAuthCredential *)authCredential {
  if (authCredential == nil) {
    return [NSNull null];
  }

  NSString *accessToken = nil;
  if ([authCredential isKindOfClass:[FIROAuthCredential class]]) {
    if (((FIROAuthCredential *)authCredential).accessToken != nil) {
      accessToken = ((FIROAuthCredential *)authCredential).accessToken;
    } else if (((FIROAuthCredential *)authCredential).IDToken != nil) {
      // For Sign In With Apple, the token is stored in IDToken
      accessToken = ((FIROAuthCredential *)authCredential).IDToken;
    }
  }

  return @{
    kArgumentProviderId : authCredential.provider,
    // Note: "signInMethod" does not exist on iOS SDK, so using provider
    // instead.
    kArgumentSignInMethod : authCredential.provider,
    kArgumentToken : @([authCredential hash]),
    kArgumentAccessToken : accessToken ?: [NSNull null],
  };
}

- (void)cleanupWithCompletion:(void (^)(void))completion {
  // Cleanup credentials.
  [credentialsMap removeAllObjects];

  for (FlutterEventChannel *channel in self->_eventChannels.allValues) {
    [channel setStreamHandler:nil];
  }
  [self->_eventChannels removeAllObjects];
  for (NSObject<FlutterStreamHandler> *handler in self->_streamHandlers.allValues) {
    [handler onCancelWithArguments:nil];
  }
  [self->_streamHandlers removeAllObjects];

  if (completion != nil) completion();
}

- (void)detachFromEngineForRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  [self cleanupWithCompletion:nil];
}

#pragma mark - AppDelegate

#if TARGET_OS_IPHONE
#if !__has_include(<FirebaseMessaging/FirebaseMessaging.h>)
- (BOOL)application:(UIApplication *)application
    didReceiveRemoteNotification:(NSDictionary *)notification
          fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler {
  if ([[FIRAuth auth] canHandleNotification:notification]) {
    completionHandler(UIBackgroundFetchResultNoData);
    return YES;
  }
  return NO;
}
#endif

- (void)application:(UIApplication *)application
    didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  _apnsToken = deviceToken;
}

- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary *)options {
  return [[FIRAuth auth] canHandleURL:url];
}
#endif

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion {
  [self cleanupWithCompletion:completion];
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  return kFLTFirebaseAuthChannelName;
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp {
  FIRAuth *auth = [FIRAuth authWithApp:firebaseApp];
  return @{
    @"APP_LANGUAGE_CODE" : (id)[auth languageCode] ?: [NSNull null],
    @"APP_CURRENT_USER" : [auth currentUser]
        ? [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
        : [NSNull null],
  };
}

#pragma mark - Firebase Auth API

// Adapted from
// https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce Used
// for Apple Sign In
- (NSString *)randomNonce:(NSInteger)length {
  NSAssert(length > 0, @"Expected nonce to have positive length");
  NSString *characterSet = @"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._";
  NSMutableString *result = [NSMutableString string];
  NSInteger remainingLength = length;

  while (remainingLength > 0) {
    NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];
    for (NSInteger i = 0; i < 16; i++) {
      uint8_t random = 0;
      int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);
      NSAssert(errorCode == errSecSuccess, @"Unable to generate nonce: OSStatus %i", errorCode);

      [randoms addObject:@(random)];
    }

    for (NSNumber *random in randoms) {
      if (remainingLength == 0) {
        break;
      }

      if (random.unsignedIntValue < characterSet.length) {
        unichar character = [characterSet characterAtIndex:random.unsignedIntValue];
        [result appendFormat:@"%C", character];
        remainingLength--;
      }
    }
  }

  return [result copy];
}

- (NSString *)stringBySha256HashingString:(NSString *)input {
  const char *string = [input UTF8String];
  unsigned char result[CC_SHA256_DIGEST_LENGTH];
  CC_SHA256(string, (CC_LONG)strlen(string), result);

  NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2];
  for (NSInteger i = 0; i < CC_SHA256_DIGEST_LENGTH; i++) {
    [hashed appendFormat:@"%02x", result[i]];
  }
  return hashed;
}

static void handleSignInWithApple(FLTFirebaseAuthPlugin *object, FIRAuthDataResult *authResult,
                                  NSString *authorizationCode, NSError *error) {
  void (^completion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
      object.appleCompletion;
  if (completion == nil) return;

  if (error != nil) {
    if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
      [object handleMultiFactorError:object.appleArguments completion:completion withError:error];
    } else {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    }
    return;
  }
  completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                               authorizationCode:authorizationCode],
             nil);
}

- (void)authorizationController:(ASAuthorizationController *)controller
    didCompleteWithAuthorization:(ASAuthorization *)authorization
    API_AVAILABLE(macos(10.15), ios(13.0)) {
  if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {
    ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;
    NSString *rawNonce = self.currentNonce;
    NSAssert(rawNonce != nil,
             @"Invalid state: A login callback was received, but no login request was sent.");

    if (appleIDCredential.identityToken == nil) {
      NSLog(@"Unable to fetch identity token.");
      return;
    }

    NSString *idToken = [[NSString alloc] initWithData:appleIDCredential.identityToken
                                              encoding:NSUTF8StringEncoding];
    if (idToken == nil) {
      NSLog(@"Unable to serialize id token from data: %@", appleIDCredential.identityToken);
    }

    NSString *authorizationCode = nil;
    if (appleIDCredential.authorizationCode != nil) {
      authorizationCode = [[NSString alloc] initWithData:appleIDCredential.authorizationCode
                                                encoding:NSUTF8StringEncoding];
    }

    FIROAuthCredential *credential =
        [FIROAuthProvider appleCredentialWithIDToken:idToken
                                            rawNonce:rawNonce
                                            fullName:appleIDCredential.fullName];

    if (self.isReauthenticatingWithApple == YES) {
      self.isReauthenticatingWithApple = NO;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [[FIRAuth.auth currentUser]
          reauthenticateWithCredential:credential
                            completion:^(FIRAuthDataResult *_Nullable authResult,
                                         NSError *_Nullable error) {
                              handleSignInWithApple(self, authResult, authorizationCode, error);
                            }];

    } else if (self.linkWithAppleUser != nil) {
      FIRUser *userToLink = self.linkWithAppleUser;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [userToLink linkWithCredential:credential
                          completion:^(FIRAuthDataResult *authResult, NSError *error) {
                            self.linkWithAppleUser = nil;
                            handleSignInWithApple(self, authResult, authorizationCode, error);
                          }];

    } else {
      FIRAuth *signInAuth =
          self.signInWithAppleAuth != nil ? self.signInWithAppleAuth : FIRAuth.auth;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [signInAuth signInWithCredential:credential
                            completion:^(FIRAuthDataResult *_Nullable authResult,
                                         NSError *_Nullable error) {
                              self.signInWithAppleAuth = nil;
                              handleSignInWithApple(self, authResult, authorizationCode, error);
                            }];
    }
  }
}

- (void)authorizationController:(ASAuthorizationController *)controller
           didCompleteWithError:(NSError *)error API_AVAILABLE(macos(10.15), ios(13.0)) {
  NSLog(@"Sign in with Apple errored: %@", error);
  switch (error.code) {
    case ASAuthorizationErrorCanceled:
      self.appleCompletion(
          nil, [FlutterError errorWithCode:@"canceled"
                                   message:@"The user canceled the authorization attempt."
                                   details:nil]);
      break;

    case ASAuthorizationErrorInvalidResponse:
      self.appleCompletion(
          nil,
          [FlutterError errorWithCode:@"invalid-response"
                              message:@"The authorization request received an invalid response."
                              details:nil]);
      break;

    case ASAuthorizationErrorNotHandled:
      self.appleCompletion(nil,
                           [FlutterError errorWithCode:@"not-handled"
                                               message:@"The authorization request wasn’t handled."
                                               details:nil]);
      break;

    case ASAuthorizationErrorFailed:
      self.appleCompletion(nil, [FlutterError errorWithCode:@"failed"
                                                    message:@"The authorization attempt failed."
                                                    details:nil]);
      break;

    case ASAuthorizationErrorUnknown:
    default:
      self.appleCompletion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
      break;
  }
  self.appleCompletion = nil;
}

- (void)handleInternalError:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                              FlutterError *_Nullable))completion
                  withError:(NSError *)error {
  const NSError *underlyingError = error.userInfo[@"NSUnderlyingError"];
  if (underlyingError != nil) {
    const NSDictionary *details =
        underlyingError.userInfo[@"FIRAuthErrorUserInfoDeserializedResponseKey"];
    completion(nil, [FlutterError errorWithCode:@"internal-error"
                                        message:error.description
                                        details:details]);
    return;
  }
  completion(nil, [FlutterError errorWithCode:@"internal-error"
                                      message:error.description
                                      details:nil]);
}

- (void)handleMultiFactorError:(AuthPigeonFirebaseApp *)app
                    completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                 FlutterError *_Nullable))completion
                     withError:(NSError *_Nullable)error {
  FIRMultiFactorResolver *resolver =
      (FIRMultiFactorResolver *)error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];

  NSArray<FIRMultiFactorInfo *> *hints = resolver.hints;
  FIRMultiFactorSession *session = resolver.session;

  NSString *sessionId = [[NSUUID UUID] UUIDString];
  self->_multiFactorSessionMap[sessionId] = session;

  NSString *resolverId = [[NSUUID UUID] UUIDString];
  self->_multiFactorResolverMap[resolverId] = resolver;

  NSMutableArray<NSDictionary *> *pigeonHints = [NSMutableArray array];

  for (FIRMultiFactorInfo *multiFactorInfo in hints) {
    NSString *phoneNumber;
    if ([multiFactorInfo class] == [FIRPhoneMultiFactorInfo class]) {
      FIRPhoneMultiFactorInfo *phoneFactorInfo = (FIRPhoneMultiFactorInfo *)multiFactorInfo;
      phoneNumber = phoneFactorInfo.phoneNumber;
    }

    PigeonMultiFactorInfo *object = [PigeonMultiFactorInfo
        makeWithDisplayName:multiFactorInfo.displayName
        enrollmentTimestamp:multiFactorInfo.enrollmentDate.timeIntervalSince1970
                   factorId:multiFactorInfo.factorID
                        uid:multiFactorInfo.UID
                phoneNumber:phoneNumber];

    [pigeonHints addObject:object.toList];
  }

  NSDictionary *output = @{
    kAppName : app.appName,
    kArgumentMultiFactorHints : pigeonHints,
    kArgumentMultiFactorSessionId : sessionId,
    kArgumentMultiFactorResolverId : resolverId,
  };
  completion(nil, [FlutterError errorWithCode:@"second-factor-required"
                                      message:error.description
                                      details:output]);
}

static void launchAppleSignInRequest(FLTFirebaseAuthPlugin *object, AuthPigeonFirebaseApp *app,
                                     PigeonSignInProvider *signInProvider,
                                     void (^_Nonnull completion)(PigeonUserCredential *_Nullable,
                                                                 FlutterError *_Nullable)) {
  if (@available(iOS 13.0, macOS 10.15, *)) {
    NSString *nonce = [object randomNonce:32];
    object.currentNonce = nonce;
    object.appleCompletion = completion;
    object.appleArguments = app;

    ASAuthorizationAppleIDProvider *appleIDProvider = [[ASAuthorizationAppleIDProvider alloc] init];

    ASAuthorizationAppleIDRequest *request = [appleIDProvider createRequest];
    NSMutableArray *requestedScopes = [NSMutableArray arrayWithCapacity:2];
    if ([signInProvider.scopes containsObject:@"name"]) {
      [requestedScopes addObject:ASAuthorizationScopeFullName];
    }
    if ([signInProvider.scopes containsObject:@"email"]) {
      [requestedScopes addObject:ASAuthorizationScopeEmail];
    }
    request.requestedScopes = [requestedScopes copy];
    request.nonce = [object stringBySha256HashingString:nonce];

    ASAuthorizationController *authorizationController =
        [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[ request ]];
    authorizationController.delegate = object;
    authorizationController.presentationContextProvider = object;
    [authorizationController performRequests];
  } else {
    NSLog(@"Sign in with Apple was introduced in iOS 13, update your Podfile with platform :ios, "
          @"'13.0'");
  }
}

static void handleAppleAuthResult(FLTFirebaseAuthPlugin *object, AuthPigeonFirebaseApp *app,
                                  FIRAuth *auth, FIRAuthCredential *credentials, NSError *error,
                                  void (^_Nonnull completion)(PigeonUserCredential *_Nullable,
                                                              FlutterError *_Nullable)) {
  if (error) {
    if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
      [object handleMultiFactorError:app completion:completion withError:error];
    } else {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    }
    return;
  }
  if (credentials) {
    [auth
        signInWithCredential:credentials
                  completion:^(FIRAuthDataResult *authResult, NSError *error) {
                    if (error != nil) {
                      NSDictionary *userInfo = [error userInfo];
                      NSError *underlyingError = [userInfo objectForKey:NSUnderlyingErrorKey];

                      NSDictionary *firebaseDictionary =
                          underlyingError.userInfo[@"FIRAuthErrorUserInfoDes"
                                                   @"erializedResponseKey"];

                      NSString *errorCode = userInfo[@"FIRAuthErrorUserInfoNameKey"];

                      if (firebaseDictionary == nil && errorCode != nil) {
                        if ([errorCode isEqual:@"ERROR_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL"]) {
                          completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                          return;
                        }

                        // Removing since it's not parsed and causing issue when sending back the
                        // object to Flutter
                        NSMutableDictionary *mutableUserInfo = [userInfo mutableCopy];
                        [mutableUserInfo
                            removeObjectForKey:@"FIRAuthErrorUserInfoUpdatedCredentialKey"];
                        NSError *modifiedError = [NSError errorWithDomain:error.domain
                                                                     code:error.code
                                                                 userInfo:mutableUserInfo];

                        completion(nil,
                                   [FlutterError errorWithCode:@"sign-in-failed"
                                                       message:userInfo[@"NSLocalizedDescription"]
                                                       details:modifiedError.userInfo]);

                      } else if (firebaseDictionary != nil &&
                                 firebaseDictionary[@"message"] != nil) {
                        // error from firebase-ios-sdk is
                        // buried in underlying error.
                        completion(nil,
                                   [FlutterError errorWithCode:@"sign-in-failed"
                                                       message:error.localizedDescription
                                                       details:firebaseDictionary[@"message"]]);
                      } else {
                        completion(nil, [FlutterError errorWithCode:@"sign-in-failed"
                                                            message:error.localizedDescription
                                                            details:error.userInfo]);
                      }
                    } else {
                      completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                   authorizationCode:nil],
                                 nil);
                    }
                  }];
  }
}

#pragma mark - Utilities

+ (NSNumber *_Nullable)storeAuthCredentialIfPresent:(NSError *)error {
  if ([error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey] != nil) {
    FIRAuthCredential *authCredential = [error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey];
    // We temporarily store the non-serializable credential so the
    // Dart API can consume these at a later time.
    NSNumber *authCredentialHash = @([authCredential hash]);
    credentialsMap[authCredentialHash] = authCredential;
    return authCredentialHash;
  }
  return nil;
}

- (FIRAuth *_Nullable)getFIRAuthFromAppNameFromPigeon:(AuthPigeonFirebaseApp *)pigeonApp {
  FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:pigeonApp.appName];
  FIRAuth *auth = [FIRAuth authWithApp:app];

  auth.tenantID = pigeonApp.tenantId;
  auth.customAuthDomain = [FLTFirebaseCorePlugin getCustomDomain:app.name];
  // Auth's `customAuthDomain` supersedes value from `getCustomDomain` set by `initializeApp`
  if (pigeonApp.customAuthDomain != nil) {
    auth.customAuthDomain = pigeonApp.customAuthDomain;
  }

  return auth;
}

- (void)getFIRAuthCredentialFromArguments:(NSDictionary *)arguments
                                      app:(AuthPigeonFirebaseApp *)app
                               completion:(void (^)(FIRAuthCredential *credential,
                                                    NSError *error))completion {
  // If the credential dictionary contains a token, it means a native one has
  // been stored for later usage, so we'll attempt to retrieve it here.
  if (arguments[kArgumentToken] != nil && ![arguments[kArgumentToken] isEqual:[NSNull null]]) {
    NSNumber *credentialHashCode = arguments[kArgumentToken];
    if (credentialsMap[credentialHashCode] != nil) {
      completion(credentialsMap[credentialHashCode], nil);
      return;
    }
  }

  NSString *signInMethod = arguments[kArgumentSignInMethod];

  if ([signInMethod isEqualToString:kSignInMethodGameCenter]) {
    // Game Center Games is different to other providers, it requires below callback to get a
    // credential. This is why getFIRAuthCredentialFromArguments now requires a completion()
    // callback
    [FIRGameCenterAuthProvider
        getCredentialWithCompletion:^(FIRAuthCredential *credential, NSError *error) {
          if (error) {
            completion(nil, error);
          } else {
            completion(credential, nil);
          }
        }];
    return;
  }

  NSString *secret = arguments[kArgumentSecret] == [NSNull null] ? nil : arguments[kArgumentSecret];
  NSString *idToken =
      arguments[kArgumentIdToken] == [NSNull null] ? nil : arguments[kArgumentIdToken];
  NSString *accessToken =
      arguments[kArgumentAccessToken] == [NSNull null] ? nil : arguments[kArgumentAccessToken];
  NSString *rawNonce =
      arguments[kArgumentRawNonce] == [NSNull null] ? nil : arguments[kArgumentRawNonce];

  // Password Auth
  if ([signInMethod isEqualToString:kSignInMethodPassword]) {
    NSString *email = arguments[kArgumentEmail];
    completion([FIREmailAuthProvider credentialWithEmail:email password:secret], nil);
    return;
  }

  // Email Link Auth
  if ([signInMethod isEqualToString:kSignInMethodEmailLink]) {
    NSString *email = arguments[kArgumentEmail];
    NSString *emailLink = arguments[kArgumentEmailLink];
    completion([FIREmailAuthProvider credentialWithEmail:email link:emailLink], nil);
    return;
  }

  // Facebook Auth
  if ([signInMethod isEqualToString:kSignInMethodFacebook]) {
    completion([FIRFacebookAuthProvider credentialWithAccessToken:accessToken], nil);
    return;
  }

  // Google Auth
  if ([signInMethod isEqualToString:kSignInMethodGoogle]) {
    completion([FIRGoogleAuthProvider credentialWithIDToken:idToken accessToken:accessToken], nil);
    return;
  }

  // Twitter Auth
  if ([signInMethod isEqualToString:kSignInMethodTwitter]) {
    completion([FIRTwitterAuthProvider credentialWithToken:accessToken secret:secret], nil);
    return;
  }

  // GitHub Auth
  if ([signInMethod isEqualToString:kSignInMethodGithub]) {
    completion([FIRGitHubAuthProvider credentialWithToken:accessToken], nil);
    return;
  }

  // Phone Auth - Only supported on iOS
  if ([signInMethod isEqualToString:kSignInMethodPhone]) {
#if TARGET_OS_IPHONE
    NSString *verificationId = arguments[kArgumentVerificationId];
    NSString *smsCode = arguments[kArgumentSmsCode];
    completion([[FIRPhoneAuthProvider providerWithAuth:[self getFIRAuthFromAppNameFromPigeon:app]]
                   credentialWithVerificationID:verificationId
                               verificationCode:smsCode],
               nil);
    return;
#else
    NSLog(@"The Firebase Phone Authentication provider is not supported on the "
          @"MacOS platform.");
    completion(nil, nil);
    return;
#endif
  }
  // Apple Auth
  if ([signInMethod isEqualToString:kSignInMethodApple]) {
    if (idToken && rawNonce) {
      // Credential with idToken, rawNonce and fullName
      NSPersonNameComponents *fullName = [[NSPersonNameComponents alloc] init];
      fullName.givenName =
          arguments[kArgumentGivenName] == [NSNull null] ? nil : arguments[kArgumentGivenName];
      fullName.familyName =
          arguments[kArgumentFamilyName] == [NSNull null] ? nil : arguments[kArgumentFamilyName];
      fullName.nickname =
          arguments[kArgumentNickname] == [NSNull null] ? nil : arguments[kArgumentNickname];
      fullName.namePrefix =
          arguments[kArgumentNamePrefix] == [NSNull null] ? nil : arguments[kArgumentNamePrefix];
      fullName.nameSuffix =
          arguments[kArgumentNameSuffix] == [NSNull null] ? nil : arguments[kArgumentNameSuffix];
      fullName.middleName =
          arguments[kArgumentMiddleName] == [NSNull null] ? nil : arguments[kArgumentMiddleName];

      completion([FIROAuthProvider appleCredentialWithIDToken:idToken
                                                     rawNonce:rawNonce
                                                     fullName:fullName],
                 nil);
      return;
    }
  }
  // OAuth
  if ([signInMethod isEqualToString:kSignInMethodOAuth]) {
    NSString *providerId = arguments[kArgumentProviderId];
    completion([FIROAuthProvider credentialWithProviderID:providerId
                                                  IDToken:idToken
                                                 rawNonce:rawNonce
                                              accessToken:accessToken],
               nil);
    return;
  }

  NSLog(@"Support for an auth provider with identifier '%@' is not implemented.", signInMethod);
  completion(nil, nil);
  return;
}

- (void)ensureAPNSTokenSetting {
#if !TARGET_OS_OSX
  FIRApp *defaultApp = [FIRApp defaultApp];
  if (defaultApp) {
    if ([FIRAuth auth].APNSToken == nil && _apnsToken != nil) {
      [[FIRAuth auth] setAPNSToken:_apnsToken type:FIRAuthAPNSTokenTypeUnknown];
      _apnsToken = nil;
    }
  }
#endif
}

- (FIRMultiFactor *)getAppMultiFactorFromPigeon:(nonnull AuthPigeonFirebaseApp *)app {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  return currentUser.multiFactor;
}

- (nonnull ASPresentationAnchor)presentationAnchorForAuthorizationController:
    (nonnull ASAuthorizationController *)controller API_AVAILABLE(macos(10.15), ios(13.0)) {
#if TARGET_OS_OSX
  return [[NSApplication sharedApplication] keyWindow];
#else
  return [[UIApplication sharedApplication] keyWindow];
#endif
}

- (void)enrollPhoneApp:(nonnull AuthPigeonFirebaseApp *)app
             assertion:(nonnull PigeonPhoneMultiFactorAssertion *)assertion
           displayName:(nullable NSString *)displayName
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  completion([FlutterError errorWithCode:@"unsupported-platform"
                                 message:@"Phone authentication is not supported on macOS"
                                 details:nil]);
#else

  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  FIRPhoneAuthCredential *credential =
      [[FIRPhoneAuthProvider providerWithAuth:[self getFIRAuthFromAppNameFromPigeon:app]]
          credentialWithVerificationID:[assertion verificationId]
                      verificationCode:[assertion verificationCode]];

  FIRMultiFactorAssertion *multiFactorAssertion =
      [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];

  [multiFactor enrollWithAssertion:multiFactorAssertion
                       displayName:displayName
                        completion:^(NSError *_Nullable error) {
                          if (error == nil) {
                            completion(nil);
                          } else {
                            completion([FlutterError errorWithCode:@"enroll-failed"
                                                           message:error.localizedDescription
                                                           details:nil]);
                          }
                        }];
#endif
}

- (void)getEnrolledFactorsApp:(nonnull AuthPigeonFirebaseApp *)app
                   completion:(nonnull void (^)(NSArray<PigeonMultiFactorInfo *> *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  NSArray<FIRMultiFactorInfo *> *enrolledFactors = [multiFactor enrolledFactors];

  NSMutableArray<PigeonMultiFactorInfo *> *results = [NSMutableArray array];

  for (FIRMultiFactorInfo *multiFactorInfo in enrolledFactors) {
    NSString *phoneNumber;
    if ([multiFactorInfo class] == [FIRPhoneMultiFactorInfo class]) {
      FIRPhoneMultiFactorInfo *phoneFactorInfo = (FIRPhoneMultiFactorInfo *)multiFactorInfo;
      phoneNumber = phoneFactorInfo.phoneNumber;
    }

    [results addObject:[PigeonMultiFactorInfo
                           makeWithDisplayName:multiFactorInfo.displayName
                           enrollmentTimestamp:multiFactorInfo.enrollmentDate.timeIntervalSince1970
                                      factorId:multiFactorInfo.factorID
                                           uid:multiFactorInfo.UID
                                   phoneNumber:phoneNumber]];
  }

  completion(results, nil);
}

- (void)getSessionApp:(nonnull AuthPigeonFirebaseApp *)app
           completion:(nonnull void (^)(PigeonMultiFactorSession *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];
  [multiFactor getSessionWithCompletion:^(FIRMultiFactorSession *_Nullable session,
                                          NSError *_Nullable error) {
    NSString *UUID = [[NSUUID UUID] UUIDString];
    self->_multiFactorSessionMap[UUID] = session;

    PigeonMultiFactorSession *pigeonSession = [PigeonMultiFactorSession makeWithId:UUID];
    completion(pigeonSession, nil);
  }];
}

- (void)unenrollApp:(nonnull AuthPigeonFirebaseApp *)app
          factorUid:(nonnull NSString *)factorUid
         completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];
  [multiFactor unenrollWithFactorUID:factorUid
                          completion:^(NSError *_Nullable error) {
                            if (error == nil) {
                              completion(nil);
                            } else {
                              completion([FlutterError errorWithCode:@"unenroll-failed"
                                                             message:error.localizedDescription
                                                             details:nil]);
                            }
                          }];
}

- (void)enrollTotpApp:(nonnull AuthPigeonFirebaseApp *)app
          assertionId:(nonnull NSString *)assertionId
          displayName:(nullable NSString *)displayName
           completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  FIRMultiFactorAssertion *assertion = _multiFactorAssertionMap[assertionId];

  [multiFactor enrollWithAssertion:assertion
                       displayName:displayName
                        completion:^(NSError *_Nullable error) {
                          if (error == nil) {
                            completion(nil);
                          } else {
                            completion([FlutterError errorWithCode:@"enroll-failed"
                                                           message:error.localizedDescription
                                                           details:nil]);
                          }
                        }];
}

- (void)resolveSignInResolverId:(nonnull NSString *)resolverId
                      assertion:(nullable PigeonPhoneMultiFactorAssertion *)assertion
                totpAssertionId:(nullable NSString *)totpAssertionId
                     completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRMultiFactorResolver *resolver = _multiFactorResolverMap[resolverId];

  FIRMultiFactorAssertion *multiFactorAssertion;

  if (assertion != nil) {
#if TARGET_OS_IPHONE
    FIRPhoneAuthCredential *credential =
        [[FIRPhoneAuthProvider provider] credentialWithVerificationID:[assertion verificationId]
                                                     verificationCode:[assertion verificationCode]];
    multiFactorAssertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];
#endif
  } else if (totpAssertionId != nil) {
    multiFactorAssertion = _multiFactorAssertionMap[totpAssertionId];
  } else {
    completion(nil,
               [FlutterError errorWithCode:@"resolve-signin-failed"
                                   message:@"Neither assertion nor totpAssertionId were provided"
                                   details:nil]);
    return;
  }

  [resolver
      resolveSignInWithAssertion:multiFactorAssertion
                      completion:^(FIRAuthDataResult *_Nullable authResult,
                                   NSError *_Nullable error) {
                        if (error == nil) {
                          completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                       authorizationCode:nil],
                                     nil);
                        } else {
                          completion(nil, [FlutterError errorWithCode:@"resolve-signin-failed"
                                                              message:error.localizedDescription
                                                              details:nil]);
                        }
                      }];
}

- (void)generateSecretSessionId:(nonnull NSString *)sessionId
                     completion:(nonnull void (^)(PigeonTotpSecret *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRMultiFactorSession *multiFactorSession = _multiFactorSessionMap[sessionId];

  [FIRTOTPMultiFactorGenerator
      generateSecretWithMultiFactorSession:multiFactorSession
                                completion:^(FIRTOTPSecret *_Nullable secret,
                                             NSError *_Nullable error) {
                                  if (error == nil) {
                                    self->_multiFactorTotpSecretMap[secret.sharedSecretKey] =
                                        secret;
                                    completion([PigeonParser getPigeonTotpSecret:secret], nil);
                                  } else {
                                    completion(
                                        nil, [FlutterError errorWithCode:@"generate-secret-failed"
                                                                 message:error.localizedDescription
                                                                 details:nil]);
                                  }
                                }];
}

- (void)getAssertionForEnrollmentSecretKey:(nonnull NSString *)secretKey
                           oneTimePassword:(nonnull NSString *)oneTimePassword
                                completion:(nonnull void (^)(NSString *_Nullable,
                                                             FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];

  FIRTOTPMultiFactorAssertion *assertion =
      [FIRTOTPMultiFactorGenerator assertionForEnrollmentWithSecret:totpSecret
                                                    oneTimePassword:oneTimePassword];

  NSString *UUID = [[NSUUID UUID] UUIDString];
  self->_multiFactorAssertionMap[UUID] = assertion;
  completion(UUID, nil);
}

- (void)getAssertionForSignInEnrollmentId:(nonnull NSString *)enrollmentId
                          oneTimePassword:(nonnull NSString *)oneTimePassword
                               completion:(nonnull void (^)(NSString *_Nullable,
                                                            FlutterError *_Nullable))completion {
  FIRTOTPMultiFactorAssertion *assertion =
      [FIRTOTPMultiFactorGenerator assertionForSignInWithEnrollmentID:enrollmentId
                                                      oneTimePassword:oneTimePassword];
  NSString *UUID = [[NSUUID UUID] UUIDString];
  self->_multiFactorAssertionMap[UUID] = assertion;
  completion(UUID, nil);
}

- (void)generateQrCodeUrlSecretKey:(nonnull NSString *)secretKey
                       accountName:(nullable NSString *)accountName
                            issuer:(nullable NSString *)issuer
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];
  completion([totpSecret generateQRCodeURLWithAccountName:accountName issuer:issuer], nil);
}

- (void)openInOtpAppSecretKey:(nonnull NSString *)secretKey
                    qrCodeUrl:(nonnull NSString *)qrCodeUrl
                   completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];
  [totpSecret openInOTPAppWithQRCodeURL:qrCodeUrl];
  completion(nil);
}

- (void)applyActionCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                      code:(nonnull NSString *)code
                completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth applyActionCode:code
             completion:^(NSError *_Nullable error) {
               if (error != nil) {
                 completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
               } else {
                 completion(nil);
               }
             }];
}

- (void)revokeTokenWithAuthorizationCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                          authorizationCode:(nonnull NSString *)authorizationCode
                                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth revokeTokenWithAuthorizationCode:authorizationCode
                              completion:^(NSError *_Nullable error) {
                                if (error != nil) {
                                  completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                } else {
                                  completion(nil);
                                }
                              }];
}

- (void)checkActionCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                      code:(nonnull NSString *)code
                completion:(nonnull void (^)(PigeonActionCodeInfo *_Nullable,
                                             FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth checkActionCode:code
             completion:^(FIRActionCodeInfo *_Nullable info, NSError *_Nullable error) {
               if (error != nil) {
                 completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
               } else {
                 completion([self parseActionCode:info], nil);
               }
             }];
}

- (PigeonActionCodeInfo *_Nullable)parseActionCode:(nonnull FIRActionCodeInfo *)info {
  PigeonActionCodeInfoData *data = [PigeonActionCodeInfoData makeWithEmail:info.email
                                                             previousEmail:info.previousEmail];

  ActionCodeInfoOperation operation;

  if (info.operation == FIRActionCodeOperationPasswordReset) {
    operation = ActionCodeInfoOperationPasswordReset;
  } else if (info.operation == FIRActionCodeOperationVerifyEmail) {
    operation = ActionCodeInfoOperationVerifyEmail;
  } else if (info.operation == FIRActionCodeOperationRecoverEmail) {
    operation = ActionCodeInfoOperationRecoverEmail;
  } else if (info.operation == FIRActionCodeOperationEmailLink) {
    operation = ActionCodeInfoOperationEmailSignIn;
  } else if (info.operation == FIRActionCodeOperationVerifyAndChangeEmail) {
    operation = ActionCodeInfoOperationVerifyAndChangeEmail;
  } else if (info.operation == FIRActionCodeOperationRevertSecondFactorAddition) {
    operation = ActionCodeInfoOperationRevertSecondFactorAddition;
  } else {
    operation = ActionCodeInfoOperationUnknown;
  }

  return [PigeonActionCodeInfo makeWithOperation:operation data:data];
}

- (void)confirmPasswordResetApp:(nonnull AuthPigeonFirebaseApp *)app
                           code:(nonnull NSString *)code
                    newPassword:(nonnull NSString *)newPassword
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth confirmPasswordResetWithCode:code
                         newPassword:newPassword
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
}

- (void)createUserWithEmailAndPasswordApp:(nonnull AuthPigeonFirebaseApp *)app
                                    email:(nonnull NSString *)email
                                 password:(nonnull NSString *)password
                               completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                            FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth createUserWithEmail:email
                   password:password
                 completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
                   if (error != nil) {
                     completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                   } else {
                     completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                  authorizationCode:nil],
                                nil);
                   }
                 }];
}

- (void)fetchSignInMethodsForEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                                email:(nonnull NSString *)email
                           completion:(nonnull void (^)(NSArray<NSString *> *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth fetchSignInMethodsForEmail:email
                        completion:^(NSArray<NSString *> *_Nullable providers,
                                     NSError *_Nullable error) {
                          if (error != nil) {
                            completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                          } else {
                            if (providers == nil) {
                              completion(@[], nil);
                            } else {
                              completion(providers, nil);
                            }
                          }
                        }];
}

- (void)registerAuthStateListenerApp:(nonnull AuthPigeonFirebaseApp *)app
                          completion:(nonnull void (^)(NSString *_Nullable,
                                                       FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name =
      [NSString stringWithFormat:@"%@/auth-state/%@", kFLTFirebaseAuthChannelName, auth.app.name];
  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  FLTAuthStateChannelStreamHandler *handler =
      [[FLTAuthStateChannelStreamHandler alloc] initWithAuth:auth];
  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
}

- (void)registerIdTokenListenerApp:(nonnull AuthPigeonFirebaseApp *)app
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name =
      [NSString stringWithFormat:@"%@/id-token/%@", kFLTFirebaseAuthChannelName, auth.app.name];

  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  FLTIdTokenChannelStreamHandler *handler =
      [[FLTIdTokenChannelStreamHandler alloc] initWithAuth:auth];
  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
}

- (void)sendPasswordResetEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                            email:(nonnull NSString *)email
               actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                       completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  if (actionCodeSettings != nil) {
    FIRActionCodeSettings *settings = [PigeonParser parseActionCodeSettings:actionCodeSettings];
    [auth sendPasswordResetWithEmail:email
                  actionCodeSettings:settings
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
  } else {
    [auth sendPasswordResetWithEmail:email
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
  }
}

- (void)sendSignInLinkToEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                           email:(nonnull NSString *)email
              actionCodeSettings:(nonnull PigeonActionCodeSettings *)actionCodeSettings
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth sendSignInLinkToEmail:email
           actionCodeSettings:[PigeonParser parseActionCodeSettings:actionCodeSettings]
                   completion:^(NSError *_Nullable error) {
                     if (error != nil) {
                       if (error.code == FIRAuthErrorCodeInternalError) {
                         [self
                             handleInternalError:^(PigeonUserCredential *_Nullable creds,
                                                   FlutterError *_Nullable internalError) {
                               completion(internalError);
                             }
                                       withError:error];
                       } else {
                         completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       }
                     } else {
                       completion(nil);
                     }
                   }];
}

- (void)setLanguageCodeApp:(nonnull AuthPigeonFirebaseApp *)app
              languageCode:(nullable NSString *)languageCode
                completion:
                    (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (languageCode != nil && ![languageCode isEqual:[NSNull null]]) {
    auth.languageCode = languageCode;
  } else {
    [auth useAppLanguage];
  }

  completion(auth.languageCode, nil);
}

- (void)setSettingsApp:(nonnull AuthPigeonFirebaseApp *)app
              settings:(nonnull PigeonFirebaseAuthSettings *)settings
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (settings.userAccessGroup != nil) {
    BOOL useUserAccessGroupSuccessful;
    NSError *useUserAccessGroupErrorPtr;
    useUserAccessGroupSuccessful = [auth useUserAccessGroup:settings.userAccessGroup
                                                      error:&useUserAccessGroupErrorPtr];
    if (!useUserAccessGroupSuccessful) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:useUserAccessGroupErrorPtr]);
      return;
    }
  }

#if TARGET_OS_IPHONE
  if (settings.appVerificationDisabledForTesting) {
    auth.settings.appVerificationDisabledForTesting = settings.appVerificationDisabledForTesting;
  }
#else
  NSLog(@"FIRAuthSettings.appVerificationDisabledForTesting is not supported "
        @"on MacOS.");
#endif

  completion(nil);
}

- (void)signInAnonymouslyApp:(nonnull AuthPigeonFirebaseApp *)app
                  completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                               FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInAnonymouslyWithCompletion:^(FIRAuthDataResult *authResult, NSError *error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                   authorizationCode:nil],
                 nil);
    }
  }];
}

- (void)signInWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                          input:(nonnull NSDictionary<NSString *, id> *)input
                     completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [auth
                                   signInWithCredential:credential
                                             completion:^(FIRAuthDataResult *authResult,
                                                          NSError *error) {
                                               if (error != nil) {
                                                 NSDictionary *userInfo = [error userInfo];
                                                 NSError *underlyingError =
                                                     [userInfo objectForKey:NSUnderlyingErrorKey];

                                                 NSDictionary *firebaseDictionary =
                                                     underlyingError
                                                         .userInfo[@"FIRAuthErrorUserInfoDeserializ"
                                                                   @"edResponseKey"];

                                                 if (firebaseDictionary != nil &&
                                                     firebaseDictionary[@"message"] != nil) {
                                                   // error from firebase-ios-sdk is buried in
                                                   // underlying error.
                                                   if ([firebaseDictionary[@"code"]
                                                           isKindOfClass:[NSNumber class]]) {
                                                     [self handleInternalError:completion
                                                                     withError:error];
                                                   } else {
                                                     completion(nil,
                                                                [FlutterError
                                                                    errorWithCode:firebaseDictionary
                                                                                      [@"code"]
                                                                          message:firebaseDictionary
                                                                                      [@"message"]
                                                                          details:nil]);
                                                   }
                                                 } else {
                                                   if (error.code ==
                                                       FIRAuthErrorCodeSecondFactorRequired) {
                                                     [self handleMultiFactorError:app
                                                                       completion:completion
                                                                        withError:error];
                                                   } else if (error.code ==
                                                              FIRAuthErrorCodeInternalError) {
                                                     [self handleInternalError:completion
                                                                     withError:error];
                                                   } else {
                                                     completion(nil,
                                                                [FLTFirebaseAuthPlugin
                                                                    convertToFlutterError:error]);
                                                   }
                                                 }
                                               } else {
                                                 completion(
                                                     [PigeonParser
                                                         getPigeonUserCredentialFromAuthResult:
                                                             authResult
                                                                             authorizationCode:nil],
                                                     nil);
                                               }
                                             }];
                             }];
}

- (void)signInWithCustomTokenApp:(nonnull AuthPigeonFirebaseApp *)app
                           token:(nonnull NSString *)token
                      completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                   FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  [auth signInWithCustomToken:token
                   completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
                     if (error != nil) {
                       if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                         [self handleMultiFactorError:app completion:completion withError:error];
                       } else if (error.code == FIRAuthErrorCodeInternalError) {
                         [self handleInternalError:completion withError:error];
                       } else {
                         completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       }
                     } else {
                       completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                    authorizationCode:nil],
                                  nil);
                     }
                   }];
}

- (void)signInWithEmailAndPasswordApp:(nonnull AuthPigeonFirebaseApp *)app
                                email:(nonnull NSString *)email
                             password:(nonnull NSString *)password
                           completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInWithEmail:email
               password:password
             completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
               if (error != nil) {
                 if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                   [self handleMultiFactorError:app completion:completion withError:error];
                 } else if (error.code == FIRAuthErrorCodeInternalError) {
                   [self handleInternalError:completion withError:error];
                 } else {
                   completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                 }
               } else {
                 completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                              authorizationCode:nil],
                            nil);
               }
             }];
}

- (void)signInWithEmailLinkApp:(nonnull AuthPigeonFirebaseApp *)app
                         email:(nonnull NSString *)email
                     emailLink:(nonnull NSString *)emailLink
                    completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                 FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInWithEmail:email
                   link:emailLink
             completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
               if (error != nil) {
                 if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                   [self handleMultiFactorError:app completion:completion withError:error];
                 } else if (error.code == FIRAuthErrorCodeInternalError) {
                   [self handleInternalError:completion withError:error];
                 } else {
                   completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                 }
               } else {
                 completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                              authorizationCode:nil],
                            nil);
               }
             }];
}

- (void)signInWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
               signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                   completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if ([signInProvider.providerId isEqualToString:kSignInMethodGameCenter]) {
    completion(
        nil,
        [FlutterError
            errorWithCode:@"sign-in-failure"
                  message:
                      @"Game Center sign-in requires signing in with 'signInWithCredential()' API."
                  details:@{}]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.signInWithAppleAuth = auth;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"signInWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId auth:auth];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [self.authProvider
      getCredentialWithUIDelegate:nil
                       completion:^(FIRAuthCredential *_Nullable credential,
                                    NSError *_Nullable error) {
                         handleAppleAuthResult(self, app, auth, credential, error, completion);
                       }];
#endif
}

- (void)signOutApp:(nonnull AuthPigeonFirebaseApp *)app
        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (auth.currentUser == nil) {
    completion(nil);
    return;
  }

  NSError *signOutErrorPtr;
  BOOL signOutSuccessful = [auth signOut:&signOutErrorPtr];

  if (!signOutSuccessful) {
    completion([FLTFirebaseAuthPlugin convertToFlutterError:signOutErrorPtr]);
  } else {
    completion(nil);
  }
}

- (void)useEmulatorApp:(nonnull AuthPigeonFirebaseApp *)app
                  host:(nonnull NSString *)host
                  port:(long)port
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth useEmulatorWithHost:host port:port];
  completion(nil);
}

- (void)verifyPasswordResetCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                              code:(nonnull NSString *)code
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  [auth verifyPasswordResetCode:code
                     completion:^(NSString *_Nullable email, NSError *_Nullable error) {
                       if (error != nil) {
                         completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       } else {
                         completion(email, nil);
                       }
                     }];
}

- (void)verifyPhoneNumberApp:(nonnull AuthPigeonFirebaseApp *)app
                     request:(nonnull PigeonVerifyPhoneNumberRequest *)request
                  completion:
                      (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  NSLog(@"The Firebase Phone Authentication provider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name = [NSString
      stringWithFormat:@"%@/phone/%@", kFLTFirebaseAuthChannelName, [NSUUID UUID].UUIDString];
  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  NSString *multiFactorSessionId = request.multiFactorSessionId;
  FIRMultiFactorSession *multiFactorSession = nil;

  if (multiFactorSessionId != nil) {
    multiFactorSession = _multiFactorSessionMap[multiFactorSessionId];
  }

  NSString *multiFactorInfoId = request.multiFactorInfoId;

  FIRPhoneMultiFactorInfo *multiFactorInfo = nil;
  if (multiFactorInfoId != nil) {
    for (NSString *resolverId in _multiFactorResolverMap) {
      for (FIRMultiFactorInfo *info in _multiFactorResolverMap[resolverId].hints) {
        if ([info.UID isEqualToString:multiFactorInfoId] &&
            [info class] == [FIRPhoneMultiFactorInfo class]) {
          multiFactorInfo = (FIRPhoneMultiFactorInfo *)info;
          break;
        }
      }
    }
  }

#if TARGET_OS_OSX
  FLTPhoneNumberVerificationStreamHandler *handler =
      [[FLTPhoneNumberVerificationStreamHandler alloc] initWithAuth:auth];
#else
  FLTPhoneNumberVerificationStreamHandler *handler =
      [[FLTPhoneNumberVerificationStreamHandler alloc] initWithAuth:auth
                                                            request:request
                                                            session:multiFactorSession
                                                         factorInfo:multiFactorInfo];
#endif

  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
#endif
}

- (void)deleteApp:(nonnull AuthPigeonFirebaseApp *)app
       completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser deleteWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)getIdTokenApp:(nonnull AuthPigeonFirebaseApp *)app
         forceRefresh:(BOOL)forceRefresh
           completion:(nonnull void (^)(PigeonIdTokenResult *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser
      getIDTokenResultForcingRefresh:forceRefresh
                          completion:^(FIRAuthTokenResult *tokenResult, NSError *error) {
                            if (error != nil) {
                              completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                              return;
                            }

                            completion([PigeonParser parseIdTokenResult:tokenResult], nil);
                          }];
}

- (void)linkWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                        input:(nonnull NSDictionary<NSString *, id> *)input
                   completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   linkWithCredential:credential
                                           completion:^(FIRAuthDataResult *authResult,
                                                        NSError *error) {
                                             if (error != nil) {
                                               if (error.code ==
                                                   FIRAuthErrorCodeSecondFactorRequired) {
                                                 [self handleMultiFactorError:app
                                                                   completion:completion
                                                                    withError:error];
                                               } else {
                                                 completion(nil, [FLTFirebaseAuthPlugin
                                                                     convertToFlutterError:error]);
                                               }
                                             } else {
                                               completion(
                                                   [PigeonParser
                                                       getPigeonUserCredentialFromAuthResult:
                                                           authResult
                                                                           authorizationCode:nil],
                                                   nil);
                                             }
                                           }];
                             }];
}

- (void)linkWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
             signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                 completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                              FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if ([signInProvider.providerId isEqualToString:kSignInMethodGameCenter]) {
    completion(
        nil,
        [FlutterError
            errorWithCode:@"provider-link-failure"
                  message:@"Game Center provider requires linking with 'linkWithCredential()' API."
                  details:@{}]);
    return;
  }

  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.linkWithAppleUser = currentUser;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"linkWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [currentUser
      linkWithProvider:self.authProvider
            UIDelegate:nil
            completion:^(FIRAuthDataResult *authResult, NSError *error) {
              handleAppleAuthResult(self, app, auth, authResult.credential, error, completion);
            }];
#endif
}

- (void)reauthenticateWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                                  input:(nonnull NSDictionary<NSString *, id> *)input
                             completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                          FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   reauthenticateWithCredential:credential
                                                     completion:^(FIRAuthDataResult *authResult,
                                                                  NSError *error) {
                                                       if (error != nil) {
                                                         if (error.code ==
                                                             FIRAuthErrorCodeSecondFactorRequired) {
                                                           [self handleMultiFactorError:app
                                                                             completion:completion
                                                                              withError:error];
                                                         } else {
                                                           completion(
                                                               nil,
                                                               [FLTFirebaseAuthPlugin
                                                                   convertToFlutterError:error]);
                                                         }
                                                       } else {
                                                         completion(
                                                             [PigeonParser
                                                                 getPigeonUserCredentialFromAuthResult:
                                                                     authResult
                                                                                     authorizationCode:
                                                                                         nil],
                                                             nil);
                                                       }
                                                     }];
                             }];
}

- (void)reauthenticateWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
                       signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                           completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.isReauthenticatingWithApple = YES;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"reauthenticateWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [currentUser reauthenticateWithProvider:self.authProvider
                               UIDelegate:nil
                               completion:^(FIRAuthDataResult *authResult, NSError *error) {
                                 handleAppleAuthResult(self, app, auth, authResult.credential,
                                                       error, completion);
                               }];
#endif
}

- (void)reloadApp:(nonnull AuthPigeonFirebaseApp *)app
       completion:
           (nonnull void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser reloadWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
    }
  }];
}

- (void)sendEmailVerificationApp:(nonnull AuthPigeonFirebaseApp *)app
              actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser
      sendEmailVerificationWithActionCodeSettings:[PigeonParser
                                                      parseActionCodeSettings:actionCodeSettings]

                                       completion:^(NSError *_Nullable error) {
                                         if (error != nil) {
                                           completion(
                                               [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                         } else {
                                           completion(nil);
                                         }
                                       }];
}

- (void)unlinkApp:(nonnull AuthPigeonFirebaseApp *)app
       providerId:(nonnull NSString *)providerId
       completion:
           (nonnull void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser unlinkFromProvider:providerId
                       completion:^(FIRUser *_Nullable user, NSError *_Nullable error) {
                         if (error != nil) {
                           completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                         } else {
                           completion([PigeonParser getPigeonUserCredentialFromFIRUser:user], nil);
                         }
                       }];
}

- (void)updateEmailApp:(nonnull AuthPigeonFirebaseApp *)app
              newEmail:(nonnull NSString *)newEmail
            completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                         FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser updateEmail:newEmail
                completion:^(NSError *_Nullable error) {
                  if (error != nil) {
                    completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                  } else {
                    [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
                      if (reloadError != nil) {
                        completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
                      } else {
                        completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
                      }
                    }];
                  }
                }];
}

- (void)updatePasswordApp:(nonnull AuthPigeonFirebaseApp *)app
              newPassword:(nonnull NSString *)newPassword
               completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                            FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser
      updatePassword:newPassword
          completion:^(NSError *_Nullable error) {
            if (error != nil) {
              completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
            } else {
              [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
                if (reloadError != nil) {
                  completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
                } else {
                  completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
                }
              }];
            }
          }];
}

- (void)updatePhoneNumberApp:(nonnull AuthPigeonFirebaseApp *)app
                       input:(nonnull NSDictionary<NSString *, id> *)input
                  completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                               FlutterError *_Nullable))completion {
#if TARGET_OS_IPHONE
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   updatePhoneNumberCredential:(FIRPhoneAuthCredential *)credential
                                                    completion:^(NSError *_Nullable error) {
                                                      if (error != nil) {
                                                        completion(
                                                            nil, [FLTFirebaseAuthPlugin
                                                                     convertToFlutterError:error]);
                                                      } else {
                                                        [currentUser
                                                            reloadWithCompletion:^(
                                                                NSError *_Nullable reloadError) {
                                                              if (reloadError != nil) {
                                                                completion(
                                                                    nil, [FLTFirebaseAuthPlugin
                                                                             convertToFlutterError:
                                                                                 reloadError]);
                                                              } else {
                                                                completion(
                                                                    [PigeonParser
                                                                        getPigeonDetails:
                                                                            auth.currentUser],
                                                                    nil);
                                                              }
                                                            }];
                                                      }
                                                    }];
                             }];
#else
  NSLog(@"Updating a users phone number via Firebase Authentication is only "
        @"supported on the iOS "
        @"platform.");
  completion(nil, nil);
#endif
}

- (void)updateProfileApp:(nonnull AuthPigeonFirebaseApp *)app
                 profile:(nonnull PigeonUserProfile *)profile
              completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                           FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  FIRUserProfileChangeRequest *changeRequest = [currentUser profileChangeRequest];

  if (profile.displayNameChanged) {
    changeRequest.displayName = profile.displayName;
  }

  if (profile.photoUrlChanged) {
    if (profile.photoUrl == nil) {
      // We apparently cannot set photoURL to nil/NULL to remove it.
      // Instead, setting it to empty string appears to work.
      // When doing so, Dart will properly receive `null` anyway.
      changeRequest.photoURL = [NSURL URLWithString:@""];
    } else {
      changeRequest.photoURL = [NSURL URLWithString:profile.photoUrl];
    }
  }

  [changeRequest commitChangesWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
        if (reloadError != nil) {
          completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
        } else {
          completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
        }
      }];
    }
  }];
}

- (void)verifyBeforeUpdateEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                          newEmail:(nonnull NSString *)newEmail
                actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser
      sendEmailVerificationBeforeUpdatingEmail:newEmail
                            actionCodeSettings:[PigeonParser
                                                   parseActionCodeSettings:actionCodeSettings]
                                    completion:^(NSError *error) {
                                      if (error != nil) {
                                        completion(
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                      } else {
                                        completion(nil);
                                      }
                                    }];
}

- (void)initializeRecaptchaConfigApp:(AuthPigeonFirebaseApp *)app
                          completion:(void (^)(FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  NSLog(@"initializeRecaptchaConfigWithCompletion is not supported on the "
        @"MacOS platform.");
  completion(nil);
#else
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth initializeRecaptchaConfigWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
#endif
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/FLTIdTokenChannelStreamHandler.m

**크기**: 1378 bytes | **라인 수**: 55 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseAuth;
#import "include/Private/FLTIdTokenChannelStreamHandler.h"
#import <FirebaseAuth/FirebaseAuth.h>
#import "include/Private/PigeonParser.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTIdTokenChannelStreamHandler {
  FIRAuth *_auth;
  FIRIDTokenDidChangeListenerHandle _listener;
}

- (instancetype)initWithAuth:(FIRAuth *)auth {
  self = [super init];
  if (self) {
    _auth = auth;
  }
  return self;
}

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
  bool __block initialAuthState = YES;

  _listener = [_auth addIDTokenDidChangeListener:^(FIRAuth *_Nonnull auth,
                                                   FIRUser *_Nullable user) {
    if (initialAuthState) {
      initialAuthState = NO;
      return;
    }

    if (user) {
      events(@{
        @"user" : [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
      });
    } else {
      events(@{@"user" : [NSNull null]});
    }
  }];

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  if (_listener) {
    [_auth removeIDTokenDidChangeListener:_listener];
  }
  _listener = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/FLTPhoneNumberVerificationStreamHandler.m

**크기**: 2823 bytes | **라인 수**: 99 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseAuth;

#import "include/Private/FLTPhoneNumberVerificationStreamHandler.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTPhoneNumberVerificationStreamHandler {
  FIRAuth *_auth;
  NSString *_phoneNumber;
#if TARGET_OS_OSX
#else
  FIRMultiFactorSession *_session;
  FIRPhoneMultiFactorInfo *_factorInfo;
#endif
}

#if TARGET_OS_OSX
- (instancetype)initWithAuth:(id)auth request:(PigeonVerifyPhoneNumberRequest *)request {
  self = [super init];
  if (self) {
    _auth = auth;
    _phoneNumber = request.phoneNumber;
  }
  return self;
}
#else
- (instancetype)initWithAuth:(id)auth
                     request:(PigeonVerifyPhoneNumberRequest *)request
                     session:(FIRMultiFactorSession *)session
                  factorInfo:(FIRPhoneMultiFactorInfo *)factorInfo {
  self = [super init];
  if (self) {
    _auth = auth;
    _phoneNumber = request.phoneNumber;
    _session = session;
    _factorInfo = factorInfo;
  }
  return self;
}
#endif

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
#if TARGET_OS_IPHONE
  id completer = ^(NSString *verificationID, NSError *error) {
    if (error != nil) {
      FlutterError *errorDetails = [FLTFirebaseAuthPlugin convertToFlutterError:error];
      events(@{
        @"name" : @"Auth#phoneVerificationFailed",
        @"error" : @{
          @"code" : errorDetails.code,
          @"message" : errorDetails.message,
          @"details" : errorDetails.details,
        }
      });
    } else {
      events(@{
        @"name" : @"Auth#phoneCodeSent",
        @"verificationId" : verificationID,
      });
    }
  };

  // Try catch to capture 'missing URL scheme' error.
  @try {
    if (_factorInfo != nil) {
      [[FIRPhoneAuthProvider providerWithAuth:_auth]
          verifyPhoneNumberWithMultiFactorInfo:_factorInfo
                                    UIDelegate:nil
                            multiFactorSession:_session
                                    completion:completer];

    } else {
      [[FIRPhoneAuthProvider providerWithAuth:_auth] verifyPhoneNumber:_phoneNumber
                                                            UIDelegate:nil
                                                    multiFactorSession:_session
                                                            completion:completer];
    }
  } @catch (NSException *exception) {
    events(@{
      @"name" : @"Auth#phoneVerificationFailed",
      @"error" : @{
        @"message" : exception.reason,
      }
    });
  }
#endif

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/PigeonParser.m

**크기**: 7041 bytes | **라인 수**: 170 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

@import FirebaseAuth;

#import "include/Private/PigeonParser.h"
#import <Foundation/Foundation.h>
#import "include/Public/CustomPigeonHeader.h"

@implementation PigeonParser

+ (PigeonUserCredential *)
    getPigeonUserCredentialFromAuthResult:(nonnull FIRAuthDataResult *)authResult
                        authorizationCode:(nullable NSString *)authorizationCode {
  return [PigeonUserCredential
            makeWithUser:[self getPigeonDetails:authResult.user]
      additionalUserInfo:[self getPigeonAdditionalUserInfo:authResult.additionalUserInfo
                                         authorizationCode:authorizationCode]
              credential:[self getPigeonAuthCredential:authResult.credential token:nil]];
}

+ (PigeonUserCredential *)getPigeonUserCredentialFromFIRUser:(nonnull FIRUser *)user {
  return [PigeonUserCredential makeWithUser:[self getPigeonDetails:user]
                         additionalUserInfo:nil
                                 credential:nil];
}

+ (PigeonUserDetails *)getPigeonDetails:(nonnull FIRUser *)user {
  return [PigeonUserDetails makeWithUserInfo:[self getPigeonUserInfo:user]
                                providerData:[self getProviderData:user.providerData]];
}

+ (PigeonUserInfo *)getPigeonUserInfo:(nonnull FIRUser *)user {
  return [PigeonUserInfo
              makeWithUid:user.uid
                    email:user.email
              displayName:user.displayName
                 photoUrl:(user.photoURL.absoluteString.length > 0) ? user.photoURL.absoluteString
                                                                    : nil
              phoneNumber:user.phoneNumber
              isAnonymous:user.isAnonymous
          isEmailVerified:user.emailVerified
               providerId:user.providerID
                 tenantId:user.tenantID
             refreshToken:user.refreshToken
        creationTimestamp:@((long)([user.metadata.creationDate timeIntervalSince1970] * 1000))
      lastSignInTimestamp:@((long)([user.metadata.lastSignInDate timeIntervalSince1970] * 1000))];
}

+ (NSArray<NSDictionary<id, id> *> *)getProviderData:
    (nonnull NSArray<id<FIRUserInfo>> *)providerData {
  NSMutableArray<NSDictionary<id, id> *> *dataArray =
      [NSMutableArray arrayWithCapacity:providerData.count];

  for (id<FIRUserInfo> userInfo in providerData) {
    NSDictionary *dataDict = @{
      @"providerId" : userInfo.providerID,
      // Can be null on emulator
      @"uid" : userInfo.uid ?: @"",
      @"displayName" : userInfo.displayName ?: [NSNull null],
      @"email" : userInfo.email ?: [NSNull null],
      @"phoneNumber" : userInfo.phoneNumber ?: [NSNull null],
      @"photoURL" : userInfo.photoURL.absoluteString ?: [NSNull null],
      // isAnonymous is always false on in a providerData object (the user is not anonymous)
      @"isAnonymous" : @NO,
      // isEmailVerified is always true on in a providerData object (the email is verified by the
      // provider)
      @"isEmailVerified" : @YES,
    };
    [dataArray addObject:dataDict];
  }
  return [dataArray copy];
}

+ (PigeonAdditionalUserInfo *)getPigeonAdditionalUserInfo:(nonnull FIRAdditionalUserInfo *)userInfo
                                        authorizationCode:(nullable NSString *)authorizationCode {
  return [PigeonAdditionalUserInfo makeWithIsNewUser:userInfo.isNewUser
                                          providerId:userInfo.providerID
                                            username:userInfo.username
                                   authorizationCode:authorizationCode
                                             profile:userInfo.profile];
}

+ (PigeonTotpSecret *)getPigeonTotpSecret:(FIRTOTPSecret *)secret {
  return [PigeonTotpSecret makeWithCodeIntervalSeconds:nil
                                            codeLength:nil
                          enrollmentCompletionDeadline:nil
                                      hashingAlgorithm:nil
                                             secretKey:secret.sharedSecretKey];
}

+ (PigeonAuthCredential *)getPigeonAuthCredential:(FIRAuthCredential *)authCredential
                                            token:(NSNumber *_Nullable)token {
  if (authCredential == nil) {
    return nil;
  }

  NSString *accessToken = nil;
  if ([authCredential isKindOfClass:[FIROAuthCredential class]]) {
    if (((FIROAuthCredential *)authCredential).accessToken != nil) {
      accessToken = ((FIROAuthCredential *)authCredential).accessToken;
    } else if (((FIROAuthCredential *)authCredential).IDToken != nil) {
      // For Sign In With Apple, the token is stored in IDToken
      accessToken = ((FIROAuthCredential *)authCredential).IDToken;
    }
  }

  NSUInteger nativeId =
      token != nil ? [token unsignedLongValue] : (NSUInteger)[authCredential hash];

  return [PigeonAuthCredential makeWithProviderId:authCredential.provider
                                     signInMethod:authCredential.provider
                                         nativeId:nativeId
                                      accessToken:accessToken ?: nil];
}

+ (FIRActionCodeSettings *_Nullable)parseActionCodeSettings:
    (nullable PigeonActionCodeSettings *)settings {
  if (settings == nil) {
    return nil;
  }

  FIRActionCodeSettings *codeSettings = [[FIRActionCodeSettings alloc] init];

  if (settings.url != nil) {
    codeSettings.URL = [NSURL URLWithString:settings.url];
  }

  if (settings.linkDomain != nil) {
    codeSettings.linkDomain = settings.linkDomain;
  }

  codeSettings.handleCodeInApp = settings.handleCodeInApp;

  if (settings.iOSBundleId != nil) {
    codeSettings.iOSBundleID = settings.iOSBundleId;
  }

  return codeSettings;
}

+ (PigeonIdTokenResult *)parseIdTokenResult:(FIRAuthTokenResult *)tokenResult {
  long expirationTimestamp = (long)[tokenResult.expirationDate timeIntervalSince1970] * 1000;
  long authTimestamp = (long)[tokenResult.authDate timeIntervalSince1970] * 1000;
  long issuedAtTimestamp = (long)[tokenResult.issuedAtDate timeIntervalSince1970] * 1000;

  return [PigeonIdTokenResult makeWithToken:tokenResult.token
                        expirationTimestamp:@(expirationTimestamp)
                              authTimestamp:@(authTimestamp)
                          issuedAtTimestamp:@(issuedAtTimestamp)
                             signInProvider:tokenResult.signInProvider
                                     claims:tokenResult.claims
                         signInSecondFactor:tokenResult.signInSecondFactor];
}

+ (NSArray *_Nonnull)getManualList:(nonnull PigeonUserDetails *)userDetails {
  NSMutableArray *output = [NSMutableArray array];

  id userInfoList = [[userDetails userInfo] toList];
  [output addObject:userInfoList];

  id providerData = [userDetails providerData];
  [output addObject:providerData];

  return [output copy];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Sources/firebase_auth/firebase_auth_messages.g.m

**크기**: 124738 bytes | **라인 수**: 2765 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "include/Public/firebase_auth_messages.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// The type of operation that generated the action code from calling
/// [checkActionCode].
@implementation ActionCodeInfoOperationBox
- (instancetype)initWithValue:(ActionCodeInfoOperation)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface PigeonMultiFactorSession ()
+ (PigeonMultiFactorSession *)fromList:(NSArray *)list;
+ (nullable PigeonMultiFactorSession *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonPhoneMultiFactorAssertion ()
+ (PigeonPhoneMultiFactorAssertion *)fromList:(NSArray *)list;
+ (nullable PigeonPhoneMultiFactorAssertion *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonMultiFactorInfo ()
+ (PigeonMultiFactorInfo *)fromList:(NSArray *)list;
+ (nullable PigeonMultiFactorInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AuthPigeonFirebaseApp ()
+ (AuthPigeonFirebaseApp *)fromList:(NSArray *)list;
+ (nullable AuthPigeonFirebaseApp *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeInfoData ()
+ (PigeonActionCodeInfoData *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeInfoData *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeInfo ()
+ (PigeonActionCodeInfo *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonAdditionalUserInfo ()
+ (PigeonAdditionalUserInfo *)fromList:(NSArray *)list;
+ (nullable PigeonAdditionalUserInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonAuthCredential ()
+ (PigeonAuthCredential *)fromList:(NSArray *)list;
+ (nullable PigeonAuthCredential *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserInfo ()
+ (PigeonUserInfo *)fromList:(NSArray *)list;
+ (nullable PigeonUserInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserDetails ()
+ (PigeonUserDetails *)fromList:(NSArray *)list;
+ (nullable PigeonUserDetails *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserCredential ()
+ (PigeonUserCredential *)fromList:(NSArray *)list;
+ (nullable PigeonUserCredential *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeSettings ()
+ (PigeonActionCodeSettings *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonFirebaseAuthSettings ()
+ (PigeonFirebaseAuthSettings *)fromList:(NSArray *)list;
+ (nullable PigeonFirebaseAuthSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonSignInProvider ()
+ (PigeonSignInProvider *)fromList:(NSArray *)list;
+ (nullable PigeonSignInProvider *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonVerifyPhoneNumberRequest ()
+ (PigeonVerifyPhoneNumberRequest *)fromList:(NSArray *)list;
+ (nullable PigeonVerifyPhoneNumberRequest *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonIdTokenResult ()
+ (PigeonIdTokenResult *)fromList:(NSArray *)list;
+ (nullable PigeonIdTokenResult *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserProfile ()
+ (PigeonUserProfile *)fromList:(NSArray *)list;
+ (nullable PigeonUserProfile *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonTotpSecret ()
+ (PigeonTotpSecret *)fromList:(NSArray *)list;
+ (nullable PigeonTotpSecret *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation PigeonMultiFactorSession
+ (instancetype)makeWithId:(NSString *)id {
  PigeonMultiFactorSession *pigeonResult = [[PigeonMultiFactorSession alloc] init];
  pigeonResult.id = id;
  return pigeonResult;
}
+ (PigeonMultiFactorSession *)fromList:(NSArray *)list {
  PigeonMultiFactorSession *pigeonResult = [[PigeonMultiFactorSession alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable PigeonMultiFactorSession *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonMultiFactorSession fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
  ];
}
@end

@implementation PigeonPhoneMultiFactorAssertion
+ (instancetype)makeWithVerificationId:(NSString *)verificationId
                      verificationCode:(NSString *)verificationCode {
  PigeonPhoneMultiFactorAssertion *pigeonResult = [[PigeonPhoneMultiFactorAssertion alloc] init];
  pigeonResult.verificationId = verificationId;
  pigeonResult.verificationCode = verificationCode;
  return pigeonResult;
}
+ (PigeonPhoneMultiFactorAssertion *)fromList:(NSArray *)list {
  PigeonPhoneMultiFactorAssertion *pigeonResult = [[PigeonPhoneMultiFactorAssertion alloc] init];
  pigeonResult.verificationId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.verificationCode = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonPhoneMultiFactorAssertion *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonPhoneMultiFactorAssertion fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.verificationId ?: [NSNull null],
    self.verificationCode ?: [NSNull null],
  ];
}
@end

@implementation PigeonMultiFactorInfo
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                enrollmentTimestamp:(double)enrollmentTimestamp
                           factorId:(nullable NSString *)factorId
                                uid:(NSString *)uid
                        phoneNumber:(nullable NSString *)phoneNumber {
  PigeonMultiFactorInfo *pigeonResult = [[PigeonMultiFactorInfo alloc] init];
  pigeonResult.displayName = displayName;
  pigeonResult.enrollmentTimestamp = enrollmentTimestamp;
  pigeonResult.factorId = factorId;
  pigeonResult.uid = uid;
  pigeonResult.phoneNumber = phoneNumber;
  return pigeonResult;
}
+ (PigeonMultiFactorInfo *)fromList:(NSArray *)list {
  PigeonMultiFactorInfo *pigeonResult = [[PigeonMultiFactorInfo alloc] init];
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.enrollmentTimestamp = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.factorId = GetNullableObjectAtIndex(list, 2);
  pigeonResult.uid = GetNullableObjectAtIndex(list, 3);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonMultiFactorInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonMultiFactorInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.displayName ?: [NSNull null],
    @(self.enrollmentTimestamp),
    self.factorId ?: [NSNull null],
    self.uid ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
  ];
}
@end

@implementation AuthPigeonFirebaseApp
+ (instancetype)makeWithAppName:(NSString *)appName
                       tenantId:(nullable NSString *)tenantId
               customAuthDomain:(nullable NSString *)customAuthDomain {
  AuthPigeonFirebaseApp *pigeonResult = [[AuthPigeonFirebaseApp alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.tenantId = tenantId;
  pigeonResult.customAuthDomain = customAuthDomain;
  return pigeonResult;
}
+ (AuthPigeonFirebaseApp *)fromList:(NSArray *)list {
  AuthPigeonFirebaseApp *pigeonResult = [[AuthPigeonFirebaseApp alloc] init];
  pigeonResult.appName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.tenantId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.customAuthDomain = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable AuthPigeonFirebaseApp *)nullableFromList:(NSArray *)list {
  return (list) ? [AuthPigeonFirebaseApp fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.appName ?: [NSNull null],
    self.tenantId ?: [NSNull null],
    self.customAuthDomain ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeInfoData
+ (instancetype)makeWithEmail:(nullable NSString *)email
                previousEmail:(nullable NSString *)previousEmail {
  PigeonActionCodeInfoData *pigeonResult = [[PigeonActionCodeInfoData alloc] init];
  pigeonResult.email = email;
  pigeonResult.previousEmail = previousEmail;
  return pigeonResult;
}
+ (PigeonActionCodeInfoData *)fromList:(NSArray *)list {
  PigeonActionCodeInfoData *pigeonResult = [[PigeonActionCodeInfoData alloc] init];
  pigeonResult.email = GetNullableObjectAtIndex(list, 0);
  pigeonResult.previousEmail = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonActionCodeInfoData *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeInfoData fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.email ?: [NSNull null],
    self.previousEmail ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeInfo
+ (instancetype)makeWithOperation:(ActionCodeInfoOperation)operation
                             data:(PigeonActionCodeInfoData *)data {
  PigeonActionCodeInfo *pigeonResult = [[PigeonActionCodeInfo alloc] init];
  pigeonResult.operation = operation;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (PigeonActionCodeInfo *)fromList:(NSArray *)list {
  PigeonActionCodeInfo *pigeonResult = [[PigeonActionCodeInfo alloc] init];
  pigeonResult.operation = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonActionCodeInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.operation),
    self.data ?: [NSNull null],
  ];
}
@end

@implementation PigeonAdditionalUserInfo
+ (instancetype)makeWithIsNewUser:(BOOL)isNewUser
                       providerId:(nullable NSString *)providerId
                         username:(nullable NSString *)username
                authorizationCode:(nullable NSString *)authorizationCode
                          profile:(nullable NSDictionary<NSString *, id> *)profile {
  PigeonAdditionalUserInfo *pigeonResult = [[PigeonAdditionalUserInfo alloc] init];
  pigeonResult.isNewUser = isNewUser;
  pigeonResult.providerId = providerId;
  pigeonResult.username = username;
  pigeonResult.authorizationCode = authorizationCode;
  pigeonResult.profile = profile;
  return pigeonResult;
}
+ (PigeonAdditionalUserInfo *)fromList:(NSArray *)list {
  PigeonAdditionalUserInfo *pigeonResult = [[PigeonAdditionalUserInfo alloc] init];
  pigeonResult.isNewUser = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.username = GetNullableObjectAtIndex(list, 2);
  pigeonResult.authorizationCode = GetNullableObjectAtIndex(list, 3);
  pigeonResult.profile = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonAdditionalUserInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonAdditionalUserInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.isNewUser),
    self.providerId ?: [NSNull null],
    self.username ?: [NSNull null],
    self.authorizationCode ?: [NSNull null],
    self.profile ?: [NSNull null],
  ];
}
@end

@implementation PigeonAuthCredential
+ (instancetype)makeWithProviderId:(NSString *)providerId
                      signInMethod:(NSString *)signInMethod
                          nativeId:(NSInteger)nativeId
                       accessToken:(nullable NSString *)accessToken {
  PigeonAuthCredential *pigeonResult = [[PigeonAuthCredential alloc] init];
  pigeonResult.providerId = providerId;
  pigeonResult.signInMethod = signInMethod;
  pigeonResult.nativeId = nativeId;
  pigeonResult.accessToken = accessToken;
  return pigeonResult;
}
+ (PigeonAuthCredential *)fromList:(NSArray *)list {
  PigeonAuthCredential *pigeonResult = [[PigeonAuthCredential alloc] init];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.signInMethod = GetNullableObjectAtIndex(list, 1);
  pigeonResult.nativeId = [GetNullableObjectAtIndex(list, 2) integerValue];
  pigeonResult.accessToken = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable PigeonAuthCredential *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonAuthCredential fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.providerId ?: [NSNull null],
    self.signInMethod ?: [NSNull null],
    @(self.nativeId),
    self.accessToken ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserInfo
+ (instancetype)makeWithUid:(NSString *)uid
                      email:(nullable NSString *)email
                displayName:(nullable NSString *)displayName
                   photoUrl:(nullable NSString *)photoUrl
                phoneNumber:(nullable NSString *)phoneNumber
                isAnonymous:(BOOL)isAnonymous
            isEmailVerified:(BOOL)isEmailVerified
                 providerId:(nullable NSString *)providerId
                   tenantId:(nullable NSString *)tenantId
               refreshToken:(nullable NSString *)refreshToken
          creationTimestamp:(nullable NSNumber *)creationTimestamp
        lastSignInTimestamp:(nullable NSNumber *)lastSignInTimestamp {
  PigeonUserInfo *pigeonResult = [[PigeonUserInfo alloc] init];
  pigeonResult.uid = uid;
  pigeonResult.email = email;
  pigeonResult.displayName = displayName;
  pigeonResult.photoUrl = photoUrl;
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.isAnonymous = isAnonymous;
  pigeonResult.isEmailVerified = isEmailVerified;
  pigeonResult.providerId = providerId;
  pigeonResult.tenantId = tenantId;
  pigeonResult.refreshToken = refreshToken;
  pigeonResult.creationTimestamp = creationTimestamp;
  pigeonResult.lastSignInTimestamp = lastSignInTimestamp;
  return pigeonResult;
}
+ (PigeonUserInfo *)fromList:(NSArray *)list {
  PigeonUserInfo *pigeonResult = [[PigeonUserInfo alloc] init];
  pigeonResult.uid = GetNullableObjectAtIndex(list, 0);
  pigeonResult.email = GetNullableObjectAtIndex(list, 1);
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 2);
  pigeonResult.photoUrl = GetNullableObjectAtIndex(list, 3);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 4);
  pigeonResult.isAnonymous = [GetNullableObjectAtIndex(list, 5) boolValue];
  pigeonResult.isEmailVerified = [GetNullableObjectAtIndex(list, 6) boolValue];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 7);
  pigeonResult.tenantId = GetNullableObjectAtIndex(list, 8);
  pigeonResult.refreshToken = GetNullableObjectAtIndex(list, 9);
  pigeonResult.creationTimestamp = GetNullableObjectAtIndex(list, 10);
  pigeonResult.lastSignInTimestamp = GetNullableObjectAtIndex(list, 11);
  return pigeonResult;
}
+ (nullable PigeonUserInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.uid ?: [NSNull null],
    self.email ?: [NSNull null],
    self.displayName ?: [NSNull null],
    self.photoUrl ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
    @(self.isAnonymous),
    @(self.isEmailVerified),
    self.providerId ?: [NSNull null],
    self.tenantId ?: [NSNull null],
    self.refreshToken ?: [NSNull null],
    self.creationTimestamp ?: [NSNull null],
    self.lastSignInTimestamp ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserDetails
+ (instancetype)makeWithUserInfo:(PigeonUserInfo *)userInfo
                    providerData:(NSArray<NSDictionary<id, id> *> *)providerData {
  PigeonUserDetails *pigeonResult = [[PigeonUserDetails alloc] init];
  pigeonResult.userInfo = userInfo;
  pigeonResult.providerData = providerData;
  return pigeonResult;
}
+ (PigeonUserDetails *)fromList:(NSArray *)list {
  PigeonUserDetails *pigeonResult = [[PigeonUserDetails alloc] init];
  pigeonResult.userInfo = GetNullableObjectAtIndex(list, 0);
  pigeonResult.providerData = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonUserDetails *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserDetails fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.userInfo ?: [NSNull null],
    self.providerData ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserCredential
+ (instancetype)makeWithUser:(nullable PigeonUserDetails *)user
          additionalUserInfo:(nullable PigeonAdditionalUserInfo *)additionalUserInfo
                  credential:(nullable PigeonAuthCredential *)credential {
  PigeonUserCredential *pigeonResult = [[PigeonUserCredential alloc] init];
  pigeonResult.user = user;
  pigeonResult.additionalUserInfo = additionalUserInfo;
  pigeonResult.credential = credential;
  return pigeonResult;
}
+ (PigeonUserCredential *)fromList:(NSArray *)list {
  PigeonUserCredential *pigeonResult = [[PigeonUserCredential alloc] init];
  pigeonResult.user = GetNullableObjectAtIndex(list, 0);
  pigeonResult.additionalUserInfo = GetNullableObjectAtIndex(list, 1);
  pigeonResult.credential = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable PigeonUserCredential *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserCredential fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.user ?: [NSNull null],
    self.additionalUserInfo ?: [NSNull null],
    self.credential ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeSettings
+ (instancetype)makeWithUrl:(NSString *)url
          dynamicLinkDomain:(nullable NSString *)dynamicLinkDomain
            handleCodeInApp:(BOOL)handleCodeInApp
                iOSBundleId:(nullable NSString *)iOSBundleId
         androidPackageName:(nullable NSString *)androidPackageName
          androidInstallApp:(BOOL)androidInstallApp
      androidMinimumVersion:(nullable NSString *)androidMinimumVersion
                 linkDomain:(nullable NSString *)linkDomain {
  PigeonActionCodeSettings *pigeonResult = [[PigeonActionCodeSettings alloc] init];
  pigeonResult.url = url;
  pigeonResult.dynamicLinkDomain = dynamicLinkDomain;
  pigeonResult.handleCodeInApp = handleCodeInApp;
  pigeonResult.iOSBundleId = iOSBundleId;
  pigeonResult.androidPackageName = androidPackageName;
  pigeonResult.androidInstallApp = androidInstallApp;
  pigeonResult.androidMinimumVersion = androidMinimumVersion;
  pigeonResult.linkDomain = linkDomain;
  return pigeonResult;
}
+ (PigeonActionCodeSettings *)fromList:(NSArray *)list {
  PigeonActionCodeSettings *pigeonResult = [[PigeonActionCodeSettings alloc] init];
  pigeonResult.url = GetNullableObjectAtIndex(list, 0);
  pigeonResult.dynamicLinkDomain = GetNullableObjectAtIndex(list, 1);
  pigeonResult.handleCodeInApp = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.iOSBundleId = GetNullableObjectAtIndex(list, 3);
  pigeonResult.androidPackageName = GetNullableObjectAtIndex(list, 4);
  pigeonResult.androidInstallApp = [GetNullableObjectAtIndex(list, 5) boolValue];
  pigeonResult.androidMinimumVersion = GetNullableObjectAtIndex(list, 6);
  pigeonResult.linkDomain = GetNullableObjectAtIndex(list, 7);
  return pigeonResult;
}
+ (nullable PigeonActionCodeSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.url ?: [NSNull null],
    self.dynamicLinkDomain ?: [NSNull null],
    @(self.handleCodeInApp),
    self.iOSBundleId ?: [NSNull null],
    self.androidPackageName ?: [NSNull null],
    @(self.androidInstallApp),
    self.androidMinimumVersion ?: [NSNull null],
    self.linkDomain ?: [NSNull null],
  ];
}
@end

@implementation PigeonFirebaseAuthSettings
+ (instancetype)makeWithAppVerificationDisabledForTesting:(BOOL)appVerificationDisabledForTesting
                                          userAccessGroup:(nullable NSString *)userAccessGroup
                                              phoneNumber:(nullable NSString *)phoneNumber
                                                  smsCode:(nullable NSString *)smsCode
                                       forceRecaptchaFlow:(nullable NSNumber *)forceRecaptchaFlow {
  PigeonFirebaseAuthSettings *pigeonResult = [[PigeonFirebaseAuthSettings alloc] init];
  pigeonResult.appVerificationDisabledForTesting = appVerificationDisabledForTesting;
  pigeonResult.userAccessGroup = userAccessGroup;
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.smsCode = smsCode;
  pigeonResult.forceRecaptchaFlow = forceRecaptchaFlow;
  return pigeonResult;
}
+ (PigeonFirebaseAuthSettings *)fromList:(NSArray *)list {
  PigeonFirebaseAuthSettings *pigeonResult = [[PigeonFirebaseAuthSettings alloc] init];
  pigeonResult.appVerificationDisabledForTesting = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.userAccessGroup = GetNullableObjectAtIndex(list, 1);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 2);
  pigeonResult.smsCode = GetNullableObjectAtIndex(list, 3);
  pigeonResult.forceRecaptchaFlow = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonFirebaseAuthSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonFirebaseAuthSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.appVerificationDisabledForTesting),
    self.userAccessGroup ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
    self.smsCode ?: [NSNull null],
    self.forceRecaptchaFlow ?: [NSNull null],
  ];
}
@end

@implementation PigeonSignInProvider
+ (instancetype)makeWithProviderId:(NSString *)providerId
                            scopes:(nullable NSArray<NSString *> *)scopes
                  customParameters:
                      (nullable NSDictionary<NSString *, NSString *> *)customParameters {
  PigeonSignInProvider *pigeonResult = [[PigeonSignInProvider alloc] init];
  pigeonResult.providerId = providerId;
  pigeonResult.scopes = scopes;
  pigeonResult.customParameters = customParameters;
  return pigeonResult;
}
+ (PigeonSignInProvider *)fromList:(NSArray *)list {
  PigeonSignInProvider *pigeonResult = [[PigeonSignInProvider alloc] init];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.scopes = GetNullableObjectAtIndex(list, 1);
  pigeonResult.customParameters = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable PigeonSignInProvider *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonSignInProvider fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.providerId ?: [NSNull null],
    self.scopes ?: [NSNull null],
    self.customParameters ?: [NSNull null],
  ];
}
@end

@implementation PigeonVerifyPhoneNumberRequest
+ (instancetype)makeWithPhoneNumber:(nullable NSString *)phoneNumber
                            timeout:(NSInteger)timeout
                forceResendingToken:(nullable NSNumber *)forceResendingToken
     autoRetrievedSmsCodeForTesting:(nullable NSString *)autoRetrievedSmsCodeForTesting
                  multiFactorInfoId:(nullable NSString *)multiFactorInfoId
               multiFactorSessionId:(nullable NSString *)multiFactorSessionId {
  PigeonVerifyPhoneNumberRequest *pigeonResult = [[PigeonVerifyPhoneNumberRequest alloc] init];
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.timeout = timeout;
  pigeonResult.forceResendingToken = forceResendingToken;
  pigeonResult.autoRetrievedSmsCodeForTesting = autoRetrievedSmsCodeForTesting;
  pigeonResult.multiFactorInfoId = multiFactorInfoId;
  pigeonResult.multiFactorSessionId = multiFactorSessionId;
  return pigeonResult;
}
+ (PigeonVerifyPhoneNumberRequest *)fromList:(NSArray *)list {
  PigeonVerifyPhoneNumberRequest *pigeonResult = [[PigeonVerifyPhoneNumberRequest alloc] init];
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 0);
  pigeonResult.timeout = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.forceResendingToken = GetNullableObjectAtIndex(list, 2);
  pigeonResult.autoRetrievedSmsCodeForTesting = GetNullableObjectAtIndex(list, 3);
  pigeonResult.multiFactorInfoId = GetNullableObjectAtIndex(list, 4);
  pigeonResult.multiFactorSessionId = GetNullableObjectAtIndex(list, 5);
  return pigeonResult;
}
+ (nullable PigeonVerifyPhoneNumberRequest *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonVerifyPhoneNumberRequest fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.phoneNumber ?: [NSNull null],
    @(self.timeout),
    self.forceResendingToken ?: [NSNull null],
    self.autoRetrievedSmsCodeForTesting ?: [NSNull null],
    self.multiFactorInfoId ?: [NSNull null],
    self.multiFactorSessionId ?: [NSNull null],
  ];
}
@end

@implementation PigeonIdTokenResult
+ (instancetype)makeWithToken:(nullable NSString *)token
          expirationTimestamp:(nullable NSNumber *)expirationTimestamp
                authTimestamp:(nullable NSNumber *)authTimestamp
            issuedAtTimestamp:(nullable NSNumber *)issuedAtTimestamp
               signInProvider:(nullable NSString *)signInProvider
                       claims:(nullable NSDictionary<NSString *, id> *)claims
           signInSecondFactor:(nullable NSString *)signInSecondFactor {
  PigeonIdTokenResult *pigeonResult = [[PigeonIdTokenResult alloc] init];
  pigeonResult.token = token;
  pigeonResult.expirationTimestamp = expirationTimestamp;
  pigeonResult.authTimestamp = authTimestamp;
  pigeonResult.issuedAtTimestamp = issuedAtTimestamp;
  pigeonResult.signInProvider = signInProvider;
  pigeonResult.claims = claims;
  pigeonResult.signInSecondFactor = signInSecondFactor;
  return pigeonResult;
}
+ (PigeonIdTokenResult *)fromList:(NSArray *)list {
  PigeonIdTokenResult *pigeonResult = [[PigeonIdTokenResult alloc] init];
  pigeonResult.token = GetNullableObjectAtIndex(list, 0);
  pigeonResult.expirationTimestamp = GetNullableObjectAtIndex(list, 1);
  pigeonResult.authTimestamp = GetNullableObjectAtIndex(list, 2);
  pigeonResult.issuedAtTimestamp = GetNullableObjectAtIndex(list, 3);
  pigeonResult.signInProvider = GetNullableObjectAtIndex(list, 4);
  pigeonResult.claims = GetNullableObjectAtIndex(list, 5);
  pigeonResult.signInSecondFactor = GetNullableObjectAtIndex(list, 6);
  return pigeonResult;
}
+ (nullable PigeonIdTokenResult *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonIdTokenResult fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.token ?: [NSNull null],
    self.expirationTimestamp ?: [NSNull null],
    self.authTimestamp ?: [NSNull null],
    self.issuedAtTimestamp ?: [NSNull null],
    self.signInProvider ?: [NSNull null],
    self.claims ?: [NSNull null],
    self.signInSecondFactor ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserProfile
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                           photoUrl:(nullable NSString *)photoUrl
                 displayNameChanged:(BOOL)displayNameChanged
                    photoUrlChanged:(BOOL)photoUrlChanged {
  PigeonUserProfile *pigeonResult = [[PigeonUserProfile alloc] init];
  pigeonResult.displayName = displayName;
  pigeonResult.photoUrl = photoUrl;
  pigeonResult.displayNameChanged = displayNameChanged;
  pigeonResult.photoUrlChanged = photoUrlChanged;
  return pigeonResult;
}
+ (PigeonUserProfile *)fromList:(NSArray *)list {
  PigeonUserProfile *pigeonResult = [[PigeonUserProfile alloc] init];
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.photoUrl = GetNullableObjectAtIndex(list, 1);
  pigeonResult.displayNameChanged = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.photoUrlChanged = [GetNullableObjectAtIndex(list, 3) boolValue];
  return pigeonResult;
}
+ (nullable PigeonUserProfile *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserProfile fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.displayName ?: [NSNull null],
    self.photoUrl ?: [NSNull null],
    @(self.displayNameChanged),
    @(self.photoUrlChanged),
  ];
}
@end

@implementation PigeonTotpSecret
+ (instancetype)makeWithCodeIntervalSeconds:(nullable NSNumber *)codeIntervalSeconds
                                 codeLength:(nullable NSNumber *)codeLength
               enrollmentCompletionDeadline:(nullable NSNumber *)enrollmentCompletionDeadline
                           hashingAlgorithm:(nullable NSString *)hashingAlgorithm
                                  secretKey:(NSString *)secretKey {
  PigeonTotpSecret *pigeonResult = [[PigeonTotpSecret alloc] init];
  pigeonResult.codeIntervalSeconds = codeIntervalSeconds;
  pigeonResult.codeLength = codeLength;
  pigeonResult.enrollmentCompletionDeadline = enrollmentCompletionDeadline;
  pigeonResult.hashingAlgorithm = hashingAlgorithm;
  pigeonResult.secretKey = secretKey;
  return pigeonResult;
}
+ (PigeonTotpSecret *)fromList:(NSArray *)list {
  PigeonTotpSecret *pigeonResult = [[PigeonTotpSecret alloc] init];
  pigeonResult.codeIntervalSeconds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.codeLength = GetNullableObjectAtIndex(list, 1);
  pigeonResult.enrollmentCompletionDeadline = GetNullableObjectAtIndex(list, 2);
  pigeonResult.hashingAlgorithm = GetNullableObjectAtIndex(list, 3);
  pigeonResult.secretKey = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonTotpSecret *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonTotpSecret fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.codeIntervalSeconds ?: [NSNull null],
    self.codeLength ?: [NSNull null],
    self.enrollmentCompletionDeadline ?: [NSNull null],
    self.hashingAlgorithm ?: [NSNull null],
    self.secretKey ?: [NSNull null],
  ];
}
@end

@interface FirebaseAuthHostApiCodecReader : FlutterStandardReader
@end
@implementation FirebaseAuthHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonActionCodeInfo fromList:[self readValue]];
    case 130:
      return [PigeonActionCodeInfoData fromList:[self readValue]];
    case 131:
      return [PigeonActionCodeSettings fromList:[self readValue]];
    case 132:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 133:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 134:
      return [PigeonFirebaseAuthSettings fromList:[self readValue]];
    case 135:
      return [PigeonIdTokenResult fromList:[self readValue]];
    case 136:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 137:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 138:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 139:
      return [PigeonSignInProvider fromList:[self readValue]];
    case 140:
      return [PigeonTotpSecret fromList:[self readValue]];
    case 141:
      return [PigeonUserCredential fromList:[self readValue]];
    case 142:
      return [PigeonUserDetails fromList:[self readValue]];
    case 143:
      return [PigeonUserInfo fromList:[self readValue]];
    case 144:
      return [PigeonUserProfile fromList:[self readValue]];
    case 145:
      return [PigeonVerifyPhoneNumberRequest fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseAuthHostApiCodecWriter : FlutterStandardWriter
@end
@implementation FirebaseAuthHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfoData class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeSettings class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseAuthSettings class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonIdTokenResult class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSignInProvider class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserProfile class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonVerifyPhoneNumberRequest class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseAuthHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseAuthHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseAuthHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseAuthHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseAuthHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseAuthHostApiCodecReaderWriter *readerWriter =
        [[FirebaseAuthHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFirebaseAuthHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FirebaseAuthHostApi> *api) {
  SetUpFirebaseAuthHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAuthHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FirebaseAuthHostApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.registerIdTokenListener",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerIdTokenListenerApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(registerIdTokenListenerApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api registerIdTokenListenerApp:arg_app
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.registerAuthStateListener",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerAuthStateListenerApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(registerAuthStateListenerApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api registerAuthStateListenerApp:arg_app
                               completion:^(NSString *_Nullable output,
                                            FlutterError *_Nullable error) {
                                 callback(wrapResult(output, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.useEmulator",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(useEmulatorApp:host:port:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(useEmulatorApp:host:port:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_host = GetNullableObjectAtIndex(args, 1);
        NSInteger arg_port = [GetNullableObjectAtIndex(args, 2) integerValue];
        [api useEmulatorApp:arg_app
                       host:arg_host
                       port:arg_port
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.applyActionCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(applyActionCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(applyActionCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api applyActionCodeApp:arg_app
                           code:arg_code
                     completion:^(FlutterError *_Nullable error) {
                       callback(wrapResult(nil, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.checkActionCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(checkActionCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(checkActionCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api checkActionCodeApp:arg_app
                           code:arg_code
                     completion:^(PigeonActionCodeInfo *_Nullable output,
                                  FlutterError *_Nullable error) {
                       callback(wrapResult(output, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.confirmPasswordReset",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(confirmPasswordResetApp:
                                                                     code:newPassword:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(confirmPasswordResetApp:code:newPassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        NSString *arg_newPassword = GetNullableObjectAtIndex(args, 2);
        [api confirmPasswordResetApp:arg_app
                                code:arg_code
                         newPassword:arg_newPassword
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.createUserWithEmailAndPassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (createUserWithEmailAndPasswordApp:email:password:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(createUserWithEmailAndPasswordApp:email:password:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_password = GetNullableObjectAtIndex(args, 2);
        [api createUserWithEmailAndPasswordApp:arg_app
                                         email:arg_email
                                      password:arg_password
                                    completion:^(PigeonUserCredential *_Nullable output,
                                                 FlutterError *_Nullable error) {
                                      callback(wrapResult(output, error));
                                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInAnonymously",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInAnonymouslyApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInAnonymouslyApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api signInAnonymouslyApp:arg_app
                       completion:^(PigeonUserCredential *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithCredential",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithCredentialApp:input:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api signInWithCredentialApp:arg_app
                               input:arg_input
                          completion:^(PigeonUserCredential *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithCustomToken",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithCustomTokenApp:token:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithCustomTokenApp:token:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_token = GetNullableObjectAtIndex(args, 1);
        [api signInWithCustomTokenApp:arg_app
                                token:arg_token
                           completion:^(PigeonUserCredential *_Nullable output,
                                        FlutterError *_Nullable error) {
                             callback(wrapResult(output, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithEmailAndPassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (signInWithEmailAndPasswordApp:email:password:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithEmailAndPasswordApp:email:password:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_password = GetNullableObjectAtIndex(args, 2);
        [api signInWithEmailAndPasswordApp:arg_app
                                     email:arg_email
                                  password:arg_password
                                completion:^(PigeonUserCredential *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithEmailLink",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithEmailLinkApp:
                                                                   email:emailLink:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithEmailLinkApp:email:emailLink:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_emailLink = GetNullableObjectAtIndex(args, 2);
        [api signInWithEmailLinkApp:arg_app
                              email:arg_email
                          emailLink:arg_emailLink
                         completion:^(PigeonUserCredential *_Nullable output,
                                      FlutterError *_Nullable error) {
                           callback(wrapResult(output, error));
                         }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithProviderApp:
                                                         signInProvider:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api signInWithProviderApp:arg_app
                    signInProvider:arg_signInProvider
                        completion:^(PigeonUserCredential *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.signOut",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(signOutApp:completion:)],
          @"FirebaseAuthHostApi api (%@) doesn't respond to @selector(signOutApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api signOutApp:arg_app
             completion:^(FlutterError *_Nullable error) {
               callback(wrapResult(nil, error));
             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.fetchSignInMethodsForEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(fetchSignInMethodsForEmailApp:email:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(fetchSignInMethodsForEmailApp:email:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        [api fetchSignInMethodsForEmailApp:arg_app
                                     email:arg_email
                                completion:^(NSArray<NSString *> *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.sendPasswordResetEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (sendPasswordResetEmailApp:email:actionCodeSettings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(sendPasswordResetEmailApp:email:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api sendPasswordResetEmailApp:arg_app
                                 email:arg_email
                    actionCodeSettings:arg_actionCodeSettings
                            completion:^(FlutterError *_Nullable error) {
                              callback(wrapResult(nil, error));
                            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.sendSignInLinkToEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (sendSignInLinkToEmailApp:email:actionCodeSettings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(sendSignInLinkToEmailApp:email:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api sendSignInLinkToEmailApp:arg_app
                                email:arg_email
                   actionCodeSettings:arg_actionCodeSettings
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.setLanguageCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLanguageCodeApp:languageCode:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(setLanguageCodeApp:languageCode:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_languageCode = GetNullableObjectAtIndex(args, 1);
        [api setLanguageCodeApp:arg_app
                   languageCode:arg_languageCode
                     completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                       callback(wrapResult(output, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.setSettings",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSettingsApp:settings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(setSettingsApp:settings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonFirebaseAuthSettings *arg_settings = GetNullableObjectAtIndex(args, 1);
        [api setSettingsApp:arg_app
                   settings:arg_settings
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.verifyPasswordResetCode",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(verifyPasswordResetCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(verifyPasswordResetCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api verifyPasswordResetCodeApp:arg_app
                                   code:arg_code
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.verifyPhoneNumber",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(verifyPhoneNumberApp:request:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(verifyPhoneNumberApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonVerifyPhoneNumberRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api verifyPhoneNumberApp:arg_app
                          request:arg_request
                       completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                          @"FirebaseAuthHostApi.revokeTokenWithAuthorizationCode",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(revokeTokenWithAuthorizationCodeApp:
                                                                    authorizationCode:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(revokeTokenWithAuthorizationCodeApp:authorizationCode:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_authorizationCode = GetNullableObjectAtIndex(args, 1);
        [api revokeTokenWithAuthorizationCodeApp:arg_app
                               authorizationCode:arg_authorizationCode
                                      completion:^(FlutterError *_Nullable error) {
                                        callback(wrapResult(nil, error));
                                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.initializeRecaptchaConfig",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeRecaptchaConfigApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(initializeRecaptchaConfigApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api initializeRecaptchaConfigApp:arg_app
                               completion:^(FlutterError *_Nullable error) {
                                 callback(wrapResult(nil, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FirebaseAuthUserHostApiCodecReader : FlutterStandardReader
@end
@implementation FirebaseAuthUserHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonActionCodeInfo fromList:[self readValue]];
    case 130:
      return [PigeonActionCodeInfoData fromList:[self readValue]];
    case 131:
      return [PigeonActionCodeSettings fromList:[self readValue]];
    case 132:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 133:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 134:
      return [PigeonFirebaseAuthSettings fromList:[self readValue]];
    case 135:
      return [PigeonIdTokenResult fromList:[self readValue]];
    case 136:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 137:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 138:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 139:
      return [PigeonSignInProvider fromList:[self readValue]];
    case 140:
      return [PigeonTotpSecret fromList:[self readValue]];
    case 141:
      return [PigeonUserCredential fromList:[self readValue]];
    case 142:
      return [PigeonUserDetails fromList:[self readValue]];
    case 143:
      return [PigeonUserInfo fromList:[self readValue]];
    case 144:
      return [PigeonUserProfile fromList:[self readValue]];
    case 145:
      return [PigeonVerifyPhoneNumberRequest fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseAuthUserHostApiCodecWriter : FlutterStandardWriter
@end
@implementation FirebaseAuthUserHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfoData class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeSettings class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseAuthSettings class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonIdTokenResult class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSignInProvider class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserProfile class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonVerifyPhoneNumberRequest class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseAuthUserHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseAuthUserHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseAuthUserHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseAuthUserHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseAuthUserHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseAuthUserHostApiCodecReaderWriter *readerWriter =
        [[FirebaseAuthUserHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFirebaseAuthUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                  NSObject<FirebaseAuthUserHostApi> *api) {
  SetUpFirebaseAuthUserHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAuthUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                            NSObject<FirebaseAuthUserHostApi> *api,
                                            NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.delete",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(deleteApp:completion:)],
          @"FirebaseAuthUserHostApi api (%@) doesn't respond to @selector(deleteApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api deleteApp:arg_app
            completion:^(FlutterError *_Nullable error) {
              callback(wrapResult(nil, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.getIdToken",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getIdTokenApp:forceRefresh:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(getIdTokenApp:forceRefresh:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        BOOL arg_forceRefresh = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api getIdTokenApp:arg_app
              forceRefresh:arg_forceRefresh
                completion:^(PigeonIdTokenResult *_Nullable output, FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.linkWithCredential",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(linkWithCredentialApp:input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(linkWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api linkWithCredentialApp:arg_app
                             input:arg_input
                        completion:^(PigeonUserCredential *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.linkWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(linkWithProviderApp:signInProvider:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(linkWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api linkWithProviderApp:arg_app
                  signInProvider:arg_signInProvider
                      completion:^(PigeonUserCredential *_Nullable output,
                                   FlutterError *_Nullable error) {
                        callback(wrapResult(output, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                          @"FirebaseAuthUserHostApi.reauthenticateWithCredential",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reauthenticateWithCredentialApp:
                                                                            input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(reauthenticateWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api reauthenticateWithCredentialApp:arg_app
                                       input:arg_input
                                  completion:^(PigeonUserCredential *_Nullable output,
                                               FlutterError *_Nullable error) {
                                    callback(wrapResult(output, error));
                                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.reauthenticateWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reauthenticateWithProviderApp:
                                                                 signInProvider:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(reauthenticateWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api reauthenticateWithProviderApp:arg_app
                            signInProvider:arg_signInProvider
                                completion:^(PigeonUserCredential *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.reload",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(reloadApp:completion:)],
          @"FirebaseAuthUserHostApi api (%@) doesn't respond to @selector(reloadApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api reloadApp:arg_app
            completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
              callback(wrapResult(output, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.sendEmailVerification",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendEmailVerificationApp:
                                                        actionCodeSettings:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(sendEmailVerificationApp:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 1);
        [api sendEmailVerificationApp:arg_app
                   actionCodeSettings:arg_actionCodeSettings
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.unlink",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unlinkApp:providerId:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(unlinkApp:providerId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_providerId = GetNullableObjectAtIndex(args, 1);
        [api unlinkApp:arg_app
            providerId:arg_providerId
            completion:^(PigeonUserCredential *_Nullable output, FlutterError *_Nullable error) {
              callback(wrapResult(output, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.updateEmail",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateEmailApp:newEmail:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updateEmailApp:newEmail:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newEmail = GetNullableObjectAtIndex(args, 1);
        [api updateEmailApp:arg_app
                   newEmail:arg_newEmail
                 completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
                   callback(wrapResult(output, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updatePassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePasswordApp:newPassword:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updatePasswordApp:newPassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newPassword = GetNullableObjectAtIndex(args, 1);
        [api updatePasswordApp:arg_app
                   newPassword:arg_newPassword
                    completion:^(PigeonUserDetails *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updatePhoneNumber",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePhoneNumberApp:input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updatePhoneNumberApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api updatePhoneNumberApp:arg_app
                            input:arg_input
                       completion:^(PigeonUserDetails *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updateProfile",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateProfileApp:profile:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updateProfileApp:profile:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonUserProfile *arg_profile = GetNullableObjectAtIndex(args, 1);
        [api
            updateProfileApp:arg_app
                     profile:arg_profile
                  completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
                    callback(wrapResult(output, error));
                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.verifyBeforeUpdateEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (verifyBeforeUpdateEmailApp:newEmail:actionCodeSettings:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(verifyBeforeUpdateEmailApp:newEmail:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newEmail = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api verifyBeforeUpdateEmailApp:arg_app
                               newEmail:arg_newEmail
                     actionCodeSettings:arg_actionCodeSettings
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactorUserHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactorUserHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 130:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 131:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactorUserHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactorUserHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactorUserHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactorUserHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactorUserHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactorUserHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactorUserHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactorUserHostApiCodecReaderWriter *readerWriter =
        [[MultiFactorUserHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactorUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<MultiFactorUserHostApi> *api) {
  SetUpMultiFactorUserHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactorUserHostApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.enrollPhone",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enrollPhoneApp:
                                                       assertion:displayName:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(enrollPhoneApp:assertion:displayName:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonPhoneMultiFactorAssertion *arg_assertion = GetNullableObjectAtIndex(args, 1);
        NSString *arg_displayName = GetNullableObjectAtIndex(args, 2);
        [api enrollPhoneApp:arg_app
                  assertion:arg_assertion
                displayName:arg_displayName
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.enrollTotp",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enrollTotpApp:
                                                    assertionId:displayName:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(enrollTotpApp:assertionId:displayName:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_assertionId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_displayName = GetNullableObjectAtIndex(args, 2);
        [api enrollTotpApp:arg_app
               assertionId:arg_assertionId
               displayName:arg_displayName
                completion:^(FlutterError *_Nullable error) {
                  callback(wrapResult(nil, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.getSession",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSessionApp:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(getSessionApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api getSessionApp:arg_app
                completion:^(PigeonMultiFactorSession *_Nullable output,
                             FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.unenroll",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unenrollApp:factorUid:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(unenrollApp:factorUid:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_factorUid = GetNullableObjectAtIndex(args, 1);
        [api unenrollApp:arg_app
               factorUid:arg_factorUid
              completion:^(FlutterError *_Nullable error) {
                callback(wrapResult(nil, error));
              }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorUserHostApi.getEnrolledFactors",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getEnrolledFactorsApp:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(getEnrolledFactorsApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api getEnrolledFactorsApp:arg_app
                        completion:^(NSArray<PigeonMultiFactorInfo *> *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactoResolverHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactoResolverHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 129:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 130:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 131:
      return [PigeonUserCredential fromList:[self readValue]];
    case 132:
      return [PigeonUserDetails fromList:[self readValue]];
    case 133:
      return [PigeonUserInfo fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactoResolverHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactoResolverHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactoResolverHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactoResolverHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactoResolverHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactoResolverHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactoResolverHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactoResolverHostApiCodecReaderWriter *readerWriter =
        [[MultiFactoResolverHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactoResolverHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<MultiFactoResolverHostApi> *api) {
  SetUpMultiFactoResolverHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactoResolverHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<MultiFactoResolverHostApi> *api,
                                              NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactoResolverHostApi.resolveSignIn",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactoResolverHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (resolveSignInResolverId:assertion:totpAssertionId:completion:)],
                @"MultiFactoResolverHostApi api (%@) doesn't respond to "
                @"@selector(resolveSignInResolverId:assertion:totpAssertionId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_resolverId = GetNullableObjectAtIndex(args, 0);
        PigeonPhoneMultiFactorAssertion *arg_assertion = GetNullableObjectAtIndex(args, 1);
        NSString *arg_totpAssertionId = GetNullableObjectAtIndex(args, 2);
        [api resolveSignInResolverId:arg_resolverId
                           assertion:arg_assertion
                     totpAssertionId:arg_totpAssertionId
                          completion:^(PigeonUserCredential *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactorTotpHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactorTotpHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonTotpSecret fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactorTotpHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactorTotpHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactorTotpHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactorTotpHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactorTotpHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactorTotpHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactorTotpHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactorTotpHostApiCodecReaderWriter *readerWriter =
        [[MultiFactorTotpHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactorTotpHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<MultiFactorTotpHostApi> *api) {
  SetUpMultiFactorTotpHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorTotpHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactorTotpHostApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.generateSecret",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(generateSecretSessionId:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(generateSecretSessionId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sessionId = GetNullableObjectAtIndex(args, 0);
        [api generateSecretSessionId:arg_sessionId
                          completion:^(PigeonTotpSecret *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.getAssertionForEnrollment",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAssertionForEnrollmentSecretKey:
                                                                     oneTimePassword:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(getAssertionForEnrollmentSecretKey:oneTimePassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_oneTimePassword = GetNullableObjectAtIndex(args, 1);
        [api getAssertionForEnrollmentSecretKey:arg_secretKey
                                oneTimePassword:arg_oneTimePassword
                                     completion:^(NSString *_Nullable output,
                                                  FlutterError *_Nullable error) {
                                       callback(wrapResult(output, error));
                                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.getAssertionForSignIn",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAssertionForSignInEnrollmentId:
                                                                    oneTimePassword:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(getAssertionForSignInEnrollmentId:oneTimePassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_enrollmentId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_oneTimePassword = GetNullableObjectAtIndex(args, 1);
        [api getAssertionForSignInEnrollmentId:arg_enrollmentId
                               oneTimePassword:arg_oneTimePassword
                                    completion:^(NSString *_Nullable output,
                                                 FlutterError *_Nullable error) {
                                      callback(wrapResult(output, error));
                                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *MultiFactorTotpSecretHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpMultiFactorTotpSecretHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<MultiFactorTotpSecretHostApi> *api) {
  SetUpMultiFactorTotpSecretHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorTotpSecretHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                 NSObject<MultiFactorTotpSecretHostApi> *api,
                                                 NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpSecretHostApi.generateQrCodeUrl",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpSecretHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(generateQrCodeUrlSecretKey:
                                                                 accountName:issuer:completion:)],
                @"MultiFactorTotpSecretHostApi api (%@) doesn't respond to "
                @"@selector(generateQrCodeUrlSecretKey:accountName:issuer:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_accountName = GetNullableObjectAtIndex(args, 1);
        NSString *arg_issuer = GetNullableObjectAtIndex(args, 2);
        [api generateQrCodeUrlSecretKey:arg_secretKey
                            accountName:arg_accountName
                                 issuer:arg_issuer
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpSecretHostApi.openInOtpApp",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpSecretHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openInOtpAppSecretKey:qrCodeUrl:completion:)],
                @"MultiFactorTotpSecretHostApi api (%@) doesn't respond to "
                @"@selector(openInOtpAppSecretKey:qrCodeUrl:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_qrCodeUrl = GetNullableObjectAtIndex(args, 1);
        [api openInOtpAppSecretKey:arg_secretKey
                         qrCodeUrl:arg_qrCodeUrl
                        completion:^(FlutterError *_Nullable error) {
                          callback(wrapResult(nil, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface GenerateInterfacesCodecReader : FlutterStandardReader
@end
@implementation GenerateInterfacesCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface GenerateInterfacesCodecWriter : FlutterStandardWriter
@end
@implementation GenerateInterfacesCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface GenerateInterfacesCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation GenerateInterfacesCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[GenerateInterfacesCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[GenerateInterfacesCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *GenerateInterfacesGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    GenerateInterfacesCodecReaderWriter *readerWriter =
        [[GenerateInterfacesCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpGenerateInterfaces(id<FlutterBinaryMessenger> binaryMessenger,
                             NSObject<GenerateInterfaces> *api) {
  SetUpGenerateInterfacesWithSuffix(binaryMessenger, api, @"");
}

void SetUpGenerateInterfacesWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<GenerateInterfaces> *api,
                                       NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.GenerateInterfaces.pigeonInterface",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:GenerateInterfacesGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(pigeonInterfaceInfo:error:)],
          @"GenerateInterfaces api (%@) doesn't respond to @selector(pigeonInterfaceInfo:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PigeonMultiFactorInfo *arg_info = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api pigeonInterfaceInfo:arg_info error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/firebase_auth/Package.swift

**크기**: 4227 bytes | **라인 수**: 117 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let authDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    authDirectory,
    "..",
    "generated_firebase_sdk_version.txt",
  ])
  do {
    let version = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
      .trimmingCharacters(in: .whitespacesAndNewlines)
    return version
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing generated_firebase_sdk_version.txt: \(error)")
  }
}

func loadPubspecVersions() throws -> (packageVersion: String, firebaseCoreVersion: String) {
  let pubspecPath = NSString.path(withComponents: [authDirectory, "..", "..", "pubspec.yaml"])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    let lines = yamlString.split(separator: "\n")

    guard let packageVersionLine = lines.first(where: { $0.starts(with: "version:") }) else {
      throw ConfigurationError.invalidFormat("No package version line found in pubspec.yaml")
    }
    var packageVersion = packageVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
      .replacingOccurrences(of: "+", with: "-")
    packageVersion = packageVersion.replacingOccurrences(of: "^", with: "")

    guard let firebaseCoreVersionLine = lines.first(where: { $0.contains("firebase_core:") }) else {
      throw ConfigurationError
        .invalidFormat("No firebase_core dependency version line found in pubspec.yaml")
    }
    var firebaseCoreVersion = firebaseCoreVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
    firebaseCoreVersion = firebaseCoreVersion.replacingOccurrences(of: "^", with: "")

    return (packageVersion, firebaseCoreVersion)
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

let library_version: String
let firebase_sdk_version_string: String
let firebase_core_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version = try loadPubspecVersions().packageVersion
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
  firebase_core_version_string = try loadPubspecVersions().firebaseCoreVersion
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

guard let shared_spm_version = Version("\(firebase_core_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(firebase_core_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "firebase_auth",
  platforms: [
    .iOS("15.0"),
  ],
  products: [
    .library(name: "firebase-auth", targets: ["firebase_auth"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "firebase_auth",
      dependencies: [
        .product(name: "FirebaseAuth", package: "firebase-ios-sdk"),
        // Wrapper dependency
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/firebase_auth/Private"),
        .headerSearchPath("include/firebase_auth/Public"),
        .define("LIBRARY_VERSION", to: "\"\(library_version)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-auth\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/ios/generated_firebase_sdk_version.txt

**크기**: 6 bytes | **라인 수**: 1 | **타입**: text

```
12.2.0
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/confirmation_result.dart

**크기**: 1125 bytes | **라인 수**: 37 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A result from a phone number sign-in, link, or reauthenticate call.
///
/// This class is only usable on web based platforms.
class ConfirmationResult {
  ConfirmationResultPlatform _delegate;

  final FirebaseAuth _auth;

  ConfirmationResult._(this._auth, this._delegate) {
    ConfirmationResultPlatform.verify(_delegate);
  }

  /// The phone number authentication operation's verification ID.
  ///
  /// This can be used along with the verification code to initialize a phone
  /// auth credential.
  String get verificationId {
    return _delegate.verificationId;
  }

  /// Finishes a phone number sign-in, link, or reauthentication, given the code
  /// that was sent to the user's mobile device.
  Future<UserCredential> confirm(String verificationCode) async {
    return UserCredential._(
      _auth,
      await _delegate.confirm(verificationCode),
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/firebase_auth.dart

**크기**: 38194 bytes | **라인 수**: 862 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// The entry point of the Firebase Authentication SDK.
class FirebaseAuth extends FirebasePluginPlatform {
  // Cached instances of [FirebaseAuth].
  static Map<String, FirebaseAuth> _firebaseAuthInstances = {};

  // Cached and lazily loaded instance of [FirebaseAuthPlatform] to avoid
  // creating a [MethodChannelFirebaseAuth] when not needed or creating an
  // instance with the default app before a user specifies an app.
  FirebaseAuthPlatform? _delegatePackingProperty;

  /// Returns the underlying delegate implementation.
  ///
  /// If called and no [_delegatePackingProperty] exists, it will first be
  /// created and assigned before returning the delegate.
  FirebaseAuthPlatform get _delegate {
    _delegatePackingProperty ??= FirebaseAuthPlatform.instanceFor(
      app: app,
      pluginConstants: pluginConstants,
    );
    return _delegatePackingProperty!;
  }

  /// The [FirebaseApp] for this current Auth instance.
  FirebaseApp app;

  FirebaseAuth._({required this.app})
      : super(app.name, 'plugins.flutter.io/firebase_auth');

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseAuth get instance {
    FirebaseApp defaultAppInstance = Firebase.app();

    return FirebaseAuth.instanceFor(app: defaultAppInstance);
  }

  /// Returns an instance using a specified [FirebaseApp].
  factory FirebaseAuth.instanceFor({
    required FirebaseApp app,
  }) {
    return _firebaseAuthInstances.putIfAbsent(app.name, () {
      return FirebaseAuth._(app: app);
    });
  }

  /// Returns the current [User] if they are currently signed-in, or `null` if
  /// not.
  ///
  /// This getter only provides a snapshot of user state. Applications that need
  /// to react to changes in user state should instead use [authStateChanges],
  /// [idTokenChanges] or [userChanges] to subscribe to updates.
  User? get currentUser {
    if (_delegate.currentUser != null) {
      return User._(this, _delegate.currentUser!);
    }

    return null;
  }

  /// The current Auth instance's language code.
  ///
  /// See [setLanguageCode] to update the language code.
  String? get languageCode {
    return _delegate.languageCode;
  }

  /// Changes this instance to point to an Auth emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "9099" (port 9099 is default for auth package)
  ///
  /// Note: Must be called immediately, prior to accessing auth methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  Future<void> useAuthEmulator(String host, int port,
      {bool automaticHostMapping = true}) async {
    String mappedHost = automaticHostMapping ? getMappedHost(host) : host;

    await _delegate.useAuthEmulator(mappedHost, port);
  }

  /// The current Auth instance's tenant ID.
  String? get tenantId {
    return _delegate.tenantId;
  }

  /// Set the current Auth instance's tenant ID.
  ///
  /// When you set the tenant ID of an Auth instance, all future sign-in/sign-up
  /// operations will pass this tenant ID and sign in or sign up users to the
  /// specified tenant project. When set to null, users are signed in to the
  /// parent project. By default, this is set to `null`.
  set tenantId(String? tenantId) {
    _delegate.tenantId = tenantId;
  }

  /// The current Auth instance's custom auth domain.
  /// The auth domain used to handle redirects from OAuth provides, for example
  /// "my-awesome-app.firebaseapp.com". By default, this is set to `null` and
  /// default auth domain is used.
  ///
  /// If not `null`, this value will supersede `authDomain` property set in `initializeApp`.
  String? get customAuthDomain {
    return _delegate.customAuthDomain;
  }

  /// Set the current Auth instance's auth domain for apple and android platforms.
  /// The auth domain used to handle redirects from OAuth provides, for example
  /// "my-awesome-app.firebaseapp.com". By default, this is set to `null` and
  /// default auth domain is used.
  ///
  /// If not `null`, this value will supersede `authDomain` property set in `initializeApp`.
  set customAuthDomain(String? customAuthDomain) {
    // Web and windows do not support setting custom auth domains on the auth instance
    if (defaultTargetPlatform == TargetPlatform.windows || kIsWeb) {
      final message = defaultTargetPlatform == TargetPlatform.windows
          ? 'Cannot set custom auth domain on a FirebaseAuth instance for windows platform'
          : 'Cannot set custom auth domain on a FirebaseAuth instance. Set the custom auth domain on `FirebaseOptions.authDomain` instance and pass into `Firebase.initializeApp()` instead.';
      throw UnimplementedError(
        message,
      );
    }
    _delegate.customAuthDomain = customAuthDomain;
  }

  /// Applies a verification code sent to the user by email or other out-of-band
  /// mechanism.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  Future<void> applyActionCode(String code) async {
    await _delegate.applyActionCode(code);
  }

  /// Checks a verification code sent to the user by email or other out-of-band
  /// mechanism.
  ///
  /// Returns [ActionCodeInfo] about the code.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  Future<ActionCodeInfo> checkActionCode(String code) {
    return _delegate.checkActionCode(code);
  }

  /// Completes the password reset process, given a confirmation code and new
  /// password.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  /// - **weak-password**:
  ///  - Thrown if the new password is not strong enough.
  Future<void> confirmPasswordReset({
    required String code,
    required String newPassword,
  }) async {
    await _delegate.confirmPasswordReset(code, newPassword);
  }

  /// Tries to create a new user account with the given email address and
  /// password.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **email-already-in-use**:
  ///  - Thrown if there already exists an account with the given email address.
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  /// - **weak-password**:
  ///  - Thrown if the password is not strong enough.
  /// - **too-many-requests**:
  ///  - Thrown if the user sent too many requests at the same time, for security
  ///     the api will not allow too many attempts at the same time, user will have
  ///     to wait for some time
  /// - **user-token-expired**:
  ///  - Thrown if the user is no longer authenticated since his refresh token
  ///    has been expired
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<UserCredential> createUserWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    return UserCredential._(
      this,
      await _delegate.createUserWithEmailAndPassword(email, password),
    );
  }

  /// Returns a UserCredential from the redirect-based sign-in flow.
  ///
  /// If sign-in succeeded, returns the signed in user. If sign-in was
  /// unsuccessful, fails with an error. If no redirect operation was called,
  /// returns a [UserCredential] with a null User.
  ///
  /// This method is only support on web platforms.
  Future<UserCredential> getRedirectResult() async {
    return UserCredential._(this, await _delegate.getRedirectResult());
  }

  /// Checks if an incoming link is a sign-in with email link.
  bool isSignInWithEmailLink(String emailLink) {
    return _delegate.isSignInWithEmailLink(emailLink);
  }

  /// Internal helper which pipes internal [Stream] events onto
  /// a users own Stream.
  Stream<User?> _pipeStreamChanges(Stream<UserPlatform?> stream) {
    return stream.map((delegateUser) {
      if (delegateUser == null) {
        return null;
      }

      return User._(this, delegateUser);
    }).asBroadcastStream(onCancel: (sub) => sub.cancel());
  }

  /// Notifies about changes to the user's sign-in state (such as sign-in or
  /// sign-out).
  Stream<User?> authStateChanges() =>
      _pipeStreamChanges(_delegate.authStateChanges());

  /// Notifies about changes to the user's sign-in state (such as sign-in or
  /// sign-out) and also token refresh events.
  Stream<User?> idTokenChanges() =>
      _pipeStreamChanges(_delegate.idTokenChanges());

  /// Notifies about changes to any user updates.
  ///
  /// This is a superset of both [authStateChanges] and [idTokenChanges]. It
  /// provides events on all user changes, such as when credentials are linked,
  /// unlinked and when updates to the user profile are made. The purpose of
  /// this Stream is for listening to realtime updates to the user state
  /// (signed-in, signed-out, different user & token refresh) without
  /// manually having to call [reload] and then rehydrating changes to your
  /// application.
  Stream<User?> userChanges() => _pipeStreamChanges(_delegate.userChanges());

  /// Sends a password reset email to the given email address.
  ///
  /// To complete the password reset, call [confirmPasswordReset] with the code supplied
  /// in the email sent to the user, along with the new password specified by the user.
  ///
  /// May throw a [FirebaseAuthException] with the following error codes:
  ///
  /// - **auth/invalid-email**\
  ///   Thrown if the email address is not valid.
  /// - **auth/missing-android-pkg-name**\
  ///   An Android package name must be provided if the Android app is required to be installed.
  /// - **auth/missing-continue-uri**\
  ///   A continue URL must be provided in the request.
  /// - **auth/missing-ios-bundle-id**\
  ///   An iOS Bundle ID must be provided if an App Store ID is provided.
  /// - **auth/invalid-continue-uri**\
  ///   The continue URL provided in the request is invalid.
  /// - **auth/unauthorized-continue-uri**\
  ///   The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console.
  /// - **auth/user-not-found**\
  ///   Thrown if there is no user corresponding to the email address. Note: This exception is no longer thrown when enabling email enumeration protection.
  Future<void> sendPasswordResetEmail({
    required String email,
    ActionCodeSettings? actionCodeSettings,
  }) {
    return _delegate.sendPasswordResetEmail(email, actionCodeSettings);
  }

  /// Sends a sign in with email link to provided email address.
  ///
  /// To complete the password reset, call [confirmPasswordReset] with the code
  /// supplied in the email sent to the user, along with the new password
  /// specified by the user.
  ///
  /// The [handleCodeInApp] of [actionCodeSettings] must be set to `true`
  /// otherwise an [ArgumentError] will be thrown.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  Future<void> sendSignInLinkToEmail({
    required String email,
    required ActionCodeSettings actionCodeSettings,
  }) async {
    if (actionCodeSettings.handleCodeInApp != true) {
      throw ArgumentError(
        'The [handleCodeInApp] value of [ActionCodeSettings] must be `true`.',
      );
    }

    await _delegate.sendSignInLinkToEmail(email, actionCodeSettings);
  }

  /// When set to null, sets the user-facing language code to be the default app language.
  ///
  /// The language code will propagate to email action templates (password
  /// reset, email verification and email change revocation), SMS templates for
  /// phone authentication, reCAPTCHA verifier and OAuth popup/redirect
  /// operations provided the specified providers support localization with the
  /// language code specified.
  Future<void> setLanguageCode(String? languageCode) {
    return _delegate.setLanguageCode(languageCode);
  }

  /// Updates the current instance with the provided settings.
  ///
  /// [appVerificationDisabledForTesting] This setting applies to Android, iOS and
  ///   web platforms. When set to `true`, this property disables app
  ///   verification for the purpose of testing phone authentication. For this
  ///   property to take effect, it needs to be set before handling a reCAPTCHA
  ///   app verifier. When this is disabled, a mock reCAPTCHA is rendered
  ///   instead. This is useful for manual testing during development or for
  ///   automated integration tests.
  ///
  ///   In order to use this feature, you will need to
  ///   [whitelist your phone number](https://firebase.google.com/docs/auth/web/phone-auth?authuser=0#test-with-whitelisted-phone-numbers)
  ///   via the Firebase Console.
  ///
  ///   The default value is `false` (app verification is enabled).
  ///
  /// [forceRecaptchaFlow] This setting applies to Android only. When set to 'true',
  ///   it forces the application verification to use the web reCAPTCHA flow for Phone Authentication.
  ///   Once this has been called, every call to PhoneAuthProvider#verifyPhoneNumber() will skip the SafetyNet verification flow and use the reCAPTCHA flow instead.
  ///   Calling this method a second time will overwrite the previously passed parameter.
  ///
  /// [phoneNumber] & [smsCode] These settings apply to Android only. The phone number and SMS code here must have been configured in the Firebase Console (Authentication > Sign In Method > Phone).
  ///   Once this has been called, every call to PhoneAuthProvider#verifyPhoneNumber() with the same phone number as the one that is configured here will have onVerificationCompleted() triggered as the callback.
  ///   Calling this method a second time will overwrite the previously passed parameters. Only one number can be configured at a given time.
  ///   Calling this method with either parameter set to null removes this functionality until valid parameters are passed.
  ///   Verifying a phone number other than the one configured here will trigger normal behavior. If the phone number is configured as a test phone number in the console, the regular testing flow occurs. Otherwise, normal phone number verification will take place.
  ///   When this is set and PhoneAuthProvider#verifyPhoneNumber() is called with a matching phone number, PhoneAuthProvider.OnVerificationStateChangedCallbacks.onCodeAutoRetrievalTimeOut(String) will never be called.
  ///
  /// [userAccessGroup] This setting only applies to iOS and MacOS platforms.
  ///   When set, it allows you to share authentication state between
  ///   applications. Set the property to your team group ID or set to `null`
  ///   to remove sharing capabilities.
  ///
  ///   Key Sharing capabilities must be enabled for your app via XCode (Project
  ///   settings > Capabilities). To learn more, visit the
  ///   [Apple documentation](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps).
  Future<void> setSettings({
    bool appVerificationDisabledForTesting = false,
    String? userAccessGroup,
    String? phoneNumber,
    String? smsCode,
    bool? forceRecaptchaFlow,
  }) {
    return _delegate.setSettings(
      appVerificationDisabledForTesting: appVerificationDisabledForTesting,
      userAccessGroup: userAccessGroup,
      phoneNumber: phoneNumber,
      smsCode: smsCode,
      forceRecaptchaFlow: forceRecaptchaFlow,
    );
  }

  /// Changes the current type of persistence on the current Auth instance for
  /// the currently saved Auth session and applies this type of persistence for
  /// future sign-in requests, including sign-in with redirect requests.
  ///
  /// This will return a promise that will resolve once the state finishes
  /// copying from one type of storage to the other. Calling a sign-in method
  /// after changing persistence will wait for that persistence change to
  /// complete before applying it on the new Auth state.
  ///
  /// This makes it easy for a user signing in to specify whether their session
  /// should be remembered or not. It also makes it easier to never persist the
  /// Auth state for applications that are shared by other users or have
  /// sensitive data.
  ///
  /// This is only supported on web based platforms.
  Future<void> setPersistence(Persistence persistence) async {
    return _delegate.setPersistence(persistence);
  }

  /// Asynchronously creates and becomes an anonymous user.
  ///
  /// If there is already an anonymous user signed in, that user will be
  /// returned instead. If there is any other existing user signed in, that
  /// user will be signed out.
  ///
  /// **Important**: You must enable Anonymous accounts in the Auth section
  /// of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **operation-not-allowed**:
  ///  - Thrown if anonymous accounts are not enabled. Enable anonymous accounts
  /// in the Firebase Console, under the Auth tab.
  Future<UserCredential> signInAnonymously() async {
    return UserCredential._(this, await _delegate.signInAnonymously());
  }

  /// Asynchronously signs in to Firebase with the given 3rd-party credentials
  /// (e.g. a Facebook login Access Token, a Google ID Token/Access Token pair,
  /// etc.) and returns additional identity provider data.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// If the user doesn't have an account already, one will be created
  /// automatically.
  ///
  /// **Important**: You must enable the relevant accounts in the Auth section
  /// of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **account-exists-with-different-credential**:
  ///  - Thrown if there already exists an account with the email address
  ///    asserted by the credential.
  // ignore: deprecated_member_use_from_same_package
  ///    Resolve this by asking
  ///    the user to sign in using one of the returned providers.
  ///    Once the user is signed in, the original credential can be linked to
  ///    the user with [linkWithCredential].
  /// - **invalid-credential**:
  ///  - Thrown if the credential is malformed or has expired.
  /// - **operation-not-allowed**:
  ///  - Thrown if the type of account corresponding to the credential is not
  ///    enabled. Enable the account type in the Firebase Console, under the
  ///    Auth tab.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given credential has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if signing in with a credential from [EmailAuthProvider.credential]
  ///    and there is no user corresponding to the given email.
  /// - **wrong-password**:
  ///  - Thrown if signing in with a credential from [EmailAuthProvider.credential]
  ///    and the password is invalid for the given email, or if the account
  ///    corresponding to the email does not have a password set.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> signInWithCredential(AuthCredential credential) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Tries to sign in a user with a given custom token.
  ///
  /// Custom tokens are used to integrate Firebase Auth with existing auth
  /// systems, and must be generated by the auth backend.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// If the user identified by the [uid] specified in the token doesn't
  /// have an account already, one will be created automatically.
  ///
  /// Read how to use Custom Token authentication and the cases where it is
  /// useful in [the guides](https://firebase.google.com/docs/auth/android/custom-auth).
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **custom-token-mismatch**:
  ///  - Thrown if the custom token is for a different Firebase App.
  /// - **invalid-custom-token**:
  ///  - Thrown if the custom token format is incorrect.
  Future<UserCredential> signInWithCustomToken(String token) async {
    try {
      return UserCredential._(
          this, await _delegate.signInWithCustomToken(token));
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Attempts to sign in a user with the given email address and password.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// **Important**: You must enable Email & Password accounts in the Auth
  /// section of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the given email.
  /// - **wrong-password**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  /// - **too-many-requests**:
  ///  - Thrown if the user sent too many requests at the same time, for security
  ///     the api will not allow too many attempts at the same time, user will have
  ///     to wait for some time
  /// - **user-token-expired**:
  ///  - Thrown if the user is no longer authenticated since his refresh token
  ///    has been expired
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **INVALID_LOGIN_CREDENTIALS** or **invalid-credential**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  ///    Depending on if you are using firebase emulator or not the code is
  ///    different
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<UserCredential> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithEmailAndPassword(email, password),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Signs in using an email address and email sign-in link.
  ///
  /// Fails with an error if the email address is invalid or OTP in email link
  /// expires.
  ///
  /// Confirm the link is a sign-in email link before calling this method,
  /// using [isSignInWithEmailLink].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if OTP in email link expires.
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  Future<UserCredential> signInWithEmailLink({
    required String email,
    required String emailLink,
  }) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithEmailLink(email, emailLink),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Signs in with an AuthProvider using native authentication flow.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  Future<UserCredential> signInWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Starts a sign-in flow for a phone number.
  ///
  /// You can optionally provide a [RecaptchaVerifier] instance to control the
  /// reCAPTCHA widget appearance and behavior.
  ///
  /// Once the reCAPTCHA verification has completed, called [ConfirmationResult.confirm]
  /// with the users SMS verification code to complete the authentication flow.
  ///
  /// This method is only available on web based platforms.
  Future<ConfirmationResult> signInWithPhoneNumber(
    String phoneNumber, [
    RecaptchaVerifier? verifier,
  ]) async {
    assert(phoneNumber.isNotEmpty);
    // If we add a recaptcha to the page by creating a new instance, we must
    // also clear that instance before proceeding.
    bool mustClear = verifier == null;
    verifier ??= RecaptchaVerifier(auth: _delegate);
    final result =
        await _delegate.signInWithPhoneNumber(phoneNumber, verifier.delegate);
    if (mustClear) {
      verifier.clear();
    }
    return ConfirmationResult._(this, result);
  }

  /// Authenticates a Firebase client using a popup-based OAuth authentication
  /// flow.
  ///
  /// If succeeds, returns the signed in user along with the provider's
  /// credential.
  ///
  /// This method is only available on web based platforms.
  Future<UserCredential> signInWithPopup(AuthProvider provider) async {
    try {
      return UserCredential._(this, await _delegate.signInWithPopup(provider));
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Authenticates a Firebase client using a full-page redirect flow.
  ///
  /// To handle the results and errors for this operation, refer to
  /// [getRedirectResult].
  Future<void> signInWithRedirect(AuthProvider provider) {
    try {
      return _delegate.signInWithRedirect(provider);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Checks a password reset code sent to the user by email or other
  /// out-of-band mechanism.
  ///
  /// Returns the user's email address if valid.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the password reset code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the password reset code is invalid. This can happen if the
  ///    code is malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the password reset code.
  ///    This may have happened if the user was deleted between when the code
  ///    was issued and when this method was called.
  Future<String> verifyPasswordResetCode(String code) {
    return _delegate.verifyPasswordResetCode(code);
  }

  /// Starts a phone number verification process for the given phone number.
  ///
  /// This method is used to verify that the user-provided phone number belongs
  /// to the user. Firebase sends a code via SMS message to the phone number,
  /// where you must then prompt the user to enter the code. The code can be
  /// combined with the verification ID to create a [PhoneAuthProvider.credential]
  /// which you can then use to sign the user in, or link with their account (
  /// see [signInWithCredential] or [linkWithCredential]).
  ///
  /// On some Android devices, auto-verification can be handled by the device
  /// and a [PhoneAuthCredential] will be automatically provided.
  ///
  /// No duplicated SMS will be sent out unless a [forceResendingToken] is
  /// provided.
  ///
  /// [phoneNumber] The phone number for the account the user is signing up
  ///   for or signing into. Make sure to pass in a phone number with country
  ///   code prefixed with plus sign ('+').
  ///   Should be null if it's a multi-factor sign in.
  ///
  /// [multiFactorInfo] The multi factor info you're using to verify the phone number.
  ///   Should be set if a [multiFactorSession] is provided.
  ///
  /// [multiFactorSession] The multi factor session you're using to verify the phone number.
  ///   Should be set if a [multiFactorInfo] is provided.
  ///
  /// [timeout] The maximum amount of time you are willing to wait for SMS
  ///   auto-retrieval to be completed by the library. Maximum allowed value
  ///   is 2 minutes.
  ///
  /// [forceResendingToken] The [forceResendingToken] obtained from [codeSent]
  ///   callback to force re-sending another verification SMS before the
  ///   auto-retrieval timeout.
  ///
  /// [verificationCompleted] Triggered when an SMS is auto-retrieved or the
  ///   phone number has been instantly verified. The callback will receive an
  ///   [PhoneAuthCredential] that can be passed to [signInWithCredential] or
  ///   [linkWithCredential].
  ///
  /// [verificationFailed] Triggered when an error occurred during phone number
  ///   verification. A [FirebaseAuthException] is provided when this is
  ///   triggered.
  ///
  /// [codeSent] Triggered when an SMS has been sent to the users phone, and
  ///   will include a [verificationId] and [forceResendingToken].
  ///
  /// [codeAutoRetrievalTimeout] Triggered when SMS auto-retrieval times out and
  ///   provide a [verificationId].
  Future<void> verifyPhoneNumber({
    String? phoneNumber,
    PhoneMultiFactorInfo? multiFactorInfo,
    required PhoneVerificationCompleted verificationCompleted,
    required PhoneVerificationFailed verificationFailed,
    required PhoneCodeSent codeSent,
    required PhoneCodeAutoRetrievalTimeout codeAutoRetrievalTimeout,
    @visibleForTesting String? autoRetrievedSmsCodeForTesting,
    Duration timeout = const Duration(seconds: 30),
    int? forceResendingToken,
    MultiFactorSession? multiFactorSession,
  }) {
    assert(
      phoneNumber != null || multiFactorInfo != null,
      'Either phoneNumber or multiFactorInfo must be provided.',
    );
    return _delegate.verifyPhoneNumber(
      phoneNumber: phoneNumber,
      multiFactorInfo: multiFactorInfo,
      timeout: timeout,
      forceResendingToken: forceResendingToken,
      verificationCompleted: verificationCompleted,
      verificationFailed: verificationFailed,
      codeSent: codeSent,
      codeAutoRetrievalTimeout: codeAutoRetrievalTimeout,
      // ignore: invalid_use_of_visible_for_testing_member
      autoRetrievedSmsCodeForTesting: autoRetrievedSmsCodeForTesting,
      multiFactorSession: multiFactorSession,
    );
  }

  /// Apple only. Users signed in with Apple provider can revoke their token using an authorization code.
  /// Authorization code can be retrieved on the user credential i.e. userCredential.additionalUserInfo.authorizationCode
  Future<void> revokeTokenWithAuthorizationCode(String authorizationCode) {
    return _delegate.revokeTokenWithAuthorizationCode(authorizationCode);
  }

  /// Signs out the current user.
  ///
  /// If successful, it also updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  Future<void> signOut() async {
    await _delegate.signOut();
  }

  /// Initializes the reCAPTCHA Enterprise client proactively to enhance reCAPTCHA signal collection and
  /// to complete reCAPTCHA-protected flows in a single attempt.
  Future<void> initializeRecaptchaConfig() {
    return _delegate.initializeRecaptchaConfig();
  }

  /// Validates a password against the password policy configured for the project or tenant.
  ///
  /// If no tenant ID is set on the Auth instance, then this method will use the password policy configured for the project.
  /// Otherwise, this method will use the policy configured for the tenant. If a password policy has not been configured,
  /// then the default policy configured for all projects will be used.
  ///
  /// If an auth flow fails because a submitted password does not meet the password policy requirements and this method has previously been called,
  /// then this method will use the most recent policy available when called again.
  ///
  /// Returns a map with the following keys:
  /// - **status**: A boolean indicating if the password is valid.
  /// - **passwordPolicy**: The password policy used to validate the password.
  /// - **meetsMinPasswordLength**: A boolean indicating if the password meets the minimum length requirement.
  /// - **meetsMaxPasswordLength**: A boolean indicating if the password meets the maximum length requirement.
  /// - **meetsLowercaseRequirement**: A boolean indicating if the password meets the lowercase requirement.
  /// - **meetsUppercaseRequirement**: A boolean indicating if the password meets the uppercase requirement.
  /// - **meetsDigitsRequirement**: A boolean indicating if the password meets the digits requirement.
  /// - **meetsSymbolsRequirement**: A boolean indicating if the password meets the symbols requirement.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-password**:
  ///  - Thrown if the password is invalid.
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **INVALID_LOGIN_CREDENTIALS** or **invalid-credential**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  ///    Depending on if you are using firebase emulator or not the code is
  ///    different
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<PasswordValidationStatus> validatePassword(
    FirebaseAuth auth,
    String? password,
  ) async {
    if (password == null || password.isEmpty) {
      throw FirebaseAuthException(
        code: 'invalid-password',
        message: 'Password cannot be null or empty',
      );
    }
    PasswordPolicyApi passwordPolicyApi =
        PasswordPolicyApi(auth.app.options.apiKey);
    PasswordPolicy passwordPolicy =
        await passwordPolicyApi.fetchPasswordPolicy();
    PasswordPolicyImpl passwordPolicyImpl = PasswordPolicyImpl(passwordPolicy);
    return passwordPolicyImpl.isPasswordValid(password);
  }

  @override
  String toString() {
    return 'FirebaseAuth(app: ${app.name})';
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/multi_factor.dart

**크기**: 7075 bytes | **라인 수**: 214 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_auth.dart';

/// Defines multi-factor related properties and operations pertaining to a [User].
/// This class acts as the main entry point for enrolling or un-enrolling
/// second factors for a user, and provides access to their currently enrolled factors.
class MultiFactor {
  MultiFactorPlatform _delegate;

  MultiFactor._(this._delegate);

  /// Returns a session identifier for a second factor enrollment operation.
  Future<MultiFactorSession> getSession() {
    return _delegate.getSession();
  }

  /// Enrolls a second factor as identified by the [MultiFactorAssertion] parameter for the current user.
  ///
  /// [displayName] can be used to provide a display name for the second factor.
  Future<void> enroll(
    MultiFactorAssertion assertion, {
    String? displayName,
  }) async {
    if (assertion._delegate is TotpMultiFactorGeneratorPlatform) {
      assert(displayName != null, 'displayName is mandatory for TOTP');
    }
    return _delegate.enroll(assertion._delegate, displayName: displayName);
  }

  /// Unenrolls a second factor from this user.
  ///
  /// [factorUid] is the unique identifier of the second factor to unenroll.
  /// [multiFactorInfo] is the [MultiFactorInfo] of the second factor to unenroll.
  /// Only one of [factorUid] or [multiFactorInfo] should be provided.
  Future<void> unenroll({String? factorUid, MultiFactorInfo? multiFactorInfo}) {
    assert(
      (factorUid != null && multiFactorInfo == null) ||
          (factorUid == null && multiFactorInfo != null),
      'Exactly one of `factorUid` or `multiFactorInfo` must be provided',
    );
    return _delegate.unenroll(
      factorUid: factorUid,
      multiFactorInfo: multiFactorInfo,
    );
  }

  /// Returns a list of the [MultiFactorInfo] already associated with this user.
  Future<List<MultiFactorInfo>> getEnrolledFactors() {
    return _delegate.getEnrolledFactors();
  }
}

/// Provider for generating a PhoneMultiFactorAssertion.
class PhoneMultiFactorGenerator {
  /// Transforms a PhoneAuthCredential into a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a phone second factor.
  static MultiFactorAssertion getAssertion(
    PhoneAuthCredential credential,
  ) {
    final assertion =
        PhoneMultiFactorGeneratorPlatform.instance.getAssertion(credential);
    return MultiFactorAssertion._(assertion);
  }
}

/// Provider for generating a PhoneMultiFactorAssertion.
class TotpMultiFactorGenerator {
  /// Transforms a PhoneAuthCredential into a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a phone second factor.
  static Future<TotpSecret> generateSecret(
    MultiFactorSession session,
  ) async {
    final secret =
        await TotpMultiFactorGeneratorPlatform.instance.generateSecret(session);
    return TotpSecret._(
      secret.codeIntervalSeconds,
      secret.codeLength,
      secret.enrollmentCompletionDeadline,
      secret.hashingAlgorithm,
      secret.secretKey,
      secret,
    );
  }

  /// Get a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a TOTP second factor.
  static Future<MultiFactorAssertion> getAssertionForEnrollment(
    TotpSecret secret,
    String oneTimePassword,
  ) async {
    final assertion = await TotpMultiFactorGeneratorPlatform.instance
        .getAssertionForEnrollment(
      secret._instance,
      oneTimePassword,
    );

    return MultiFactorAssertion._(assertion);
  }

  /// Get a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a TOTP second factor.
  static Future<MultiFactorAssertion> getAssertionForSignIn(
    String enrollmentId,
    String oneTimePassword,
  ) async {
    final assertion =
        await TotpMultiFactorGeneratorPlatform.instance.getAssertionForSignIn(
      enrollmentId,
      oneTimePassword,
    );

    return MultiFactorAssertion._(assertion);
  }
}

class TotpSecret {
  final TotpSecretPlatform _instance;

  final int? codeIntervalSeconds;
  final int? codeLength;
  final DateTime? enrollmentCompletionDeadline;
  final String? hashingAlgorithm;
  final String secretKey;

  TotpSecret._(
    this.codeIntervalSeconds,
    this.codeLength,
    this.enrollmentCompletionDeadline,
    this.hashingAlgorithm,
    this.secretKey,
    this._instance,
  );

  /// Generate a TOTP secret for the authenticated user.
  Future<String> generateQrCodeUrl({
    String? accountName,
    String? issuer,
  }) {
    return _instance.generateQrCodeUrl(
      accountName: accountName,
      issuer: issuer,
    );
  }

  /// Opens the specified QR Code URL in a password manager like iCloud Keychain.
  Future<void> openInOtpApp(
    String qrCodeUrl,
  ) async {
    await _instance.openInOtpApp(
      qrCodeUrl,
    );
  }
}

/// Represents an assertion that the Firebase Authentication server
/// can use to authenticate a user as part of a multi-factor flow.
class MultiFactorAssertion {
  final MultiFactorAssertionPlatform _delegate;

  MultiFactorAssertion._(this._delegate) {
    MultiFactorAssertionPlatform.verify(_delegate);
  }
}

/// Utility class that contains methods to resolve second factor
/// requirements on users that have opted into two-factor authentication.
class MultiFactorResolver {
  final FirebaseAuth _auth;
  final MultiFactorResolverPlatform _delegate;

  MultiFactorResolver._(this._auth, this._delegate) {
    MultiFactorResolverPlatform.verify(_delegate);
  }

  /// List of [MultiFactorInfo] which represents the available
  /// second factors that can be used to complete the sign-in for the current session.
  List<MultiFactorInfo> get hints => _delegate.hints;

  /// A MultiFactorSession, an opaque session identifier for the current sign-in flow.
  MultiFactorSession get session => _delegate.session;

  /// Completes sign in with a second factor using an MultiFactorAssertion which
  /// confirms that the user has successfully completed the second factor challenge.
  Future<UserCredential> resolveSignIn(
    MultiFactorAssertion assertion,
  ) async {
    final credential = await _delegate.resolveSignIn(assertion._delegate);
    return UserCredential._(_auth, credential);
  }
}

/// MultiFactor exception related to Firebase Authentication. Check the error code
/// and message for more details.
class FirebaseAuthMultiFactorException extends FirebaseAuthException {
  final FirebaseAuth _auth;
  final FirebaseAuthMultiFactorExceptionPlatform _delegate;

  FirebaseAuthMultiFactorException._(this._auth, this._delegate)
      : super(
          code: _delegate.code,
          message: _delegate.message,
          email: _delegate.email,
          credential: _delegate.credential,
          phoneNumber: _delegate.phoneNumber,
          tenantId: _delegate.tenantId,
        );

  MultiFactorResolver get resolver =>
      MultiFactorResolver._(_auth, _delegate.resolver);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/recaptcha_verifier.dart

**크기**: 3570 bytes | **라인 수**: 101 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// An [reCAPTCHA](https://www.google.com/recaptcha/?authuser=0)-based
/// application verifier.
class RecaptchaVerifier {
  static final RecaptchaVerifierFactoryPlatform _factory =
      RecaptchaVerifierFactoryPlatform.instance;

  RecaptchaVerifier._(this._delegate);

  RecaptchaVerifierFactoryPlatform _delegate;

  /// Creates a new [RecaptchaVerifier] instance used to render a reCAPTCHA widget
  /// when calling [signInWithPhoneNumber].
  ///
  /// It is possible to configure the reCAPTCHA widget with the following arguments,
  /// however if no arguments are provided, an "invisible" reCAPTCHA widget with
  /// defaults will be created.
  ///
  /// [container] If a value is provided, the element must exist in the DOM when
  ///   [render] or [signInWithPhoneNumber] is called. The reCAPTCHA widget will
  ///   be rendered within the specified DOM element.
  ///
  ///   If no value is provided, an "invisible" reCAPTCHA will be shown when [render]
  ///   is called. An invisible reCAPTCHA widget is shown a modal on-top of your
  ///   application.
  ///
  /// [size] When providing a custom [container], a size (normal or compact) can
  ///   be provided to change the size of the reCAPTCHA widget. This has no effect
  ///    when a [container] is not provided. Defaults to [RecaptchaVerifierSize.normal].
  ///
  /// [theme] When providing a custom [container], a theme (light or dark) can
  ///   be provided to change the appearance of the reCAPTCHA widget. This has no
  ///   effect when a [container] is not provided. Defaults to [RecaptchaVerifierTheme.light].
  ///
  /// [onSuccess] An optional callback which is called when the user successfully
  ///   completes the reCAPTCHA widget.
  ///
  /// [onError] An optional callback which is called when the reCAPTCHA widget errors
  ///   (such as a network issue).
  ///
  /// [onExpired] An optional callback which is called when the reCAPTCHA expires.
  factory RecaptchaVerifier({
    required FirebaseAuthPlatform auth,
    String? container,
    RecaptchaVerifierSize size = RecaptchaVerifierSize.normal,
    RecaptchaVerifierTheme theme = RecaptchaVerifierTheme.light,
    RecaptchaVerifierOnSuccess? onSuccess,
    RecaptchaVerifierOnError? onError,
    RecaptchaVerifierOnExpired? onExpired,
  }) {
    return RecaptchaVerifier._(
      _factory.delegateFor(
        auth: auth,
        container: container,
        size: size,
        theme: theme,
        onSuccess: onSuccess,
        onError: onError,
        onExpired: onExpired,
      ),
    );
  }

  /// Returns the underlying factory delegate instance.
  @protected
  RecaptchaVerifierFactoryPlatform get delegate {
    return _delegate;
  }

  /// The application verifier type. For a reCAPTCHA verifier, this is
  /// 'recaptcha'.
  String get type {
    return _delegate.type;
  }

  /// Clears the reCAPTCHA widget from the page and destroys the current
  /// instance.
  void clear() {
    return _delegate.clear();
  }

  /// Renders the reCAPTCHA widget on the page.
  ///
  /// Returns a [Future] that resolves with the reCAPTCHA widget ID.
  Future<int> render() async {
    return _delegate.render();
  }

  /// Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA
  /// token.
  Future<String> verify() async {
    return _delegate.verify();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/user.dart

**크기**: 29891 bytes | **라인 수**: 686 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A user account.
class User {
  UserPlatform _delegate;

  final FirebaseAuth _auth;
  MultiFactor? _multiFactor;

  User._(this._auth, this._delegate) {
    UserPlatform.verify(_delegate);
  }

  /// The users display name.
  ///
  /// Will be `null` if signing in anonymously or via password authentication.
  String? get displayName {
    return _delegate.displayName;
  }

  /// The users email address.
  ///
  /// Will be `null` if signing in anonymously.
  String? get email {
    return _delegate.email;
  }

  /// Returns whether the users email address has been verified.
  ///
  /// To send a verification email, see [sendEmailVerification].
  ///
  /// Once verified, call [reload] to ensure the latest user information is
  /// retrieved from Firebase.
  bool get emailVerified {
    return _delegate.isEmailVerified;
  }

  /// Returns whether the user is a anonymous.
  bool get isAnonymous {
    return _delegate.isAnonymous;
  }

  /// Returns additional metadata about the user, such as their creation time.
  UserMetadata get metadata {
    return _delegate.metadata;
  }

  /// Returns the users phone number.
  ///
  /// This property will be `null` if the user has not signed in or been has
  /// their phone number linked.
  String? get phoneNumber {
    return _delegate.phoneNumber;
  }

  /// Returns a photo URL for the user.
  ///
  /// This property will be populated if the user has signed in or been linked
  /// with a 3rd party OAuth provider (such as Google).
  String? get photoURL {
    return _delegate.photoURL;
  }

  /// Returns a list of user information for each linked provider.
  List<UserInfo> get providerData {
    return _delegate.providerData;
  }

  /// Returns a JWT refresh token for the user.
  ///
  /// This property will be an empty string for native platforms (android, iOS & macOS) as they do not
  /// support refresh tokens.
  String? get refreshToken {
    return _delegate.refreshToken;
  }

  /// The current user's tenant ID.
  ///
  /// This is a read-only property, which indicates the tenant ID used to sign
  /// in the current user. This is `null` if the user is signed in from the
  /// parent project.
  String? get tenantId {
    return _delegate.tenantId;
  }

  /// The user's unique ID.
  String get uid {
    return _delegate.uid;
  }

  /// Deletes and signs out the user.
  ///
  /// **Important**: this is a security-sensitive operation that requires the
  /// user to have recently signed in. If this requirement isn't met, ask the
  /// user to authenticate again and then call [User.reauthenticateWithCredential].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **requires-recent-login**:
  ///  - Thrown if the user's last sign-in time does not meet the security
  ///    threshold. Use [User.reauthenticateWithCredential] to resolve. This
  ///    does not apply if the user is anonymous.
  Future<void> delete() async {
    return _delegate.delete();
  }

  /// Returns a JSON Web Token (JWT) used to identify the user to a Firebase
  /// service.
  ///
  /// Returns the current token if it has not expired. Otherwise, this will
  /// refresh the token and return a new one.
  ///
  /// If [forceRefresh] is `true`, the token returned will be refreshed regardless
  /// of token expiration.
  Future<String?> getIdToken([bool forceRefresh = false]) {
    return _delegate.getIdToken(forceRefresh);
  }

  /// Returns a [IdTokenResult] containing the users JSON Web Token (JWT) and
  /// other metadata.
  ///
  /// Returns the current token if it has not expired. Otherwise, this will
  /// refresh the token and return a new one.
  ///
  /// If [forceRefresh] is `true`, the token returned will be refreshed regardless
  /// of token expiration.
  Future<IdTokenResult> getIdTokenResult([bool forceRefresh = false]) {
    return _delegate.getIdTokenResult(forceRefresh);
  }

  /// Links the user account with the given credentials.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential]. Please note, you will
  ///    not recover from this error if you're using a [PhoneAuthCredential] to link
  ///    a provider to an account. Once an attempt to link an account has been made,
  ///    a new sms code is required to sign in the user.
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential. To
  ///    do so, sign in to `email` via one of
  ///    the providers returned and then [User.linkWithCredential] the original
  ///    credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **invalid-email**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> linkWithCredential(AuthCredential credential) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links with an AuthProvider using native authentication flow.
  /// On web, you should use [linkWithPopup] or [linkWithRedirect] instead.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<UserCredential> linkWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a Provider.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.reauthenticateWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a popup on Web.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithPopup(
    AuthProvider provider,
  ) async {
    return UserCredential._(
      _auth,
      await _delegate.reauthenticateWithPopup(provider),
    );
  }

  /// Re-authenticates a user using a redirection on Web.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<void> reauthenticateWithRedirect(
    AuthProvider provider,
  ) async {
    await _delegate.reauthenticateWithRedirect(provider);
  }

  /// Links the user account with the given provider.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<UserCredential> linkWithPopup(AuthProvider provider) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithPopup(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links the user account with the given provider.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<void> linkWithRedirect(AuthProvider provider) async {
    try {
      await _delegate.linkWithRedirect(provider);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links the user account with the given phone number.
  ///
  /// This method is only supported on web platforms. Use [verifyPhoneNumber] and
  /// then [linkWithCredential] on these platforms.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **captcha-check-failed**:
  ///  - Thrown if the reCAPTCHA response token was invalid, expired, or if this
  ///    method was called from a non-whitelisted domain.
  /// - **invalid-phone-number**:
  ///  - Thrown if the phone number has an invalid format.
  /// - **quota-exceeded**:
  ///  - Thrown if the SMS quota for the Firebase project has been exceeded.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given phone number has been disabled.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the phone number already exists
  ///    among your users, or is already linked to a Firebase User.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the phone authentication provider in the
  ///  Firebase Console. Go to the Firebase Console for your project, in the Auth
  ///  section and the Sign in Method tab and configure the provider.
  Future<ConfirmationResult> linkWithPhoneNumber(
    String phoneNumber, [
    RecaptchaVerifier? verifier,
  ]) async {
    assert(phoneNumber.isNotEmpty);
    // If we add a recaptcha to the page by creating a new instance, we must
    // also clear that instance before proceeding.
    bool mustClear = verifier == null;
    verifier ??= RecaptchaVerifier(auth: _delegate.auth);
    try {
      final result =
          await _delegate.linkWithPhoneNumber(phoneNumber, verifier.delegate);
      if (mustClear) {
        verifier.clear();
      }
      return ConfirmationResult._(_auth, result);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a fresh credential.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithCredential(
    AuthCredential credential,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.reauthenticateWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Refreshes the current user, if signed in.
  Future<void> reload() async {
    await _delegate.reload();
  }

  /// Sends a verification email to a user.
  ///
  /// The verification process is completed by calling [applyActionCode].
  Future<void> sendEmailVerification([
    ActionCodeSettings? actionCodeSettings,
  ]) async {
    await _delegate.sendEmailVerification(actionCodeSettings);
  }

  /// Unlinks a provider from a user account.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **no-such-provider**:
  ///  - Thrown if the user does not have this provider linked or when the
  ///    provider ID given does not exist.
  Future<User> unlink(String providerId) async {
    return User._(_auth, await _delegate.unlink(providerId));
  }

  /// Updates the user's email address.
  ///
  /// An email will be sent to the original email address (if it was set) that
  /// allows to revoke the email address change, in order to protect them from
  /// account hijacking.
  ///
  /// **Important**: this is a security sensitive operation that requires the
  ///   user to have recently signed in. If this requirement isn't met, ask the
  ///   user to authenticate again and then call [User.reauthenticateWithCredential].
  ///

  /// Updates the user's password.
  ///
  /// **Important**: this is a security sensitive operation that requires the
  ///   user to have recently signed in. If this requirement isn't met, ask the
  ///   user to authenticate again and then call [User.reauthenticateWithCredential].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **weak-password**:
  ///  - Thrown if the password is not strong enough.
  /// - **requires-recent-login**:
  ///  - Thrown if the user's last sign-in time does not meet the security
  ///    threshold. Use [User.reauthenticateWithCredential] to resolve. This
  ///    does not apply if the user is anonymous.
  Future<void> updatePassword(String newPassword) async {
    await _delegate.updatePassword(newPassword);
  }

  /// Updates the user's phone number.
  ///
  /// A credential can be created by verifying a phone number via [verifyPhoneNumber].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-verification-code**:
  ///  - Thrown if the verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the verification ID of the credential is not valid.
  Future<void> updatePhoneNumber(PhoneAuthCredential phoneCredential) async {
    await _delegate.updatePhoneNumber(phoneCredential);
  }

  /// Update the user name.
  Future<void> updateDisplayName(String? displayName) {
    return _delegate
        .updateProfile(<String, String?>{'displayName': displayName});
  }

  /// Update the user's profile picture.
  Future<void> updatePhotoURL(String? photoURL) {
    return _delegate.updateProfile(<String, String?>{'photoURL': photoURL});
  }

  /// Updates a user's profile data.
  Future<void> updateProfile({String? displayName, String? photoURL}) {
    return _delegate.updateProfile(<String, String?>{
      'displayName': displayName,
      'photoURL': photoURL,
    });
  }

  /// Sends a verification email to a new email address. The user's email will
  /// be updated to the new one after being verified.
  ///
  /// If you have a custom email action handler, you can complete the
  /// verification process by calling [applyActionCode].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **missing-android-pkg-name**:
  ///  - An Android package name must be provided if the Android app is required to be installed.
  /// - **missing-continue-uri**:
  ///  - A continue URL must be provided in the request.
  /// - **missing-ios-bundle-id**:
  ///  - An iOS bundle ID must be provided if an App Store ID is provided.
  /// - **invalid-continue-uri**:
  ///  - The continue URL provided in the request is invalid.
  /// - **unauthorized-continue-uri**:
  ///  - The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console.
  Future<void> verifyBeforeUpdateEmail(
    String newEmail, [
    ActionCodeSettings? actionCodeSettings,
  ]) async {
    await _delegate.verifyBeforeUpdateEmail(newEmail, actionCodeSettings);
  }

  MultiFactor get multiFactor {
    if (!kIsWeb && (defaultTargetPlatform == TargetPlatform.windows)) {
      throw UnimplementedError(
        'MultiFactor Authentication is only supported on web, Android, iOS and macOS.',
      );
    }
    return _multiFactor ??= MultiFactor._(_delegate.multiFactor);
  }

  @override
  String toString() {
    return '$User('
        'displayName: $displayName, '
        'email: $email, '
        'isEmailVerified: $emailVerified, '
        'isAnonymous: $isAnonymous, '
        'metadata: $metadata, '
        'phoneNumber: $phoneNumber, '
        'photoURL: $photoURL, '
        'providerData, $providerData, '
        'refreshToken: $refreshToken, '
        'tenantId: $tenantId, '
        'uid: $uid)';
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/src/user_credential.dart

**크기**: 1284 bytes | **라인 수**: 40 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A UserCredential is returned from authentication requests such as
/// [createUserWithEmailAndPassword].
class UserCredential {
  UserCredential._(this._auth, this._delegate) {
    UserCredentialPlatform.verify(_delegate);
  }

  final FirebaseAuth _auth;
  final UserCredentialPlatform _delegate;

  /// Returns additional information about the user, such as whether they are a
  /// newly created one.
  AdditionalUserInfo? get additionalUserInfo => _delegate.additionalUserInfo;

  /// The users [AuthCredential].
  AuthCredential? get credential => _delegate.credential;

  /// Returns a [User] containing additional information and user specific
  /// methods.
  User? get user {
    // TODO(rousselGit): cache the `user` instance or override == so that ".user == .user"
    return _delegate.user == null ? null : User._(_auth, _delegate.user!);
  }

  @override
  String toString() {
    return 'UserCredential('
        'additionalUserInfo: $additionalUserInfo, '
        'credential: $credential, '
        'user: $user)';
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/lib/firebase_auth.dart

**크기**: 2309 bytes | **라인 수**: 73 | **타입**: text

```
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter/foundation.dart';

export 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart'
    show
        FirebaseAuthException,
        MultiFactorInfo,
        MultiFactorSession,
        PhoneMultiFactorInfo,
        TotpMultiFactorInfo,
        IdTokenResult,
        UserMetadata,
        UserInfo,
        ActionCodeInfo,
        ActionCodeSettings,
        AdditionalUserInfo,
        ActionCodeInfoOperation,
        Persistence,
        PhoneVerificationCompleted,
        PhoneVerificationFailed,
        PhoneCodeSent,
        PhoneCodeAutoRetrievalTimeout,
        AuthCredential,
        AuthProvider,
        AppleAuthProvider,
        AppleFullPersonName,
        AppleAuthCredential,
        EmailAuthProvider,
        EmailAuthCredential,
        FacebookAuthProvider,
        FacebookAuthCredential,
        GameCenterAuthProvider,
        GameCenterAuthCredential,
        PlayGamesAuthProvider,
        PlayGamesAuthCredential,
        GithubAuthProvider,
        GithubAuthCredential,
        GoogleAuthProvider,
        GoogleAuthCredential,
        YahooAuthProvider,
        YahooAuthCredential,
        MicrosoftAuthProvider,
        OAuthProvider,
        OAuthCredential,
        PhoneAuthProvider,
        PhoneAuthCredential,
        SAMLAuthProvider,
        TwitterAuthProvider,
        TwitterAuthCredential,
        RecaptchaVerifierOnSuccess,
        RecaptchaVerifierOnExpired,
        RecaptchaVerifierOnError,
        RecaptchaVerifierSize,
        RecaptchaVerifierTheme,
        PasswordValidationStatus;
export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseException;

part 'src/confirmation_result.dart';
part 'src/firebase_auth.dart';
part 'src/multi_factor.dart';
part 'src/recaptcha_verifier.dart';
part 'src/user.dart';
part 'src/user_credential.dart';

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Private/FLTAuthStateChannelStreamHandler.h

**크기**: 568 bytes | **라인 수**: 27 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <Foundation/Foundation.h>
#import "../Public/CustomPigeonHeader.h"

@class FIRAuth;

NS_ASSUME_NONNULL_BEGIN

@interface FLTAuthStateChannelStreamHandler : NSObject <FlutterStreamHandler>

- (instancetype)initWithAuth:(FIRAuth *)auth;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Private/FLTIdTokenChannelStreamHandler.h

**크기**: 567 bytes | **라인 수**: 28 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "../Public/CustomPigeonHeader.h"

#import <Foundation/Foundation.h>

@class FIRAuth;

NS_ASSUME_NONNULL_BEGIN

@interface FLTIdTokenChannelStreamHandler : NSObject <FlutterStreamHandler>

- (instancetype)initWithAuth:(FIRAuth *)auth;

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Private/FLTPhoneNumberVerificationStreamHandler.h

**크기**: 957 bytes | **라인 수**: 37 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "../Public/firebase_auth_messages.g.h"

#import <Foundation/Foundation.h>

@class FIRAuth;
@class FIRMultiFactorSession;
@class FIRPhoneMultiFactorInfo;

NS_ASSUME_NONNULL_BEGIN

@interface FLTPhoneNumberVerificationStreamHandler : NSObject <FlutterStreamHandler>

#if TARGET_OS_OSX
- (instancetype)initWithAuth:(FIRAuth *)auth arguments:(NSDictionary *)arguments;
#else
- (instancetype)initWithAuth:(FIRAuth *)auth
                     request:(PigeonVerifyPhoneNumberRequest *)request
                     session:(FIRMultiFactorSession *)session
                  factorInfo:(FIRPhoneMultiFactorInfo *)factorInfo;
#endif

@end

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Private/PigeonParser.h

**크기**: 1539 bytes | **라인 수**: 34 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#import <Foundation/Foundation.h>
#import "../Public/firebase_auth_messages.g.h"

@class FIRAuthDataResult;
@class FIRUser;
@class FIRActionCodeSettings;
@class FIRAuthTokenResult;
@class FIRTOTPSecret;
@class FIRAuthCredential;

@interface PigeonParser : NSObject

+ (NSArray *_Nonnull)getManualList:(nonnull PigeonUserDetails *)userDetails;
+ (PigeonUserCredential *_Nullable)
    getPigeonUserCredentialFromAuthResult:(nonnull FIRAuthDataResult *)authResult
                        authorizationCode:(nullable NSString *)authorizationCode;
+ (PigeonUserDetails *_Nullable)getPigeonDetails:(nonnull FIRUser *)user;
+ (PigeonUserInfo *_Nullable)getPigeonUserInfo:(nonnull FIRUser *)user;
+ (FIRActionCodeSettings *_Nullable)parseActionCodeSettings:
    (nullable PigeonActionCodeSettings *)settings;
+ (PigeonUserCredential *_Nullable)getPigeonUserCredentialFromFIRUser:(nonnull FIRUser *)user;
+ (PigeonIdTokenResult *_Nonnull)parseIdTokenResult:(nonnull FIRAuthTokenResult *)tokenResult;
+ (PigeonTotpSecret *_Nonnull)getPigeonTotpSecret:(nonnull FIRTOTPSecret *)secret;
+ (PigeonAuthCredential *_Nullable)getPigeonAuthCredential:
                                       (FIRAuthCredential *_Nullable)authCredentialToken
                                                     token:(NSNumber *_Nullable)token;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Public/CustomPigeonHeader.h

**크기**: 404 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import "firebase_auth_messages.g.h"

@interface PigeonMultiFactorInfo (Map)
- (NSDictionary *)toList;
@end

@interface PigeonUserDetails (Map)
- (NSDictionary *)toList;
@end

@interface PigeonUserInfo (Map)
- (NSDictionary *)toList;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Public/FLTFirebaseAuthPlugin.h

**크기**: 1146 bytes | **라인 수**: 35 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import <AuthenticationServices/AuthenticationServices.h>
#import <Foundation/Foundation.h>
#if __has_include(<firebase_core/FLTFirebasePlugin.h>)
#import <firebase_core/FLTFirebasePlugin.h>
#else
#import <FLTFirebasePlugin.h>
#endif
#import "firebase_auth_messages.g.h"

@interface FLTFirebaseAuthPlugin
    : FLTFirebasePlugin <FlutterPlugin,
                         FirebaseAuthHostApi,
                         FirebaseAuthUserHostApi,
                         MultiFactorUserHostApi,
                         MultiFactoResolverHostApi,
                         MultiFactorTotpHostApi,
                         MultiFactorTotpSecretHostApi,
                         ASAuthorizationControllerDelegate,
                         ASAuthorizationControllerPresentationContextProviding>

+ (FlutterError *)convertToFlutterError:(NSError *)error;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/include/Public/firebase_auth_messages.g.h

**크기**: 30697 bytes | **라인 수**: 571 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

/// The type of operation that generated the action code from calling
/// [checkActionCode].
typedef NS_ENUM(NSUInteger, ActionCodeInfoOperation) {
  /// Unknown operation.
  ActionCodeInfoOperationUnknown = 0,
  /// Password reset code generated via [sendPasswordResetEmail].
  ActionCodeInfoOperationPasswordReset = 1,
  /// Email verification code generated via [User.sendEmailVerification].
  ActionCodeInfoOperationVerifyEmail = 2,
  /// Email change revocation code generated via [User.updateEmail].
  ActionCodeInfoOperationRecoverEmail = 3,
  /// Email sign in code generated via [sendSignInLinkToEmail].
  ActionCodeInfoOperationEmailSignIn = 4,
  /// Verify and change email code generated via [User.verifyBeforeUpdateEmail].
  ActionCodeInfoOperationVerifyAndChangeEmail = 5,
  /// Action code for reverting second factor addition.
  ActionCodeInfoOperationRevertSecondFactorAddition = 6,
};

/// Wrapper for ActionCodeInfoOperation to allow for nullability.
@interface ActionCodeInfoOperationBox : NSObject
@property(nonatomic, assign) ActionCodeInfoOperation value;
- (instancetype)initWithValue:(ActionCodeInfoOperation)value;
@end

@class PigeonMultiFactorSession;
@class PigeonPhoneMultiFactorAssertion;
@class PigeonMultiFactorInfo;
@class AuthPigeonFirebaseApp;
@class PigeonActionCodeInfoData;
@class PigeonActionCodeInfo;
@class PigeonAdditionalUserInfo;
@class PigeonAuthCredential;
@class PigeonUserInfo;
@class PigeonUserDetails;
@class PigeonUserCredential;
@class PigeonActionCodeSettings;
@class PigeonFirebaseAuthSettings;
@class PigeonSignInProvider;
@class PigeonVerifyPhoneNumberRequest;
@class PigeonIdTokenResult;
@class PigeonUserProfile;
@class PigeonTotpSecret;

@interface PigeonMultiFactorSession : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithId:(NSString *)id;
@property(nonatomic, copy) NSString *id;
@end

@interface PigeonPhoneMultiFactorAssertion : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithVerificationId:(NSString *)verificationId
                      verificationCode:(NSString *)verificationCode;
@property(nonatomic, copy) NSString *verificationId;
@property(nonatomic, copy) NSString *verificationCode;
@end

@interface PigeonMultiFactorInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                enrollmentTimestamp:(double)enrollmentTimestamp
                           factorId:(nullable NSString *)factorId
                                uid:(NSString *)uid
                        phoneNumber:(nullable NSString *)phoneNumber;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, assign) double enrollmentTimestamp;
@property(nonatomic, copy, nullable) NSString *factorId;
@property(nonatomic, copy) NSString *uid;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@end

@interface AuthPigeonFirebaseApp : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppName:(NSString *)appName
                       tenantId:(nullable NSString *)tenantId
               customAuthDomain:(nullable NSString *)customAuthDomain;
@property(nonatomic, copy) NSString *appName;
@property(nonatomic, copy, nullable) NSString *tenantId;
@property(nonatomic, copy, nullable) NSString *customAuthDomain;
@end

@interface PigeonActionCodeInfoData : NSObject
+ (instancetype)makeWithEmail:(nullable NSString *)email
                previousEmail:(nullable NSString *)previousEmail;
@property(nonatomic, copy, nullable) NSString *email;
@property(nonatomic, copy, nullable) NSString *previousEmail;
@end

@interface PigeonActionCodeInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithOperation:(ActionCodeInfoOperation)operation
                             data:(PigeonActionCodeInfoData *)data;
@property(nonatomic, assign) ActionCodeInfoOperation operation;
@property(nonatomic, strong) PigeonActionCodeInfoData *data;
@end

@interface PigeonAdditionalUserInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithIsNewUser:(BOOL)isNewUser
                       providerId:(nullable NSString *)providerId
                         username:(nullable NSString *)username
                authorizationCode:(nullable NSString *)authorizationCode
                          profile:(nullable NSDictionary<NSString *, id> *)profile;
@property(nonatomic, assign) BOOL isNewUser;
@property(nonatomic, copy, nullable) NSString *providerId;
@property(nonatomic, copy, nullable) NSString *username;
@property(nonatomic, copy, nullable) NSString *authorizationCode;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, id> *profile;
@end

@interface PigeonAuthCredential : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithProviderId:(NSString *)providerId
                      signInMethod:(NSString *)signInMethod
                          nativeId:(NSInteger)nativeId
                       accessToken:(nullable NSString *)accessToken;
@property(nonatomic, copy) NSString *providerId;
@property(nonatomic, copy) NSString *signInMethod;
@property(nonatomic, assign) NSInteger nativeId;
@property(nonatomic, copy, nullable) NSString *accessToken;
@end

@interface PigeonUserInfo : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUid:(NSString *)uid
                      email:(nullable NSString *)email
                displayName:(nullable NSString *)displayName
                   photoUrl:(nullable NSString *)photoUrl
                phoneNumber:(nullable NSString *)phoneNumber
                isAnonymous:(BOOL)isAnonymous
            isEmailVerified:(BOOL)isEmailVerified
                 providerId:(nullable NSString *)providerId
                   tenantId:(nullable NSString *)tenantId
               refreshToken:(nullable NSString *)refreshToken
          creationTimestamp:(nullable NSNumber *)creationTimestamp
        lastSignInTimestamp:(nullable NSNumber *)lastSignInTimestamp;
@property(nonatomic, copy) NSString *uid;
@property(nonatomic, copy, nullable) NSString *email;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, copy, nullable) NSString *photoUrl;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, assign) BOOL isAnonymous;
@property(nonatomic, assign) BOOL isEmailVerified;
@property(nonatomic, copy, nullable) NSString *providerId;
@property(nonatomic, copy, nullable) NSString *tenantId;
@property(nonatomic, copy, nullable) NSString *refreshToken;
@property(nonatomic, strong, nullable) NSNumber *creationTimestamp;
@property(nonatomic, strong, nullable) NSNumber *lastSignInTimestamp;
@end

@interface PigeonUserDetails : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUserInfo:(PigeonUserInfo *)userInfo
                    providerData:(NSArray<NSDictionary<id, id> *> *)providerData;
@property(nonatomic, strong) PigeonUserInfo *userInfo;
@property(nonatomic, copy) NSArray<NSDictionary<id, id> *> *providerData;
@end

@interface PigeonUserCredential : NSObject
+ (instancetype)makeWithUser:(nullable PigeonUserDetails *)user
          additionalUserInfo:(nullable PigeonAdditionalUserInfo *)additionalUserInfo
                  credential:(nullable PigeonAuthCredential *)credential;
@property(nonatomic, strong, nullable) PigeonUserDetails *user;
@property(nonatomic, strong, nullable) PigeonAdditionalUserInfo *additionalUserInfo;
@property(nonatomic, strong, nullable) PigeonAuthCredential *credential;
@end

@interface PigeonActionCodeSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithUrl:(NSString *)url
          dynamicLinkDomain:(nullable NSString *)dynamicLinkDomain
            handleCodeInApp:(BOOL)handleCodeInApp
                iOSBundleId:(nullable NSString *)iOSBundleId
         androidPackageName:(nullable NSString *)androidPackageName
          androidInstallApp:(BOOL)androidInstallApp
      androidMinimumVersion:(nullable NSString *)androidMinimumVersion
                 linkDomain:(nullable NSString *)linkDomain;
@property(nonatomic, copy) NSString *url;
@property(nonatomic, copy, nullable) NSString *dynamicLinkDomain;
@property(nonatomic, assign) BOOL handleCodeInApp;
@property(nonatomic, copy, nullable) NSString *iOSBundleId;
@property(nonatomic, copy, nullable) NSString *androidPackageName;
@property(nonatomic, assign) BOOL androidInstallApp;
@property(nonatomic, copy, nullable) NSString *androidMinimumVersion;
@property(nonatomic, copy, nullable) NSString *linkDomain;
@end

@interface PigeonFirebaseAuthSettings : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithAppVerificationDisabledForTesting:(BOOL)appVerificationDisabledForTesting
                                          userAccessGroup:(nullable NSString *)userAccessGroup
                                              phoneNumber:(nullable NSString *)phoneNumber
                                                  smsCode:(nullable NSString *)smsCode
                                       forceRecaptchaFlow:(nullable NSNumber *)forceRecaptchaFlow;
@property(nonatomic, assign) BOOL appVerificationDisabledForTesting;
@property(nonatomic, copy, nullable) NSString *userAccessGroup;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, copy, nullable) NSString *smsCode;
@property(nonatomic, strong, nullable) NSNumber *forceRecaptchaFlow;
@end

@interface PigeonSignInProvider : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithProviderId:(NSString *)providerId
                            scopes:(nullable NSArray<NSString *> *)scopes
                  customParameters:
                      (nullable NSDictionary<NSString *, NSString *> *)customParameters;
@property(nonatomic, copy) NSString *providerId;
@property(nonatomic, copy, nullable) NSArray<NSString *> *scopes;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, NSString *> *customParameters;
@end

@interface PigeonVerifyPhoneNumberRequest : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithPhoneNumber:(nullable NSString *)phoneNumber
                            timeout:(NSInteger)timeout
                forceResendingToken:(nullable NSNumber *)forceResendingToken
     autoRetrievedSmsCodeForTesting:(nullable NSString *)autoRetrievedSmsCodeForTesting
                  multiFactorInfoId:(nullable NSString *)multiFactorInfoId
               multiFactorSessionId:(nullable NSString *)multiFactorSessionId;
@property(nonatomic, copy, nullable) NSString *phoneNumber;
@property(nonatomic, assign) NSInteger timeout;
@property(nonatomic, strong, nullable) NSNumber *forceResendingToken;
@property(nonatomic, copy, nullable) NSString *autoRetrievedSmsCodeForTesting;
@property(nonatomic, copy, nullable) NSString *multiFactorInfoId;
@property(nonatomic, copy, nullable) NSString *multiFactorSessionId;
@end

@interface PigeonIdTokenResult : NSObject
+ (instancetype)makeWithToken:(nullable NSString *)token
          expirationTimestamp:(nullable NSNumber *)expirationTimestamp
                authTimestamp:(nullable NSNumber *)authTimestamp
            issuedAtTimestamp:(nullable NSNumber *)issuedAtTimestamp
               signInProvider:(nullable NSString *)signInProvider
                       claims:(nullable NSDictionary<NSString *, id> *)claims
           signInSecondFactor:(nullable NSString *)signInSecondFactor;
@property(nonatomic, copy, nullable) NSString *token;
@property(nonatomic, strong, nullable) NSNumber *expirationTimestamp;
@property(nonatomic, strong, nullable) NSNumber *authTimestamp;
@property(nonatomic, strong, nullable) NSNumber *issuedAtTimestamp;
@property(nonatomic, copy, nullable) NSString *signInProvider;
@property(nonatomic, copy, nullable) NSDictionary<NSString *, id> *claims;
@property(nonatomic, copy, nullable) NSString *signInSecondFactor;
@end

@interface PigeonUserProfile : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                           photoUrl:(nullable NSString *)photoUrl
                 displayNameChanged:(BOOL)displayNameChanged
                    photoUrlChanged:(BOOL)photoUrlChanged;
@property(nonatomic, copy, nullable) NSString *displayName;
@property(nonatomic, copy, nullable) NSString *photoUrl;
@property(nonatomic, assign) BOOL displayNameChanged;
@property(nonatomic, assign) BOOL photoUrlChanged;
@end

@interface PigeonTotpSecret : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithCodeIntervalSeconds:(nullable NSNumber *)codeIntervalSeconds
                                 codeLength:(nullable NSNumber *)codeLength
               enrollmentCompletionDeadline:(nullable NSNumber *)enrollmentCompletionDeadline
                           hashingAlgorithm:(nullable NSString *)hashingAlgorithm
                                  secretKey:(NSString *)secretKey;
@property(nonatomic, strong, nullable) NSNumber *codeIntervalSeconds;
@property(nonatomic, strong, nullable) NSNumber *codeLength;
@property(nonatomic, strong, nullable) NSNumber *enrollmentCompletionDeadline;
@property(nonatomic, copy, nullable) NSString *hashingAlgorithm;
@property(nonatomic, copy) NSString *secretKey;
@end

/// The codec used by FirebaseAuthHostApi.
NSObject<FlutterMessageCodec> *FirebaseAuthHostApiGetCodec(void);

@protocol FirebaseAuthHostApi
- (void)registerIdTokenListenerApp:(AuthPigeonFirebaseApp *)app
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)registerAuthStateListenerApp:(AuthPigeonFirebaseApp *)app
                          completion:
                              (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)useEmulatorApp:(AuthPigeonFirebaseApp *)app
                  host:(NSString *)host
                  port:(NSInteger)port
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)applyActionCodeApp:(AuthPigeonFirebaseApp *)app
                      code:(NSString *)code
                completion:(void (^)(FlutterError *_Nullable))completion;
- (void)checkActionCodeApp:(AuthPigeonFirebaseApp *)app
                      code:(NSString *)code
                completion:
                    (void (^)(PigeonActionCodeInfo *_Nullable, FlutterError *_Nullable))completion;
- (void)confirmPasswordResetApp:(AuthPigeonFirebaseApp *)app
                           code:(NSString *)code
                    newPassword:(NSString *)newPassword
                     completion:(void (^)(FlutterError *_Nullable))completion;
- (void)createUserWithEmailAndPasswordApp:(AuthPigeonFirebaseApp *)app
                                    email:(NSString *)email
                                 password:(NSString *)password
                               completion:(void (^)(PigeonUserCredential *_Nullable,
                                                    FlutterError *_Nullable))completion;
- (void)signInAnonymouslyApp:(AuthPigeonFirebaseApp *)app
                  completion:(void (^)(PigeonUserCredential *_Nullable,
                                       FlutterError *_Nullable))completion;
- (void)signInWithCredentialApp:(AuthPigeonFirebaseApp *)app
                          input:(NSDictionary<NSString *, id> *)input
                     completion:(void (^)(PigeonUserCredential *_Nullable,
                                          FlutterError *_Nullable))completion;
- (void)signInWithCustomTokenApp:(AuthPigeonFirebaseApp *)app
                           token:(NSString *)token
                      completion:(void (^)(PigeonUserCredential *_Nullable,
                                           FlutterError *_Nullable))completion;
- (void)signInWithEmailAndPasswordApp:(AuthPigeonFirebaseApp *)app
                                email:(NSString *)email
                             password:(NSString *)password
                           completion:(void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)signInWithEmailLinkApp:(AuthPigeonFirebaseApp *)app
                         email:(NSString *)email
                     emailLink:(NSString *)emailLink
                    completion:(void (^)(PigeonUserCredential *_Nullable,
                                         FlutterError *_Nullable))completion;
- (void)signInWithProviderApp:(AuthPigeonFirebaseApp *)app
               signInProvider:(PigeonSignInProvider *)signInProvider
                   completion:(void (^)(PigeonUserCredential *_Nullable,
                                        FlutterError *_Nullable))completion;
- (void)signOutApp:(AuthPigeonFirebaseApp *)app
        completion:(void (^)(FlutterError *_Nullable))completion;
- (void)fetchSignInMethodsForEmailApp:(AuthPigeonFirebaseApp *)app
                                email:(NSString *)email
                           completion:(void (^)(NSArray<NSString *> *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)sendPasswordResetEmailApp:(AuthPigeonFirebaseApp *)app
                            email:(NSString *)email
               actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                       completion:(void (^)(FlutterError *_Nullable))completion;
- (void)sendSignInLinkToEmailApp:(AuthPigeonFirebaseApp *)app
                           email:(NSString *)email
              actionCodeSettings:(PigeonActionCodeSettings *)actionCodeSettings
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setLanguageCodeApp:(AuthPigeonFirebaseApp *)app
              languageCode:(nullable NSString *)languageCode
                completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)setSettingsApp:(AuthPigeonFirebaseApp *)app
              settings:(PigeonFirebaseAuthSettings *)settings
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)verifyPasswordResetCodeApp:(AuthPigeonFirebaseApp *)app
                              code:(NSString *)code
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)verifyPhoneNumberApp:(AuthPigeonFirebaseApp *)app
                     request:(PigeonVerifyPhoneNumberRequest *)request
                  completion:(void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)revokeTokenWithAuthorizationCodeApp:(AuthPigeonFirebaseApp *)app
                          authorizationCode:(NSString *)authorizationCode
                                 completion:(void (^)(FlutterError *_Nullable))completion;
- (void)initializeRecaptchaConfigApp:(AuthPigeonFirebaseApp *)app
                          completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAuthHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                     NSObject<FirebaseAuthHostApi> *_Nullable api);

extern void SetUpFirebaseAuthHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                               NSObject<FirebaseAuthHostApi> *_Nullable api,
                                               NSString *messageChannelSuffix);

/// The codec used by FirebaseAuthUserHostApi.
NSObject<FlutterMessageCodec> *FirebaseAuthUserHostApiGetCodec(void);

@protocol FirebaseAuthUserHostApi
- (void)deleteApp:(AuthPigeonFirebaseApp *)app
       completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getIdTokenApp:(AuthPigeonFirebaseApp *)app
         forceRefresh:(BOOL)forceRefresh
           completion:(void (^)(PigeonIdTokenResult *_Nullable, FlutterError *_Nullable))completion;
- (void)linkWithCredentialApp:(AuthPigeonFirebaseApp *)app
                        input:(NSDictionary<NSString *, id> *)input
                   completion:(void (^)(PigeonUserCredential *_Nullable,
                                        FlutterError *_Nullable))completion;
- (void)linkWithProviderApp:(AuthPigeonFirebaseApp *)app
             signInProvider:(PigeonSignInProvider *)signInProvider
                 completion:
                     (void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion;
- (void)reauthenticateWithCredentialApp:(AuthPigeonFirebaseApp *)app
                                  input:(NSDictionary<NSString *, id> *)input
                             completion:(void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion;
- (void)reauthenticateWithProviderApp:(AuthPigeonFirebaseApp *)app
                       signInProvider:(PigeonSignInProvider *)signInProvider
                           completion:(void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion;
- (void)reloadApp:(AuthPigeonFirebaseApp *)app
       completion:(void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)sendEmailVerificationApp:(AuthPigeonFirebaseApp *)app
              actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)unlinkApp:(AuthPigeonFirebaseApp *)app
       providerId:(NSString *)providerId
       completion:(void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion;
- (void)updateEmailApp:(AuthPigeonFirebaseApp *)app
              newEmail:(NSString *)newEmail
            completion:(void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updatePasswordApp:(AuthPigeonFirebaseApp *)app
              newPassword:(NSString *)newPassword
               completion:
                   (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updatePhoneNumberApp:(AuthPigeonFirebaseApp *)app
                       input:(NSDictionary<NSString *, id> *)input
                  completion:
                      (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)updateProfileApp:(AuthPigeonFirebaseApp *)app
                 profile:(PigeonUserProfile *)profile
              completion:
                  (void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion;
- (void)verifyBeforeUpdateEmailApp:(AuthPigeonFirebaseApp *)app
                          newEmail:(NSString *)newEmail
                actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                        completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAuthUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                         NSObject<FirebaseAuthUserHostApi> *_Nullable api);

extern void SetUpFirebaseAuthUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                   NSObject<FirebaseAuthUserHostApi> *_Nullable api,
                                                   NSString *messageChannelSuffix);

/// The codec used by MultiFactorUserHostApi.
NSObject<FlutterMessageCodec> *MultiFactorUserHostApiGetCodec(void);

@protocol MultiFactorUserHostApi
- (void)enrollPhoneApp:(AuthPigeonFirebaseApp *)app
             assertion:(PigeonPhoneMultiFactorAssertion *)assertion
           displayName:(nullable NSString *)displayName
            completion:(void (^)(FlutterError *_Nullable))completion;
- (void)enrollTotpApp:(AuthPigeonFirebaseApp *)app
          assertionId:(NSString *)assertionId
          displayName:(nullable NSString *)displayName
           completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getSessionApp:(AuthPigeonFirebaseApp *)app
           completion:
               (void (^)(PigeonMultiFactorSession *_Nullable, FlutterError *_Nullable))completion;
- (void)unenrollApp:(AuthPigeonFirebaseApp *)app
          factorUid:(NSString *)factorUid
         completion:(void (^)(FlutterError *_Nullable))completion;
- (void)getEnrolledFactorsApp:(AuthPigeonFirebaseApp *)app
                   completion:(void (^)(NSArray<PigeonMultiFactorInfo *> *_Nullable,
                                        FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<MultiFactorUserHostApi> *_Nullable api);

extern void SetUpMultiFactorUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                  NSObject<MultiFactorUserHostApi> *_Nullable api,
                                                  NSString *messageChannelSuffix);

/// The codec used by MultiFactoResolverHostApi.
NSObject<FlutterMessageCodec> *MultiFactoResolverHostApiGetCodec(void);

@protocol MultiFactoResolverHostApi
- (void)resolveSignInResolverId:(NSString *)resolverId
                      assertion:(nullable PigeonPhoneMultiFactorAssertion *)assertion
                totpAssertionId:(nullable NSString *)totpAssertionId
                     completion:(void (^)(PigeonUserCredential *_Nullable,
                                          FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactoResolverHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactoResolverHostApi> *_Nullable api);

extern void SetUpMultiFactoResolverHostApiWithSuffix(
    id<FlutterBinaryMessenger> binaryMessenger, NSObject<MultiFactoResolverHostApi> *_Nullable api,
    NSString *messageChannelSuffix);

/// The codec used by MultiFactorTotpHostApi.
NSObject<FlutterMessageCodec> *MultiFactorTotpHostApiGetCodec(void);

@protocol MultiFactorTotpHostApi
- (void)generateSecretSessionId:(NSString *)sessionId
                     completion:
                         (void (^)(PigeonTotpSecret *_Nullable, FlutterError *_Nullable))completion;
- (void)getAssertionForEnrollmentSecretKey:(NSString *)secretKey
                           oneTimePassword:(NSString *)oneTimePassword
                                completion:(void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion;
- (void)getAssertionForSignInEnrollmentId:(NSString *)enrollmentId
                          oneTimePassword:(NSString *)oneTimePassword
                               completion:(void (^)(NSString *_Nullable,
                                                    FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorTotpHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<MultiFactorTotpHostApi> *_Nullable api);

extern void SetUpMultiFactorTotpHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                  NSObject<MultiFactorTotpHostApi> *_Nullable api,
                                                  NSString *messageChannelSuffix);

/// The codec used by MultiFactorTotpSecretHostApi.
NSObject<FlutterMessageCodec> *MultiFactorTotpSecretHostApiGetCodec(void);

@protocol MultiFactorTotpSecretHostApi
- (void)generateQrCodeUrlSecretKey:(NSString *)secretKey
                       accountName:(nullable NSString *)accountName
                            issuer:(nullable NSString *)issuer
                        completion:
                            (void (^)(NSString *_Nullable, FlutterError *_Nullable))completion;
- (void)openInOtpAppSecretKey:(NSString *)secretKey
                    qrCodeUrl:(NSString *)qrCodeUrl
                   completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpMultiFactorTotpSecretHostApi(
    id<FlutterBinaryMessenger> binaryMessenger,
    NSObject<MultiFactorTotpSecretHostApi> *_Nullable api);

extern void SetUpMultiFactorTotpSecretHostApiWithSuffix(
    id<FlutterBinaryMessenger> binaryMessenger,
    NSObject<MultiFactorTotpSecretHostApi> *_Nullable api, NSString *messageChannelSuffix);

/// The codec used by GenerateInterfaces.
NSObject<FlutterMessageCodec> *GenerateInterfacesGetCodec(void);

/// Only used to generate the object interface that are use outside of the Pigeon interface
@protocol GenerateInterfaces
- (void)pigeonInterfaceInfo:(PigeonMultiFactorInfo *)info
                      error:(FlutterError *_Nullable *_Nonnull)error;
@end

extern void SetUpGenerateInterfaces(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<GenerateInterfaces> *_Nullable api);

extern void SetUpGenerateInterfacesWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<GenerateInterfaces> *_Nullable api,
                                              NSString *messageChannelSuffix);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/FLTAuthStateChannelStreamHandler.m

**크기**: 1407 bytes | **라인 수**: 57 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseAuth;
#import "include/Private/FLTAuthStateChannelStreamHandler.h"
#import <FirebaseAuth/FirebaseAuth.h>
#import "include/Private/PigeonParser.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTAuthStateChannelStreamHandler {
  FIRAuth *_auth;
  FIRAuthStateDidChangeListenerHandle _listener;
}

- (instancetype)initWithAuth:(FIRAuth *)auth {
  self = [super init];
  if (self) {
    _auth = auth;
  }
  return self;
}

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
  bool __block initialAuthState = YES;

  _listener = [_auth addAuthStateDidChangeListener:^(FIRAuth *_Nonnull auth,
                                                     FIRUser *_Nullable user) {
    if (initialAuthState) {
      initialAuthState = NO;
      return;
    }

    if (user) {
      events(@{
        @"user" : [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
      });
    } else {
      events(@{
        @"user" : [NSNull null],
      });
    }
  }];

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  if (_listener) {
    [_auth removeAuthStateDidChangeListener:_listener];
  }
  _listener = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/FLTFirebaseAuthPlugin.m

**크기**: 99462 bytes | **라인 수**: 2176 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseAuth;
#import <FirebaseAuth/FirebaseAuth.h>
#import <TargetConditionals.h>
#if __has_include(<firebase_core/FLTFirebasePluginRegistry.h>)
#import <firebase_core/FLTFirebasePluginRegistry.h>
#else
#import <FLTFirebasePluginRegistry.h>
#endif

#import "include/Private/FLTAuthStateChannelStreamHandler.h"
#import "include/Private/FLTIdTokenChannelStreamHandler.h"
#import "include/Private/FLTPhoneNumberVerificationStreamHandler.h"
#import "include/Private/PigeonParser.h"

#import "include/Public/CustomPigeonHeader.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"
@import CommonCrypto;
#import <AuthenticationServices/AuthenticationServices.h>

#if __has_include(<firebase_core/FLTFirebaseCorePlugin.h>)
#import <firebase_core/FLTFirebaseCorePlugin.h>
#else
#import <FLTFirebaseCorePlugin.h>
#endif

NSString *const kFLTFirebaseAuthChannelName = @"plugins.flutter.io/firebase_auth";

// Argument Keys
NSString *const kAppName = @"appName";

// Provider type keys.
NSString *const kSignInMethodPassword = @"password";
NSString *const kSignInMethodEmailLink = @"emailLink";
NSString *const kSignInMethodFacebook = @"facebook.com";
NSString *const kSignInMethodGoogle = @"google.com";
NSString *const kSignInMethodGameCenter = @"gc.apple.com";
NSString *const kSignInMethodTwitter = @"twitter.com";
NSString *const kSignInMethodGithub = @"github.com";
NSString *const kSignInMethodApple = @"apple.com";
NSString *const kSignInMethodPhone = @"phone";
NSString *const kSignInMethodOAuth = @"oauth";

// Credential argument keys.
NSString *const kArgumentCredential = @"credential";
NSString *const kArgumentProviderId = @"providerId";
NSString *const kArgumentProviderScope = @"scopes";
NSString *const kArgumentProviderCustomParameters = @"customParameters";
NSString *const kArgumentSignInMethod = @"signInMethod";
NSString *const kArgumentSecret = @"secret";
NSString *const kArgumentIdToken = @"idToken";
NSString *const kArgumentAccessToken = @"accessToken";
NSString *const kArgumentRawNonce = @"rawNonce";
NSString *const kArgumentEmail = @"email";
NSString *const kArgumentCode = @"code";
NSString *const kArgumentNewEmail = @"newEmail";
NSString *const kArgumentEmailLink = kSignInMethodEmailLink;
NSString *const kArgumentToken = @"token";
NSString *const kArgumentVerificationId = @"verificationId";
NSString *const kArgumentSmsCode = @"smsCode";
NSString *const kArgumentActionCodeSettings = @"actionCodeSettings";
NSString *const kArgumentFamilyName = @"familyName";
NSString *const kArgumentGivenName = @"givenName";
NSString *const kArgumentMiddleName = @"middleName";
NSString *const kArgumentNickname = @"nickname";
NSString *const kArgumentNamePrefix = @"namePrefix";
NSString *const kArgumentNameSuffix = @"nameSuffix";

// MultiFactor
NSString *const kArgumentMultiFactorHints = @"multiFactorHints";
NSString *const kArgumentMultiFactorSessionId = @"multiFactorSessionId";
NSString *const kArgumentMultiFactorResolverId = @"multiFactorResolverId";
NSString *const kArgumentMultiFactorInfo = @"multiFactorInfo";

// Manual error codes & messages.
NSString *const kErrCodeNoCurrentUser = @"no-current-user";
NSString *const kErrMsgNoCurrentUser = @"No user currently signed in.";
NSString *const kErrCodeInvalidCredential = @"invalid-credential";
NSString *const kErrMsgInvalidCredential =
    @"The supplied auth credential is malformed, has expired or is not "
    @"currently supported.";

// Used for caching credentials between Method Channel method calls.
static NSMutableDictionary<NSNumber *, FIRAuthCredential *> *credentialsMap;

@interface FLTFirebaseAuthPlugin ()
@property(nonatomic, retain) NSObject<FlutterBinaryMessenger> *messenger;
@property(strong, nonatomic) FIROAuthProvider *authProvider;
// Used to keep the user who wants to link with Apple Sign In
@property(strong, nonatomic) FIRUser *linkWithAppleUser;
@property(strong, nonatomic) FIRAuth *signInWithAppleAuth;
@property BOOL isReauthenticatingWithApple;
@property(strong, nonatomic) NSString *currentNonce;
@property(strong, nonatomic) void (^appleCompletion)
    (PigeonUserCredential *_Nullable, FlutterError *_Nullable);
@property(strong, nonatomic) AuthPigeonFirebaseApp *appleArguments;

@end

@implementation FLTFirebaseAuthPlugin {
  // Map an id to a MultiFactorSession object.
  NSMutableDictionary<NSString *, FIRMultiFactorSession *> *_multiFactorSessionMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRMultiFactorResolver *> *_multiFactorResolverMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRMultiFactorAssertion *> *_multiFactorAssertionMap;

  // Map an id to a MultiFactorResolver object.
  NSMutableDictionary<NSString *, FIRTOTPSecret *> *_multiFactorTotpSecretMap;

  NSObject<FlutterBinaryMessenger> *_binaryMessenger;
  NSMutableDictionary<NSString *, FlutterEventChannel *> *_eventChannels;
  NSMutableDictionary<NSString *, NSObject<FlutterStreamHandler> *> *_streamHandlers;
  NSData *_apnsToken;
}

#pragma mark - FlutterPlugin

- (instancetype)init:(NSObject<FlutterBinaryMessenger> *)messenger {
  self = [super init];
  if (self) {
    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:self];
    credentialsMap = [NSMutableDictionary<NSNumber *, FIRAuthCredential *> dictionary];
    _binaryMessenger = messenger;
    _eventChannels = [NSMutableDictionary dictionary];
    _streamHandlers = [NSMutableDictionary dictionary];

    _multiFactorSessionMap = [NSMutableDictionary dictionary];
    _multiFactorResolverMap = [NSMutableDictionary dictionary];
    _multiFactorAssertionMap = [NSMutableDictionary dictionary];
    _multiFactorTotpSecretMap = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FlutterMethodChannel *channel =
      [FlutterMethodChannel methodChannelWithName:kFLTFirebaseAuthChannelName
                                  binaryMessenger:[registrar messenger]];
  FLTFirebaseAuthPlugin *instance = [[FLTFirebaseAuthPlugin alloc] init:registrar.messenger];

  [registrar addMethodCallDelegate:instance channel:channel];

  [registrar publish:instance];
  [registrar addApplicationDelegate:instance];
  SetUpFirebaseAuthHostApi(registrar.messenger, instance);
  SetUpFirebaseAuthUserHostApi(registrar.messenger, instance);
  SetUpMultiFactorUserHostApi(registrar.messenger, instance);
  SetUpMultiFactoResolverHostApi(registrar.messenger, instance);
  SetUpMultiFactorTotpHostApi(registrar.messenger, instance);
  SetUpMultiFactorTotpSecretHostApi(registrar.messenger, instance);
}

+ (FlutterError *)convertToFlutterError:(NSError *)error {
  NSString *code = @"unknown";
  NSString *message = @"An unknown error has occurred.";

  if (error == nil) {
    return [FlutterError errorWithCode:code message:message details:@{}];
  }

  // code
  if ([error userInfo][FIRAuthErrorUserInfoNameKey] != nil) {
    // See [FIRAuthErrorCodeString] for list of codes.
    // Codes are in the format "ERROR_SOME_NAME", converting below to the format
    // required in Dart. ERROR_SOME_NAME -> SOME_NAME
    NSString *firebaseErrorCode = [error userInfo][FIRAuthErrorUserInfoNameKey];
    code = [firebaseErrorCode stringByReplacingOccurrencesOfString:@"ERROR_" withString:@""];
    // SOME_NAME -> SOME-NAME
    code = [code stringByReplacingOccurrencesOfString:@"_" withString:@"-"];
    // SOME-NAME -> some-name
    code = [code lowercaseString];
  }

  // message
  if ([error userInfo][NSLocalizedDescriptionKey] != nil) {
    message = [error userInfo][NSLocalizedDescriptionKey];
  }

  NSMutableDictionary *additionalData = [NSMutableDictionary dictionary];
  // additionalData.email
  if ([error userInfo][FIRAuthErrorUserInfoEmailKey] != nil) {
    additionalData[kArgumentEmail] = [error userInfo][FIRAuthErrorUserInfoEmailKey];
  }
  // We want to store the credential if present for future sign in if the exception contains a
  // credential, we pass a token back to Flutter to allow retrieval of the credential.
  NSNumber *token = [FLTFirebaseAuthPlugin storeAuthCredentialIfPresent:error];

  // additionalData.authCredential
  if ([error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey] != nil) {
    FIRAuthCredential *authCredential = [error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey];
    additionalData[@"authCredential"] = [PigeonParser getPigeonAuthCredential:authCredential
                                                                        token:token];
  }

  // Manual message overrides to ensure messages/codes matches other platforms.
  if ([message isEqual:@"The password must be 6 characters long or more."]) {
    message = @"Password should be at least 6 characters";
  }

  return [FlutterError errorWithCode:code message:message details:additionalData];
}

+ (id)getNSDictionaryFromAuthCredential:(FIRAuthCredential *)authCredential {
  if (authCredential == nil) {
    return [NSNull null];
  }

  NSString *accessToken = nil;
  if ([authCredential isKindOfClass:[FIROAuthCredential class]]) {
    if (((FIROAuthCredential *)authCredential).accessToken != nil) {
      accessToken = ((FIROAuthCredential *)authCredential).accessToken;
    } else if (((FIROAuthCredential *)authCredential).IDToken != nil) {
      // For Sign In With Apple, the token is stored in IDToken
      accessToken = ((FIROAuthCredential *)authCredential).IDToken;
    }
  }

  return @{
    kArgumentProviderId : authCredential.provider,
    // Note: "signInMethod" does not exist on iOS SDK, so using provider
    // instead.
    kArgumentSignInMethod : authCredential.provider,
    kArgumentToken : @([authCredential hash]),
    kArgumentAccessToken : accessToken ?: [NSNull null],
  };
}

- (void)cleanupWithCompletion:(void (^)(void))completion {
  // Cleanup credentials.
  [credentialsMap removeAllObjects];

  for (FlutterEventChannel *channel in self->_eventChannels.allValues) {
    [channel setStreamHandler:nil];
  }
  [self->_eventChannels removeAllObjects];
  for (NSObject<FlutterStreamHandler> *handler in self->_streamHandlers.allValues) {
    [handler onCancelWithArguments:nil];
  }
  [self->_streamHandlers removeAllObjects];

  if (completion != nil) completion();
}

- (void)detachFromEngineForRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  [self cleanupWithCompletion:nil];
}

#pragma mark - AppDelegate

#if TARGET_OS_IPHONE
#if !__has_include(<FirebaseMessaging/FirebaseMessaging.h>)
- (BOOL)application:(UIApplication *)application
    didReceiveRemoteNotification:(NSDictionary *)notification
          fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler {
  if ([[FIRAuth auth] canHandleNotification:notification]) {
    completionHandler(UIBackgroundFetchResultNoData);
    return YES;
  }
  return NO;
}
#endif

- (void)application:(UIApplication *)application
    didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  _apnsToken = deviceToken;
}

- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary *)options {
  return [[FIRAuth auth] canHandleURL:url];
}
#endif

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion {
  [self cleanupWithCompletion:completion];
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  return kFLTFirebaseAuthChannelName;
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp {
  FIRAuth *auth = [FIRAuth authWithApp:firebaseApp];
  return @{
    @"APP_LANGUAGE_CODE" : (id)[auth languageCode] ?: [NSNull null],
    @"APP_CURRENT_USER" : [auth currentUser]
        ? [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
        : [NSNull null],
  };
}

#pragma mark - Firebase Auth API

// Adapted from
// https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce Used
// for Apple Sign In
- (NSString *)randomNonce:(NSInteger)length {
  NSAssert(length > 0, @"Expected nonce to have positive length");
  NSString *characterSet = @"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._";
  NSMutableString *result = [NSMutableString string];
  NSInteger remainingLength = length;

  while (remainingLength > 0) {
    NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];
    for (NSInteger i = 0; i < 16; i++) {
      uint8_t random = 0;
      int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);
      NSAssert(errorCode == errSecSuccess, @"Unable to generate nonce: OSStatus %i", errorCode);

      [randoms addObject:@(random)];
    }

    for (NSNumber *random in randoms) {
      if (remainingLength == 0) {
        break;
      }

      if (random.unsignedIntValue < characterSet.length) {
        unichar character = [characterSet characterAtIndex:random.unsignedIntValue];
        [result appendFormat:@"%C", character];
        remainingLength--;
      }
    }
  }

  return [result copy];
}

- (NSString *)stringBySha256HashingString:(NSString *)input {
  const char *string = [input UTF8String];
  unsigned char result[CC_SHA256_DIGEST_LENGTH];
  CC_SHA256(string, (CC_LONG)strlen(string), result);

  NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2];
  for (NSInteger i = 0; i < CC_SHA256_DIGEST_LENGTH; i++) {
    [hashed appendFormat:@"%02x", result[i]];
  }
  return hashed;
}

static void handleSignInWithApple(FLTFirebaseAuthPlugin *object, FIRAuthDataResult *authResult,
                                  NSString *authorizationCode, NSError *error) {
  void (^completion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
      object.appleCompletion;
  if (completion == nil) return;

  if (error != nil) {
    if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
      [object handleMultiFactorError:object.appleArguments completion:completion withError:error];
    } else {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    }
    return;
  }
  completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                               authorizationCode:authorizationCode],
             nil);
}

- (void)authorizationController:(ASAuthorizationController *)controller
    didCompleteWithAuthorization:(ASAuthorization *)authorization
    API_AVAILABLE(macos(10.15), ios(13.0)) {
  if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {
    ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;
    NSString *rawNonce = self.currentNonce;
    NSAssert(rawNonce != nil,
             @"Invalid state: A login callback was received, but no login request was sent.");

    if (appleIDCredential.identityToken == nil) {
      NSLog(@"Unable to fetch identity token.");
      return;
    }

    NSString *idToken = [[NSString alloc] initWithData:appleIDCredential.identityToken
                                              encoding:NSUTF8StringEncoding];
    if (idToken == nil) {
      NSLog(@"Unable to serialize id token from data: %@", appleIDCredential.identityToken);
    }

    NSString *authorizationCode = nil;
    if (appleIDCredential.authorizationCode != nil) {
      authorizationCode = [[NSString alloc] initWithData:appleIDCredential.authorizationCode
                                                encoding:NSUTF8StringEncoding];
    }

    FIROAuthCredential *credential =
        [FIROAuthProvider appleCredentialWithIDToken:idToken
                                            rawNonce:rawNonce
                                            fullName:appleIDCredential.fullName];

    if (self.isReauthenticatingWithApple == YES) {
      self.isReauthenticatingWithApple = NO;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [[FIRAuth.auth currentUser]
          reauthenticateWithCredential:credential
                            completion:^(FIRAuthDataResult *_Nullable authResult,
                                         NSError *_Nullable error) {
                              handleSignInWithApple(self, authResult, authorizationCode, error);
                            }];

    } else if (self.linkWithAppleUser != nil) {
      FIRUser *userToLink = self.linkWithAppleUser;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [userToLink linkWithCredential:credential
                          completion:^(FIRAuthDataResult *authResult, NSError *error) {
                            self.linkWithAppleUser = nil;
                            handleSignInWithApple(self, authResult, authorizationCode, error);
                          }];

    } else {
      FIRAuth *signInAuth =
          self.signInWithAppleAuth != nil ? self.signInWithAppleAuth : FIRAuth.auth;
      void (^capturedCompletion)(PigeonUserCredential *_Nullable, FlutterError *_Nullable) =
          self.appleCompletion;
      [signInAuth signInWithCredential:credential
                            completion:^(FIRAuthDataResult *_Nullable authResult,
                                         NSError *_Nullable error) {
                              self.signInWithAppleAuth = nil;
                              handleSignInWithApple(self, authResult, authorizationCode, error);
                            }];
    }
  }
}

- (void)authorizationController:(ASAuthorizationController *)controller
           didCompleteWithError:(NSError *)error API_AVAILABLE(macos(10.15), ios(13.0)) {
  NSLog(@"Sign in with Apple errored: %@", error);
  switch (error.code) {
    case ASAuthorizationErrorCanceled:
      self.appleCompletion(
          nil, [FlutterError errorWithCode:@"canceled"
                                   message:@"The user canceled the authorization attempt."
                                   details:nil]);
      break;

    case ASAuthorizationErrorInvalidResponse:
      self.appleCompletion(
          nil,
          [FlutterError errorWithCode:@"invalid-response"
                              message:@"The authorization request received an invalid response."
                              details:nil]);
      break;

    case ASAuthorizationErrorNotHandled:
      self.appleCompletion(nil,
                           [FlutterError errorWithCode:@"not-handled"
                                               message:@"The authorization request wasn’t handled."
                                               details:nil]);
      break;

    case ASAuthorizationErrorFailed:
      self.appleCompletion(nil, [FlutterError errorWithCode:@"failed"
                                                    message:@"The authorization attempt failed."
                                                    details:nil]);
      break;

    case ASAuthorizationErrorUnknown:
    default:
      self.appleCompletion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
      break;
  }
  self.appleCompletion = nil;
}

- (void)handleInternalError:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                              FlutterError *_Nullable))completion
                  withError:(NSError *)error {
  const NSError *underlyingError = error.userInfo[@"NSUnderlyingError"];
  if (underlyingError != nil) {
    const NSDictionary *details =
        underlyingError.userInfo[@"FIRAuthErrorUserInfoDeserializedResponseKey"];
    completion(nil, [FlutterError errorWithCode:@"internal-error"
                                        message:error.description
                                        details:details]);
    return;
  }
  completion(nil, [FlutterError errorWithCode:@"internal-error"
                                      message:error.description
                                      details:nil]);
}

- (void)handleMultiFactorError:(AuthPigeonFirebaseApp *)app
                    completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                 FlutterError *_Nullable))completion
                     withError:(NSError *_Nullable)error {
  FIRMultiFactorResolver *resolver =
      (FIRMultiFactorResolver *)error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];

  NSArray<FIRMultiFactorInfo *> *hints = resolver.hints;
  FIRMultiFactorSession *session = resolver.session;

  NSString *sessionId = [[NSUUID UUID] UUIDString];
  self->_multiFactorSessionMap[sessionId] = session;

  NSString *resolverId = [[NSUUID UUID] UUIDString];
  self->_multiFactorResolverMap[resolverId] = resolver;

  NSMutableArray<NSDictionary *> *pigeonHints = [NSMutableArray array];

  for (FIRMultiFactorInfo *multiFactorInfo in hints) {
    NSString *phoneNumber;
    if ([multiFactorInfo class] == [FIRPhoneMultiFactorInfo class]) {
      FIRPhoneMultiFactorInfo *phoneFactorInfo = (FIRPhoneMultiFactorInfo *)multiFactorInfo;
      phoneNumber = phoneFactorInfo.phoneNumber;
    }

    PigeonMultiFactorInfo *object = [PigeonMultiFactorInfo
        makeWithDisplayName:multiFactorInfo.displayName
        enrollmentTimestamp:multiFactorInfo.enrollmentDate.timeIntervalSince1970
                   factorId:multiFactorInfo.factorID
                        uid:multiFactorInfo.UID
                phoneNumber:phoneNumber];

    [pigeonHints addObject:object.toList];
  }

  NSDictionary *output = @{
    kAppName : app.appName,
    kArgumentMultiFactorHints : pigeonHints,
    kArgumentMultiFactorSessionId : sessionId,
    kArgumentMultiFactorResolverId : resolverId,
  };
  completion(nil, [FlutterError errorWithCode:@"second-factor-required"
                                      message:error.description
                                      details:output]);
}

static void launchAppleSignInRequest(FLTFirebaseAuthPlugin *object, AuthPigeonFirebaseApp *app,
                                     PigeonSignInProvider *signInProvider,
                                     void (^_Nonnull completion)(PigeonUserCredential *_Nullable,
                                                                 FlutterError *_Nullable)) {
  if (@available(iOS 13.0, macOS 10.15, *)) {
    NSString *nonce = [object randomNonce:32];
    object.currentNonce = nonce;
    object.appleCompletion = completion;
    object.appleArguments = app;

    ASAuthorizationAppleIDProvider *appleIDProvider = [[ASAuthorizationAppleIDProvider alloc] init];

    ASAuthorizationAppleIDRequest *request = [appleIDProvider createRequest];
    NSMutableArray *requestedScopes = [NSMutableArray arrayWithCapacity:2];
    if ([signInProvider.scopes containsObject:@"name"]) {
      [requestedScopes addObject:ASAuthorizationScopeFullName];
    }
    if ([signInProvider.scopes containsObject:@"email"]) {
      [requestedScopes addObject:ASAuthorizationScopeEmail];
    }
    request.requestedScopes = [requestedScopes copy];
    request.nonce = [object stringBySha256HashingString:nonce];

    ASAuthorizationController *authorizationController =
        [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[ request ]];
    authorizationController.delegate = object;
    authorizationController.presentationContextProvider = object;
    [authorizationController performRequests];
  } else {
    NSLog(@"Sign in with Apple was introduced in iOS 13, update your Podfile with platform :ios, "
          @"'13.0'");
  }
}

static void handleAppleAuthResult(FLTFirebaseAuthPlugin *object, AuthPigeonFirebaseApp *app,
                                  FIRAuth *auth, FIRAuthCredential *credentials, NSError *error,
                                  void (^_Nonnull completion)(PigeonUserCredential *_Nullable,
                                                              FlutterError *_Nullable)) {
  if (error) {
    if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
      [object handleMultiFactorError:app completion:completion withError:error];
    } else {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    }
    return;
  }
  if (credentials) {
    [auth
        signInWithCredential:credentials
                  completion:^(FIRAuthDataResult *authResult, NSError *error) {
                    if (error != nil) {
                      NSDictionary *userInfo = [error userInfo];
                      NSError *underlyingError = [userInfo objectForKey:NSUnderlyingErrorKey];

                      NSDictionary *firebaseDictionary =
                          underlyingError.userInfo[@"FIRAuthErrorUserInfoDes"
                                                   @"erializedResponseKey"];

                      NSString *errorCode = userInfo[@"FIRAuthErrorUserInfoNameKey"];

                      if (firebaseDictionary == nil && errorCode != nil) {
                        if ([errorCode isEqual:@"ERROR_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL"]) {
                          completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                          return;
                        }

                        // Removing since it's not parsed and causing issue when sending back the
                        // object to Flutter
                        NSMutableDictionary *mutableUserInfo = [userInfo mutableCopy];
                        [mutableUserInfo
                            removeObjectForKey:@"FIRAuthErrorUserInfoUpdatedCredentialKey"];
                        NSError *modifiedError = [NSError errorWithDomain:error.domain
                                                                     code:error.code
                                                                 userInfo:mutableUserInfo];

                        completion(nil,
                                   [FlutterError errorWithCode:@"sign-in-failed"
                                                       message:userInfo[@"NSLocalizedDescription"]
                                                       details:modifiedError.userInfo]);

                      } else if (firebaseDictionary != nil &&
                                 firebaseDictionary[@"message"] != nil) {
                        // error from firebase-ios-sdk is
                        // buried in underlying error.
                        completion(nil,
                                   [FlutterError errorWithCode:@"sign-in-failed"
                                                       message:error.localizedDescription
                                                       details:firebaseDictionary[@"message"]]);
                      } else {
                        completion(nil, [FlutterError errorWithCode:@"sign-in-failed"
                                                            message:error.localizedDescription
                                                            details:error.userInfo]);
                      }
                    } else {
                      completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                   authorizationCode:nil],
                                 nil);
                    }
                  }];
  }
}

#pragma mark - Utilities

+ (NSNumber *_Nullable)storeAuthCredentialIfPresent:(NSError *)error {
  if ([error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey] != nil) {
    FIRAuthCredential *authCredential = [error userInfo][FIRAuthErrorUserInfoUpdatedCredentialKey];
    // We temporarily store the non-serializable credential so the
    // Dart API can consume these at a later time.
    NSNumber *authCredentialHash = @([authCredential hash]);
    credentialsMap[authCredentialHash] = authCredential;
    return authCredentialHash;
  }
  return nil;
}

- (FIRAuth *_Nullable)getFIRAuthFromAppNameFromPigeon:(AuthPigeonFirebaseApp *)pigeonApp {
  FIRApp *app = [FLTFirebasePlugin firebaseAppNamed:pigeonApp.appName];
  FIRAuth *auth = [FIRAuth authWithApp:app];

  auth.tenantID = pigeonApp.tenantId;
  auth.customAuthDomain = [FLTFirebaseCorePlugin getCustomDomain:app.name];
  // Auth's `customAuthDomain` supersedes value from `getCustomDomain` set by `initializeApp`
  if (pigeonApp.customAuthDomain != nil) {
    auth.customAuthDomain = pigeonApp.customAuthDomain;
  }

  return auth;
}

- (void)getFIRAuthCredentialFromArguments:(NSDictionary *)arguments
                                      app:(AuthPigeonFirebaseApp *)app
                               completion:(void (^)(FIRAuthCredential *credential,
                                                    NSError *error))completion {
  // If the credential dictionary contains a token, it means a native one has
  // been stored for later usage, so we'll attempt to retrieve it here.
  if (arguments[kArgumentToken] != nil && ![arguments[kArgumentToken] isEqual:[NSNull null]]) {
    NSNumber *credentialHashCode = arguments[kArgumentToken];
    if (credentialsMap[credentialHashCode] != nil) {
      completion(credentialsMap[credentialHashCode], nil);
      return;
    }
  }

  NSString *signInMethod = arguments[kArgumentSignInMethod];

  if ([signInMethod isEqualToString:kSignInMethodGameCenter]) {
    // Game Center Games is different to other providers, it requires below callback to get a
    // credential. This is why getFIRAuthCredentialFromArguments now requires a completion()
    // callback
    [FIRGameCenterAuthProvider
        getCredentialWithCompletion:^(FIRAuthCredential *credential, NSError *error) {
          if (error) {
            completion(nil, error);
          } else {
            completion(credential, nil);
          }
        }];
    return;
  }

  NSString *secret = arguments[kArgumentSecret] == [NSNull null] ? nil : arguments[kArgumentSecret];
  NSString *idToken =
      arguments[kArgumentIdToken] == [NSNull null] ? nil : arguments[kArgumentIdToken];
  NSString *accessToken =
      arguments[kArgumentAccessToken] == [NSNull null] ? nil : arguments[kArgumentAccessToken];
  NSString *rawNonce =
      arguments[kArgumentRawNonce] == [NSNull null] ? nil : arguments[kArgumentRawNonce];

  // Password Auth
  if ([signInMethod isEqualToString:kSignInMethodPassword]) {
    NSString *email = arguments[kArgumentEmail];
    completion([FIREmailAuthProvider credentialWithEmail:email password:secret], nil);
    return;
  }

  // Email Link Auth
  if ([signInMethod isEqualToString:kSignInMethodEmailLink]) {
    NSString *email = arguments[kArgumentEmail];
    NSString *emailLink = arguments[kArgumentEmailLink];
    completion([FIREmailAuthProvider credentialWithEmail:email link:emailLink], nil);
    return;
  }

  // Facebook Auth
  if ([signInMethod isEqualToString:kSignInMethodFacebook]) {
    completion([FIRFacebookAuthProvider credentialWithAccessToken:accessToken], nil);
    return;
  }

  // Google Auth
  if ([signInMethod isEqualToString:kSignInMethodGoogle]) {
    completion([FIRGoogleAuthProvider credentialWithIDToken:idToken accessToken:accessToken], nil);
    return;
  }

  // Twitter Auth
  if ([signInMethod isEqualToString:kSignInMethodTwitter]) {
    completion([FIRTwitterAuthProvider credentialWithToken:accessToken secret:secret], nil);
    return;
  }

  // GitHub Auth
  if ([signInMethod isEqualToString:kSignInMethodGithub]) {
    completion([FIRGitHubAuthProvider credentialWithToken:accessToken], nil);
    return;
  }

  // Phone Auth - Only supported on iOS
  if ([signInMethod isEqualToString:kSignInMethodPhone]) {
#if TARGET_OS_IPHONE
    NSString *verificationId = arguments[kArgumentVerificationId];
    NSString *smsCode = arguments[kArgumentSmsCode];
    completion([[FIRPhoneAuthProvider providerWithAuth:[self getFIRAuthFromAppNameFromPigeon:app]]
                   credentialWithVerificationID:verificationId
                               verificationCode:smsCode],
               nil);
    return;
#else
    NSLog(@"The Firebase Phone Authentication provider is not supported on the "
          @"MacOS platform.");
    completion(nil, nil);
    return;
#endif
  }
  // Apple Auth
  if ([signInMethod isEqualToString:kSignInMethodApple]) {
    if (idToken && rawNonce) {
      // Credential with idToken, rawNonce and fullName
      NSPersonNameComponents *fullName = [[NSPersonNameComponents alloc] init];
      fullName.givenName =
          arguments[kArgumentGivenName] == [NSNull null] ? nil : arguments[kArgumentGivenName];
      fullName.familyName =
          arguments[kArgumentFamilyName] == [NSNull null] ? nil : arguments[kArgumentFamilyName];
      fullName.nickname =
          arguments[kArgumentNickname] == [NSNull null] ? nil : arguments[kArgumentNickname];
      fullName.namePrefix =
          arguments[kArgumentNamePrefix] == [NSNull null] ? nil : arguments[kArgumentNamePrefix];
      fullName.nameSuffix =
          arguments[kArgumentNameSuffix] == [NSNull null] ? nil : arguments[kArgumentNameSuffix];
      fullName.middleName =
          arguments[kArgumentMiddleName] == [NSNull null] ? nil : arguments[kArgumentMiddleName];

      completion([FIROAuthProvider appleCredentialWithIDToken:idToken
                                                     rawNonce:rawNonce
                                                     fullName:fullName],
                 nil);
      return;
    }
  }
  // OAuth
  if ([signInMethod isEqualToString:kSignInMethodOAuth]) {
    NSString *providerId = arguments[kArgumentProviderId];
    completion([FIROAuthProvider credentialWithProviderID:providerId
                                                  IDToken:idToken
                                                 rawNonce:rawNonce
                                              accessToken:accessToken],
               nil);
    return;
  }

  NSLog(@"Support for an auth provider with identifier '%@' is not implemented.", signInMethod);
  completion(nil, nil);
  return;
}

- (void)ensureAPNSTokenSetting {
#if !TARGET_OS_OSX
  FIRApp *defaultApp = [FIRApp defaultApp];
  if (defaultApp) {
    if ([FIRAuth auth].APNSToken == nil && _apnsToken != nil) {
      [[FIRAuth auth] setAPNSToken:_apnsToken type:FIRAuthAPNSTokenTypeUnknown];
      _apnsToken = nil;
    }
  }
#endif
}

- (FIRMultiFactor *)getAppMultiFactorFromPigeon:(nonnull AuthPigeonFirebaseApp *)app {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  return currentUser.multiFactor;
}

- (nonnull ASPresentationAnchor)presentationAnchorForAuthorizationController:
    (nonnull ASAuthorizationController *)controller API_AVAILABLE(macos(10.15), ios(13.0)) {
#if TARGET_OS_OSX
  return [[NSApplication sharedApplication] keyWindow];
#else
  return [[UIApplication sharedApplication] keyWindow];
#endif
}

- (void)enrollPhoneApp:(nonnull AuthPigeonFirebaseApp *)app
             assertion:(nonnull PigeonPhoneMultiFactorAssertion *)assertion
           displayName:(nullable NSString *)displayName
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  completion([FlutterError errorWithCode:@"unsupported-platform"
                                 message:@"Phone authentication is not supported on macOS"
                                 details:nil]);
#else

  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  FIRPhoneAuthCredential *credential =
      [[FIRPhoneAuthProvider providerWithAuth:[self getFIRAuthFromAppNameFromPigeon:app]]
          credentialWithVerificationID:[assertion verificationId]
                      verificationCode:[assertion verificationCode]];

  FIRMultiFactorAssertion *multiFactorAssertion =
      [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];

  [multiFactor enrollWithAssertion:multiFactorAssertion
                       displayName:displayName
                        completion:^(NSError *_Nullable error) {
                          if (error == nil) {
                            completion(nil);
                          } else {
                            completion([FlutterError errorWithCode:@"enroll-failed"
                                                           message:error.localizedDescription
                                                           details:nil]);
                          }
                        }];
#endif
}

- (void)getEnrolledFactorsApp:(nonnull AuthPigeonFirebaseApp *)app
                   completion:(nonnull void (^)(NSArray<PigeonMultiFactorInfo *> *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  NSArray<FIRMultiFactorInfo *> *enrolledFactors = [multiFactor enrolledFactors];

  NSMutableArray<PigeonMultiFactorInfo *> *results = [NSMutableArray array];

  for (FIRMultiFactorInfo *multiFactorInfo in enrolledFactors) {
    NSString *phoneNumber;
    if ([multiFactorInfo class] == [FIRPhoneMultiFactorInfo class]) {
      FIRPhoneMultiFactorInfo *phoneFactorInfo = (FIRPhoneMultiFactorInfo *)multiFactorInfo;
      phoneNumber = phoneFactorInfo.phoneNumber;
    }

    [results addObject:[PigeonMultiFactorInfo
                           makeWithDisplayName:multiFactorInfo.displayName
                           enrollmentTimestamp:multiFactorInfo.enrollmentDate.timeIntervalSince1970
                                      factorId:multiFactorInfo.factorID
                                           uid:multiFactorInfo.UID
                                   phoneNumber:phoneNumber]];
  }

  completion(results, nil);
}

- (void)getSessionApp:(nonnull AuthPigeonFirebaseApp *)app
           completion:(nonnull void (^)(PigeonMultiFactorSession *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];
  [multiFactor getSessionWithCompletion:^(FIRMultiFactorSession *_Nullable session,
                                          NSError *_Nullable error) {
    NSString *UUID = [[NSUUID UUID] UUIDString];
    self->_multiFactorSessionMap[UUID] = session;

    PigeonMultiFactorSession *pigeonSession = [PigeonMultiFactorSession makeWithId:UUID];
    completion(pigeonSession, nil);
  }];
}

- (void)unenrollApp:(nonnull AuthPigeonFirebaseApp *)app
          factorUid:(nonnull NSString *)factorUid
         completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];
  [multiFactor unenrollWithFactorUID:factorUid
                          completion:^(NSError *_Nullable error) {
                            if (error == nil) {
                              completion(nil);
                            } else {
                              completion([FlutterError errorWithCode:@"unenroll-failed"
                                                             message:error.localizedDescription
                                                             details:nil]);
                            }
                          }];
}

- (void)enrollTotpApp:(nonnull AuthPigeonFirebaseApp *)app
          assertionId:(nonnull NSString *)assertionId
          displayName:(nullable NSString *)displayName
           completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRMultiFactor *multiFactor = [self getAppMultiFactorFromPigeon:app];

  FIRMultiFactorAssertion *assertion = _multiFactorAssertionMap[assertionId];

  [multiFactor enrollWithAssertion:assertion
                       displayName:displayName
                        completion:^(NSError *_Nullable error) {
                          if (error == nil) {
                            completion(nil);
                          } else {
                            completion([FlutterError errorWithCode:@"enroll-failed"
                                                           message:error.localizedDescription
                                                           details:nil]);
                          }
                        }];
}

- (void)resolveSignInResolverId:(nonnull NSString *)resolverId
                      assertion:(nullable PigeonPhoneMultiFactorAssertion *)assertion
                totpAssertionId:(nullable NSString *)totpAssertionId
                     completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRMultiFactorResolver *resolver = _multiFactorResolverMap[resolverId];

  FIRMultiFactorAssertion *multiFactorAssertion;

  if (assertion != nil) {
#if TARGET_OS_IPHONE
    FIRPhoneAuthCredential *credential =
        [[FIRPhoneAuthProvider provider] credentialWithVerificationID:[assertion verificationId]
                                                     verificationCode:[assertion verificationCode]];
    multiFactorAssertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];
#endif
  } else if (totpAssertionId != nil) {
    multiFactorAssertion = _multiFactorAssertionMap[totpAssertionId];
  } else {
    completion(nil,
               [FlutterError errorWithCode:@"resolve-signin-failed"
                                   message:@"Neither assertion nor totpAssertionId were provided"
                                   details:nil]);
    return;
  }

  [resolver
      resolveSignInWithAssertion:multiFactorAssertion
                      completion:^(FIRAuthDataResult *_Nullable authResult,
                                   NSError *_Nullable error) {
                        if (error == nil) {
                          completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                       authorizationCode:nil],
                                     nil);
                        } else {
                          completion(nil, [FlutterError errorWithCode:@"resolve-signin-failed"
                                                              message:error.localizedDescription
                                                              details:nil]);
                        }
                      }];
}

- (void)generateSecretSessionId:(nonnull NSString *)sessionId
                     completion:(nonnull void (^)(PigeonTotpSecret *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRMultiFactorSession *multiFactorSession = _multiFactorSessionMap[sessionId];

  [FIRTOTPMultiFactorGenerator
      generateSecretWithMultiFactorSession:multiFactorSession
                                completion:^(FIRTOTPSecret *_Nullable secret,
                                             NSError *_Nullable error) {
                                  if (error == nil) {
                                    self->_multiFactorTotpSecretMap[secret.sharedSecretKey] =
                                        secret;
                                    completion([PigeonParser getPigeonTotpSecret:secret], nil);
                                  } else {
                                    completion(
                                        nil, [FlutterError errorWithCode:@"generate-secret-failed"
                                                                 message:error.localizedDescription
                                                                 details:nil]);
                                  }
                                }];
}

- (void)getAssertionForEnrollmentSecretKey:(nonnull NSString *)secretKey
                           oneTimePassword:(nonnull NSString *)oneTimePassword
                                completion:(nonnull void (^)(NSString *_Nullable,
                                                             FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];

  FIRTOTPMultiFactorAssertion *assertion =
      [FIRTOTPMultiFactorGenerator assertionForEnrollmentWithSecret:totpSecret
                                                    oneTimePassword:oneTimePassword];

  NSString *UUID = [[NSUUID UUID] UUIDString];
  self->_multiFactorAssertionMap[UUID] = assertion;
  completion(UUID, nil);
}

- (void)getAssertionForSignInEnrollmentId:(nonnull NSString *)enrollmentId
                          oneTimePassword:(nonnull NSString *)oneTimePassword
                               completion:(nonnull void (^)(NSString *_Nullable,
                                                            FlutterError *_Nullable))completion {
  FIRTOTPMultiFactorAssertion *assertion =
      [FIRTOTPMultiFactorGenerator assertionForSignInWithEnrollmentID:enrollmentId
                                                      oneTimePassword:oneTimePassword];
  NSString *UUID = [[NSUUID UUID] UUIDString];
  self->_multiFactorAssertionMap[UUID] = assertion;
  completion(UUID, nil);
}

- (void)generateQrCodeUrlSecretKey:(nonnull NSString *)secretKey
                       accountName:(nullable NSString *)accountName
                            issuer:(nullable NSString *)issuer
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];
  completion([totpSecret generateQRCodeURLWithAccountName:accountName issuer:issuer], nil);
}

- (void)openInOtpAppSecretKey:(nonnull NSString *)secretKey
                    qrCodeUrl:(nonnull NSString *)qrCodeUrl
                   completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRTOTPSecret *totpSecret = _multiFactorTotpSecretMap[secretKey];
  [totpSecret openInOTPAppWithQRCodeURL:qrCodeUrl];
  completion(nil);
}

- (void)applyActionCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                      code:(nonnull NSString *)code
                completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth applyActionCode:code
             completion:^(NSError *_Nullable error) {
               if (error != nil) {
                 completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
               } else {
                 completion(nil);
               }
             }];
}

- (void)revokeTokenWithAuthorizationCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                          authorizationCode:(nonnull NSString *)authorizationCode
                                 completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth revokeTokenWithAuthorizationCode:authorizationCode
                              completion:^(NSError *_Nullable error) {
                                if (error != nil) {
                                  completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                } else {
                                  completion(nil);
                                }
                              }];
}

- (void)checkActionCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                      code:(nonnull NSString *)code
                completion:(nonnull void (^)(PigeonActionCodeInfo *_Nullable,
                                             FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth checkActionCode:code
             completion:^(FIRActionCodeInfo *_Nullable info, NSError *_Nullable error) {
               if (error != nil) {
                 completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
               } else {
                 completion([self parseActionCode:info], nil);
               }
             }];
}

- (PigeonActionCodeInfo *_Nullable)parseActionCode:(nonnull FIRActionCodeInfo *)info {
  PigeonActionCodeInfoData *data = [PigeonActionCodeInfoData makeWithEmail:info.email
                                                             previousEmail:info.previousEmail];

  ActionCodeInfoOperation operation;

  if (info.operation == FIRActionCodeOperationPasswordReset) {
    operation = ActionCodeInfoOperationPasswordReset;
  } else if (info.operation == FIRActionCodeOperationVerifyEmail) {
    operation = ActionCodeInfoOperationVerifyEmail;
  } else if (info.operation == FIRActionCodeOperationRecoverEmail) {
    operation = ActionCodeInfoOperationRecoverEmail;
  } else if (info.operation == FIRActionCodeOperationEmailLink) {
    operation = ActionCodeInfoOperationEmailSignIn;
  } else if (info.operation == FIRActionCodeOperationVerifyAndChangeEmail) {
    operation = ActionCodeInfoOperationVerifyAndChangeEmail;
  } else if (info.operation == FIRActionCodeOperationRevertSecondFactorAddition) {
    operation = ActionCodeInfoOperationRevertSecondFactorAddition;
  } else {
    operation = ActionCodeInfoOperationUnknown;
  }

  return [PigeonActionCodeInfo makeWithOperation:operation data:data];
}

- (void)confirmPasswordResetApp:(nonnull AuthPigeonFirebaseApp *)app
                           code:(nonnull NSString *)code
                    newPassword:(nonnull NSString *)newPassword
                     completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth confirmPasswordResetWithCode:code
                         newPassword:newPassword
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
}

- (void)createUserWithEmailAndPasswordApp:(nonnull AuthPigeonFirebaseApp *)app
                                    email:(nonnull NSString *)email
                                 password:(nonnull NSString *)password
                               completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                            FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth createUserWithEmail:email
                   password:password
                 completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
                   if (error != nil) {
                     completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                   } else {
                     completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                  authorizationCode:nil],
                                nil);
                   }
                 }];
}

- (void)fetchSignInMethodsForEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                                email:(nonnull NSString *)email
                           completion:(nonnull void (^)(NSArray<NSString *> *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth fetchSignInMethodsForEmail:email
                        completion:^(NSArray<NSString *> *_Nullable providers,
                                     NSError *_Nullable error) {
                          if (error != nil) {
                            completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                          } else {
                            if (providers == nil) {
                              completion(@[], nil);
                            } else {
                              completion(providers, nil);
                            }
                          }
                        }];
}

- (void)registerAuthStateListenerApp:(nonnull AuthPigeonFirebaseApp *)app
                          completion:(nonnull void (^)(NSString *_Nullable,
                                                       FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name =
      [NSString stringWithFormat:@"%@/auth-state/%@", kFLTFirebaseAuthChannelName, auth.app.name];
  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  FLTAuthStateChannelStreamHandler *handler =
      [[FLTAuthStateChannelStreamHandler alloc] initWithAuth:auth];
  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
}

- (void)registerIdTokenListenerApp:(nonnull AuthPigeonFirebaseApp *)app
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name =
      [NSString stringWithFormat:@"%@/id-token/%@", kFLTFirebaseAuthChannelName, auth.app.name];

  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  FLTIdTokenChannelStreamHandler *handler =
      [[FLTIdTokenChannelStreamHandler alloc] initWithAuth:auth];
  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
}

- (void)sendPasswordResetEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                            email:(nonnull NSString *)email
               actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                       completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  if (actionCodeSettings != nil) {
    FIRActionCodeSettings *settings = [PigeonParser parseActionCodeSettings:actionCodeSettings];
    [auth sendPasswordResetWithEmail:email
                  actionCodeSettings:settings
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
  } else {
    [auth sendPasswordResetWithEmail:email
                          completion:^(NSError *_Nullable error) {
                            if (error != nil) {
                              completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                            } else {
                              completion(nil);
                            }
                          }];
  }
}

- (void)sendSignInLinkToEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                           email:(nonnull NSString *)email
              actionCodeSettings:(nonnull PigeonActionCodeSettings *)actionCodeSettings
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth sendSignInLinkToEmail:email
           actionCodeSettings:[PigeonParser parseActionCodeSettings:actionCodeSettings]
                   completion:^(NSError *_Nullable error) {
                     if (error != nil) {
                       if (error.code == FIRAuthErrorCodeInternalError) {
                         [self
                             handleInternalError:^(PigeonUserCredential *_Nullable creds,
                                                   FlutterError *_Nullable internalError) {
                               completion(internalError);
                             }
                                       withError:error];
                       } else {
                         completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       }
                     } else {
                       completion(nil);
                     }
                   }];
}

- (void)setLanguageCodeApp:(nonnull AuthPigeonFirebaseApp *)app
              languageCode:(nullable NSString *)languageCode
                completion:
                    (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (languageCode != nil && ![languageCode isEqual:[NSNull null]]) {
    auth.languageCode = languageCode;
  } else {
    [auth useAppLanguage];
  }

  completion(auth.languageCode, nil);
}

- (void)setSettingsApp:(nonnull AuthPigeonFirebaseApp *)app
              settings:(nonnull PigeonFirebaseAuthSettings *)settings
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (settings.userAccessGroup != nil) {
    BOOL useUserAccessGroupSuccessful;
    NSError *useUserAccessGroupErrorPtr;
    useUserAccessGroupSuccessful = [auth useUserAccessGroup:settings.userAccessGroup
                                                      error:&useUserAccessGroupErrorPtr];
    if (!useUserAccessGroupSuccessful) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:useUserAccessGroupErrorPtr]);
      return;
    }
  }

#if TARGET_OS_IPHONE
  if (settings.appVerificationDisabledForTesting) {
    auth.settings.appVerificationDisabledForTesting = settings.appVerificationDisabledForTesting;
  }
#else
  NSLog(@"FIRAuthSettings.appVerificationDisabledForTesting is not supported "
        @"on MacOS.");
#endif

  completion(nil);
}

- (void)signInAnonymouslyApp:(nonnull AuthPigeonFirebaseApp *)app
                  completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                               FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInAnonymouslyWithCompletion:^(FIRAuthDataResult *authResult, NSError *error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                   authorizationCode:nil],
                 nil);
    }
  }];
}

- (void)signInWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                          input:(nonnull NSDictionary<NSString *, id> *)input
                     completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                  FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [auth
                                   signInWithCredential:credential
                                             completion:^(FIRAuthDataResult *authResult,
                                                          NSError *error) {
                                               if (error != nil) {
                                                 NSDictionary *userInfo = [error userInfo];
                                                 NSError *underlyingError =
                                                     [userInfo objectForKey:NSUnderlyingErrorKey];

                                                 NSDictionary *firebaseDictionary =
                                                     underlyingError
                                                         .userInfo[@"FIRAuthErrorUserInfoDeserializ"
                                                                   @"edResponseKey"];

                                                 if (firebaseDictionary != nil &&
                                                     firebaseDictionary[@"message"] != nil) {
                                                   // error from firebase-ios-sdk is buried in
                                                   // underlying error.
                                                   if ([firebaseDictionary[@"code"]
                                                           isKindOfClass:[NSNumber class]]) {
                                                     [self handleInternalError:completion
                                                                     withError:error];
                                                   } else {
                                                     completion(nil,
                                                                [FlutterError
                                                                    errorWithCode:firebaseDictionary
                                                                                      [@"code"]
                                                                          message:firebaseDictionary
                                                                                      [@"message"]
                                                                          details:nil]);
                                                   }
                                                 } else {
                                                   if (error.code ==
                                                       FIRAuthErrorCodeSecondFactorRequired) {
                                                     [self handleMultiFactorError:app
                                                                       completion:completion
                                                                        withError:error];
                                                   } else if (error.code ==
                                                              FIRAuthErrorCodeInternalError) {
                                                     [self handleInternalError:completion
                                                                     withError:error];
                                                   } else {
                                                     completion(nil,
                                                                [FLTFirebaseAuthPlugin
                                                                    convertToFlutterError:error]);
                                                   }
                                                 }
                                               } else {
                                                 completion(
                                                     [PigeonParser
                                                         getPigeonUserCredentialFromAuthResult:
                                                             authResult
                                                                             authorizationCode:nil],
                                                     nil);
                                               }
                                             }];
                             }];
}

- (void)signInWithCustomTokenApp:(nonnull AuthPigeonFirebaseApp *)app
                           token:(nonnull NSString *)token
                      completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                   FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  [auth signInWithCustomToken:token
                   completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
                     if (error != nil) {
                       if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                         [self handleMultiFactorError:app completion:completion withError:error];
                       } else if (error.code == FIRAuthErrorCodeInternalError) {
                         [self handleInternalError:completion withError:error];
                       } else {
                         completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       }
                     } else {
                       completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                                    authorizationCode:nil],
                                  nil);
                     }
                   }];
}

- (void)signInWithEmailAndPasswordApp:(nonnull AuthPigeonFirebaseApp *)app
                                email:(nonnull NSString *)email
                             password:(nonnull NSString *)password
                           completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInWithEmail:email
               password:password
             completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
               if (error != nil) {
                 if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                   [self handleMultiFactorError:app completion:completion withError:error];
                 } else if (error.code == FIRAuthErrorCodeInternalError) {
                   [self handleInternalError:completion withError:error];
                 } else {
                   completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                 }
               } else {
                 completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                              authorizationCode:nil],
                            nil);
               }
             }];
}

- (void)signInWithEmailLinkApp:(nonnull AuthPigeonFirebaseApp *)app
                         email:(nonnull NSString *)email
                     emailLink:(nonnull NSString *)emailLink
                    completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                 FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth signInWithEmail:email
                   link:emailLink
             completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
               if (error != nil) {
                 if (error.code == FIRAuthErrorCodeSecondFactorRequired) {
                   [self handleMultiFactorError:app completion:completion withError:error];
                 } else if (error.code == FIRAuthErrorCodeInternalError) {
                   [self handleInternalError:completion withError:error];
                 } else {
                   completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                 }
               } else {
                 completion([PigeonParser getPigeonUserCredentialFromAuthResult:authResult
                                                              authorizationCode:nil],
                            nil);
               }
             }];
}

- (void)signInWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
               signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                   completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if ([signInProvider.providerId isEqualToString:kSignInMethodGameCenter]) {
    completion(
        nil,
        [FlutterError
            errorWithCode:@"sign-in-failure"
                  message:
                      @"Game Center sign-in requires signing in with 'signInWithCredential()' API."
                  details:@{}]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.signInWithAppleAuth = auth;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"signInWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId auth:auth];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [self.authProvider
      getCredentialWithUIDelegate:nil
                       completion:^(FIRAuthCredential *_Nullable credential,
                                    NSError *_Nullable error) {
                         handleAppleAuthResult(self, app, auth, credential, error, completion);
                       }];
#endif
}

- (void)signOutApp:(nonnull AuthPigeonFirebaseApp *)app
        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  if (auth.currentUser == nil) {
    completion(nil);
    return;
  }

  NSError *signOutErrorPtr;
  BOOL signOutSuccessful = [auth signOut:&signOutErrorPtr];

  if (!signOutSuccessful) {
    completion([FLTFirebaseAuthPlugin convertToFlutterError:signOutErrorPtr]);
  } else {
    completion(nil);
  }
}

- (void)useEmulatorApp:(nonnull AuthPigeonFirebaseApp *)app
                  host:(nonnull NSString *)host
                  port:(long)port
            completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth useEmulatorWithHost:host port:port];
  completion(nil);
}

- (void)verifyPasswordResetCodeApp:(nonnull AuthPigeonFirebaseApp *)app
                              code:(nonnull NSString *)code
                        completion:(nonnull void (^)(NSString *_Nullable,
                                                     FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  [auth verifyPasswordResetCode:code
                     completion:^(NSString *_Nullable email, NSError *_Nullable error) {
                       if (error != nil) {
                         completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                       } else {
                         completion(email, nil);
                       }
                     }];
}

- (void)verifyPhoneNumberApp:(nonnull AuthPigeonFirebaseApp *)app
                     request:(nonnull PigeonVerifyPhoneNumberRequest *)request
                  completion:
                      (nonnull void (^)(NSString *_Nullable, FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  NSLog(@"The Firebase Phone Authentication provider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];

  NSString *name = [NSString
      stringWithFormat:@"%@/phone/%@", kFLTFirebaseAuthChannelName, [NSUUID UUID].UUIDString];
  FlutterEventChannel *channel = [FlutterEventChannel eventChannelWithName:name
                                                           binaryMessenger:_binaryMessenger];

  NSString *multiFactorSessionId = request.multiFactorSessionId;
  FIRMultiFactorSession *multiFactorSession = nil;

  if (multiFactorSessionId != nil) {
    multiFactorSession = _multiFactorSessionMap[multiFactorSessionId];
  }

  NSString *multiFactorInfoId = request.multiFactorInfoId;

  FIRPhoneMultiFactorInfo *multiFactorInfo = nil;
  if (multiFactorInfoId != nil) {
    for (NSString *resolverId in _multiFactorResolverMap) {
      for (FIRMultiFactorInfo *info in _multiFactorResolverMap[resolverId].hints) {
        if ([info.UID isEqualToString:multiFactorInfoId] &&
            [info class] == [FIRPhoneMultiFactorInfo class]) {
          multiFactorInfo = (FIRPhoneMultiFactorInfo *)info;
          break;
        }
      }
    }
  }

#if TARGET_OS_OSX
  FLTPhoneNumberVerificationStreamHandler *handler =
      [[FLTPhoneNumberVerificationStreamHandler alloc] initWithAuth:auth];
#else
  FLTPhoneNumberVerificationStreamHandler *handler =
      [[FLTPhoneNumberVerificationStreamHandler alloc] initWithAuth:auth
                                                            request:request
                                                            session:multiFactorSession
                                                         factorInfo:multiFactorInfo];
#endif

  [channel setStreamHandler:handler];

  [_eventChannels setObject:channel forKey:name];
  [_streamHandlers setObject:handler forKey:name];

  completion(name, nil);
#endif
}

- (void)deleteApp:(nonnull AuthPigeonFirebaseApp *)app
       completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser deleteWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
}

- (void)getIdTokenApp:(nonnull AuthPigeonFirebaseApp *)app
         forceRefresh:(BOOL)forceRefresh
           completion:(nonnull void (^)(PigeonIdTokenResult *_Nullable,
                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser
      getIDTokenResultForcingRefresh:forceRefresh
                          completion:^(FIRAuthTokenResult *tokenResult, NSError *error) {
                            if (error != nil) {
                              completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                              return;
                            }

                            completion([PigeonParser parseIdTokenResult:tokenResult], nil);
                          }];
}

- (void)linkWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                        input:(nonnull NSDictionary<NSString *, id> *)input
                   completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   linkWithCredential:credential
                                           completion:^(FIRAuthDataResult *authResult,
                                                        NSError *error) {
                                             if (error != nil) {
                                               if (error.code ==
                                                   FIRAuthErrorCodeSecondFactorRequired) {
                                                 [self handleMultiFactorError:app
                                                                   completion:completion
                                                                    withError:error];
                                               } else {
                                                 completion(nil, [FLTFirebaseAuthPlugin
                                                                     convertToFlutterError:error]);
                                               }
                                             } else {
                                               completion(
                                                   [PigeonParser
                                                       getPigeonUserCredentialFromAuthResult:
                                                           authResult
                                                                           authorizationCode:nil],
                                                   nil);
                                             }
                                           }];
                             }];
}

- (void)linkWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
             signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                 completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                              FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if ([signInProvider.providerId isEqualToString:kSignInMethodGameCenter]) {
    completion(
        nil,
        [FlutterError
            errorWithCode:@"provider-link-failure"
                  message:@"Game Center provider requires linking with 'linkWithCredential()' API."
                  details:@{}]);
    return;
  }

  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.linkWithAppleUser = currentUser;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"linkWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [currentUser
      linkWithProvider:self.authProvider
            UIDelegate:nil
            completion:^(FIRAuthDataResult *authResult, NSError *error) {
              handleAppleAuthResult(self, app, auth, authResult.credential, error, completion);
            }];
#endif
}

- (void)reauthenticateWithCredentialApp:(nonnull AuthPigeonFirebaseApp *)app
                                  input:(nonnull NSDictionary<NSString *, id> *)input
                             completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                          FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   reauthenticateWithCredential:credential
                                                     completion:^(FIRAuthDataResult *authResult,
                                                                  NSError *error) {
                                                       if (error != nil) {
                                                         if (error.code ==
                                                             FIRAuthErrorCodeSecondFactorRequired) {
                                                           [self handleMultiFactorError:app
                                                                             completion:completion
                                                                              withError:error];
                                                         } else {
                                                           completion(
                                                               nil,
                                                               [FLTFirebaseAuthPlugin
                                                                   convertToFlutterError:error]);
                                                         }
                                                       } else {
                                                         completion(
                                                             [PigeonParser
                                                                 getPigeonUserCredentialFromAuthResult:
                                                                     authResult
                                                                                     authorizationCode:
                                                                                         nil],
                                                             nil);
                                                       }
                                                     }];
                             }];
}

- (void)reauthenticateWithProviderApp:(nonnull AuthPigeonFirebaseApp *)app
                       signInProvider:(nonnull PigeonSignInProvider *)signInProvider
                           completion:(nonnull void (^)(PigeonUserCredential *_Nullable,
                                                        FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  if ([signInProvider.providerId isEqualToString:kSignInMethodApple]) {
    self.isReauthenticatingWithApple = YES;
    launchAppleSignInRequest(self, app, signInProvider, completion);
    return;
  }
#if TARGET_OS_OSX
  NSLog(@"reauthenticateWithProvider is not supported on the "
        @"MacOS platform.");
  completion(nil, nil);
#else
  self.authProvider = [FIROAuthProvider providerWithProviderID:signInProvider.providerId];
  NSArray *scopes = signInProvider.scopes;
  if (scopes != nil) {
    [self.authProvider setScopes:scopes];
  }
  NSDictionary *customParameters = signInProvider.customParameters;
  if (customParameters != nil) {
    [self.authProvider setCustomParameters:customParameters];
  }

  [currentUser reauthenticateWithProvider:self.authProvider
                               UIDelegate:nil
                               completion:^(FIRAuthDataResult *authResult, NSError *error) {
                                 handleAppleAuthResult(self, app, auth, authResult.credential,
                                                       error, completion);
                               }];
#endif
}

- (void)reloadApp:(nonnull AuthPigeonFirebaseApp *)app
       completion:
           (nonnull void (^)(PigeonUserDetails *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser reloadWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
    }
  }];
}

- (void)sendEmailVerificationApp:(nonnull AuthPigeonFirebaseApp *)app
              actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                      completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser
      sendEmailVerificationWithActionCodeSettings:[PigeonParser
                                                      parseActionCodeSettings:actionCodeSettings]

                                       completion:^(NSError *_Nullable error) {
                                         if (error != nil) {
                                           completion(
                                               [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                         } else {
                                           completion(nil);
                                         }
                                       }];
}

- (void)unlinkApp:(nonnull AuthPigeonFirebaseApp *)app
       providerId:(nonnull NSString *)providerId
       completion:
           (nonnull void (^)(PigeonUserCredential *_Nullable, FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser unlinkFromProvider:providerId
                       completion:^(FIRUser *_Nullable user, NSError *_Nullable error) {
                         if (error != nil) {
                           completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                         } else {
                           completion([PigeonParser getPigeonUserCredentialFromFIRUser:user], nil);
                         }
                       }];
}

- (void)updateEmailApp:(nonnull AuthPigeonFirebaseApp *)app
              newEmail:(nonnull NSString *)newEmail
            completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                         FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser updateEmail:newEmail
                completion:^(NSError *_Nullable error) {
                  if (error != nil) {
                    completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                  } else {
                    [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
                      if (reloadError != nil) {
                        completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
                      } else {
                        completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
                      }
                    }];
                  }
                }];
}

- (void)updatePasswordApp:(nonnull AuthPigeonFirebaseApp *)app
              newPassword:(nonnull NSString *)newPassword
               completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                            FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [currentUser
      updatePassword:newPassword
          completion:^(NSError *_Nullable error) {
            if (error != nil) {
              completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
            } else {
              [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
                if (reloadError != nil) {
                  completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
                } else {
                  completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
                }
              }];
            }
          }];
}

- (void)updatePhoneNumberApp:(nonnull AuthPigeonFirebaseApp *)app
                       input:(nonnull NSDictionary<NSString *, id> *)input
                  completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                               FlutterError *_Nullable))completion {
#if TARGET_OS_IPHONE
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  [self
      getFIRAuthCredentialFromArguments:input
                                    app:app
                             completion:^(FIRAuthCredential *credential, NSError *error) {
                               if (credential == nil) {
                                 completion(nil,
                                            [FlutterError errorWithCode:kErrCodeInvalidCredential
                                                                message:kErrMsgInvalidCredential
                                                                details:nil]);
                                 return;
                               }

                               if (error) {
                                 completion(nil,
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                               }

                               [currentUser
                                   updatePhoneNumberCredential:(FIRPhoneAuthCredential *)credential
                                                    completion:^(NSError *_Nullable error) {
                                                      if (error != nil) {
                                                        completion(
                                                            nil, [FLTFirebaseAuthPlugin
                                                                     convertToFlutterError:error]);
                                                      } else {
                                                        [currentUser
                                                            reloadWithCompletion:^(
                                                                NSError *_Nullable reloadError) {
                                                              if (reloadError != nil) {
                                                                completion(
                                                                    nil, [FLTFirebaseAuthPlugin
                                                                             convertToFlutterError:
                                                                                 reloadError]);
                                                              } else {
                                                                completion(
                                                                    [PigeonParser
                                                                        getPigeonDetails:
                                                                            auth.currentUser],
                                                                    nil);
                                                              }
                                                            }];
                                                      }
                                                    }];
                             }];
#else
  NSLog(@"Updating a users phone number via Firebase Authentication is only "
        @"supported on the iOS "
        @"platform.");
  completion(nil, nil);
#endif
}

- (void)updateProfileApp:(nonnull AuthPigeonFirebaseApp *)app
                 profile:(nonnull PigeonUserProfile *)profile
              completion:(nonnull void (^)(PigeonUserDetails *_Nullable,
                                           FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion(nil, [FlutterError errorWithCode:kErrCodeNoCurrentUser
                                        message:kErrMsgNoCurrentUser
                                        details:nil]);
    return;
  }

  FIRUserProfileChangeRequest *changeRequest = [currentUser profileChangeRequest];

  if (profile.displayNameChanged) {
    changeRequest.displayName = profile.displayName;
  }

  if (profile.photoUrlChanged) {
    if (profile.photoUrl == nil) {
      // We apparently cannot set photoURL to nil/NULL to remove it.
      // Instead, setting it to empty string appears to work.
      // When doing so, Dart will properly receive `null` anyway.
      changeRequest.photoURL = [NSURL URLWithString:@""];
    } else {
      changeRequest.photoURL = [NSURL URLWithString:profile.photoUrl];
    }
  }

  [changeRequest commitChangesWithCompletion:^(NSError *error) {
    if (error != nil) {
      completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      [currentUser reloadWithCompletion:^(NSError *_Nullable reloadError) {
        if (reloadError != nil) {
          completion(nil, [FLTFirebaseAuthPlugin convertToFlutterError:reloadError]);
        } else {
          completion([PigeonParser getPigeonDetails:auth.currentUser], nil);
        }
      }];
    }
  }];
}

- (void)verifyBeforeUpdateEmailApp:(nonnull AuthPigeonFirebaseApp *)app
                          newEmail:(nonnull NSString *)newEmail
                actionCodeSettings:(nullable PigeonActionCodeSettings *)actionCodeSettings
                        completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  FIRUser *currentUser = auth.currentUser;
  if (currentUser == nil) {
    completion([FlutterError errorWithCode:kErrCodeNoCurrentUser
                                   message:kErrMsgNoCurrentUser
                                   details:nil]);
    return;
  }

  [currentUser
      sendEmailVerificationBeforeUpdatingEmail:newEmail
                            actionCodeSettings:[PigeonParser
                                                   parseActionCodeSettings:actionCodeSettings]
                                    completion:^(NSError *error) {
                                      if (error != nil) {
                                        completion(
                                            [FLTFirebaseAuthPlugin convertToFlutterError:error]);
                                      } else {
                                        completion(nil);
                                      }
                                    }];
}

- (void)initializeRecaptchaConfigApp:(AuthPigeonFirebaseApp *)app
                          completion:(void (^)(FlutterError *_Nullable))completion {
#if TARGET_OS_OSX
  NSLog(@"initializeRecaptchaConfigWithCompletion is not supported on the "
        @"MacOS platform.");
  completion(nil);
#else
  FIRAuth *auth = [self getFIRAuthFromAppNameFromPigeon:app];
  [auth initializeRecaptchaConfigWithCompletion:^(NSError *_Nullable error) {
    if (error != nil) {
      completion([FLTFirebaseAuthPlugin convertToFlutterError:error]);
    } else {
      completion(nil);
    }
  }];
#endif
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/FLTIdTokenChannelStreamHandler.m

**크기**: 1378 bytes | **라인 수**: 55 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@import FirebaseAuth;
#import "include/Private/FLTIdTokenChannelStreamHandler.h"
#import <FirebaseAuth/FirebaseAuth.h>
#import "include/Private/PigeonParser.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTIdTokenChannelStreamHandler {
  FIRAuth *_auth;
  FIRIDTokenDidChangeListenerHandle _listener;
}

- (instancetype)initWithAuth:(FIRAuth *)auth {
  self = [super init];
  if (self) {
    _auth = auth;
  }
  return self;
}

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
  bool __block initialAuthState = YES;

  _listener = [_auth addIDTokenDidChangeListener:^(FIRAuth *_Nonnull auth,
                                                   FIRUser *_Nullable user) {
    if (initialAuthState) {
      initialAuthState = NO;
      return;
    }

    if (user) {
      events(@{
        @"user" : [PigeonParser getManualList:[PigeonParser getPigeonDetails:[auth currentUser]]]
      });
    } else {
      events(@{@"user" : [NSNull null]});
    }
  }];

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  if (_listener) {
    [_auth removeIDTokenDidChangeListener:_listener];
  }
  _listener = nil;

  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/FLTPhoneNumberVerificationStreamHandler.m

**크기**: 2823 bytes | **라인 수**: 99 | **타입**: text

```
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@import FirebaseAuth;

#import "include/Private/FLTPhoneNumberVerificationStreamHandler.h"
#import "include/Public/FLTFirebaseAuthPlugin.h"

@implementation FLTPhoneNumberVerificationStreamHandler {
  FIRAuth *_auth;
  NSString *_phoneNumber;
#if TARGET_OS_OSX
#else
  FIRMultiFactorSession *_session;
  FIRPhoneMultiFactorInfo *_factorInfo;
#endif
}

#if TARGET_OS_OSX
- (instancetype)initWithAuth:(id)auth request:(PigeonVerifyPhoneNumberRequest *)request {
  self = [super init];
  if (self) {
    _auth = auth;
    _phoneNumber = request.phoneNumber;
  }
  return self;
}
#else
- (instancetype)initWithAuth:(id)auth
                     request:(PigeonVerifyPhoneNumberRequest *)request
                     session:(FIRMultiFactorSession *)session
                  factorInfo:(FIRPhoneMultiFactorInfo *)factorInfo {
  self = [super init];
  if (self) {
    _auth = auth;
    _phoneNumber = request.phoneNumber;
    _session = session;
    _factorInfo = factorInfo;
  }
  return self;
}
#endif

- (FlutterError *)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)events {
#if TARGET_OS_IPHONE
  id completer = ^(NSString *verificationID, NSError *error) {
    if (error != nil) {
      FlutterError *errorDetails = [FLTFirebaseAuthPlugin convertToFlutterError:error];
      events(@{
        @"name" : @"Auth#phoneVerificationFailed",
        @"error" : @{
          @"code" : errorDetails.code,
          @"message" : errorDetails.message,
          @"details" : errorDetails.details,
        }
      });
    } else {
      events(@{
        @"name" : @"Auth#phoneCodeSent",
        @"verificationId" : verificationID,
      });
    }
  };

  // Try catch to capture 'missing URL scheme' error.
  @try {
    if (_factorInfo != nil) {
      [[FIRPhoneAuthProvider providerWithAuth:_auth]
          verifyPhoneNumberWithMultiFactorInfo:_factorInfo
                                    UIDelegate:nil
                            multiFactorSession:_session
                                    completion:completer];

    } else {
      [[FIRPhoneAuthProvider providerWithAuth:_auth] verifyPhoneNumber:_phoneNumber
                                                            UIDelegate:nil
                                                    multiFactorSession:_session
                                                            completion:completer];
    }
  } @catch (NSException *exception) {
    events(@{
      @"name" : @"Auth#phoneVerificationFailed",
      @"error" : @{
        @"message" : exception.reason,
      }
    });
  }
#endif

  return nil;
}

- (FlutterError *)onCancelWithArguments:(id)arguments {
  return nil;
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/PigeonParser.m

**크기**: 7041 bytes | **라인 수**: 170 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

@import FirebaseAuth;

#import "include/Private/PigeonParser.h"
#import <Foundation/Foundation.h>
#import "include/Public/CustomPigeonHeader.h"

@implementation PigeonParser

+ (PigeonUserCredential *)
    getPigeonUserCredentialFromAuthResult:(nonnull FIRAuthDataResult *)authResult
                        authorizationCode:(nullable NSString *)authorizationCode {
  return [PigeonUserCredential
            makeWithUser:[self getPigeonDetails:authResult.user]
      additionalUserInfo:[self getPigeonAdditionalUserInfo:authResult.additionalUserInfo
                                         authorizationCode:authorizationCode]
              credential:[self getPigeonAuthCredential:authResult.credential token:nil]];
}

+ (PigeonUserCredential *)getPigeonUserCredentialFromFIRUser:(nonnull FIRUser *)user {
  return [PigeonUserCredential makeWithUser:[self getPigeonDetails:user]
                         additionalUserInfo:nil
                                 credential:nil];
}

+ (PigeonUserDetails *)getPigeonDetails:(nonnull FIRUser *)user {
  return [PigeonUserDetails makeWithUserInfo:[self getPigeonUserInfo:user]
                                providerData:[self getProviderData:user.providerData]];
}

+ (PigeonUserInfo *)getPigeonUserInfo:(nonnull FIRUser *)user {
  return [PigeonUserInfo
              makeWithUid:user.uid
                    email:user.email
              displayName:user.displayName
                 photoUrl:(user.photoURL.absoluteString.length > 0) ? user.photoURL.absoluteString
                                                                    : nil
              phoneNumber:user.phoneNumber
              isAnonymous:user.isAnonymous
          isEmailVerified:user.emailVerified
               providerId:user.providerID
                 tenantId:user.tenantID
             refreshToken:user.refreshToken
        creationTimestamp:@((long)([user.metadata.creationDate timeIntervalSince1970] * 1000))
      lastSignInTimestamp:@((long)([user.metadata.lastSignInDate timeIntervalSince1970] * 1000))];
}

+ (NSArray<NSDictionary<id, id> *> *)getProviderData:
    (nonnull NSArray<id<FIRUserInfo>> *)providerData {
  NSMutableArray<NSDictionary<id, id> *> *dataArray =
      [NSMutableArray arrayWithCapacity:providerData.count];

  for (id<FIRUserInfo> userInfo in providerData) {
    NSDictionary *dataDict = @{
      @"providerId" : userInfo.providerID,
      // Can be null on emulator
      @"uid" : userInfo.uid ?: @"",
      @"displayName" : userInfo.displayName ?: [NSNull null],
      @"email" : userInfo.email ?: [NSNull null],
      @"phoneNumber" : userInfo.phoneNumber ?: [NSNull null],
      @"photoURL" : userInfo.photoURL.absoluteString ?: [NSNull null],
      // isAnonymous is always false on in a providerData object (the user is not anonymous)
      @"isAnonymous" : @NO,
      // isEmailVerified is always true on in a providerData object (the email is verified by the
      // provider)
      @"isEmailVerified" : @YES,
    };
    [dataArray addObject:dataDict];
  }
  return [dataArray copy];
}

+ (PigeonAdditionalUserInfo *)getPigeonAdditionalUserInfo:(nonnull FIRAdditionalUserInfo *)userInfo
                                        authorizationCode:(nullable NSString *)authorizationCode {
  return [PigeonAdditionalUserInfo makeWithIsNewUser:userInfo.isNewUser
                                          providerId:userInfo.providerID
                                            username:userInfo.username
                                   authorizationCode:authorizationCode
                                             profile:userInfo.profile];
}

+ (PigeonTotpSecret *)getPigeonTotpSecret:(FIRTOTPSecret *)secret {
  return [PigeonTotpSecret makeWithCodeIntervalSeconds:nil
                                            codeLength:nil
                          enrollmentCompletionDeadline:nil
                                      hashingAlgorithm:nil
                                             secretKey:secret.sharedSecretKey];
}

+ (PigeonAuthCredential *)getPigeonAuthCredential:(FIRAuthCredential *)authCredential
                                            token:(NSNumber *_Nullable)token {
  if (authCredential == nil) {
    return nil;
  }

  NSString *accessToken = nil;
  if ([authCredential isKindOfClass:[FIROAuthCredential class]]) {
    if (((FIROAuthCredential *)authCredential).accessToken != nil) {
      accessToken = ((FIROAuthCredential *)authCredential).accessToken;
    } else if (((FIROAuthCredential *)authCredential).IDToken != nil) {
      // For Sign In With Apple, the token is stored in IDToken
      accessToken = ((FIROAuthCredential *)authCredential).IDToken;
    }
  }

  NSUInteger nativeId =
      token != nil ? [token unsignedLongValue] : (NSUInteger)[authCredential hash];

  return [PigeonAuthCredential makeWithProviderId:authCredential.provider
                                     signInMethod:authCredential.provider
                                         nativeId:nativeId
                                      accessToken:accessToken ?: nil];
}

+ (FIRActionCodeSettings *_Nullable)parseActionCodeSettings:
    (nullable PigeonActionCodeSettings *)settings {
  if (settings == nil) {
    return nil;
  }

  FIRActionCodeSettings *codeSettings = [[FIRActionCodeSettings alloc] init];

  if (settings.url != nil) {
    codeSettings.URL = [NSURL URLWithString:settings.url];
  }

  if (settings.linkDomain != nil) {
    codeSettings.linkDomain = settings.linkDomain;
  }

  codeSettings.handleCodeInApp = settings.handleCodeInApp;

  if (settings.iOSBundleId != nil) {
    codeSettings.iOSBundleID = settings.iOSBundleId;
  }

  return codeSettings;
}

+ (PigeonIdTokenResult *)parseIdTokenResult:(FIRAuthTokenResult *)tokenResult {
  long expirationTimestamp = (long)[tokenResult.expirationDate timeIntervalSince1970] * 1000;
  long authTimestamp = (long)[tokenResult.authDate timeIntervalSince1970] * 1000;
  long issuedAtTimestamp = (long)[tokenResult.issuedAtDate timeIntervalSince1970] * 1000;

  return [PigeonIdTokenResult makeWithToken:tokenResult.token
                        expirationTimestamp:@(expirationTimestamp)
                              authTimestamp:@(authTimestamp)
                          issuedAtTimestamp:@(issuedAtTimestamp)
                             signInProvider:tokenResult.signInProvider
                                     claims:tokenResult.claims
                         signInSecondFactor:tokenResult.signInSecondFactor];
}

+ (NSArray *_Nonnull)getManualList:(nonnull PigeonUserDetails *)userDetails {
  NSMutableArray *output = [NSMutableArray array];

  id userInfoList = [[userDetails userInfo] toList];
  [output addObject:userInfoList];

  id providerData = [userDetails providerData];
  [output addObject:providerData];

  return [output copy];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Sources/firebase_auth/firebase_auth_messages.g.m

**크기**: 124738 bytes | **라인 수**: 2765 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "include/Public/firebase_auth_messages.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// The type of operation that generated the action code from calling
/// [checkActionCode].
@implementation ActionCodeInfoOperationBox
- (instancetype)initWithValue:(ActionCodeInfoOperation)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface PigeonMultiFactorSession ()
+ (PigeonMultiFactorSession *)fromList:(NSArray *)list;
+ (nullable PigeonMultiFactorSession *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonPhoneMultiFactorAssertion ()
+ (PigeonPhoneMultiFactorAssertion *)fromList:(NSArray *)list;
+ (nullable PigeonPhoneMultiFactorAssertion *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonMultiFactorInfo ()
+ (PigeonMultiFactorInfo *)fromList:(NSArray *)list;
+ (nullable PigeonMultiFactorInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AuthPigeonFirebaseApp ()
+ (AuthPigeonFirebaseApp *)fromList:(NSArray *)list;
+ (nullable AuthPigeonFirebaseApp *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeInfoData ()
+ (PigeonActionCodeInfoData *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeInfoData *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeInfo ()
+ (PigeonActionCodeInfo *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonAdditionalUserInfo ()
+ (PigeonAdditionalUserInfo *)fromList:(NSArray *)list;
+ (nullable PigeonAdditionalUserInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonAuthCredential ()
+ (PigeonAuthCredential *)fromList:(NSArray *)list;
+ (nullable PigeonAuthCredential *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserInfo ()
+ (PigeonUserInfo *)fromList:(NSArray *)list;
+ (nullable PigeonUserInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserDetails ()
+ (PigeonUserDetails *)fromList:(NSArray *)list;
+ (nullable PigeonUserDetails *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserCredential ()
+ (PigeonUserCredential *)fromList:(NSArray *)list;
+ (nullable PigeonUserCredential *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonActionCodeSettings ()
+ (PigeonActionCodeSettings *)fromList:(NSArray *)list;
+ (nullable PigeonActionCodeSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonFirebaseAuthSettings ()
+ (PigeonFirebaseAuthSettings *)fromList:(NSArray *)list;
+ (nullable PigeonFirebaseAuthSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonSignInProvider ()
+ (PigeonSignInProvider *)fromList:(NSArray *)list;
+ (nullable PigeonSignInProvider *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonVerifyPhoneNumberRequest ()
+ (PigeonVerifyPhoneNumberRequest *)fromList:(NSArray *)list;
+ (nullable PigeonVerifyPhoneNumberRequest *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonIdTokenResult ()
+ (PigeonIdTokenResult *)fromList:(NSArray *)list;
+ (nullable PigeonIdTokenResult *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonUserProfile ()
+ (PigeonUserProfile *)fromList:(NSArray *)list;
+ (nullable PigeonUserProfile *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonTotpSecret ()
+ (PigeonTotpSecret *)fromList:(NSArray *)list;
+ (nullable PigeonTotpSecret *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation PigeonMultiFactorSession
+ (instancetype)makeWithId:(NSString *)id {
  PigeonMultiFactorSession *pigeonResult = [[PigeonMultiFactorSession alloc] init];
  pigeonResult.id = id;
  return pigeonResult;
}
+ (PigeonMultiFactorSession *)fromList:(NSArray *)list {
  PigeonMultiFactorSession *pigeonResult = [[PigeonMultiFactorSession alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable PigeonMultiFactorSession *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonMultiFactorSession fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
  ];
}
@end

@implementation PigeonPhoneMultiFactorAssertion
+ (instancetype)makeWithVerificationId:(NSString *)verificationId
                      verificationCode:(NSString *)verificationCode {
  PigeonPhoneMultiFactorAssertion *pigeonResult = [[PigeonPhoneMultiFactorAssertion alloc] init];
  pigeonResult.verificationId = verificationId;
  pigeonResult.verificationCode = verificationCode;
  return pigeonResult;
}
+ (PigeonPhoneMultiFactorAssertion *)fromList:(NSArray *)list {
  PigeonPhoneMultiFactorAssertion *pigeonResult = [[PigeonPhoneMultiFactorAssertion alloc] init];
  pigeonResult.verificationId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.verificationCode = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonPhoneMultiFactorAssertion *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonPhoneMultiFactorAssertion fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.verificationId ?: [NSNull null],
    self.verificationCode ?: [NSNull null],
  ];
}
@end

@implementation PigeonMultiFactorInfo
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                enrollmentTimestamp:(double)enrollmentTimestamp
                           factorId:(nullable NSString *)factorId
                                uid:(NSString *)uid
                        phoneNumber:(nullable NSString *)phoneNumber {
  PigeonMultiFactorInfo *pigeonResult = [[PigeonMultiFactorInfo alloc] init];
  pigeonResult.displayName = displayName;
  pigeonResult.enrollmentTimestamp = enrollmentTimestamp;
  pigeonResult.factorId = factorId;
  pigeonResult.uid = uid;
  pigeonResult.phoneNumber = phoneNumber;
  return pigeonResult;
}
+ (PigeonMultiFactorInfo *)fromList:(NSArray *)list {
  PigeonMultiFactorInfo *pigeonResult = [[PigeonMultiFactorInfo alloc] init];
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.enrollmentTimestamp = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.factorId = GetNullableObjectAtIndex(list, 2);
  pigeonResult.uid = GetNullableObjectAtIndex(list, 3);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonMultiFactorInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonMultiFactorInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.displayName ?: [NSNull null],
    @(self.enrollmentTimestamp),
    self.factorId ?: [NSNull null],
    self.uid ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
  ];
}
@end

@implementation AuthPigeonFirebaseApp
+ (instancetype)makeWithAppName:(NSString *)appName
                       tenantId:(nullable NSString *)tenantId
               customAuthDomain:(nullable NSString *)customAuthDomain {
  AuthPigeonFirebaseApp *pigeonResult = [[AuthPigeonFirebaseApp alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.tenantId = tenantId;
  pigeonResult.customAuthDomain = customAuthDomain;
  return pigeonResult;
}
+ (AuthPigeonFirebaseApp *)fromList:(NSArray *)list {
  AuthPigeonFirebaseApp *pigeonResult = [[AuthPigeonFirebaseApp alloc] init];
  pigeonResult.appName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.tenantId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.customAuthDomain = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable AuthPigeonFirebaseApp *)nullableFromList:(NSArray *)list {
  return (list) ? [AuthPigeonFirebaseApp fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.appName ?: [NSNull null],
    self.tenantId ?: [NSNull null],
    self.customAuthDomain ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeInfoData
+ (instancetype)makeWithEmail:(nullable NSString *)email
                previousEmail:(nullable NSString *)previousEmail {
  PigeonActionCodeInfoData *pigeonResult = [[PigeonActionCodeInfoData alloc] init];
  pigeonResult.email = email;
  pigeonResult.previousEmail = previousEmail;
  return pigeonResult;
}
+ (PigeonActionCodeInfoData *)fromList:(NSArray *)list {
  PigeonActionCodeInfoData *pigeonResult = [[PigeonActionCodeInfoData alloc] init];
  pigeonResult.email = GetNullableObjectAtIndex(list, 0);
  pigeonResult.previousEmail = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonActionCodeInfoData *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeInfoData fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.email ?: [NSNull null],
    self.previousEmail ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeInfo
+ (instancetype)makeWithOperation:(ActionCodeInfoOperation)operation
                             data:(PigeonActionCodeInfoData *)data {
  PigeonActionCodeInfo *pigeonResult = [[PigeonActionCodeInfo alloc] init];
  pigeonResult.operation = operation;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (PigeonActionCodeInfo *)fromList:(NSArray *)list {
  PigeonActionCodeInfo *pigeonResult = [[PigeonActionCodeInfo alloc] init];
  pigeonResult.operation = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.data = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonActionCodeInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.operation),
    self.data ?: [NSNull null],
  ];
}
@end

@implementation PigeonAdditionalUserInfo
+ (instancetype)makeWithIsNewUser:(BOOL)isNewUser
                       providerId:(nullable NSString *)providerId
                         username:(nullable NSString *)username
                authorizationCode:(nullable NSString *)authorizationCode
                          profile:(nullable NSDictionary<NSString *, id> *)profile {
  PigeonAdditionalUserInfo *pigeonResult = [[PigeonAdditionalUserInfo alloc] init];
  pigeonResult.isNewUser = isNewUser;
  pigeonResult.providerId = providerId;
  pigeonResult.username = username;
  pigeonResult.authorizationCode = authorizationCode;
  pigeonResult.profile = profile;
  return pigeonResult;
}
+ (PigeonAdditionalUserInfo *)fromList:(NSArray *)list {
  PigeonAdditionalUserInfo *pigeonResult = [[PigeonAdditionalUserInfo alloc] init];
  pigeonResult.isNewUser = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.username = GetNullableObjectAtIndex(list, 2);
  pigeonResult.authorizationCode = GetNullableObjectAtIndex(list, 3);
  pigeonResult.profile = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonAdditionalUserInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonAdditionalUserInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.isNewUser),
    self.providerId ?: [NSNull null],
    self.username ?: [NSNull null],
    self.authorizationCode ?: [NSNull null],
    self.profile ?: [NSNull null],
  ];
}
@end

@implementation PigeonAuthCredential
+ (instancetype)makeWithProviderId:(NSString *)providerId
                      signInMethod:(NSString *)signInMethod
                          nativeId:(NSInteger)nativeId
                       accessToken:(nullable NSString *)accessToken {
  PigeonAuthCredential *pigeonResult = [[PigeonAuthCredential alloc] init];
  pigeonResult.providerId = providerId;
  pigeonResult.signInMethod = signInMethod;
  pigeonResult.nativeId = nativeId;
  pigeonResult.accessToken = accessToken;
  return pigeonResult;
}
+ (PigeonAuthCredential *)fromList:(NSArray *)list {
  PigeonAuthCredential *pigeonResult = [[PigeonAuthCredential alloc] init];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.signInMethod = GetNullableObjectAtIndex(list, 1);
  pigeonResult.nativeId = [GetNullableObjectAtIndex(list, 2) integerValue];
  pigeonResult.accessToken = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable PigeonAuthCredential *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonAuthCredential fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.providerId ?: [NSNull null],
    self.signInMethod ?: [NSNull null],
    @(self.nativeId),
    self.accessToken ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserInfo
+ (instancetype)makeWithUid:(NSString *)uid
                      email:(nullable NSString *)email
                displayName:(nullable NSString *)displayName
                   photoUrl:(nullable NSString *)photoUrl
                phoneNumber:(nullable NSString *)phoneNumber
                isAnonymous:(BOOL)isAnonymous
            isEmailVerified:(BOOL)isEmailVerified
                 providerId:(nullable NSString *)providerId
                   tenantId:(nullable NSString *)tenantId
               refreshToken:(nullable NSString *)refreshToken
          creationTimestamp:(nullable NSNumber *)creationTimestamp
        lastSignInTimestamp:(nullable NSNumber *)lastSignInTimestamp {
  PigeonUserInfo *pigeonResult = [[PigeonUserInfo alloc] init];
  pigeonResult.uid = uid;
  pigeonResult.email = email;
  pigeonResult.displayName = displayName;
  pigeonResult.photoUrl = photoUrl;
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.isAnonymous = isAnonymous;
  pigeonResult.isEmailVerified = isEmailVerified;
  pigeonResult.providerId = providerId;
  pigeonResult.tenantId = tenantId;
  pigeonResult.refreshToken = refreshToken;
  pigeonResult.creationTimestamp = creationTimestamp;
  pigeonResult.lastSignInTimestamp = lastSignInTimestamp;
  return pigeonResult;
}
+ (PigeonUserInfo *)fromList:(NSArray *)list {
  PigeonUserInfo *pigeonResult = [[PigeonUserInfo alloc] init];
  pigeonResult.uid = GetNullableObjectAtIndex(list, 0);
  pigeonResult.email = GetNullableObjectAtIndex(list, 1);
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 2);
  pigeonResult.photoUrl = GetNullableObjectAtIndex(list, 3);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 4);
  pigeonResult.isAnonymous = [GetNullableObjectAtIndex(list, 5) boolValue];
  pigeonResult.isEmailVerified = [GetNullableObjectAtIndex(list, 6) boolValue];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 7);
  pigeonResult.tenantId = GetNullableObjectAtIndex(list, 8);
  pigeonResult.refreshToken = GetNullableObjectAtIndex(list, 9);
  pigeonResult.creationTimestamp = GetNullableObjectAtIndex(list, 10);
  pigeonResult.lastSignInTimestamp = GetNullableObjectAtIndex(list, 11);
  return pigeonResult;
}
+ (nullable PigeonUserInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.uid ?: [NSNull null],
    self.email ?: [NSNull null],
    self.displayName ?: [NSNull null],
    self.photoUrl ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
    @(self.isAnonymous),
    @(self.isEmailVerified),
    self.providerId ?: [NSNull null],
    self.tenantId ?: [NSNull null],
    self.refreshToken ?: [NSNull null],
    self.creationTimestamp ?: [NSNull null],
    self.lastSignInTimestamp ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserDetails
+ (instancetype)makeWithUserInfo:(PigeonUserInfo *)userInfo
                    providerData:(NSArray<NSDictionary<id, id> *> *)providerData {
  PigeonUserDetails *pigeonResult = [[PigeonUserDetails alloc] init];
  pigeonResult.userInfo = userInfo;
  pigeonResult.providerData = providerData;
  return pigeonResult;
}
+ (PigeonUserDetails *)fromList:(NSArray *)list {
  PigeonUserDetails *pigeonResult = [[PigeonUserDetails alloc] init];
  pigeonResult.userInfo = GetNullableObjectAtIndex(list, 0);
  pigeonResult.providerData = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable PigeonUserDetails *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserDetails fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.userInfo ?: [NSNull null],
    self.providerData ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserCredential
+ (instancetype)makeWithUser:(nullable PigeonUserDetails *)user
          additionalUserInfo:(nullable PigeonAdditionalUserInfo *)additionalUserInfo
                  credential:(nullable PigeonAuthCredential *)credential {
  PigeonUserCredential *pigeonResult = [[PigeonUserCredential alloc] init];
  pigeonResult.user = user;
  pigeonResult.additionalUserInfo = additionalUserInfo;
  pigeonResult.credential = credential;
  return pigeonResult;
}
+ (PigeonUserCredential *)fromList:(NSArray *)list {
  PigeonUserCredential *pigeonResult = [[PigeonUserCredential alloc] init];
  pigeonResult.user = GetNullableObjectAtIndex(list, 0);
  pigeonResult.additionalUserInfo = GetNullableObjectAtIndex(list, 1);
  pigeonResult.credential = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable PigeonUserCredential *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserCredential fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.user ?: [NSNull null],
    self.additionalUserInfo ?: [NSNull null],
    self.credential ?: [NSNull null],
  ];
}
@end

@implementation PigeonActionCodeSettings
+ (instancetype)makeWithUrl:(NSString *)url
          dynamicLinkDomain:(nullable NSString *)dynamicLinkDomain
            handleCodeInApp:(BOOL)handleCodeInApp
                iOSBundleId:(nullable NSString *)iOSBundleId
         androidPackageName:(nullable NSString *)androidPackageName
          androidInstallApp:(BOOL)androidInstallApp
      androidMinimumVersion:(nullable NSString *)androidMinimumVersion
                 linkDomain:(nullable NSString *)linkDomain {
  PigeonActionCodeSettings *pigeonResult = [[PigeonActionCodeSettings alloc] init];
  pigeonResult.url = url;
  pigeonResult.dynamicLinkDomain = dynamicLinkDomain;
  pigeonResult.handleCodeInApp = handleCodeInApp;
  pigeonResult.iOSBundleId = iOSBundleId;
  pigeonResult.androidPackageName = androidPackageName;
  pigeonResult.androidInstallApp = androidInstallApp;
  pigeonResult.androidMinimumVersion = androidMinimumVersion;
  pigeonResult.linkDomain = linkDomain;
  return pigeonResult;
}
+ (PigeonActionCodeSettings *)fromList:(NSArray *)list {
  PigeonActionCodeSettings *pigeonResult = [[PigeonActionCodeSettings alloc] init];
  pigeonResult.url = GetNullableObjectAtIndex(list, 0);
  pigeonResult.dynamicLinkDomain = GetNullableObjectAtIndex(list, 1);
  pigeonResult.handleCodeInApp = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.iOSBundleId = GetNullableObjectAtIndex(list, 3);
  pigeonResult.androidPackageName = GetNullableObjectAtIndex(list, 4);
  pigeonResult.androidInstallApp = [GetNullableObjectAtIndex(list, 5) boolValue];
  pigeonResult.androidMinimumVersion = GetNullableObjectAtIndex(list, 6);
  pigeonResult.linkDomain = GetNullableObjectAtIndex(list, 7);
  return pigeonResult;
}
+ (nullable PigeonActionCodeSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonActionCodeSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.url ?: [NSNull null],
    self.dynamicLinkDomain ?: [NSNull null],
    @(self.handleCodeInApp),
    self.iOSBundleId ?: [NSNull null],
    self.androidPackageName ?: [NSNull null],
    @(self.androidInstallApp),
    self.androidMinimumVersion ?: [NSNull null],
    self.linkDomain ?: [NSNull null],
  ];
}
@end

@implementation PigeonFirebaseAuthSettings
+ (instancetype)makeWithAppVerificationDisabledForTesting:(BOOL)appVerificationDisabledForTesting
                                          userAccessGroup:(nullable NSString *)userAccessGroup
                                              phoneNumber:(nullable NSString *)phoneNumber
                                                  smsCode:(nullable NSString *)smsCode
                                       forceRecaptchaFlow:(nullable NSNumber *)forceRecaptchaFlow {
  PigeonFirebaseAuthSettings *pigeonResult = [[PigeonFirebaseAuthSettings alloc] init];
  pigeonResult.appVerificationDisabledForTesting = appVerificationDisabledForTesting;
  pigeonResult.userAccessGroup = userAccessGroup;
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.smsCode = smsCode;
  pigeonResult.forceRecaptchaFlow = forceRecaptchaFlow;
  return pigeonResult;
}
+ (PigeonFirebaseAuthSettings *)fromList:(NSArray *)list {
  PigeonFirebaseAuthSettings *pigeonResult = [[PigeonFirebaseAuthSettings alloc] init];
  pigeonResult.appVerificationDisabledForTesting = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.userAccessGroup = GetNullableObjectAtIndex(list, 1);
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 2);
  pigeonResult.smsCode = GetNullableObjectAtIndex(list, 3);
  pigeonResult.forceRecaptchaFlow = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonFirebaseAuthSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonFirebaseAuthSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.appVerificationDisabledForTesting),
    self.userAccessGroup ?: [NSNull null],
    self.phoneNumber ?: [NSNull null],
    self.smsCode ?: [NSNull null],
    self.forceRecaptchaFlow ?: [NSNull null],
  ];
}
@end

@implementation PigeonSignInProvider
+ (instancetype)makeWithProviderId:(NSString *)providerId
                            scopes:(nullable NSArray<NSString *> *)scopes
                  customParameters:
                      (nullable NSDictionary<NSString *, NSString *> *)customParameters {
  PigeonSignInProvider *pigeonResult = [[PigeonSignInProvider alloc] init];
  pigeonResult.providerId = providerId;
  pigeonResult.scopes = scopes;
  pigeonResult.customParameters = customParameters;
  return pigeonResult;
}
+ (PigeonSignInProvider *)fromList:(NSArray *)list {
  PigeonSignInProvider *pigeonResult = [[PigeonSignInProvider alloc] init];
  pigeonResult.providerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.scopes = GetNullableObjectAtIndex(list, 1);
  pigeonResult.customParameters = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable PigeonSignInProvider *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonSignInProvider fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.providerId ?: [NSNull null],
    self.scopes ?: [NSNull null],
    self.customParameters ?: [NSNull null],
  ];
}
@end

@implementation PigeonVerifyPhoneNumberRequest
+ (instancetype)makeWithPhoneNumber:(nullable NSString *)phoneNumber
                            timeout:(NSInteger)timeout
                forceResendingToken:(nullable NSNumber *)forceResendingToken
     autoRetrievedSmsCodeForTesting:(nullable NSString *)autoRetrievedSmsCodeForTesting
                  multiFactorInfoId:(nullable NSString *)multiFactorInfoId
               multiFactorSessionId:(nullable NSString *)multiFactorSessionId {
  PigeonVerifyPhoneNumberRequest *pigeonResult = [[PigeonVerifyPhoneNumberRequest alloc] init];
  pigeonResult.phoneNumber = phoneNumber;
  pigeonResult.timeout = timeout;
  pigeonResult.forceResendingToken = forceResendingToken;
  pigeonResult.autoRetrievedSmsCodeForTesting = autoRetrievedSmsCodeForTesting;
  pigeonResult.multiFactorInfoId = multiFactorInfoId;
  pigeonResult.multiFactorSessionId = multiFactorSessionId;
  return pigeonResult;
}
+ (PigeonVerifyPhoneNumberRequest *)fromList:(NSArray *)list {
  PigeonVerifyPhoneNumberRequest *pigeonResult = [[PigeonVerifyPhoneNumberRequest alloc] init];
  pigeonResult.phoneNumber = GetNullableObjectAtIndex(list, 0);
  pigeonResult.timeout = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.forceResendingToken = GetNullableObjectAtIndex(list, 2);
  pigeonResult.autoRetrievedSmsCodeForTesting = GetNullableObjectAtIndex(list, 3);
  pigeonResult.multiFactorInfoId = GetNullableObjectAtIndex(list, 4);
  pigeonResult.multiFactorSessionId = GetNullableObjectAtIndex(list, 5);
  return pigeonResult;
}
+ (nullable PigeonVerifyPhoneNumberRequest *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonVerifyPhoneNumberRequest fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.phoneNumber ?: [NSNull null],
    @(self.timeout),
    self.forceResendingToken ?: [NSNull null],
    self.autoRetrievedSmsCodeForTesting ?: [NSNull null],
    self.multiFactorInfoId ?: [NSNull null],
    self.multiFactorSessionId ?: [NSNull null],
  ];
}
@end

@implementation PigeonIdTokenResult
+ (instancetype)makeWithToken:(nullable NSString *)token
          expirationTimestamp:(nullable NSNumber *)expirationTimestamp
                authTimestamp:(nullable NSNumber *)authTimestamp
            issuedAtTimestamp:(nullable NSNumber *)issuedAtTimestamp
               signInProvider:(nullable NSString *)signInProvider
                       claims:(nullable NSDictionary<NSString *, id> *)claims
           signInSecondFactor:(nullable NSString *)signInSecondFactor {
  PigeonIdTokenResult *pigeonResult = [[PigeonIdTokenResult alloc] init];
  pigeonResult.token = token;
  pigeonResult.expirationTimestamp = expirationTimestamp;
  pigeonResult.authTimestamp = authTimestamp;
  pigeonResult.issuedAtTimestamp = issuedAtTimestamp;
  pigeonResult.signInProvider = signInProvider;
  pigeonResult.claims = claims;
  pigeonResult.signInSecondFactor = signInSecondFactor;
  return pigeonResult;
}
+ (PigeonIdTokenResult *)fromList:(NSArray *)list {
  PigeonIdTokenResult *pigeonResult = [[PigeonIdTokenResult alloc] init];
  pigeonResult.token = GetNullableObjectAtIndex(list, 0);
  pigeonResult.expirationTimestamp = GetNullableObjectAtIndex(list, 1);
  pigeonResult.authTimestamp = GetNullableObjectAtIndex(list, 2);
  pigeonResult.issuedAtTimestamp = GetNullableObjectAtIndex(list, 3);
  pigeonResult.signInProvider = GetNullableObjectAtIndex(list, 4);
  pigeonResult.claims = GetNullableObjectAtIndex(list, 5);
  pigeonResult.signInSecondFactor = GetNullableObjectAtIndex(list, 6);
  return pigeonResult;
}
+ (nullable PigeonIdTokenResult *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonIdTokenResult fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.token ?: [NSNull null],
    self.expirationTimestamp ?: [NSNull null],
    self.authTimestamp ?: [NSNull null],
    self.issuedAtTimestamp ?: [NSNull null],
    self.signInProvider ?: [NSNull null],
    self.claims ?: [NSNull null],
    self.signInSecondFactor ?: [NSNull null],
  ];
}
@end

@implementation PigeonUserProfile
+ (instancetype)makeWithDisplayName:(nullable NSString *)displayName
                           photoUrl:(nullable NSString *)photoUrl
                 displayNameChanged:(BOOL)displayNameChanged
                    photoUrlChanged:(BOOL)photoUrlChanged {
  PigeonUserProfile *pigeonResult = [[PigeonUserProfile alloc] init];
  pigeonResult.displayName = displayName;
  pigeonResult.photoUrl = photoUrl;
  pigeonResult.displayNameChanged = displayNameChanged;
  pigeonResult.photoUrlChanged = photoUrlChanged;
  return pigeonResult;
}
+ (PigeonUserProfile *)fromList:(NSArray *)list {
  PigeonUserProfile *pigeonResult = [[PigeonUserProfile alloc] init];
  pigeonResult.displayName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.photoUrl = GetNullableObjectAtIndex(list, 1);
  pigeonResult.displayNameChanged = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.photoUrlChanged = [GetNullableObjectAtIndex(list, 3) boolValue];
  return pigeonResult;
}
+ (nullable PigeonUserProfile *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonUserProfile fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.displayName ?: [NSNull null],
    self.photoUrl ?: [NSNull null],
    @(self.displayNameChanged),
    @(self.photoUrlChanged),
  ];
}
@end

@implementation PigeonTotpSecret
+ (instancetype)makeWithCodeIntervalSeconds:(nullable NSNumber *)codeIntervalSeconds
                                 codeLength:(nullable NSNumber *)codeLength
               enrollmentCompletionDeadline:(nullable NSNumber *)enrollmentCompletionDeadline
                           hashingAlgorithm:(nullable NSString *)hashingAlgorithm
                                  secretKey:(NSString *)secretKey {
  PigeonTotpSecret *pigeonResult = [[PigeonTotpSecret alloc] init];
  pigeonResult.codeIntervalSeconds = codeIntervalSeconds;
  pigeonResult.codeLength = codeLength;
  pigeonResult.enrollmentCompletionDeadline = enrollmentCompletionDeadline;
  pigeonResult.hashingAlgorithm = hashingAlgorithm;
  pigeonResult.secretKey = secretKey;
  return pigeonResult;
}
+ (PigeonTotpSecret *)fromList:(NSArray *)list {
  PigeonTotpSecret *pigeonResult = [[PigeonTotpSecret alloc] init];
  pigeonResult.codeIntervalSeconds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.codeLength = GetNullableObjectAtIndex(list, 1);
  pigeonResult.enrollmentCompletionDeadline = GetNullableObjectAtIndex(list, 2);
  pigeonResult.hashingAlgorithm = GetNullableObjectAtIndex(list, 3);
  pigeonResult.secretKey = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable PigeonTotpSecret *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonTotpSecret fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.codeIntervalSeconds ?: [NSNull null],
    self.codeLength ?: [NSNull null],
    self.enrollmentCompletionDeadline ?: [NSNull null],
    self.hashingAlgorithm ?: [NSNull null],
    self.secretKey ?: [NSNull null],
  ];
}
@end

@interface FirebaseAuthHostApiCodecReader : FlutterStandardReader
@end
@implementation FirebaseAuthHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonActionCodeInfo fromList:[self readValue]];
    case 130:
      return [PigeonActionCodeInfoData fromList:[self readValue]];
    case 131:
      return [PigeonActionCodeSettings fromList:[self readValue]];
    case 132:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 133:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 134:
      return [PigeonFirebaseAuthSettings fromList:[self readValue]];
    case 135:
      return [PigeonIdTokenResult fromList:[self readValue]];
    case 136:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 137:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 138:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 139:
      return [PigeonSignInProvider fromList:[self readValue]];
    case 140:
      return [PigeonTotpSecret fromList:[self readValue]];
    case 141:
      return [PigeonUserCredential fromList:[self readValue]];
    case 142:
      return [PigeonUserDetails fromList:[self readValue]];
    case 143:
      return [PigeonUserInfo fromList:[self readValue]];
    case 144:
      return [PigeonUserProfile fromList:[self readValue]];
    case 145:
      return [PigeonVerifyPhoneNumberRequest fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseAuthHostApiCodecWriter : FlutterStandardWriter
@end
@implementation FirebaseAuthHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfoData class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeSettings class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseAuthSettings class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonIdTokenResult class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSignInProvider class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserProfile class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonVerifyPhoneNumberRequest class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseAuthHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseAuthHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseAuthHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseAuthHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseAuthHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseAuthHostApiCodecReaderWriter *readerWriter =
        [[FirebaseAuthHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFirebaseAuthHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FirebaseAuthHostApi> *api) {
  SetUpFirebaseAuthHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAuthHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FirebaseAuthHostApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.registerIdTokenListener",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerIdTokenListenerApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(registerIdTokenListenerApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api registerIdTokenListenerApp:arg_app
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.registerAuthStateListener",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerAuthStateListenerApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(registerAuthStateListenerApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api registerAuthStateListenerApp:arg_app
                               completion:^(NSString *_Nullable output,
                                            FlutterError *_Nullable error) {
                                 callback(wrapResult(output, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.useEmulator",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(useEmulatorApp:host:port:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(useEmulatorApp:host:port:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_host = GetNullableObjectAtIndex(args, 1);
        NSInteger arg_port = [GetNullableObjectAtIndex(args, 2) integerValue];
        [api useEmulatorApp:arg_app
                       host:arg_host
                       port:arg_port
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.applyActionCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(applyActionCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(applyActionCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api applyActionCodeApp:arg_app
                           code:arg_code
                     completion:^(FlutterError *_Nullable error) {
                       callback(wrapResult(nil, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.checkActionCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(checkActionCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(checkActionCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api checkActionCodeApp:arg_app
                           code:arg_code
                     completion:^(PigeonActionCodeInfo *_Nullable output,
                                  FlutterError *_Nullable error) {
                       callback(wrapResult(output, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.confirmPasswordReset",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(confirmPasswordResetApp:
                                                                     code:newPassword:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(confirmPasswordResetApp:code:newPassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        NSString *arg_newPassword = GetNullableObjectAtIndex(args, 2);
        [api confirmPasswordResetApp:arg_app
                                code:arg_code
                         newPassword:arg_newPassword
                          completion:^(FlutterError *_Nullable error) {
                            callback(wrapResult(nil, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.createUserWithEmailAndPassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (createUserWithEmailAndPasswordApp:email:password:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(createUserWithEmailAndPasswordApp:email:password:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_password = GetNullableObjectAtIndex(args, 2);
        [api createUserWithEmailAndPasswordApp:arg_app
                                         email:arg_email
                                      password:arg_password
                                    completion:^(PigeonUserCredential *_Nullable output,
                                                 FlutterError *_Nullable error) {
                                      callback(wrapResult(output, error));
                                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInAnonymously",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInAnonymouslyApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInAnonymouslyApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api signInAnonymouslyApp:arg_app
                       completion:^(PigeonUserCredential *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithCredential",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithCredentialApp:input:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api signInWithCredentialApp:arg_app
                               input:arg_input
                          completion:^(PigeonUserCredential *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithCustomToken",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithCustomTokenApp:token:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithCustomTokenApp:token:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_token = GetNullableObjectAtIndex(args, 1);
        [api signInWithCustomTokenApp:arg_app
                                token:arg_token
                           completion:^(PigeonUserCredential *_Nullable output,
                                        FlutterError *_Nullable error) {
                             callback(wrapResult(output, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithEmailAndPassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (signInWithEmailAndPasswordApp:email:password:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithEmailAndPasswordApp:email:password:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_password = GetNullableObjectAtIndex(args, 2);
        [api signInWithEmailAndPasswordApp:arg_app
                                     email:arg_email
                                  password:arg_password
                                completion:^(PigeonUserCredential *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithEmailLink",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithEmailLinkApp:
                                                                   email:emailLink:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithEmailLinkApp:email:emailLink:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        NSString *arg_emailLink = GetNullableObjectAtIndex(args, 2);
        [api signInWithEmailLinkApp:arg_app
                              email:arg_email
                          emailLink:arg_emailLink
                         completion:^(PigeonUserCredential *_Nullable output,
                                      FlutterError *_Nullable error) {
                           callback(wrapResult(output, error));
                         }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.signInWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithProviderApp:
                                                         signInProvider:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(signInWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api signInWithProviderApp:arg_app
                    signInProvider:arg_signInProvider
                        completion:^(PigeonUserCredential *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.signOut",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(signOutApp:completion:)],
          @"FirebaseAuthHostApi api (%@) doesn't respond to @selector(signOutApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api signOutApp:arg_app
             completion:^(FlutterError *_Nullable error) {
               callback(wrapResult(nil, error));
             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.fetchSignInMethodsForEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(fetchSignInMethodsForEmailApp:email:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(fetchSignInMethodsForEmailApp:email:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        [api fetchSignInMethodsForEmailApp:arg_app
                                     email:arg_email
                                completion:^(NSArray<NSString *> *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.sendPasswordResetEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (sendPasswordResetEmailApp:email:actionCodeSettings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(sendPasswordResetEmailApp:email:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api sendPasswordResetEmailApp:arg_app
                                 email:arg_email
                    actionCodeSettings:arg_actionCodeSettings
                            completion:^(FlutterError *_Nullable error) {
                              callback(wrapResult(nil, error));
                            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.sendSignInLinkToEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (sendSignInLinkToEmailApp:email:actionCodeSettings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(sendSignInLinkToEmailApp:email:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_email = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api sendSignInLinkToEmailApp:arg_app
                                email:arg_email
                   actionCodeSettings:arg_actionCodeSettings
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.setLanguageCode",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLanguageCodeApp:languageCode:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(setLanguageCodeApp:languageCode:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_languageCode = GetNullableObjectAtIndex(args, 1);
        [api setLanguageCodeApp:arg_app
                   languageCode:arg_languageCode
                     completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                       callback(wrapResult(output, error));
                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthHostApi.setSettings",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSettingsApp:settings:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(setSettingsApp:settings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonFirebaseAuthSettings *arg_settings = GetNullableObjectAtIndex(args, 1);
        [api setSettingsApp:arg_app
                   settings:arg_settings
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.verifyPasswordResetCode",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(verifyPasswordResetCodeApp:code:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(verifyPasswordResetCodeApp:code:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_code = GetNullableObjectAtIndex(args, 1);
        [api verifyPasswordResetCodeApp:arg_app
                                   code:arg_code
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.verifyPhoneNumber",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(verifyPhoneNumberApp:request:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(verifyPhoneNumberApp:request:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonVerifyPhoneNumberRequest *arg_request = GetNullableObjectAtIndex(args, 1);
        [api verifyPhoneNumberApp:arg_app
                          request:arg_request
                       completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                          @"FirebaseAuthHostApi.revokeTokenWithAuthorizationCode",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(revokeTokenWithAuthorizationCodeApp:
                                                                    authorizationCode:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(revokeTokenWithAuthorizationCodeApp:authorizationCode:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_authorizationCode = GetNullableObjectAtIndex(args, 1);
        [api revokeTokenWithAuthorizationCodeApp:arg_app
                               authorizationCode:arg_authorizationCode
                                      completion:^(FlutterError *_Nullable error) {
                                        callback(wrapResult(nil, error));
                                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthHostApi.initializeRecaptchaConfig",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeRecaptchaConfigApp:completion:)],
                @"FirebaseAuthHostApi api (%@) doesn't respond to "
                @"@selector(initializeRecaptchaConfigApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api initializeRecaptchaConfigApp:arg_app
                               completion:^(FlutterError *_Nullable error) {
                                 callback(wrapResult(nil, error));
                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FirebaseAuthUserHostApiCodecReader : FlutterStandardReader
@end
@implementation FirebaseAuthUserHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonActionCodeInfo fromList:[self readValue]];
    case 130:
      return [PigeonActionCodeInfoData fromList:[self readValue]];
    case 131:
      return [PigeonActionCodeSettings fromList:[self readValue]];
    case 132:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 133:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 134:
      return [PigeonFirebaseAuthSettings fromList:[self readValue]];
    case 135:
      return [PigeonIdTokenResult fromList:[self readValue]];
    case 136:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 137:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 138:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 139:
      return [PigeonSignInProvider fromList:[self readValue]];
    case 140:
      return [PigeonTotpSecret fromList:[self readValue]];
    case 141:
      return [PigeonUserCredential fromList:[self readValue]];
    case 142:
      return [PigeonUserDetails fromList:[self readValue]];
    case 143:
      return [PigeonUserInfo fromList:[self readValue]];
    case 144:
      return [PigeonUserProfile fromList:[self readValue]];
    case 145:
      return [PigeonVerifyPhoneNumberRequest fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirebaseAuthUserHostApiCodecWriter : FlutterStandardWriter
@end
@implementation FirebaseAuthUserHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeInfoData class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonActionCodeSettings class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonFirebaseAuthSettings class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonIdTokenResult class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonSignInProvider class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserProfile class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonVerifyPhoneNumberRequest class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirebaseAuthUserHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirebaseAuthUserHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirebaseAuthUserHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirebaseAuthUserHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirebaseAuthUserHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirebaseAuthUserHostApiCodecReaderWriter *readerWriter =
        [[FirebaseAuthUserHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFirebaseAuthUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                  NSObject<FirebaseAuthUserHostApi> *api) {
  SetUpFirebaseAuthUserHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAuthUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                            NSObject<FirebaseAuthUserHostApi> *api,
                                            NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.delete",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(deleteApp:completion:)],
          @"FirebaseAuthUserHostApi api (%@) doesn't respond to @selector(deleteApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api deleteApp:arg_app
            completion:^(FlutterError *_Nullable error) {
              callback(wrapResult(nil, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.getIdToken",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getIdTokenApp:forceRefresh:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(getIdTokenApp:forceRefresh:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        BOOL arg_forceRefresh = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api getIdTokenApp:arg_app
              forceRefresh:arg_forceRefresh
                completion:^(PigeonIdTokenResult *_Nullable output, FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.linkWithCredential",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(linkWithCredentialApp:input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(linkWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api linkWithCredentialApp:arg_app
                             input:arg_input
                        completion:^(PigeonUserCredential *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.linkWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(linkWithProviderApp:signInProvider:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(linkWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api linkWithProviderApp:arg_app
                  signInProvider:arg_signInProvider
                      completion:^(PigeonUserCredential *_Nullable output,
                                   FlutterError *_Nullable error) {
                        callback(wrapResult(output, error));
                      }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                          @"FirebaseAuthUserHostApi.reauthenticateWithCredential",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reauthenticateWithCredentialApp:
                                                                            input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(reauthenticateWithCredentialApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api reauthenticateWithCredentialApp:arg_app
                                       input:arg_input
                                  completion:^(PigeonUserCredential *_Nullable output,
                                               FlutterError *_Nullable error) {
                                    callback(wrapResult(output, error));
                                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.reauthenticateWithProvider",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reauthenticateWithProviderApp:
                                                                 signInProvider:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(reauthenticateWithProviderApp:signInProvider:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonSignInProvider *arg_signInProvider = GetNullableObjectAtIndex(args, 1);
        [api reauthenticateWithProviderApp:arg_app
                            signInProvider:arg_signInProvider
                                completion:^(PigeonUserCredential *_Nullable output,
                                             FlutterError *_Nullable error) {
                                  callback(wrapResult(output, error));
                                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.reload",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(reloadApp:completion:)],
          @"FirebaseAuthUserHostApi api (%@) doesn't respond to @selector(reloadApp:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api reloadApp:arg_app
            completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
              callback(wrapResult(output, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.sendEmailVerification",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendEmailVerificationApp:
                                                        actionCodeSettings:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(sendEmailVerificationApp:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 1);
        [api sendEmailVerificationApp:arg_app
                   actionCodeSettings:arg_actionCodeSettings
                           completion:^(FlutterError *_Nullable error) {
                             callback(wrapResult(nil, error));
                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.unlink",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unlinkApp:providerId:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(unlinkApp:providerId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_providerId = GetNullableObjectAtIndex(args, 1);
        [api unlinkApp:arg_app
            providerId:arg_providerId
            completion:^(PigeonUserCredential *_Nullable output, FlutterError *_Nullable error) {
              callback(wrapResult(output, error));
            }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.FirebaseAuthUserHostApi.updateEmail",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateEmailApp:newEmail:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updateEmailApp:newEmail:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newEmail = GetNullableObjectAtIndex(args, 1);
        [api updateEmailApp:arg_app
                   newEmail:arg_newEmail
                 completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
                   callback(wrapResult(output, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updatePassword",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePasswordApp:newPassword:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updatePasswordApp:newPassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newPassword = GetNullableObjectAtIndex(args, 1);
        [api updatePasswordApp:arg_app
                   newPassword:arg_newPassword
                    completion:^(PigeonUserDetails *_Nullable output,
                                 FlutterError *_Nullable error) {
                      callback(wrapResult(output, error));
                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updatePhoneNumber",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePhoneNumberApp:input:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updatePhoneNumberApp:input:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_input = GetNullableObjectAtIndex(args, 1);
        [api updatePhoneNumberApp:arg_app
                            input:arg_input
                       completion:^(PigeonUserDetails *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.updateProfile",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateProfileApp:profile:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(updateProfileApp:profile:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonUserProfile *arg_profile = GetNullableObjectAtIndex(args, 1);
        [api
            updateProfileApp:arg_app
                     profile:arg_profile
                  completion:^(PigeonUserDetails *_Nullable output, FlutterError *_Nullable error) {
                    callback(wrapResult(output, error));
                  }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"FirebaseAuthUserHostApi.verifyBeforeUpdateEmail",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FirebaseAuthUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (verifyBeforeUpdateEmailApp:newEmail:actionCodeSettings:completion:)],
                @"FirebaseAuthUserHostApi api (%@) doesn't respond to "
                @"@selector(verifyBeforeUpdateEmailApp:newEmail:actionCodeSettings:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_newEmail = GetNullableObjectAtIndex(args, 1);
        PigeonActionCodeSettings *arg_actionCodeSettings = GetNullableObjectAtIndex(args, 2);
        [api verifyBeforeUpdateEmailApp:arg_app
                               newEmail:arg_newEmail
                     actionCodeSettings:arg_actionCodeSettings
                             completion:^(FlutterError *_Nullable error) {
                               callback(wrapResult(nil, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactorUserHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactorUserHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [AuthPigeonFirebaseApp fromList:[self readValue]];
    case 129:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    case 130:
      return [PigeonMultiFactorSession fromList:[self readValue]];
    case 131:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactorUserHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactorUserHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AuthPigeonFirebaseApp class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonMultiFactorSession class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactorUserHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactorUserHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactorUserHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactorUserHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactorUserHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactorUserHostApiCodecReaderWriter *readerWriter =
        [[MultiFactorUserHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactorUserHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<MultiFactorUserHostApi> *api) {
  SetUpMultiFactorUserHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorUserHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactorUserHostApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.enrollPhone",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enrollPhoneApp:
                                                       assertion:displayName:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(enrollPhoneApp:assertion:displayName:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        PigeonPhoneMultiFactorAssertion *arg_assertion = GetNullableObjectAtIndex(args, 1);
        NSString *arg_displayName = GetNullableObjectAtIndex(args, 2);
        [api enrollPhoneApp:arg_app
                  assertion:arg_assertion
                displayName:arg_displayName
                 completion:^(FlutterError *_Nullable error) {
                   callback(wrapResult(nil, error));
                 }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.enrollTotp",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(enrollTotpApp:
                                                    assertionId:displayName:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(enrollTotpApp:assertionId:displayName:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_assertionId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_displayName = GetNullableObjectAtIndex(args, 2);
        [api enrollTotpApp:arg_app
               assertionId:arg_assertionId
               displayName:arg_displayName
                completion:^(FlutterError *_Nullable error) {
                  callback(wrapResult(nil, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.getSession",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSessionApp:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(getSessionApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api getSessionApp:arg_app
                completion:^(PigeonMultiFactorSession *_Nullable output,
                             FlutterError *_Nullable error) {
                  callback(wrapResult(output, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.MultiFactorUserHostApi.unenroll",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unenrollApp:factorUid:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(unenrollApp:factorUid:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        NSString *arg_factorUid = GetNullableObjectAtIndex(args, 1);
        [api unenrollApp:arg_app
               factorUid:arg_factorUid
              completion:^(FlutterError *_Nullable error) {
                callback(wrapResult(nil, error));
              }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorUserHostApi.getEnrolledFactors",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorUserHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getEnrolledFactorsApp:completion:)],
                @"MultiFactorUserHostApi api (%@) doesn't respond to "
                @"@selector(getEnrolledFactorsApp:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AuthPigeonFirebaseApp *arg_app = GetNullableObjectAtIndex(args, 0);
        [api getEnrolledFactorsApp:arg_app
                        completion:^(NSArray<PigeonMultiFactorInfo *> *_Nullable output,
                                     FlutterError *_Nullable error) {
                          callback(wrapResult(output, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactoResolverHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactoResolverHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonAdditionalUserInfo fromList:[self readValue]];
    case 129:
      return [PigeonAuthCredential fromList:[self readValue]];
    case 130:
      return [PigeonPhoneMultiFactorAssertion fromList:[self readValue]];
    case 131:
      return [PigeonUserCredential fromList:[self readValue]];
    case 132:
      return [PigeonUserDetails fromList:[self readValue]];
    case 133:
      return [PigeonUserInfo fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactoResolverHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactoResolverHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonAdditionalUserInfo class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonAuthCredential class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonPhoneMultiFactorAssertion class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserCredential class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserDetails class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonUserInfo class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactoResolverHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactoResolverHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactoResolverHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactoResolverHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactoResolverHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactoResolverHostApiCodecReaderWriter *readerWriter =
        [[MultiFactoResolverHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactoResolverHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<MultiFactoResolverHostApi> *api) {
  SetUpMultiFactoResolverHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactoResolverHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<MultiFactoResolverHostApi> *api,
                                              NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactoResolverHostApi.resolveSignIn",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactoResolverHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (resolveSignInResolverId:assertion:totpAssertionId:completion:)],
                @"MultiFactoResolverHostApi api (%@) doesn't respond to "
                @"@selector(resolveSignInResolverId:assertion:totpAssertionId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_resolverId = GetNullableObjectAtIndex(args, 0);
        PigeonPhoneMultiFactorAssertion *arg_assertion = GetNullableObjectAtIndex(args, 1);
        NSString *arg_totpAssertionId = GetNullableObjectAtIndex(args, 2);
        [api resolveSignInResolverId:arg_resolverId
                           assertion:arg_assertion
                     totpAssertionId:arg_totpAssertionId
                          completion:^(PigeonUserCredential *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MultiFactorTotpHostApiCodecReader : FlutterStandardReader
@end
@implementation MultiFactorTotpHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonTotpSecret fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MultiFactorTotpHostApiCodecWriter : FlutterStandardWriter
@end
@implementation MultiFactorTotpHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonTotpSecret class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MultiFactorTotpHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MultiFactorTotpHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MultiFactorTotpHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MultiFactorTotpHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MultiFactorTotpHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MultiFactorTotpHostApiCodecReaderWriter *readerWriter =
        [[MultiFactorTotpHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMultiFactorTotpHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<MultiFactorTotpHostApi> *api) {
  SetUpMultiFactorTotpHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorTotpHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<MultiFactorTotpHostApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.generateSecret",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(generateSecretSessionId:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(generateSecretSessionId:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sessionId = GetNullableObjectAtIndex(args, 0);
        [api generateSecretSessionId:arg_sessionId
                          completion:^(PigeonTotpSecret *_Nullable output,
                                       FlutterError *_Nullable error) {
                            callback(wrapResult(output, error));
                          }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.getAssertionForEnrollment",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAssertionForEnrollmentSecretKey:
                                                                     oneTimePassword:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(getAssertionForEnrollmentSecretKey:oneTimePassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_oneTimePassword = GetNullableObjectAtIndex(args, 1);
        [api getAssertionForEnrollmentSecretKey:arg_secretKey
                                oneTimePassword:arg_oneTimePassword
                                     completion:^(NSString *_Nullable output,
                                                  FlutterError *_Nullable error) {
                                       callback(wrapResult(output, error));
                                     }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpHostApi.getAssertionForSignIn",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAssertionForSignInEnrollmentId:
                                                                    oneTimePassword:completion:)],
                @"MultiFactorTotpHostApi api (%@) doesn't respond to "
                @"@selector(getAssertionForSignInEnrollmentId:oneTimePassword:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_enrollmentId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_oneTimePassword = GetNullableObjectAtIndex(args, 1);
        [api getAssertionForSignInEnrollmentId:arg_enrollmentId
                               oneTimePassword:arg_oneTimePassword
                                    completion:^(NSString *_Nullable output,
                                                 FlutterError *_Nullable error) {
                                      callback(wrapResult(output, error));
                                    }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *MultiFactorTotpSecretHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpMultiFactorTotpSecretHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<MultiFactorTotpSecretHostApi> *api) {
  SetUpMultiFactorTotpSecretHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpMultiFactorTotpSecretHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                                 NSObject<MultiFactorTotpSecretHostApi> *api,
                                                 NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpSecretHostApi.generateQrCodeUrl",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpSecretHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(generateQrCodeUrlSecretKey:
                                                                 accountName:issuer:completion:)],
                @"MultiFactorTotpSecretHostApi api (%@) doesn't respond to "
                @"@selector(generateQrCodeUrlSecretKey:accountName:issuer:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_accountName = GetNullableObjectAtIndex(args, 1);
        NSString *arg_issuer = GetNullableObjectAtIndex(args, 2);
        [api generateQrCodeUrlSecretKey:arg_secretKey
                            accountName:arg_accountName
                                 issuer:arg_issuer
                             completion:^(NSString *_Nullable output,
                                          FlutterError *_Nullable error) {
                               callback(wrapResult(output, error));
                             }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_auth_platform_interface."
                                             @"MultiFactorTotpSecretHostApi.openInOtpApp",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:MultiFactorTotpSecretHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openInOtpAppSecretKey:qrCodeUrl:completion:)],
                @"MultiFactorTotpSecretHostApi api (%@) doesn't respond to "
                @"@selector(openInOtpAppSecretKey:qrCodeUrl:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_qrCodeUrl = GetNullableObjectAtIndex(args, 1);
        [api openInOtpAppSecretKey:arg_secretKey
                         qrCodeUrl:arg_qrCodeUrl
                        completion:^(FlutterError *_Nullable error) {
                          callback(wrapResult(nil, error));
                        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface GenerateInterfacesCodecReader : FlutterStandardReader
@end
@implementation GenerateInterfacesCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128:
      return [PigeonMultiFactorInfo fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface GenerateInterfacesCodecWriter : FlutterStandardWriter
@end
@implementation GenerateInterfacesCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonMultiFactorInfo class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface GenerateInterfacesCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation GenerateInterfacesCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[GenerateInterfacesCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[GenerateInterfacesCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *GenerateInterfacesGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    GenerateInterfacesCodecReaderWriter *readerWriter =
        [[GenerateInterfacesCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpGenerateInterfaces(id<FlutterBinaryMessenger> binaryMessenger,
                             NSObject<GenerateInterfaces> *api) {
  SetUpGenerateInterfacesWithSuffix(binaryMessenger, api, @"");
}

void SetUpGenerateInterfacesWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<GenerateInterfaces> *api,
                                       NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_auth_platform_"
                                                   @"interface.GenerateInterfaces.pigeonInterface",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:GenerateInterfacesGetCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(pigeonInterfaceInfo:error:)],
          @"GenerateInterfaces api (%@) doesn't respond to @selector(pigeonInterfaceInfo:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PigeonMultiFactorInfo *arg_info = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api pigeonInterfaceInfo:arg_info error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/macos/firebase_auth/Package.swift

**크기**: 4251 bytes | **라인 수**: 119 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let authDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    authDirectory,
    "..",
    "..",
    "ios",
    "generated_firebase_sdk_version.txt",
  ])
  do {
    let version = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
      .trimmingCharacters(in: .whitespacesAndNewlines)
    return version
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing generated_firebase_sdk_version.txt: \(error)")
  }
}

func loadPubspecVersions() throws -> (packageVersion: String, firebaseCoreVersion: String) {
  let pubspecPath = NSString.path(withComponents: [authDirectory, "..", "..", "pubspec.yaml"])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    let lines = yamlString.split(separator: "\n")

    guard let packageVersionLine = lines.first(where: { $0.starts(with: "version:") }) else {
      throw ConfigurationError.invalidFormat("No package version line found in pubspec.yaml")
    }
    var packageVersion = packageVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
      .replacingOccurrences(of: "+", with: "-")
    packageVersion = packageVersion.replacingOccurrences(of: "^", with: "")

    guard let firebaseCoreVersionLine = lines.first(where: { $0.contains("firebase_core:") }) else {
      throw ConfigurationError
        .invalidFormat("No firebase_core dependency version line found in pubspec.yaml")
    }
    var firebaseCoreVersion = firebaseCoreVersionLine.split(separator: ":")[1]
      .trimmingCharacters(in: .whitespaces)
    firebaseCoreVersion = firebaseCoreVersion.replacingOccurrences(of: "^", with: "")

    return (packageVersion, firebaseCoreVersion)
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

let library_version: String
let firebase_sdk_version_string: String
let firebase_core_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version = try loadPubspecVersions().packageVersion
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
  firebase_core_version_string = try loadPubspecVersions().firebaseCoreVersion
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

guard let shared_spm_version = Version("\(firebase_core_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(firebase_core_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "firebase_auth",
  platforms: [
    .macOS("10.15"),
  ],
  products: [
    .library(name: "firebase-auth", targets: ["firebase_auth"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "firebase_auth",
      dependencies: [
        .product(name: "FirebaseAuth", package: "firebase-ios-sdk"),
        // Wrapper dependency
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/firebase_auth/Private"),
        .headerSearchPath("include/firebase_auth/Public"),
        .define("LIBRARY_VERSION", to: "\"\(library_version)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-auth\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/test/firebase_auth_test.dart

**크기**: 45101 bytes | **라인 수**: 1330 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:async/async.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_auth_platform_interface/src/method_channel/method_channel_firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

import './mock.dart';

void main() {
  setupFirebaseAuthMocks();

  late FirebaseAuth auth;

  const String kMockActionCode = '12345';
  const String kMockEmail = 'test@example.com';
  const String kMockPassword = 'passw0rd';
  const String kMockIdToken = '12345';
  const String kMockRawNonce = 'abcde12345';
  const String kMockAccessToken = '67890';
  const String kMockGithubToken = 'github';
  const String kMockCustomToken = '12345';
  const String kMockPhoneNumber = '5555555555';
  const String kMockVerificationId = '12345';
  const String kMockSmsCode = '123456';
  const String kMockLanguage = 'en';
  const String kMockOobCode = 'oobcode';
  const String kMockURL = 'http://www.example.com';
  const String kMockHost = 'www.example.com';
  const String kMockValidPassword =
      'Password123!'; // For password policy impl testing
  const String kMockInvalidPassword = 'Pa1!';
  const String kMockInvalidPassword2 = 'password123!';
  const String kMockInvalidPassword3 = 'PASSWORD123!';
  const String kMockInvalidPassword4 = 'password!';
  const String kMockInvalidPassword5 = 'Password123';
  const Map<String, dynamic> kMockPasswordPolicy = {
    'customStrengthOptions': {
      'minPasswordLength': 6,
      'maxPasswordLength': 12,
      'containsLowercaseCharacter': true,
      'containsUppercaseCharacter': true,
      'containsNumericCharacter': true,
      'containsNonAlphanumericCharacter': true,
    },
    'allowedNonAlphanumericCharacters': ['!'],
    'schemaVersion': 1,
    'enforcement': 'OFF',
  };
  final PasswordPolicy kMockPasswordPolicyObject =
      PasswordPolicy(kMockPasswordPolicy);
  const int kMockPort = 31337;

  final TestAuthProvider testAuthProvider = TestAuthProvider();
  final int kMockCreationTimestamp =
      DateTime.now().subtract(const Duration(days: 2)).millisecondsSinceEpoch;
  final int kMockLastSignInTimestamp =
      DateTime.now().subtract(const Duration(days: 1)).millisecondsSinceEpoch;

  final kMockUser = PigeonUserDetails(
    userInfo: PigeonUserInfo(
      uid: '12345',
      displayName: 'displayName',
      creationTimestamp: kMockCreationTimestamp,
      lastSignInTimestamp: kMockLastSignInTimestamp,
      isAnonymous: true,
      isEmailVerified: false,
    ),
    providerData: [
      {
        'providerId': 'firebase',
        'uid': '12345',
        'displayName': 'Flutter Test User',
        'photoUrl': 'http://www.example.com/',
        'email': 'test@example.com',
      }
    ],
  );

  late MockUserPlatform mockUserPlatform;
  late MockUserCredentialPlatform mockUserCredPlatform;
  late MockConfirmationResultPlatform mockConfirmationResultPlatform;
  late MockRecaptchaVerifier mockVerifier;
  late AdditionalUserInfo mockAdditionalUserInfo;
  late EmailAuthCredential mockCredential;

  MockFirebaseAuth mockAuthPlatform = MockFirebaseAuth();

  group('$FirebaseAuth', () {
    PigeonUserDetails user;
    // used to generate a unique application name for each test
    var testCount = 0;

    setUp(() async {
      FirebaseAuthPlatform.instance = mockAuthPlatform = MockFirebaseAuth();

      // Each test uses a unique FirebaseApp instance to avoid sharing state
      final app = await Firebase.initializeApp(
        name: '$testCount',
        options: const FirebaseOptions(
          apiKey: '',
          appId: '',
          messagingSenderId: '',
          projectId: '',
        ),
      );

      auth = FirebaseAuth.instanceFor(app: app);
      user = kMockUser;

      mockUserPlatform = MockUserPlatform(
          mockAuthPlatform, TestMultiFactorPlatform(mockAuthPlatform), user);
      mockConfirmationResultPlatform = MockConfirmationResultPlatform();
      mockAdditionalUserInfo = AdditionalUserInfo(
        isNewUser: false,
        username: 'flutterUser',
        providerId: 'testProvider',
        profile: <String, dynamic>{'foo': 'bar'},
      );
      mockCredential = EmailAuthProvider.credential(
        email: 'test',
        password: 'test',
      ) as EmailAuthCredential;
      mockUserCredPlatform = MockUserCredentialPlatform(
        FirebaseAuthPlatform.instance,
        mockAdditionalUserInfo,
        mockCredential,
        mockUserPlatform,
      );
      mockVerifier = MockRecaptchaVerifier();

      when(mockAuthPlatform.signInAnonymously())
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithCredential(any)).thenAnswer(
          (_) => Future<UserCredentialPlatform>.value(mockUserCredPlatform));

      when(mockAuthPlatform.currentUser).thenReturn(mockUserPlatform);

      when(mockAuthPlatform.instanceFor(
        app: anyNamed('app'),
        pluginConstants: anyNamed('pluginConstants'),
      )).thenAnswer((_) => mockUserPlatform);

      when(mockAuthPlatform.delegateFor(
        app: anyNamed('app'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.setInitialValues(
        currentUser: anyNamed('currentUser'),
        languageCode: anyNamed('languageCode'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.createUserWithEmailAndPassword(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.getRedirectResult())
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithCustomToken(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithEmailAndPassword(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithEmailLink(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithPhoneNumber(any, any))
          .thenAnswer((_) async => mockConfirmationResultPlatform);

      when(mockVerifier.delegate).thenReturn(mockVerifier.mockDelegate);

      when(mockAuthPlatform.signInWithPopup(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithRedirect(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.authStateChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      when(mockAuthPlatform.idTokenChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      when(mockAuthPlatform.userChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(MethodChannelFirebaseAuth.channel,
              (call) async {
        return <String, dynamic>{'user': user};
      });
    });

    // incremented after tests completed, in case a test may want to use this
    // value for an assertion (toString)
    tearDown(() => testCount++);

    setUp(() async {
      user = kMockUser;
      await auth.signInAnonymously();
    });

    group('emulator', () {
      test('useAuthEmulator() should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.useAuthEmulator(kMockHost, kMockPort))
            .thenAnswer((i) async {});
        await auth.useAuthEmulator(kMockHost, kMockPort);
        verify(mockAuthPlatform.useAuthEmulator(kMockHost, kMockPort));
      });
    });

    group('currentUser', () {
      test('get currentUser', () {
        User? user = auth.currentUser;
        verify(mockAuthPlatform.currentUser);
        expect(user, isA<User>());
      });
    });

    group('tenantId', () {
      test('set tenantId should call delegate method', () async {
        // Each test uses a unique FirebaseApp instance to avoid sharing state
        final app = await Firebase.initializeApp(
            name: 'tenantIdTest',
            options: const FirebaseOptions(
                apiKey: 'apiKey',
                appId: 'appId',
                messagingSenderId: 'messagingSenderId',
                projectId: 'projectId'));

        FirebaseAuthPlatform.instance =
            FakeFirebaseAuthPlatform(tenantId: 'foo');
        auth = FirebaseAuth.instanceFor(app: app);

        expect(auth.tenantId, 'foo');

        auth.tenantId = 'bar';

        expect(auth.tenantId, 'bar');
        expect(FirebaseAuthPlatform.instance.tenantId, 'bar');
      });
    });

    group('customAuthDomain', () {
      test('set customAuthDomain should call delegate method', () async {
        // Each test uses a unique FirebaseApp instance to avoid sharing state
        final app = await Firebase.initializeApp(
            name: 'customAuthDomainTest',
            options: const FirebaseOptions(
                apiKey: 'apiKey',
                appId: 'appId',
                messagingSenderId: 'messagingSenderId',
                projectId: 'projectId'));

        FirebaseAuthPlatform.instance =
            FakeFirebaseAuthPlatform(customAuthDomain: 'foo');
        auth = FirebaseAuth.instanceFor(app: app);

        expect(auth.customAuthDomain, 'foo');
        if (defaultTargetPlatform == TargetPlatform.windows || kIsWeb) {
          try {
            auth.customAuthDomain = 'bar';
          } on UnimplementedError catch (e) {
            expect(e.message, contains('Cannot set auth domain'));
          }
        } else {
          auth.customAuthDomain = 'bar';

          expect(auth.customAuthDomain, 'bar');
          expect(FirebaseAuthPlatform.instance.customAuthDomain, 'bar');
        }
      });
    });

    group('languageCode', () {
      test('.languageCode should call delegate method', () {
        auth.languageCode;
        verify(mockAuthPlatform.languageCode);
      });

      test('setLanguageCode() should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setLanguageCode(any)).thenAnswer((i) async {});

        await auth.setLanguageCode(kMockLanguage);
        verify(mockAuthPlatform.setLanguageCode(kMockLanguage));
      });
    });

    group('checkActionCode()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.checkActionCode(any)).thenAnswer(
          (i) async => ActionCodeInfo(
            data: ActionCodeInfoData(email: null, previousEmail: null),
            operation: ActionCodeInfoOperation.unknown,
          ),
        );

        await auth.checkActionCode(kMockActionCode);
        verify(mockAuthPlatform.checkActionCode(kMockActionCode));
      });
    });

    group('confirmPasswordReset()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.confirmPasswordReset(any, any))
            .thenAnswer((i) async {});

        await auth.confirmPasswordReset(
          code: kMockActionCode,
          newPassword: kMockPassword,
        );
        verify(mockAuthPlatform.confirmPasswordReset(
            kMockActionCode, kMockPassword));
      });
    });

    group('createUserWithEmailAndPassword()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.createUserWithEmailAndPassword(any, any))
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.createUserWithEmailAndPassword(
          email: kMockEmail,
          password: kMockPassword,
        );

        verify(mockAuthPlatform.createUserWithEmailAndPassword(
          kMockEmail,
          kMockPassword,
        ));
      });
    });

    group('getRedirectResult()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.getRedirectResult())
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.getRedirectResult();
        verify(mockAuthPlatform.getRedirectResult());
      });
    });

    group('isSignInWithEmailLink()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.isSignInWithEmailLink(any))
            .thenAnswer((i) => false);

        auth.isSignInWithEmailLink(kMockURL);
        verify(mockAuthPlatform.isSignInWithEmailLink(kMockURL));
      });
    });

    group('authStateChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.authStateChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('idTokenChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.idTokenChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('userChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.userChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('sendPasswordResetEmail()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendPasswordResetEmail(any))
            .thenAnswer((i) async {});

        await auth.sendPasswordResetEmail(email: kMockEmail);
        verify(mockAuthPlatform.sendPasswordResetEmail(kMockEmail));
      });
    });

    group('sendPasswordResetEmail()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendPasswordResetEmail(any))
            .thenAnswer((i) async {});

        await auth.sendPasswordResetEmail(email: kMockEmail);
        verify(mockAuthPlatform.sendPasswordResetEmail(kMockEmail));
      });
    });

    group('sendSignInLinkToEmail()', () {
      test('should throw if actionCodeSettings.handleCodeInApp is not true',
          () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendSignInLinkToEmail(any, any))
            .thenAnswer((i) async {});

        final ActionCodeSettings kMockActionCodeSettingsNull =
            ActionCodeSettings(url: kMockURL);
        final ActionCodeSettings kMockActionCodeSettingsFalse =
            ActionCodeSettings(url: kMockURL);

        // when handleCodeInApp is null
        expect(
          () => auth.sendSignInLinkToEmail(
              email: kMockEmail,
              actionCodeSettings: kMockActionCodeSettingsNull),
          throwsArgumentError,
        );
        // when handleCodeInApp is false
        expect(
          () => auth.sendSignInLinkToEmail(
              email: kMockEmail,
              actionCodeSettings: kMockActionCodeSettingsFalse),
          throwsArgumentError,
        );
      });

      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendSignInLinkToEmail(any, any))
            .thenAnswer((i) async {});

        final ActionCodeSettings kMockActionCodeSettingsValid =
            ActionCodeSettings(url: kMockURL, handleCodeInApp: true);

        await auth.sendSignInLinkToEmail(
          email: kMockEmail,
          actionCodeSettings: kMockActionCodeSettingsValid,
        );

        verify(mockAuthPlatform.sendSignInLinkToEmail(
          kMockEmail,
          kMockActionCodeSettingsValid,
        ));
      });
    });

    group('setSettings()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setSettings(
          appVerificationDisabledForTesting: any,
          phoneNumber: any,
          smsCode: any,
          forceRecaptchaFlow: any,
          userAccessGroup: any,
        )).thenAnswer((i) async {});

        String phoneNumber = '123456';
        String smsCode = '1234';
        bool forceRecaptchaFlow = true;
        bool appVerificationDisabledForTesting = true;
        String userAccessGroup = 'group-id';

        await auth.setSettings(
          appVerificationDisabledForTesting: appVerificationDisabledForTesting,
          phoneNumber: phoneNumber,
          smsCode: smsCode,
          forceRecaptchaFlow: forceRecaptchaFlow,
          userAccessGroup: userAccessGroup,
        );

        verify(
          mockAuthPlatform.setSettings(
            appVerificationDisabledForTesting:
                appVerificationDisabledForTesting,
            phoneNumber: phoneNumber,
            smsCode: smsCode,
            forceRecaptchaFlow: forceRecaptchaFlow,
            userAccessGroup: userAccessGroup,
          ),
        );
      });
    });

    group('setPersistence()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setPersistence(any)).thenAnswer((i) async {});

        await auth.setPersistence(Persistence.LOCAL);
        verify(mockAuthPlatform.setPersistence(Persistence.LOCAL));
      });
    });

    group('signInAnonymously()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.signInAnonymously())
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.signInAnonymously();
        verify(mockAuthPlatform.signInAnonymously());
      });
    });

    group('signInWithCredential()', () {
      test('GithubAuthProvider signInWithCredential', () async {
        final AuthCredential credential =
            GithubAuthProvider.credential(kMockGithubToken);
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<GithubAuthCredential>());
        expect(captured.providerId, equals('github.com'));
        expect(captured.accessToken, equals(kMockGithubToken));
      });

      test('EmailAuthProvider (withLink) signInWithCredential', () async {
        final AuthCredential credential = EmailAuthProvider.credentialWithLink(
          email: 'test@example.com',
          emailLink: '<Url with domain from your Firebase project>',
        );
        await auth.signInWithCredential(credential);
        final EmailAuthCredential captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('password'));
        expect(captured.email, equals('test@example.com'));
        expect(captured.emailLink,
            equals('<Url with domain from your Firebase project>'));
      });

      test('TwitterAuthProvider signInWithCredential', () async {
        final AuthCredential credential = TwitterAuthProvider.credential(
          accessToken: kMockIdToken,
          secret: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<TwitterAuthCredential>());
        expect(captured.providerId, equals('twitter.com'));
        expect(captured.accessToken, equals(kMockIdToken));
        expect(captured.secret, equals(kMockAccessToken));
      });

      test('GoogleAuthProvider signInWithCredential', () async {
        final credential = GoogleAuthProvider.credential(
          idToken: kMockIdToken,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<GoogleAuthCredential>());
        expect(captured.providerId, equals('google.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.accessToken, equals(kMockAccessToken));
      });

      test('OAuthProvider signInWithCredential for Apple', () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.accessToken, equals(kMockAccessToken));
        expect(captured.rawNonce, equals(null));
      });

      test('OAuthProvider signInWithCredential for Apple with rawNonce',
          () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          rawNonce: kMockRawNonce,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.rawNonce, equals(kMockRawNonce));
        expect(captured.accessToken, equals(kMockAccessToken));
      });

      test(
          'OAuthProvider signInWithCredential for Apple with rawNonce (empty accessToken)',
          () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          rawNonce: kMockRawNonce,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.rawNonce, equals(kMockRawNonce));
        expect(captured.accessToken, equals(null));
      });

      test('PhoneAuthProvider signInWithCredential', () async {
        final PhoneAuthCredential credential = PhoneAuthProvider.credential(
          verificationId: kMockVerificationId,
          smsCode: kMockSmsCode,
        );
        await auth.signInWithCredential(credential);
        final PhoneAuthCredential captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('phone'));
        expect(captured.verificationId, equals(kMockVerificationId));
        expect(captured.smsCode, equals(kMockSmsCode));
      });

      test('FacebookAuthProvider signInWithCredential', () async {
        final AuthCredential credential =
            FacebookAuthProvider.credential(kMockAccessToken);
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<FacebookAuthCredential>());
        expect(captured.providerId, equals('facebook.com'));
        expect(captured.accessToken, equals(kMockAccessToken));
      });
    });

    group('signInWithCustomToken()', () {
      test('should call delegate method', () async {
        await auth.signInWithCustomToken(kMockCustomToken);
        verify(mockAuthPlatform.signInWithCustomToken(kMockCustomToken));
      });
    });

    group('signInWithEmailAndPassword()', () {
      test('should call delegate method', () async {
        await auth.signInWithEmailAndPassword(
            email: kMockEmail, password: kMockPassword);
        verify(mockAuthPlatform.signInWithEmailAndPassword(
            kMockEmail, kMockPassword));
      });
    });

    group('signInWithEmailLink()', () {
      test('should call delegate method', () async {
        await auth.signInWithEmailLink(email: kMockEmail, emailLink: kMockURL);
        verify(mockAuthPlatform.signInWithEmailLink(kMockEmail, kMockURL));
      });
    });

    group('signInWithPhoneNumber()', () {
      test('should call delegate method', () async {
        await auth.signInWithPhoneNumber(kMockPhoneNumber, mockVerifier);
        verify(mockAuthPlatform.signInWithPhoneNumber(kMockPhoneNumber, any));
      });
    });

    group('signInWithPopup()', () {
      test('should call delegate method', () async {
        await auth.signInWithPopup(testAuthProvider);
        verify(mockAuthPlatform.signInWithPopup(testAuthProvider));
      });
    });

    group('signInWithRedirect()', () {
      test('should call delegate method', () async {
        await auth.signInWithRedirect(testAuthProvider);
        verify(mockAuthPlatform.signInWithRedirect(testAuthProvider));
      });
    });

    group('signOut()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.signOut()).thenAnswer((i) async {});

        await auth.signOut();
        verify(mockAuthPlatform.signOut());
      });
    });

    group('verifyPasswordResetCode()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.verifyPasswordResetCode(any))
            .thenAnswer((i) async => '');

        await auth.verifyPasswordResetCode(kMockOobCode);
        verify(mockAuthPlatform.verifyPasswordResetCode(kMockOobCode));
      });
    });

    group('verifyPhoneNumber()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.verifyPhoneNumber(
          autoRetrievedSmsCodeForTesting:
              anyNamed('autoRetrievedSmsCodeForTesting'),
          codeAutoRetrievalTimeout: anyNamed('codeAutoRetrievalTimeout'),
          codeSent: anyNamed('codeSent'),
          forceResendingToken: anyNamed('forceResendingToken'),
          phoneNumber: anyNamed('phoneNumber'),
          timeout: anyNamed('timeout'),
          verificationCompleted: anyNamed('verificationCompleted'),
          verificationFailed: anyNamed('verificationFailed'),
        )).thenAnswer((i) async {});

        final PhoneVerificationCompleted verificationCompleted =
            (PhoneAuthCredential phoneAuthCredential) {};
        final PhoneVerificationFailed verificationFailed =
            (FirebaseAuthException authException) {};
        final PhoneCodeSent codeSent =
            (String verificationId, [int? forceResendingToken]) async {};
        final PhoneCodeAutoRetrievalTimeout autoRetrievalTimeout =
            (String verificationId) {};

        await auth.verifyPhoneNumber(
          phoneNumber: kMockPhoneNumber,
          verificationCompleted: verificationCompleted,
          verificationFailed: verificationFailed,
          codeSent: codeSent,
          codeAutoRetrievalTimeout: autoRetrievalTimeout,
        );

        verify(
          mockAuthPlatform.verifyPhoneNumber(
            phoneNumber: kMockPhoneNumber,
            verificationCompleted: verificationCompleted,
            verificationFailed: verificationFailed,
            codeSent: codeSent,
            codeAutoRetrievalTimeout: autoRetrievalTimeout,
          ),
        );
      });
    });

    group('passwordPolicy', () {
      test('passwordPolicy should be initialized with correct parameters',
          () async {
        PasswordPolicyImpl passwordPolicy =
            PasswordPolicyImpl(kMockPasswordPolicyObject);
        expect(passwordPolicy.policy, equals(kMockPasswordPolicyObject));
      });

      PasswordPolicyImpl passwordPolicy =
          PasswordPolicyImpl(kMockPasswordPolicyObject);

      test('should return true for valid password', () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockValidPassword);
        expect(status.isValid, isTrue);
      });

      test('should return false for invalid password that is too short',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword);
        expect(status.isValid, isFalse);
      });

      test(
          'should return false for invalid password with no capital characters',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword2);
        expect(status.isValid, isFalse);
      });

      test(
          'should return false for invalid password with no lowercase characters',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword3);
        expect(status.isValid, isFalse);
      });

      test('should return false for invalid password with no numbers',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword4);
        expect(status.isValid, isFalse);
      });

      test('should return false for invalid password with no symbols',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword5);
        expect(status.isValid, isFalse);
      });
    });

    test('toString()', () async {
      expect(
        auth.toString(),
        equals('FirebaseAuth(app: $testCount)'),
      );
    });
  });
}

class MockFirebaseAuth extends Mock
    with MockPlatformInterfaceMixin
    implements TestFirebaseAuthPlatform {
  @override
  Stream<UserPlatform?> userChanges() {
    return super.noSuchMethod(
      Invocation.method(#userChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  Stream<UserPlatform?> idTokenChanges() {
    return super.noSuchMethod(
      Invocation.method(#idTokenChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  Stream<UserPlatform?> authStateChanges() {
    return super.noSuchMethod(
      Invocation.method(#authStateChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return super.noSuchMethod(
      Invocation.method(#delegateFor, [], {#app: app}),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  Future<UserCredentialPlatform> createUserWithEmailAndPassword(
    String? email,
    String? password,
  ) {
    return super.noSuchMethod(
      Invocation.method(#createUserWithEmailAndPassword, [email, password]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<ConfirmationResultPlatform> signInWithPhoneNumber(
    String? phoneNumber,
    RecaptchaVerifierFactoryPlatform? applicationVerifier,
  ) {
    return super.noSuchMethod(
      Invocation.method(
        #signInWithPhoneNumber,
        [phoneNumber, applicationVerifier],
      ),
      returnValue: neverEndingFuture<ConfirmationResultPlatform>(),
      returnValueForMissingStub:
          neverEndingFuture<ConfirmationResultPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithCustomToken(String? token) {
    return super.noSuchMethod(
      Invocation.method(#signInWithCustomToken, [token]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithEmailAndPassword(
    String? email,
    String? password,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithEmailAndPassword, [email, password]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithPopup(AuthProvider? provider) {
    return super.noSuchMethod(
      Invocation.method(#signInWithPopup, [provider]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithEmailLink(
    String? email,
    String? emailLink,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithEmailLink, [email, emailLink]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> signInWithRedirect(AuthProvider? provider) {
    return super.noSuchMethod(
      Invocation.method(#signInWithRedirect, [provider]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInAnonymously() {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, [], {
        #currentUser: currentUser,
        #languageCode: languageCode,
      }),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  Future<UserCredentialPlatform> getRedirectResult() {
    return super.noSuchMethod(
      Invocation.method(#getRedirectResult, []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> setLanguageCode(String? languageCode) {
    return super.noSuchMethod(
      Invocation.method(#setLanguageCode, [languageCode]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> useAuthEmulator(String host, int port) {
    return super.noSuchMethod(
      Invocation.method(#useEmulator, [host, port]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<ActionCodeInfo> checkActionCode(String? code) {
    return super.noSuchMethod(
      Invocation.method(#checkActionCode, [code]),
      returnValue: neverEndingFuture<ActionCodeInfo>(),
      returnValueForMissingStub: neverEndingFuture<ActionCodeInfo>(),
    );
  }

  @override
  Future<void> confirmPasswordReset(String? code, String? newPassword) {
    return super.noSuchMethod(
      Invocation.method(#confirmPasswordReset, [code, newPassword]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  bool isSignInWithEmailLink(String? emailLink) {
    return super.noSuchMethod(
      Invocation.method(#isSignInWithEmailLink, [emailLink]),
      returnValue: false,
      returnValueForMissingStub: false,
    );
  }

  @override
  Future<void> sendPasswordResetEmail(
    String? email, [
    ActionCodeSettings? actionCodeSettings,
  ]) {
    return super.noSuchMethod(
      Invocation.method(#sendPasswordResetEmail, [email, actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> sendSignInLinkToEmail(
    String? email,
    ActionCodeSettings? actionCodeSettings,
  ) {
    return super.noSuchMethod(
      Invocation.method(#sendSignInLinkToEmail, [email, actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> setSettings({
    bool? appVerificationDisabledForTesting,
    String? userAccessGroup,
    String? phoneNumber,
    String? smsCode,
    bool? forceRecaptchaFlow,
  }) {
    return super.noSuchMethod(
      Invocation.method(#setSettings, [
        appVerificationDisabledForTesting,
        userAccessGroup,
        phoneNumber,
        smsCode,
        forceRecaptchaFlow,
      ]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> setPersistence(Persistence? persistence) {
    return super.noSuchMethod(
      Invocation.method(#setPersistence, [persistence]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> signOut() {
    return super.noSuchMethod(
      Invocation.method(#signOut, [signOut]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<String> verifyPasswordResetCode(String? code) {
    return super.noSuchMethod(
      Invocation.method(#verifyPasswordResetCode, [code]),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }

  @override
  Future<void> verifyPhoneNumber({
    String? phoneNumber,
    PhoneMultiFactorInfo? multiFactorInfo,
    MultiFactorSession? multiFactorSession,
    Object? verificationCompleted,
    Object? verificationFailed,
    Object? codeSent,
    Object? codeAutoRetrievalTimeout,
    Duration? timeout = const Duration(seconds: 30),
    int? forceResendingToken,
    String? autoRetrievedSmsCodeForTesting,
  }) {
    return super.noSuchMethod(
      Invocation.method(#verifyPhoneNumber, [], {
        #phoneNumber: phoneNumber,
        #verificationCompleted: verificationCompleted,
        #verificationFailed: verificationFailed,
        #codeSent: codeSent,
        #codeAutoRetrievalTimeout: codeAutoRetrievalTimeout,
        #timeout: timeout,
        #forceResendingToken: forceResendingToken,
        #autoRetrievedSmsCodeForTesting: autoRetrievedSmsCodeForTesting,
      }),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }
}

class FakeFirebaseAuthPlatform extends Fake
    with MockPlatformInterfaceMixin
    implements FirebaseAuthPlatform {
  FakeFirebaseAuthPlatform({this.tenantId, this.customAuthDomain});

  @override
  String? tenantId;

  @override
  String? customAuthDomain;

  @override
  FirebaseAuthPlatform delegateFor(
      {required FirebaseApp app, Persistence? persistence}) {
    return this;
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class MockUserPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserPlatform {
  MockUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails _user) {
    TestUserPlatform(auth, multiFactor, _user);
  }
}

class MockUserCredentialPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserCredentialPlatform {
  MockUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) {
    TestUserCredentialPlatform(
      auth,
      additionalUserInfo,
      credential,
      userPlatform,
    );
  }
}

class MockConfirmationResultPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestConfirmationResultPlatform {
  MockConfirmationResultPlatform() {
    TestConfirmationResultPlatform();
  }
}

class TestConfirmationResultPlatform extends ConfirmationResultPlatform {
  TestConfirmationResultPlatform() : super('TEST');
}

class TestFirebaseAuthPlatform extends FirebaseAuthPlatform {
  TestFirebaseAuthPlatform() : super();

  void instanceFor({
    FirebaseApp? app,
    Map<dynamic, dynamic>? pluginConstants,
  }) {}

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return this;
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class MockRecaptchaVerifier extends Mock
    with MockPlatformInterfaceMixin
    implements TestRecaptchaVerifier {
  MockRecaptchaVerifier() {
    TestRecaptchaVerifier();
  }

  RecaptchaVerifierFactoryPlatform get mockDelegate {
    return MockRecaptchaVerifierFactoryPlatform();
  }

  @override
  RecaptchaVerifierFactoryPlatform get delegate {
    return super.noSuchMethod(
      Invocation.getter(#delegate),
      returnValue: MockRecaptchaVerifierFactoryPlatform(),
      returnValueForMissingStub: MockRecaptchaVerifierFactoryPlatform(),
    );
  }
}

class MockRecaptchaVerifierFactoryPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestRecaptchaVerifierFactoryPlatform {
  MockRecaptchaVerifierFactoryPlatform() {
    TestRecaptchaVerifierFactoryPlatform();
  }
}

class TestRecaptchaVerifier implements RecaptchaVerifier {
  TestRecaptchaVerifier() : super();

  @override
  void clear() {}

  @override
  RecaptchaVerifierFactoryPlatform get delegate =>
      TestRecaptchaVerifierFactoryPlatform();

  @override
  Future<int> render() {
    throw UnimplementedError();
  }

  @override
  String get type => throw UnimplementedError();

  @override
  Future<String> verify() {
    throw UnimplementedError();
  }
}

class TestRecaptchaVerifierFactoryPlatform
    extends RecaptchaVerifierFactoryPlatform {}

class TestAuthProvider extends AuthProvider {
  TestAuthProvider() : super('TEST');
}

class TestUserPlatform extends UserPlatform {
  TestUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails data)
      : super(auth, multiFactor, data);
}

class TestMultiFactorPlatform extends MultiFactorPlatform {
  TestMultiFactorPlatform(FirebaseAuthPlatform auth) : super(auth);
}

class TestUserCredentialPlatform extends UserCredentialPlatform {
  TestUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) : super(
          auth: auth,
          additionalUserInfo: additionalUserInfo,
          credential: credential,
          user: userPlatform,
        );
}

class EmptyUserCredentialPlatform extends UserCredentialPlatform {
  EmptyUserCredentialPlatform() : super(auth: FirebaseAuthPlatform.instance);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/test/mock.dart

**크기**: 672 bytes | **라인 수**: 23 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/test.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

typedef Callback = void Function(MethodCall call);

void setupFirebaseAuthMocks([Callback? customHandlers]) {
  TestWidgetsFlutterBinding.ensureInitialized();

  setupFirebaseCoreMocks();
}

Future<T> neverEndingFuture<T>() async {
  // ignore: literal_only_boolean_expressions
  while (true) {
    await Future.delayed(const Duration(minutes: 5));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/test/user_test.dart

**크기**: 17841 bytes | **라인 수**: 572 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_auth_platform_interface/src/method_channel/method_channel_firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
// import 'package:mockito/annotations.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

// import './user_test.mocks.dart';
import './mock.dart';
import 'firebase_auth_test.dart';

Map<String, dynamic> kMockUser1 = <String, dynamic>{
  'isAnonymous': true,
  'emailVerified': false,
  'displayName': 'displayName',
};

// @GenerateMocks([], customMocks: [
//   MockSpec<MockFirebaseAuthPlatformBase>(as: #MockFirebaseAuthPlatform),
//   MockSpec<MockUserPlatformBase>(as: #MockUserPlatform),
// ])
void main() {
  setupFirebaseAuthMocks();

  late FirebaseAuth auth;

  final kMockIdTokenResult = PigeonIdTokenResult(
    token: '12345',
    expirationTimestamp: 123456,
    authTimestamp: 1234567,
    issuedAtTimestamp: 12345678,
    signInProvider: 'password',
    claims: {
      'claim1': 'value1',
    },
  );

  final int kMockCreationTimestamp =
      DateTime.now().subtract(const Duration(days: 2)).millisecondsSinceEpoch;
  final int kMockLastSignInTimestamp =
      DateTime.now().subtract(const Duration(days: 1)).millisecondsSinceEpoch;

  final kMockUser = PigeonUserDetails(
    userInfo: PigeonUserInfo(
      uid: '12345',
      displayName: 'displayName',
      creationTimestamp: kMockCreationTimestamp,
      lastSignInTimestamp: kMockLastSignInTimestamp,
      isAnonymous: true,
      isEmailVerified: false,
    ),
    providerData: [
      {
        'providerId': 'firebase',
        'uid': '12345',
        'displayName': 'Flutter Test User',
        'photoUrl': null,
        'email': 'test@example.com',
        'isAnonymous': true,
        'isEmailVerified': false,
      }
    ],
  );
  late MockUserPlatform mockUserPlatform;
  late MockUserCredentialPlatform mockUserCredPlatform;

  AdditionalUserInfo mockAdditionalInfo = AdditionalUserInfo(
    isNewUser: false,
    username: 'flutterUser',
    providerId: 'testProvider',
    profile: <String, dynamic>{'foo': 'bar'},
  );

  EmailAuthCredential mockCredential =
      EmailAuthProvider.credential(email: 'test', password: 'test')
          as EmailAuthCredential;

  var mockAuthPlatform = MockFirebaseAuth();

  group('$User', () {
    late PigeonUserDetails user;

    // used to generate a unique application name for each test
    var testCount = 0;

    setUp(() async {
      FirebaseAuthPlatform.instance = mockAuthPlatform = MockFirebaseAuth();

      // Each test uses a unique FirebaseApp instance to avoid sharing state
      final app = await Firebase.initializeApp(
        name: '$testCount',
        options: const FirebaseOptions(
          apiKey: '',
          appId: '',
          messagingSenderId: '',
          projectId: '',
        ),
      );

      auth = FirebaseAuth.instanceFor(app: app);

      user = kMockUser;

      mockUserPlatform = MockUserPlatform(mockAuthPlatform, user);

      mockUserCredPlatform = MockUserCredentialPlatform(
        FirebaseAuthPlatform.instance,
        mockAdditionalInfo,
        mockCredential,
        mockUserPlatform,
      );

      when(mockAuthPlatform.signInAnonymously()).thenAnswer(
          (_) => Future<UserCredentialPlatform>.value(mockUserCredPlatform));

      when(mockAuthPlatform.currentUser).thenReturn(mockUserPlatform);

      when(mockAuthPlatform.delegateFor(
        app: anyNamed('app'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.setInitialValues(
        currentUser: anyNamed('currentUser'),
        languageCode: anyNamed('languageCode'),
      )).thenAnswer((_) => mockAuthPlatform);

      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(MethodChannelFirebaseAuth.channel,
              (call) async {
        switch (call.method) {
          default:
            return <String, dynamic>{'user': user};
        }
      });
    });

    tearDown(() => testCount++);

    setUp(() async {
      user = kMockUser;
      await auth.signInAnonymously();
    });

    test('delete()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.delete()).thenAnswer((i) async {});

      await auth.currentUser!.delete();

      verify(mockUserPlatform.delete());
    });

    test('getIdToken()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.getIdToken(any)).thenAnswer((_) async => 'token');

      final token = await auth.currentUser!.getIdToken(true);

      verify(mockUserPlatform.getIdToken(true));
      expect(token, isA<String>());
    });

    test('getIdTokenResult()', () async {
      when(mockUserPlatform.getIdTokenResult(any))
          .thenAnswer((_) async => IdTokenResult(kMockIdTokenResult));

      final idTokenResult = await auth.currentUser!.getIdTokenResult(true);

      verify(mockUserPlatform.getIdTokenResult(true));
      expect(idTokenResult, isA<IdTokenResult>());
    });

    group('linkWithCredential()', () {
      setUp(() {
        when(mockUserPlatform.linkWithCredential(any))
            .thenAnswer((_) async => mockUserCredPlatform);
      });

      test('should call linkWithCredential()', () async {
        String newEmail = 'new@email.com';
        EmailAuthCredential credential =
            EmailAuthProvider.credential(email: newEmail, password: 'test')
                as EmailAuthCredential;

        await auth.currentUser!.linkWithCredential(credential);

        verify(mockUserPlatform.linkWithCredential(credential));
      });
    });

    group('reauthenticateWithCredential()', () {
      setUp(() {
        when(mockUserPlatform.reauthenticateWithCredential(any))
            .thenAnswer((_) => Future.value(mockUserCredPlatform));
      });
      test('should call reauthenticateWithCredential()', () async {
        String newEmail = 'new@email.com';
        EmailAuthCredential credential =
            EmailAuthProvider.credential(email: newEmail, password: 'test')
                as EmailAuthCredential;

        await auth.currentUser!.reauthenticateWithCredential(credential);

        verify(mockUserPlatform.reauthenticateWithCredential(credential));
      });
    });

    test('reload()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.reload()).thenAnswer((i) async {});

      await auth.currentUser!.reload();

      verify(mockUserPlatform.reload());
    });

    test('sendEmailVerification()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.sendEmailVerification(any))
          .thenAnswer((i) async {});

      final ActionCodeSettings actionCodeSettings =
          ActionCodeSettings(url: 'test');

      await auth.currentUser!.sendEmailVerification(actionCodeSettings);

      verify(mockUserPlatform.sendEmailVerification(actionCodeSettings));
    });

    group('unlink()', () {
      setUp(() {
        when(mockUserPlatform.unlink(any))
            .thenAnswer((_) => Future.value(mockUserPlatform));
      });
      test('should call unlink()', () async {
        const String providerId = 'providerId';

        await auth.currentUser!.unlink(providerId);

        verify(mockUserPlatform.unlink(providerId));
      });
    });

    group('updatePassword()', () {
      test('should call updatePassword()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.updatePassword(any)).thenAnswer((i) async {});

        const String newPassword = 'newPassword';

        await auth.currentUser!.updatePassword(newPassword);

        verify(mockUserPlatform.updatePassword(newPassword));
      });
    });
    group('updatePhoneNumber()', () {
      test('should call updatePhoneNumber()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.updatePhoneNumber(any)).thenAnswer((i) async {});

        PhoneAuthCredential phoneAuthCredential = PhoneAuthProvider.credential(
          verificationId: 'test',
          smsCode: 'test',
        );

        await auth.currentUser!.updatePhoneNumber(phoneAuthCredential);

        verify(mockUserPlatform.updatePhoneNumber(phoneAuthCredential));
      });
    });

    test('updateProfile()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.updateProfile(any)).thenAnswer((i) async {});

      const String displayName = 'updatedName';
      const String photoURL = 'testUrl';
      Map<String, String> data = <String, String>{
        'displayName': displayName,
        'photoURL': photoURL
      };

      await auth.currentUser!
          // ignore: deprecated_member_use_from_same_package
          .updateProfile(displayName: displayName, photoURL: photoURL);

      verify(mockUserPlatform.updateProfile(data));
    });

    group('verifyBeforeUpdateEmail()', () {
      test('should call verifyBeforeUpdateEmail()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.verifyBeforeUpdateEmail(any, any))
            .thenAnswer((i) async {});

        const newEmail = 'new@email.com';
        ActionCodeSettings actionCodeSettings = ActionCodeSettings(url: 'test');

        await auth.currentUser!
            .verifyBeforeUpdateEmail(newEmail, actionCodeSettings);

        verify(mockUserPlatform.verifyBeforeUpdateEmail(
            newEmail, actionCodeSettings));
      });
    });

    test('toString()', () async {
      when(mockAuthPlatform.currentUser).thenReturn(TestUserPlatform(
          mockAuthPlatform, TestMultiFactorPlatform(mockAuthPlatform), user));

      const userInfo = 'UserInfo('
          'displayName: Flutter Test User, '
          'email: test@example.com, '
          'phoneNumber: null, '
          'photoURL: null, '
          'providerId: firebase, '
          'uid: 12345)';

      final userMetadata = 'UserMetadata('
          'creationTime: ${DateTime.fromMillisecondsSinceEpoch(kMockCreationTimestamp, isUtc: true)}, '
          'lastSignInTime: ${DateTime.fromMillisecondsSinceEpoch(kMockLastSignInTimestamp, isUtc: true)})';

      expect(
        auth.currentUser.toString(),
        'User('
        'displayName: displayName, '
        'email: null, '
        'isEmailVerified: false, '
        'isAnonymous: true, '
        'metadata: $userMetadata, '
        'phoneNumber: null, '
        'photoURL: null, '
        'providerData, '
        '[$userInfo], '
        'refreshToken: null, '
        'tenantId: null, '
        'uid: 12345)',
      );
    });
  });
}

class MockFirebaseAuthPlatformBase = TestFirebaseAuthPlatform
    with MockPlatformInterfaceMixin;

class MockUserPlatformBase = TestUserPlatform with MockPlatformInterfaceMixin;

class MockFirebaseAuth extends Mock
    with MockPlatformInterfaceMixin
    implements TestFirebaseAuthPlatform {
  @override
  Future<UserCredentialPlatform> signInAnonymously() {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, const []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return super.noSuchMethod(
      Invocation.method(#delegateFor, const [], {#app: app}),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return super.noSuchMethod(
      Invocation.method(#setInitialValues, const [], {
        #currentUser: currentUser,
        #languageCode: languageCode,
      }),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }
}

class MockUserPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserPlatform {
  MockUserPlatform(FirebaseAuthPlatform auth, PigeonUserDetails _user) {
    TestUserPlatform(auth, TestMultiFactorPlatform(auth), _user);
  }

  @override
  Future<void> delete() {
    return super.noSuchMethod(
      Invocation.method(#delete, []),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> reload() {
    return super.noSuchMethod(
      Invocation.method(#reload, []),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<String> getIdToken(bool? forceRefresh) {
    return super.noSuchMethod(
      Invocation.method(#getIdToken, [forceRefresh]),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }

  @override
  Future<UserPlatform> unlink(String? providerId) {
    return super.noSuchMethod(
      Invocation.method(#unlink, [providerId]),
      returnValue: neverEndingFuture<UserPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserPlatform>(),
    );
  }

  @override
  Future<IdTokenResult> getIdTokenResult(bool? forceRefresh) {
    return super.noSuchMethod(
      Invocation.method(#getIdTokenResult, [forceRefresh]),
      returnValue: neverEndingFuture<IdTokenResult>(),
      returnValueForMissingStub: neverEndingFuture<IdTokenResult>(),
    );
  }

  @override
  Future<UserCredentialPlatform> reauthenticateWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#reauthenticateWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> linkWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#linkWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> sendEmailVerification(ActionCodeSettings? actionCodeSettings) {
    return super.noSuchMethod(
      Invocation.method(#sendEmailVerification, [actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updatePassword(String? newPassword) {
    return super.noSuchMethod(
      Invocation.method(#updatePassword, [newPassword]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updatePhoneNumber(PhoneAuthCredential? phoneCredential) {
    return super.noSuchMethod(
      Invocation.method(#updatePhoneNumber, [phoneCredential]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updateProfile(Map<String, String?>? profile) {
    return super.noSuchMethod(
      Invocation.method(#updateProfile, [profile]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> verifyBeforeUpdateEmail(
    String? newEmail, [
    ActionCodeSettings? actionCodeSettings,
  ]) {
    return super.noSuchMethod(
      Invocation.method(#verifyBeforeUpdateEmail, [
        newEmail,
        actionCodeSettings,
      ]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }
}

class MockUserCredentialPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserCredentialPlatform {
  MockUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) {
    TestUserCredentialPlatform(
      auth,
      additionalUserInfo,
      credential,
      userPlatform,
    );
  }
}

class TestFirebaseAuthPlatform extends FirebaseAuthPlatform {
  TestFirebaseAuthPlatform() : super();

  @override
  FirebaseAuthPlatform delegateFor(
          {FirebaseApp? app, Persistence? persistence}) =>
      this;

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class TestUserPlatform extends UserPlatform {
  TestUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails data)
      : super(auth, multiFactor, data);
}

class TestUserCredentialPlatform extends UserCredentialPlatform {
  TestUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) : super(
            auth: auth,
            additionalUserInfo: additionalUserInfo,
            credential: credential,
            user: userPlatform);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/include/firebase_auth/firebase_auth_plugin_c_api.h

**크기**: 789 bytes | **라인 수**: 30 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_C_API_H_
#define FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_C_API_H_

#include <flutter_plugin_registrar.h>

#ifdef FLUTTER_PLUGIN_IMPL
#define FLUTTER_PLUGIN_EXPORT __declspec(dllexport)
#else
#define FLUTTER_PLUGIN_EXPORT __declspec(dllimport)
#endif

#if defined(__cplusplus)
extern "C" {
#endif

FLUTTER_PLUGIN_EXPORT void FirebaseAuthPluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar);

#if defined(__cplusplus)
}  // extern "C"
#endif

#endif  // FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_C_API_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/test/firebase_auth_plugin_test.cpp

**크기**: 1365 bytes | **라인 수**: 48 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "firebase_auth_plugin.h"

#include <flutter/method_call.h>
#include <flutter/method_result_functions.h>
#include <flutter/standard_method_codec.h>
#include <gtest/gtest.h>
#include <windows.h>

#include <memory>
#include <string>
#include <variant>

namespace firebase_auth {
namespace test {

namespace {

using flutter::EncodableMap;
using flutter::EncodableValue;
using flutter::MethodCall;
using flutter::MethodResultFunctions;

}  // namespace

TEST(FirebaseAuthPlugin, GetPlatformVersion) {
  FirebaseAuthPlugin plugin;
  // Save the reply value from the success callback.
  std::string result_string;
  plugin.HandleMethodCall(
      MethodCall("getPlatformVersion", std::make_unique<EncodableValue>()),
      std::make_unique<MethodResultFunctions<>>(
          [&result_string](const EncodableValue* result) {
            result_string = std::get<std::string>(*result);
          },
          nullptr, nullptr));

  // Since the exact string varies by host, just ensure that it's a string
  // with the expected format.
  EXPECT_TRUE(result_string.rfind("Windows ", 0) == 0);
}

}  // namespace test
}  // namespace firebase_auth

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/CMakeLists.txt

**크기**: 4783 bytes | **라인 수**: 124 | **타입**: text

```
# The Flutter tooling requires that developers have a version of Visual Studio
# installed that includes CMake 3.14 or later. You should not increase this
# version, as doing so will cause the plugin to fail to compile for some
# customers of the plugin.
cmake_minimum_required(VERSION 3.14)

# Project-level configuration.
set(PROJECT_NAME "firebase_auth")
project(${PROJECT_NAME} LANGUAGES CXX)

# This value is used when generating builds using this plugin, so it must
# not be changed
set(PLUGIN_NAME "firebase_auth_plugin")

# Any new source files that you add to the plugin should be added here.
list(APPEND PLUGIN_SOURCES
  "firebase_auth_plugin.cpp"
  "firebase_auth_plugin.h"
  "messages.g.cpp"
  "messages.g.h"
)

# Read version from pubspec.yaml
file(STRINGS "../pubspec.yaml" pubspec_content)
foreach(line ${pubspec_content})
  string(FIND ${line} "version: " has_version)
  
  if("${has_version}" STREQUAL "0")
    string(FIND ${line} ": " version_start_pos)
    math(EXPR version_start_pos "${version_start_pos} + 2")
    string(LENGTH ${line} version_end_pos)
    math(EXPR len "${version_end_pos} - ${version_start_pos}")
    string(SUBSTRING ${line} ${version_start_pos} ${len} PLUGIN_VERSION)
    break()
  endif()
endforeach(line)

configure_file(plugin_version.h.in ${CMAKE_BINARY_DIR}/generated/firebase_auth/plugin_version.h)
include_directories(${CMAKE_BINARY_DIR}/generated/)

# Define the plugin library target. Its name must not be changed (see comment
# on PLUGIN_NAME above).
add_library(${PLUGIN_NAME} STATIC
  "include/firebase_auth/firebase_auth_plugin_c_api.h"
  "firebase_auth_plugin_c_api.cpp"
  ${PLUGIN_SOURCES}
  ${CMAKE_BINARY_DIR}/generated/firebase_auth/plugin_version.h
)

# Apply a standard set of build settings that are configured in the
# application-level CMakeLists.txt. This can be removed for plugins that want
# full control over build settings.
apply_standard_settings(${PLUGIN_NAME})

# Symbols are hidden by default to reduce the chance of accidental conflicts
# between plugins. This should not be removed; any symbols that should be
# exported should be explicitly exported with the FLUTTER_PLUGIN_EXPORT macro.
set_target_properties(${PLUGIN_NAME} PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_compile_definitions(${PLUGIN_NAME} PUBLIC FLUTTER_PLUGIN_IMPL)
# Enable firebase-cpp-sdk's platform logging api.
target_compile_definitions(${PLUGIN_NAME} PRIVATE -DINTERNAL_EXPERIMENTAL=1)

# Source include directories and library dependencies. Add any plugin-specific
# dependencies here.
set(MSVC_RUNTIME_MODE MD)
set(firebase_libs firebase_core_plugin firebase_auth)
target_link_libraries(${PLUGIN_NAME} PRIVATE "${firebase_libs}")

target_include_directories(${PLUGIN_NAME} INTERFACE
  "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(${PLUGIN_NAME} PUBLIC flutter flutter_wrapper_plugin)

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(firebase_auth_bundled_libraries
  ""
  PARENT_SCOPE
)

# === Tests ===
# These unit tests can be run from a terminal after building the example, or
# from Visual Studio after opening the generated solution file.

# Only enable test builds when building the example (which sets this variable)
# so that plugin clients aren't building the tests.
if (${include_${PROJECT_NAME}_tests})
set(TEST_RUNNER "${PROJECT_NAME}_test")
enable_testing()

# Add the Google Test dependency.
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/release-1.11.0.zip
)
# Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
# Disable install commands for gtest so it doesn't end up in the bundle.
set(INSTALL_GTEST OFF CACHE BOOL "Disable installation of googletest" FORCE)
FetchContent_MakeAvailable(googletest)

# The plugin's C API is not very useful for unit testing, so build the sources
# directly into the test binary rather than using the DLL.
add_executable(${TEST_RUNNER}
  test/firebase_auth_plugin_test.cpp
  ${PLUGIN_SOURCES}
)
apply_standard_settings(${TEST_RUNNER})
target_include_directories(${TEST_RUNNER} PRIVATE "${CMAKE_CURRENT_SOURCE_DIR}")
target_link_libraries(${TEST_RUNNER} PRIVATE flutter_wrapper_plugin)
target_link_libraries(${TEST_RUNNER} PRIVATE gtest_main gmock)
# flutter_wrapper_plugin has link dependencies on the Flutter DLL.
add_custom_command(TARGET ${TEST_RUNNER} POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_if_different
  "${FLUTTER_LIBRARY}" $<TARGET_FILE_DIR:${TEST_RUNNER}>
)

# Enable automatic test discovery.
include(GoogleTest)
gtest_discover_tests(${TEST_RUNNER})
endif()

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/firebase_auth_plugin.cpp

**크기**: 47780 bytes | **라인 수**: 1289 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "firebase_auth_plugin.h"

// This must be included before many other Windows headers.
#include <windows.h>

#include <chrono>
#include <thread>

#include "firebase/app.h"
#include "firebase/auth.h"
#include "firebase/future.h"
#include "firebase/log.h"
#include "firebase/util.h"
#include "firebase/variant.h"
#include "firebase_auth/plugin_version.h"
#include "firebase_core/firebase_core_plugin_c_api.h"
#include "messages.g.h"

// For getPlatformVersion; remove unless needed for your plugin implementation.
#include <VersionHelpers.h>
#include <flutter/event_channel.h>
#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>
#include <flutter/standard_method_codec.h>

#include <future>
#include <iostream>
#include <memory>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>

using ::firebase::App;
using ::firebase::auth::Auth;

namespace firebase_auth_windows {

static std::string kLibraryName = "flutter-fire-auth";
flutter::BinaryMessenger* FirebaseAuthPlugin::binaryMessenger = nullptr;

// static
void FirebaseAuthPlugin::RegisterWithRegistrar(
    flutter::PluginRegistrarWindows* registrar) {
  auto plugin = std::make_unique<FirebaseAuthPlugin>();

  FirebaseAuthHostApi::SetUp(registrar->messenger(), plugin.get());
  FirebaseAuthUserHostApi::SetUp(registrar->messenger(), plugin.get());

  registrar->AddPlugin(std::move(plugin));

  binaryMessenger = registrar->messenger();

  // Register for platform logging
  App::RegisterLibrary(kLibraryName.c_str(), getPluginVersion().c_str(),
                       nullptr);
}

FirebaseAuthPlugin::FirebaseAuthPlugin() {
  firebase::SetLogLevel(firebase::kLogLevelVerbose);
}

FirebaseAuthPlugin::~FirebaseAuthPlugin() = default;

Auth* GetAuthFromPigeon(const AuthPigeonFirebaseApp& pigeonApp) {
  App* app = App::GetInstance(pigeonApp.app_name().c_str());

  Auth* auth = Auth::GetAuth(app);

  return auth;
}

PigeonUserCredential ParseAuthResult(
    const firebase::auth::AuthResult* authResult) {
  PigeonUserCredential result = PigeonUserCredential();
  result.set_user(FirebaseAuthPlugin::ParseUserDetails(authResult->user));
  result.set_additional_user_info(FirebaseAuthPlugin::ParseAdditionalUserInfo(
      authResult->additional_user_info));
  return result;
}

using flutter::EncodableMap;
using flutter::EncodableValue;

flutter::EncodableMap
firebase_auth_windows::FirebaseAuthPlugin::ConvertToEncodableMap(
    const std::map<firebase::Variant, firebase::Variant>& originalMap) {
  EncodableMap convertedMap;
  for (const auto& kv : originalMap) {
    EncodableValue key = ConvertToEncodableValue(
        kv.first);  // convert std::string to EncodableValue
    EncodableValue value = ConvertToEncodableValue(
        kv.second);             // convert FieldValue to EncodableValue
    convertedMap[key] = value;  // insert into the new map
  }
  return convertedMap;
}

flutter::EncodableValue
firebase_auth_windows::FirebaseAuthPlugin::ConvertToEncodableValue(
    const firebase::Variant& variant) {
  switch (variant.type()) {
    case firebase::Variant::kTypeNull:
      return EncodableValue();
    case firebase::Variant::kTypeInt64:
      return EncodableValue(variant.int64_value());
    case firebase::Variant::kTypeDouble:
      return EncodableValue(variant.double_value());
    case firebase::Variant::kTypeBool:
      return EncodableValue(variant.bool_value());
    case firebase::Variant::kTypeStaticString:
      return EncodableValue(variant.string_value());
    case firebase::Variant::kTypeMutableString:
      return EncodableValue(variant.mutable_string());
    case firebase::Variant::kTypeMap:
      return FirebaseAuthPlugin::ConvertToEncodableMap(variant.map());
    case firebase::Variant::kTypeStaticBlob:
      return EncodableValue(flutter::CustomEncodableValue(variant.blob_data()));
    case firebase::Variant::kTypeMutableBlob:
      return EncodableValue(
          flutter::CustomEncodableValue(variant.mutable_blob_data()));
    default:
      return EncodableValue();
  }
}

PigeonAdditionalUserInfo FirebaseAuthPlugin::ParseAdditionalUserInfo(
    const firebase::auth::AdditionalUserInfo additionalUserInfo) {
  // Cannot know if the user is new or not with current API
  PigeonAdditionalUserInfo result = PigeonAdditionalUserInfo(false);
  result.set_profile(ConvertToEncodableMap(additionalUserInfo.profile));
  result.set_provider_id(additionalUserInfo.provider_id);
  result.set_username(additionalUserInfo.user_name);
  return result;
}

PigeonUserDetails FirebaseAuthPlugin::ParseUserDetails(
    const firebase::auth::User user) {
  PigeonUserDetails result =
      PigeonUserDetails(FirebaseAuthPlugin::ParseUserInfo(&user),
                        FirebaseAuthPlugin::ParseProviderData(&user));

  return result;
}

PigeonUserInfo FirebaseAuthPlugin::ParseUserInfo(
    const firebase::auth::User* user) {
  PigeonUserInfo result = PigeonUserInfo(user->uid(), user->is_anonymous(),
                                         user->is_email_verified());
  result.set_display_name(user->display_name());
  result.set_email(user->email());
  result.set_phone_number(user->phone_number());
  result.set_photo_url(user->photo_url());
  result.set_provider_id(user->provider_id());
  result.set_uid(user->uid());
  result.set_creation_timestamp(user->metadata().creation_timestamp);
  result.set_last_sign_in_timestamp(user->metadata().last_sign_in_timestamp);

  return result;
}

flutter::EncodableList FirebaseAuthPlugin::ParseProviderData(
    const firebase::auth::User* user) {
  flutter::EncodableList output;

  for (firebase::auth::UserInfoInterface userInfo : user->provider_data()) {
    output.push_back(FirebaseAuthPlugin::ParseUserInfoToMap(&userInfo));
  }

  return flutter::EncodableList(output);
}

flutter::EncodableValue FirebaseAuthPlugin::ParseUserInfoToMap(
    firebase::auth::UserInfoInterface* userInfo) {
  return flutter::EncodableValue(flutter::EncodableMap{
      {flutter::EncodableValue("displayName"),
       flutter::EncodableValue(userInfo->display_name())},
      {flutter::EncodableValue("email"),
       flutter::EncodableValue(userInfo->email())},
      {flutter::EncodableValue("isEmailVerified"),
       flutter::EncodableValue(true)},
      {flutter::EncodableValue("phoneNumber"),
       flutter::EncodableValue(userInfo->phone_number())},
      {flutter::EncodableValue("photoUrl"),
       flutter::EncodableValue(userInfo->photo_url())},
      {flutter::EncodableValue("uid"),
       flutter::EncodableValue(userInfo->uid().empty() ? std::string("")
                                                       : userInfo->uid())},
      {flutter::EncodableValue("providerId"),
       flutter::EncodableValue(userInfo->provider_id())},
      {flutter::EncodableValue("isAnonymous"),
       flutter::EncodableValue(false)}});
}

std::string FirebaseAuthPlugin::GetAuthErrorCode(AuthError authError) {
  switch (authError) {
    case firebase::auth::kAuthErrorInvalidCustomToken:
      return "invalid-custom-token";
    case firebase::auth::kAuthErrorCustomTokenMismatch:
      return "custom-token-mismatch";
    case firebase::auth::kAuthErrorInvalidEmail:
      return "invalid-email";
    case firebase::auth::kAuthErrorInvalidCredential:
      return "invalid-credential";
    case firebase::auth::kAuthErrorUserDisabled:
      return "user-disabled";
    case firebase::auth::kAuthErrorEmailAlreadyInUse:
      return "email-already-in-use";
    case firebase::auth::kAuthErrorWrongPassword:
      return "wrong-password";
    case firebase::auth::kAuthErrorTooManyRequests:
      return "too-many-requests";
    case firebase::auth::kAuthErrorAccountExistsWithDifferentCredentials:
      return "account-exists-with-different-credentials";
    case firebase::auth::kAuthErrorRequiresRecentLogin:
      return "requires-recent-login";
    case firebase::auth::kAuthErrorProviderAlreadyLinked:
      return "provider-already-linked";
    case firebase::auth::kAuthErrorNoSuchProvider:
      return "no-such-provider";
    case firebase::auth::kAuthErrorInvalidUserToken:
      return "invalid-user-token";
    case firebase::auth::kAuthErrorUserTokenExpired:
      return "user-token-expired";
    case firebase::auth::kAuthErrorUserNotFound:
      return "user-not-found";
    case firebase::auth::kAuthErrorInvalidApiKey:
      return "invalid-api-key";
    case firebase::auth::kAuthErrorCredentialAlreadyInUse:
      return "credential-already-in-use";
    case firebase::auth::kAuthErrorOperationNotAllowed:
      return "operation-not-allowed";
    case firebase::auth::kAuthErrorWeakPassword:
      return "weak-password";
    case firebase::auth::kAuthErrorAppNotAuthorized:
      return "app-not-authorized";
    case firebase::auth::kAuthErrorExpiredActionCode:
      return "expired-action-code";
    case firebase::auth::kAuthErrorInvalidActionCode:
      return "invalid-action-code";
    case firebase::auth::kAuthErrorInvalidMessagePayload:
      return "invalid-message-payload";
    case firebase::auth::kAuthErrorInvalidSender:
      return "invalid-sender";
    case firebase::auth::kAuthErrorInvalidRecipientEmail:
      return "invalid-recipient-email";
    case firebase::auth::kAuthErrorUnauthorizedDomain:
      return "unauthorized-domain";
    case firebase::auth::kAuthErrorInvalidContinueUri:
      return "invalid-continue-uri";
    case firebase::auth::kAuthErrorMissingContinueUri:
      return "missing-continue-uri";
    case firebase::auth::kAuthErrorMissingEmail:
      return "missing-email";
    case firebase::auth::kAuthErrorMissingPhoneNumber:
      return "missing-phone-number";
    case firebase::auth::kAuthErrorInvalidPhoneNumber:
      return "invalid-phone-number";
    case firebase::auth::kAuthErrorMissingVerificationCode:
      return "missing-verification-code";
    case firebase::auth::kAuthErrorInvalidVerificationCode:
      return "invalid-verification-code";
    case firebase::auth::kAuthErrorMissingVerificationId:
      return "missing-verification-id";
    case firebase::auth::kAuthErrorInvalidVerificationId:
      return "invalid-verification-id";
    case firebase::auth::kAuthErrorSessionExpired:
      return "session-expired";
    case firebase::auth::kAuthErrorQuotaExceeded:
      return "quota-exceeded";
    case firebase::auth::kAuthErrorMissingAppCredential:
      return "missing-app-credential";
    case firebase::auth::kAuthErrorInvalidAppCredential:
      return "invalid-app-credential";
    case firebase::auth::kAuthErrorMissingClientIdentifier:
      return "missing-client-identifier";
    case firebase::auth::kAuthErrorTenantIdMismatch:
      return "tenant-id-mismatch";
    case firebase::auth::kAuthErrorUnsupportedTenantOperation:
      return "unsupported-tenant-operation";
    case firebase::auth::kAuthErrorUserMismatch:
      return "user-mismatch";
    case firebase::auth::kAuthErrorNetworkRequestFailed:
      return "network-request-failed";
    case firebase::auth::kAuthErrorNoSignedInUser:
      return "no-signed-in-user";
    case firebase::auth::kAuthErrorCancelled:
      return "cancelled";

    default:
      return "unknown-error";
  }
}

FlutterError FirebaseAuthPlugin::ParseError(
    const firebase::FutureBase& completed_future) {
  const AuthError errorCode =
      static_cast<const AuthError>(completed_future.error());

  return FlutterError(FirebaseAuthPlugin::GetAuthErrorCode(errorCode),
                      completed_future.error_message());
}

std::string const kFLTFirebaseAuthChannelName = "firebase_auth_plugin";

class FlutterIdTokenListener : public firebase::auth::IdTokenListener {
 public:
  void SetEventSink(
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> event_sink) {
    event_sink_ = std::move(event_sink);
  }

  void OnIdTokenChanged(Auth* auth) override {
    // Generate your ID Token
    firebase::auth::User user = auth->current_user();
    PigeonUserDetails userDetails = FirebaseAuthPlugin::ParseUserDetails(user);

    using flutter::EncodableList;
    using flutter::EncodableMap;
    using flutter::EncodableValue;

    if (event_sink_) {
      if (user.is_valid()) {
        EncodableList userDetailsList = EncodableList();
        userDetailsList.push_back(userDetails.user_info().ToEncodableList());
        userDetailsList.push_back(userDetails.provider_data());
        event_sink_->Success(EncodableValue(
            EncodableMap{{EncodableValue("user"), userDetailsList}}));
      } else {
        event_sink_->Success(EncodableValue(EncodableMap{
            {EncodableValue("user"), EncodableValue(std::monostate{})}}));
      }
    }
  }

 private:
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> event_sink_;
};

class IdTokenStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  IdTokenStreamHandler(Auth* auth) {
    listener_ = nullptr;
    auth_ = auth;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    listener_ = new FlutterIdTokenListener();
    listener_->SetEventSink(std::move(events));
    auth_->AddIdTokenListener(listener_);
    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    auth_->RemoveIdTokenListener(listener_);
    listener_->SetEventSink(nullptr);
    listener_ = nullptr;
    return nullptr;
  }

 private:
  FlutterIdTokenListener* listener_;
  firebase::auth::Auth* auth_;
};

void FirebaseAuthPlugin::RegisterIdTokenListener(
    const AuthPigeonFirebaseApp& app,
    std::function<void(ErrorOr<std::string> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  std::string name =
      kFLTFirebaseAuthChannelName + "/id-token/" + app.app_name();

  auto id_token_handler = std::make_unique<IdTokenStreamHandler>(firebaseAuth);

  flutter::EventChannel<flutter::EncodableValue> channel(
      binaryMessenger, name, &flutter::StandardMethodCodec::GetInstance());

  channel.SetStreamHandler(std::move(id_token_handler));

  result(ErrorOr<std::string>(std::string(name)));
}

class FlutterAuthStateListener : public firebase::auth::AuthStateListener {
 public:
  void SetEventSink(
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> event_sink) {
    event_sink_ = std::move(event_sink);
  }

  void OnAuthStateChanged(Auth* auth) override {
    // Generate your ID Token
    firebase::auth::User user = auth->current_user();
    PigeonUserDetails userDetails = FirebaseAuthPlugin::ParseUserDetails(user);

    using flutter::EncodableList;
    using flutter::EncodableMap;
    using flutter::EncodableValue;

    if (event_sink_) {
      if (user.is_valid()) {
        EncodableList userDetailsList = EncodableList();
        userDetailsList.push_back(userDetails.user_info().ToEncodableList());
        userDetailsList.push_back(userDetails.provider_data());

        event_sink_->Success(EncodableValue(
            EncodableMap{{EncodableValue("user"), userDetailsList}}));
      } else {
        event_sink_->Success(EncodableValue(EncodableMap{
            {EncodableValue("user"), EncodableValue(std::monostate{})}}));
      }
    }
  }

 private:
  std::unique_ptr<flutter::EventSink<flutter::EncodableValue>> event_sink_;
};

class AuthStateStreamHandler
    : public flutter::StreamHandler<flutter::EncodableValue> {
 public:
  AuthStateStreamHandler(Auth* auth) {
    listener_ = nullptr;
    auth_ = auth;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnListenInternal(
      const flutter::EncodableValue* arguments,
      std::unique_ptr<flutter::EventSink<flutter::EncodableValue>>&& events)
      override {
    listener_ = new FlutterAuthStateListener();
    listener_->SetEventSink(std::move(events));

    auth_->AddAuthStateListener(listener_);

    return nullptr;
  }

  std::unique_ptr<flutter::StreamHandlerError<flutter::EncodableValue>>
  OnCancelInternal(const flutter::EncodableValue* arguments) override {
    auth_->RemoveAuthStateListener(listener_);

    listener_->SetEventSink(nullptr);
    listener_ = nullptr;
    return nullptr;
  }

 private:
  FlutterAuthStateListener* listener_;
  firebase::auth::Auth* auth_;
};

void FirebaseAuthPlugin::RegisterAuthStateListener(
    const AuthPigeonFirebaseApp& app,
    std::function<void(ErrorOr<std::string> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  std::string name =
      kFLTFirebaseAuthChannelName + "/auth-state/" + app.app_name();

  auto auth_state_handler =
      std::make_unique<AuthStateStreamHandler>(firebaseAuth);

  flutter::EventChannel<flutter::EncodableValue> channel(
      binaryMessenger, name, &flutter::StandardMethodCodec::GetInstance());

  channel.SetStreamHandler(std::move(auth_state_handler));

  result(ErrorOr<std::string>(std::string(name)));
}

void FirebaseAuthPlugin::UseEmulator(
    const AuthPigeonFirebaseApp& app, const std::string& host, int64_t port,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebaseAuth->UseEmulator(host, static_cast<uint32_t>(port));
  result(std::nullopt);
}

void FirebaseAuthPlugin::ApplyActionCode(
    const AuthPigeonFirebaseApp& app, const std::string& code,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError("unimplemented",
                      "ApplyActionCode is not available on this platform yet.",
                      nullptr));
}

void FirebaseAuthPlugin::CheckActionCode(
    const AuthPigeonFirebaseApp& app, const std::string& code,
    std::function<void(ErrorOr<PigeonActionCodeInfo> reply)> result) {
  result(FlutterError("unimplemented",
                      "CheckActionCode is not available on this platform yet.",
                      nullptr));
}

void FirebaseAuthPlugin::ConfirmPasswordReset(
    const AuthPigeonFirebaseApp& app, const std::string& code,
    const std::string& new_password,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "ConfirmPasswordReset is not available on this platform yet.", nullptr));
}

void FirebaseAuthPlugin::CreateUserWithEmailAndPassword(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    const std::string& password,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::AuthResult> createUserFuture =
      firebaseAuth->CreateUserWithEmailAndPassword(email.c_str(),
                                                   password.c_str());

  createUserFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SignInAnonymously(
    const AuthPigeonFirebaseApp& app,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::AuthResult> signInFuture =
      firebaseAuth->SignInAnonymously();

  signInFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

// Provider type keys.
std::string const kSignInMethodPassword = "password";
std::string const kSignInMethodEmailLink = "emailLink";
std::string const kSignInMethodFacebook = "facebook.com";
std::string const kSignInMethodGoogle = "google.com";
std::string const kSignInMethodTwitter = "twitter.com";
std::string const kSignInMethodGithub = "github.com";
std::string const kSignInMethodApple = "apple.com";
std::string const kSignInMethodPhone = "phone";
std::string const kSignInMethodOAuth = "oauth";

// Credential argument keys.
std::string const kArgumentCredential = "credential";
std::string const kArgumentProviderId = "providerId";
std::string const kArgumentProviderScope = "scopes";
std::string const kArgumentProviderCustomParameters = "customParameters";
std::string const kArgumentSignInMethod = "signInMethod";
std::string const kArgumentSecret = "secret";
std::string const kArgumentIdToken = "idToken";
std::string const kArgumentAccessToken = "accessToken";
std::string const kArgumentRawNonce = "rawNonce";
std::string const kArgumentEmail = "email";
std::string const kArgumentCode = "code";
std::string const kArgumentNewEmail = "newEmail";
std::string const kArgumentEmailLink = kSignInMethodEmailLink;
std::string const kArgumentToken = "token";
std::string const kArgumentVerificationId = "verificationId";
std::string const kArgumentSmsCode = "smsCode";
std::string const kArgumentActionCodeSettings = "actionCodeSettings";

// Emulating NSDictionary
typedef std::unordered_map<std::string, std::string> Dictionary;

firebase::auth::Credential getCredentialFromArguments(
    flutter::EncodableMap arguments, const AuthPigeonFirebaseApp& app) {
  std::string signInMethod =
      std::get<std::string>(arguments[kArgumentSignInMethod]);

  // Password Auth
  if (signInMethod == kSignInMethodPassword) {
    std::string email = std::get<std::string>(arguments[kArgumentEmail]);
    std::string secret = std::get<std::string>(arguments[kArgumentSecret]);
    return firebase::auth::EmailAuthProvider::GetCredential(email.c_str(),
                                                            secret.c_str());
  }

  // Email Link Auth
  if (signInMethod == kSignInMethodEmailLink) {
    // Firebase C++ SDK doesn't have email link authentication as of my
    // knowledge cutoff in September 2021
    std::cout << "Email link authentication is not supported in Firebase C++ "
                 "SDK as of September 2021.\n";
    return firebase::auth::Credential();
  }

  // Lambda function to extract an optional string from the arguments map. This
  // allows us to pass nullptr if no value exists
  auto getStringOpt =
      [&](const std::string& key) -> std::optional<std::string> {
    auto it = arguments.find(key);
    if (it != arguments.end() &&
        std::holds_alternative<std::string>(it->second)) {
      return std::get<std::string>(it->second);
    }
    return std::nullopt;
  };

  std::optional<std::string> idToken = getStringOpt(kArgumentIdToken);
  std::optional<std::string> accessToken = getStringOpt(kArgumentAccessToken);

  // Facebook Auth
  if (signInMethod == kSignInMethodFacebook) {
    return firebase::auth::FacebookAuthProvider::GetCredential(
        accessToken.value().c_str());
  }

  // Google Auth
  if (signInMethod == kSignInMethodGoogle) {
    // Both accessToken and idToken arguments can be null. You can use one or
    // the other
    return firebase::auth::GoogleAuthProvider::GetCredential(
        idToken ? idToken.value().c_str() : nullptr,
        accessToken ? accessToken.value().c_str() : nullptr);
  }

  // Twitter Auth
  if (signInMethod == kSignInMethodTwitter) {
    std::string secret = std::get<std::string>(arguments[kArgumentSecret]);
    return firebase::auth::TwitterAuthProvider::GetCredential(
        idToken.value().c_str(), secret.c_str());
  }

  // GitHub Auth
  if (signInMethod == kSignInMethodGithub) {
    return firebase::auth::GitHubAuthProvider::GetCredential(
        accessToken.value().c_str());
  }

  // OAuth
  if (signInMethod == kSignInMethodOAuth) {
    std::string providerId =
        std::get<std::string>(arguments[kArgumentProviderId]);
    std::optional<std::string> rawNonce = getStringOpt(kArgumentRawNonce);
    // If rawNonce provided use corresponding credential builder
    // e.g. AppleID auth through the webView
    if (rawNonce) {
      return firebase::auth::OAuthProvider::GetCredential(
          providerId.c_str(), idToken.value().c_str(), rawNonce.value().c_str(),
          accessToken ? accessToken.value().c_str() : nullptr);
    } else {
      return firebase::auth::OAuthProvider::GetCredential(
          providerId.c_str(), idToken.value().c_str(),
          accessToken.value().c_str());
    }
  }

  // If no known auth method matched
  printf(
      "Support for an auth provider with identifier '%s' is not implemented.\n",
      signInMethod.c_str());
  return firebase::auth::Credential();
}

void FirebaseAuthPlugin::SignInWithCredential(
    const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::User> signInFuture =
      firebaseAuth->SignInWithCredential(
          getCredentialFromArguments(input, app));

  signInFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::User>& completed_future) {
        if (completed_future.error() == 0) {
          // TODO: not the right return type from C++ SDK
          PigeonUserInfo credential = ParseUserInfo(completed_future.result());
          PigeonUserCredential userCredential = PigeonUserCredential();
          PigeonUserDetails user =
              PigeonUserDetails(credential, flutter::EncodableList());
          userCredential.set_user(user);
          result(userCredential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SignInWithCustomToken(
    const AuthPigeonFirebaseApp& app, const std::string& token,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::AuthResult> signInFuture =
      firebaseAuth->SignInWithCustomToken(token.c_str());

  signInFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SignInWithEmailAndPassword(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    const std::string& password,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::AuthResult> signInFuture =
      firebaseAuth->SignInWithEmailAndPassword(email.c_str(), password.c_str());

  signInFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SignInWithEmailLink(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    const std::string& email_link,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "SignInWithEmailLink is not available on this platform yet.", nullptr));
}

std::vector<std::string> TransformEncodableList(
    const flutter::EncodableList& encodable_list) {
  std::vector<std::string> transformed_list;

  for (const auto& value : encodable_list) {
    if (std::holds_alternative<std::string>(value)) {
      transformed_list.push_back(std::get<std::string>(value));
    }
  }

  return transformed_list;
}

std::map<std::string, std::string> TransformEncodableMap(
    const flutter::EncodableMap& encodable_map) {
  std::map<std::string, std::string> transformed_map;

  for (const auto& pair : encodable_map) {
    if (std::holds_alternative<std::string>(pair.first) &&
        std::holds_alternative<std::string>(pair.second)) {
      transformed_map[std::get<std::string>(pair.first)] =
          std::get<std::string>(pair.second);
    }
  }

  return transformed_map;
}

firebase::auth::FederatedOAuthProvider getProviderFromArguments(
    const PigeonSignInProvider& sign_in_provider) {
  firebase::auth::FederatedOAuthProviderData federatedOAuthProviderData =
      firebase::auth::FederatedOAuthProviderData(
          sign_in_provider.provider_id().c_str(),
          TransformEncodableList(*sign_in_provider.scopes()),
          TransformEncodableMap(*sign_in_provider.custom_parameters()));
  firebase::auth::FederatedOAuthProvider federatedAuthProvider =
      firebase::auth::FederatedOAuthProvider(federatedOAuthProviderData);

  return federatedAuthProvider;
}

void FirebaseAuthPlugin::SignInWithProvider(
    const AuthPigeonFirebaseApp& app,
    const PigeonSignInProvider& sign_in_provider,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::AuthResult> signInFuture =
      firebaseAuth->SignInWithProvider(
          &getProviderFromArguments(sign_in_provider));

  signInFuture.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SignOut(
    const AuthPigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebaseAuth->SignOut();

  result(std::nullopt);
}

flutter::EncodableList TransformStringList(
    const std::vector<std::string>& string_list) {
  flutter::EncodableList encodable_list;

  for (const auto& value : string_list) {
    encodable_list.push_back(value);
  }

  return encodable_list;
}

void FirebaseAuthPlugin::FetchSignInMethodsForEmail(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    std::function<void(ErrorOr<flutter::EncodableList> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<firebase::auth::Auth::FetchProvidersResult> signInFuture =
      firebaseAuth->FetchProvidersForEmail(email.c_str());

  signInFuture.OnCompletion(
      [result](
          const firebase::Future<firebase::auth::Auth::FetchProvidersResult>&
              completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          result(TransformStringList(completed_future.result()->providers));
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SendPasswordResetEmail(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    const PigeonActionCodeSettings* action_code_settings,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  firebase::Future<void> signInFuture =
      firebaseAuth->SendPasswordResetEmail(email.c_str());

  signInFuture.OnCompletion(
      [result](const firebase::Future<void>& completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          result(std::nullopt);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::SendSignInLinkToEmail(
    const AuthPigeonFirebaseApp& app, const std::string& email,
    const PigeonActionCodeSettings& action_code_settings,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "SendSignInLinkToEmail is not available on this platform yet.", nullptr));
}

void FirebaseAuthPlugin::SetLanguageCode(
    const AuthPigeonFirebaseApp& app, const std::string* language_code,
    std::function<void(ErrorOr<std::string> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);

  if (language_code == nullptr) {
    firebaseAuth->UseAppLanguage();
    result(firebaseAuth->language_code());
    return;
  }

  firebaseAuth->set_language_code(language_code->c_str());

  result(*language_code);
}

void FirebaseAuthPlugin::SetSettings(
    const AuthPigeonFirebaseApp& app,
    const PigeonFirebaseAuthSettings& settings,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError("unimplemented",
                      "SetSettings is not available on this platform yet.",
                      nullptr));
}

void FirebaseAuthPlugin::VerifyPasswordResetCode(
    const AuthPigeonFirebaseApp& app, const std::string& code,
    std::function<void(ErrorOr<std::string> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "VerifyPasswordResetCode is not available on this platform yet.",
      nullptr));
}

void FirebaseAuthPlugin::VerifyPhoneNumber(
    const AuthPigeonFirebaseApp& app,
    const PigeonVerifyPhoneNumberRequest& request,
    std::function<void(ErrorOr<std::string> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "VerifyPhoneNumber is not available on this platform yet.", nullptr));
}

void FirebaseAuthPlugin::Delete(
    const AuthPigeonFirebaseApp& app,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<void> future = user.Delete();

  future.OnCompletion([result](const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      result(std::nullopt);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::GetIdToken(
    const AuthPigeonFirebaseApp& app, bool force_refresh,
    std::function<void(ErrorOr<PigeonIdTokenResult> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<std::string> future = user.GetToken(force_refresh);

  future.OnCompletion(
      [result](const firebase::Future<std::string>& completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonIdTokenResult token_result;
          std::string_view sv(*completed_future.result());
          token_result.set_token(sv);
          result(token_result);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::LinkWithCredential(
    const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<firebase::auth::AuthResult> future =
      user.LinkWithCredential(getCredentialFromArguments(input, app));

  future.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::LinkWithProvider(
    const AuthPigeonFirebaseApp& app,
    const PigeonSignInProvider& sign_in_provider,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<firebase::auth::AuthResult> future =
      user.LinkWithProvider(&getProviderFromArguments(sign_in_provider));

  future.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::ReauthenticateWithCredential(
    const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<void> future =
      user.Reauthenticate(getCredentialFromArguments(input, app));

  future.OnCompletion([result](const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      // TODO: wrong return type
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::ReauthenticateWithProvider(
    const AuthPigeonFirebaseApp& app,
    const PigeonSignInProvider& sign_in_provider,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<firebase::auth::AuthResult> future =
      user.ReauthenticateWithProvider(
          &getProviderFromArguments(sign_in_provider));

  future.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::Reload(
    const AuthPigeonFirebaseApp& app,
    std::function<void(ErrorOr<PigeonUserDetails> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<void> future = user.Reload();

  future.OnCompletion([result, firebaseAuth](
                          const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      PigeonUserDetails user = ParseUserDetails(firebaseAuth->current_user());
      result(user);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::SendEmailVerification(
    const AuthPigeonFirebaseApp& app,
    const PigeonActionCodeSettings* action_code_settings,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<void> future = user.SendEmailVerification();

  future.OnCompletion([result](const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      result(std::nullopt);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::Unlink(
    const AuthPigeonFirebaseApp& app, const std::string& provider_id,
    std::function<void(ErrorOr<PigeonUserCredential> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<firebase::auth::AuthResult> future =
      user.Unlink(provider_id.c_str());

  future.OnCompletion(
      [result](const firebase::Future<firebase::auth::AuthResult>&
                   completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserCredential credential =
              ParseAuthResult(completed_future.result());
          result(credential);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::UpdateEmail(
    const AuthPigeonFirebaseApp& app, const std::string& new_email,
    std::function<void(ErrorOr<PigeonUserDetails> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

#pragma warning(push)
#pragma warning(disable : 4996)
  firebase::Future<void> future = user.UpdateEmail(new_email.c_str());
#pragma warning(pop)

  future.OnCompletion([result, firebaseAuth](
                          const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      PigeonUserDetails user = ParseUserDetails(firebaseAuth->current_user());
      result(user);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::UpdatePassword(
    const AuthPigeonFirebaseApp& app, const std::string& new_password,
    std::function<void(ErrorOr<PigeonUserDetails> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<void> future = user.UpdatePassword(new_password.c_str());

  future.OnCompletion([result, firebaseAuth](
                          const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      PigeonUserDetails user = ParseUserDetails(firebaseAuth->current_user());
      result(user);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

firebase::auth::PhoneAuthCredential getPhoneCredentialFromArguments(
    flutter::EncodableMap arguments, const AuthPigeonFirebaseApp& app) {
  std::string signInMethod =
      std::get<std::string>(arguments[kArgumentSignInMethod]);

  if (signInMethod == kSignInMethodPhone) {
    std::string verificationId =
        std::get<std::string>(arguments[kArgumentVerificationId]);
    std::string smsCode = std::get<std::string>(arguments[kArgumentSmsCode]);

    // TODO: we cannot construct a PhoneAuthCredential from the verificationId
    return firebase::auth::PhoneAuthCredential::PhoneAuthCredential();
  }
  // If no known auth method matched
  printf(
      "Support for an auth provider with identifier '%s' is not "
      "implemented.\n",
      signInMethod.c_str());
  throw;
}

void FirebaseAuthPlugin::UpdatePhoneNumber(
    const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
    std::function<void(ErrorOr<PigeonUserDetails> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::Future<firebase::auth::User> future =
      user.UpdatePhoneNumberCredential(
          getPhoneCredentialFromArguments(input, app));

  future.OnCompletion(
      [result](const firebase::Future<firebase::auth::User>& completed_future) {
        // We are probably in a different thread right now.
        if (completed_future.error() == 0) {
          PigeonUserDetails user = ParseUserDetails(*completed_future.result());
          result(user);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::UpdateProfile(
    const AuthPigeonFirebaseApp& app, const PigeonUserProfile& profile,
    std::function<void(ErrorOr<PigeonUserDetails> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  firebase::auth::User::UserProfile userProfile;

  if (profile.display_name_changed()) {
    userProfile.display_name = profile.display_name()->c_str();
  }
  if (profile.photo_url_changed()) {
    userProfile.photo_url = profile.photo_url()->c_str();
  }

  firebase::Future<void> future = user.UpdateUserProfile(userProfile);

  future.OnCompletion([result, firebaseAuth](
                          const firebase::Future<void>& completed_future) {
    // We are probably in a different thread right now.
    if (completed_future.error() == 0) {
      PigeonUserDetails user = ParseUserDetails(firebaseAuth->current_user());
      result(user);
    } else {
      result(FirebaseAuthPlugin::ParseError(completed_future));
    }
  });
}

void FirebaseAuthPlugin::VerifyBeforeUpdateEmail(
    const AuthPigeonFirebaseApp& app, const std::string& new_email,
    const PigeonActionCodeSettings* action_code_settings,
    std::function<void(std::optional<FlutterError> reply)> result) {
  firebase::auth::Auth* firebaseAuth = GetAuthFromPigeon(app);
  firebase::auth::User user = firebaseAuth->current_user();

  if (action_code_settings != nullptr) {
    printf(
        "Firebase C++ SDK does not support using `ActionCodeSettings` for "
        "`verifyBeforeUpdateEmail()` API currently");
  }

  firebase::Future<void> future =
      user.SendEmailVerificationBeforeUpdatingEmail(new_email.c_str());

  future.OnCompletion(
      [result, firebaseAuth](const firebase::Future<void>& completed_future) {
        if (completed_future.error() == 0) {
          result(std::nullopt);
        } else {
          result(FirebaseAuthPlugin::ParseError(completed_future));
        }
      });
}

void FirebaseAuthPlugin::RevokeTokenWithAuthorizationCode(
    const AuthPigeonFirebaseApp& app, const std::string& authorization_code,
    std::function<void(std::optional<FlutterError> reply)> result) {
  result(FlutterError(
      "unimplemented",
      "RevokeTokenWithAuthorizationCode is not available on this platform yet.",
      nullptr));
}

}  // namespace firebase_auth_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/firebase_auth_plugin.h

**크기**: 9081 bytes | **라인 수**: 190 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_H_
#define FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_H_

#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>

#include <memory>

#include "firebase/app.h"
#include "firebase/auth.h"
#include "firebase/auth/types.h"
#include "firebase/future.h"
#include "messages.g.h"

using firebase::auth::AuthError;

namespace firebase_auth_windows {

class FirebaseAuthPlugin : public flutter::Plugin,
                           public FirebaseAuthHostApi,
                           public FirebaseAuthUserHostApi {
 public:
  static void RegisterWithRegistrar(flutter::PluginRegistrarWindows* registrar);

  FirebaseAuthPlugin();

  virtual ~FirebaseAuthPlugin();

  // Disallow copy and assign.
  FirebaseAuthPlugin(const FirebaseAuthPlugin&) = delete;
  FirebaseAuthPlugin& operator=(const FirebaseAuthPlugin&) = delete;

  // Parser functions
  static std::string GetAuthErrorCode(AuthError authError);
  static FlutterError ParseError(const firebase::FutureBase& future);

  static PigeonUserDetails ParseUserDetails(const firebase::auth::User user);
  static PigeonAdditionalUserInfo ParseAdditionalUserInfo(
      const firebase::auth::AdditionalUserInfo user);
  static flutter::EncodableMap ConvertToEncodableMap(
      const std::map<firebase::Variant, firebase::Variant>& originalMap);
  static flutter::EncodableValue ConvertToEncodableValue(
      const firebase::Variant& variant);
  static PigeonUserInfo ParseUserInfo(const firebase::auth::User* user);
  static flutter::EncodableList ParseProviderData(
      const firebase::auth::User* user);
  static flutter::EncodableValue ParseUserInfoToMap(
      firebase::auth::UserInfoInterface* userInfo);

  // FirebaseAuthHostApi methods.
  virtual void RegisterIdTokenListener(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void RegisterAuthStateListener(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void UseEmulator(
      const AuthPigeonFirebaseApp& app, const std::string& host, int64_t port,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void ApplyActionCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void CheckActionCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(ErrorOr<PigeonActionCodeInfo> reply)> result) override;
  virtual void ConfirmPasswordReset(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      const std::string& new_password,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void CreateUserWithEmailAndPassword(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& password,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInAnonymously(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInWithCustomToken(
      const AuthPigeonFirebaseApp& app, const std::string& token,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInWithEmailAndPassword(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& password,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInWithEmailLink(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& email_link,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignInWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void SignOut(
      const AuthPigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void FetchSignInMethodsForEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result)
      override;
  virtual void SendPasswordResetEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SendSignInLinkToEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const PigeonActionCodeSettings& action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SetLanguageCode(
      const AuthPigeonFirebaseApp& app, const std::string* language_code,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void SetSettings(
      const AuthPigeonFirebaseApp& app,
      const PigeonFirebaseAuthSettings& settings,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void VerifyPasswordResetCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(ErrorOr<std::string> reply)> result) override;
  virtual void VerifyPhoneNumber(
      const AuthPigeonFirebaseApp& app,
      const PigeonVerifyPhoneNumberRequest& request,
      std::function<void(ErrorOr<std::string> reply)> result) override;

  // FirebaseAuthUserHostApi methods.
  virtual void Delete(
      const AuthPigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void GetIdToken(
      const AuthPigeonFirebaseApp& app, bool force_refresh,
      std::function<void(ErrorOr<PigeonIdTokenResult> reply)> result) override;
  virtual void LinkWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void LinkWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void ReauthenticateWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void ReauthenticateWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void Reload(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) override;
  virtual void SendEmailVerification(
      const AuthPigeonFirebaseApp& app,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void Unlink(
      const AuthPigeonFirebaseApp& app, const std::string& provider_id,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) override;
  virtual void UpdateEmail(
      const AuthPigeonFirebaseApp& app, const std::string& new_email,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) override;
  virtual void UpdatePassword(
      const AuthPigeonFirebaseApp& app, const std::string& new_password,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) override;
  virtual void UpdatePhoneNumber(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) override;
  virtual void UpdateProfile(
      const AuthPigeonFirebaseApp& app, const PigeonUserProfile& profile,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) override;
  virtual void VerifyBeforeUpdateEmail(
      const AuthPigeonFirebaseApp& app, const std::string& new_email,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) override;

  virtual void RevokeTokenWithAuthorizationCode(
      const AuthPigeonFirebaseApp& app, const std::string& authorization_code,
      std::function<void(std::optional<FlutterError> reply)> result) override;

 private:
  static flutter::BinaryMessenger* binaryMessenger;
};

}  // namespace firebase_auth_windows

#endif  // FLUTTER_PLUGIN_FIREBASE_AUTH_PLUGIN_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/firebase_auth_plugin_c_api.cpp

**크기**: 656 bytes | **라인 수**: 17 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "include/firebase_auth/firebase_auth_plugin_c_api.h"

#include <flutter/plugin_registrar_windows.h>

#include "firebase_auth_plugin.h"

void FirebaseAuthPluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar) {
  firebase_auth_windows::FirebaseAuthPlugin::RegisterWithRegistrar(
      flutter::PluginRegistrarManager::GetInstance()
          ->GetRegistrar<flutter::PluginRegistrarWindows>(registrar));
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/messages.g.cpp

**크기**: 198214 bytes | **라인 수**: 5021 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace firebase_auth_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// PigeonMultiFactorSession

PigeonMultiFactorSession::PigeonMultiFactorSession(const std::string& id)
    : id_(id) {}

const std::string& PigeonMultiFactorSession::id() const { return id_; }

void PigeonMultiFactorSession::set_id(std::string_view value_arg) {
  id_ = value_arg;
}

EncodableList PigeonMultiFactorSession::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(id_));
  return list;
}

PigeonMultiFactorSession PigeonMultiFactorSession::FromEncodableList(
    const EncodableList& list) {
  PigeonMultiFactorSession decoded(std::get<std::string>(list[0]));
  return decoded;
}

// PigeonPhoneMultiFactorAssertion

PigeonPhoneMultiFactorAssertion::PigeonPhoneMultiFactorAssertion(
    const std::string& verification_id, const std::string& verification_code)
    : verification_id_(verification_id),
      verification_code_(verification_code) {}

const std::string& PigeonPhoneMultiFactorAssertion::verification_id() const {
  return verification_id_;
}

void PigeonPhoneMultiFactorAssertion::set_verification_id(
    std::string_view value_arg) {
  verification_id_ = value_arg;
}

const std::string& PigeonPhoneMultiFactorAssertion::verification_code() const {
  return verification_code_;
}

void PigeonPhoneMultiFactorAssertion::set_verification_code(
    std::string_view value_arg) {
  verification_code_ = value_arg;
}

EncodableList PigeonPhoneMultiFactorAssertion::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(verification_id_));
  list.push_back(EncodableValue(verification_code_));
  return list;
}

PigeonPhoneMultiFactorAssertion
PigeonPhoneMultiFactorAssertion::FromEncodableList(const EncodableList& list) {
  PigeonPhoneMultiFactorAssertion decoded(std::get<std::string>(list[0]),
                                          std::get<std::string>(list[1]));
  return decoded;
}

// PigeonMultiFactorInfo

PigeonMultiFactorInfo::PigeonMultiFactorInfo(double enrollment_timestamp,
                                             const std::string& uid)
    : enrollment_timestamp_(enrollment_timestamp), uid_(uid) {}

PigeonMultiFactorInfo::PigeonMultiFactorInfo(const std::string* display_name,
                                             double enrollment_timestamp,
                                             const std::string* factor_id,
                                             const std::string& uid,
                                             const std::string* phone_number)
    : display_name_(display_name ? std::optional<std::string>(*display_name)
                                 : std::nullopt),
      enrollment_timestamp_(enrollment_timestamp),
      factor_id_(factor_id ? std::optional<std::string>(*factor_id)
                           : std::nullopt),
      uid_(uid),
      phone_number_(phone_number ? std::optional<std::string>(*phone_number)
                                 : std::nullopt) {}

const std::string* PigeonMultiFactorInfo::display_name() const {
  return display_name_ ? &(*display_name_) : nullptr;
}

void PigeonMultiFactorInfo::set_display_name(
    const std::string_view* value_arg) {
  display_name_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonMultiFactorInfo::set_display_name(std::string_view value_arg) {
  display_name_ = value_arg;
}

double PigeonMultiFactorInfo::enrollment_timestamp() const {
  return enrollment_timestamp_;
}

void PigeonMultiFactorInfo::set_enrollment_timestamp(double value_arg) {
  enrollment_timestamp_ = value_arg;
}

const std::string* PigeonMultiFactorInfo::factor_id() const {
  return factor_id_ ? &(*factor_id_) : nullptr;
}

void PigeonMultiFactorInfo::set_factor_id(const std::string_view* value_arg) {
  factor_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonMultiFactorInfo::set_factor_id(std::string_view value_arg) {
  factor_id_ = value_arg;
}

const std::string& PigeonMultiFactorInfo::uid() const { return uid_; }

void PigeonMultiFactorInfo::set_uid(std::string_view value_arg) {
  uid_ = value_arg;
}

const std::string* PigeonMultiFactorInfo::phone_number() const {
  return phone_number_ ? &(*phone_number_) : nullptr;
}

void PigeonMultiFactorInfo::set_phone_number(
    const std::string_view* value_arg) {
  phone_number_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonMultiFactorInfo::set_phone_number(std::string_view value_arg) {
  phone_number_ = value_arg;
}

EncodableList PigeonMultiFactorInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(display_name_ ? EncodableValue(*display_name_)
                               : EncodableValue());
  list.push_back(EncodableValue(enrollment_timestamp_));
  list.push_back(factor_id_ ? EncodableValue(*factor_id_) : EncodableValue());
  list.push_back(EncodableValue(uid_));
  list.push_back(phone_number_ ? EncodableValue(*phone_number_)
                               : EncodableValue());
  return list;
}

PigeonMultiFactorInfo PigeonMultiFactorInfo::FromEncodableList(
    const EncodableList& list) {
  PigeonMultiFactorInfo decoded(std::get<double>(list[1]),
                                std::get<std::string>(list[3]));
  auto& encodable_display_name = list[0];
  if (!encodable_display_name.IsNull()) {
    decoded.set_display_name(std::get<std::string>(encodable_display_name));
  }
  auto& encodable_factor_id = list[2];
  if (!encodable_factor_id.IsNull()) {
    decoded.set_factor_id(std::get<std::string>(encodable_factor_id));
  }
  auto& encodable_phone_number = list[4];
  if (!encodable_phone_number.IsNull()) {
    decoded.set_phone_number(std::get<std::string>(encodable_phone_number));
  }
  return decoded;
}

// AuthPigeonFirebaseApp

AuthPigeonFirebaseApp::AuthPigeonFirebaseApp(const std::string& app_name)
    : app_name_(app_name) {}

AuthPigeonFirebaseApp::AuthPigeonFirebaseApp(
    const std::string& app_name, const std::string* tenant_id,
    const std::string* custom_auth_domain)
    : app_name_(app_name),
      tenant_id_(tenant_id ? std::optional<std::string>(*tenant_id)
                           : std::nullopt),
      custom_auth_domain_(custom_auth_domain
                              ? std::optional<std::string>(*custom_auth_domain)
                              : std::nullopt) {}

const std::string& AuthPigeonFirebaseApp::app_name() const { return app_name_; }

void AuthPigeonFirebaseApp::set_app_name(std::string_view value_arg) {
  app_name_ = value_arg;
}

const std::string* AuthPigeonFirebaseApp::tenant_id() const {
  return tenant_id_ ? &(*tenant_id_) : nullptr;
}

void AuthPigeonFirebaseApp::set_tenant_id(const std::string_view* value_arg) {
  tenant_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AuthPigeonFirebaseApp::set_tenant_id(std::string_view value_arg) {
  tenant_id_ = value_arg;
}

const std::string* AuthPigeonFirebaseApp::custom_auth_domain() const {
  return custom_auth_domain_ ? &(*custom_auth_domain_) : nullptr;
}

void AuthPigeonFirebaseApp::set_custom_auth_domain(
    const std::string_view* value_arg) {
  custom_auth_domain_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AuthPigeonFirebaseApp::set_custom_auth_domain(std::string_view value_arg) {
  custom_auth_domain_ = value_arg;
}

EncodableList AuthPigeonFirebaseApp::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(app_name_));
  list.push_back(tenant_id_ ? EncodableValue(*tenant_id_) : EncodableValue());
  list.push_back(custom_auth_domain_ ? EncodableValue(*custom_auth_domain_)
                                     : EncodableValue());
  return list;
}

AuthPigeonFirebaseApp AuthPigeonFirebaseApp::FromEncodableList(
    const EncodableList& list) {
  AuthPigeonFirebaseApp decoded(std::get<std::string>(list[0]));
  auto& encodable_tenant_id = list[1];
  if (!encodable_tenant_id.IsNull()) {
    decoded.set_tenant_id(std::get<std::string>(encodable_tenant_id));
  }
  auto& encodable_custom_auth_domain = list[2];
  if (!encodable_custom_auth_domain.IsNull()) {
    decoded.set_custom_auth_domain(
        std::get<std::string>(encodable_custom_auth_domain));
  }
  return decoded;
}

// PigeonActionCodeInfoData

PigeonActionCodeInfoData::PigeonActionCodeInfoData() {}

PigeonActionCodeInfoData::PigeonActionCodeInfoData(
    const std::string* email, const std::string* previous_email)
    : email_(email ? std::optional<std::string>(*email) : std::nullopt),
      previous_email_(previous_email
                          ? std::optional<std::string>(*previous_email)
                          : std::nullopt) {}

const std::string* PigeonActionCodeInfoData::email() const {
  return email_ ? &(*email_) : nullptr;
}

void PigeonActionCodeInfoData::set_email(const std::string_view* value_arg) {
  email_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeInfoData::set_email(std::string_view value_arg) {
  email_ = value_arg;
}

const std::string* PigeonActionCodeInfoData::previous_email() const {
  return previous_email_ ? &(*previous_email_) : nullptr;
}

void PigeonActionCodeInfoData::set_previous_email(
    const std::string_view* value_arg) {
  previous_email_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeInfoData::set_previous_email(std::string_view value_arg) {
  previous_email_ = value_arg;
}

EncodableList PigeonActionCodeInfoData::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(email_ ? EncodableValue(*email_) : EncodableValue());
  list.push_back(previous_email_ ? EncodableValue(*previous_email_)
                                 : EncodableValue());
  return list;
}

PigeonActionCodeInfoData PigeonActionCodeInfoData::FromEncodableList(
    const EncodableList& list) {
  PigeonActionCodeInfoData decoded;
  auto& encodable_email = list[0];
  if (!encodable_email.IsNull()) {
    decoded.set_email(std::get<std::string>(encodable_email));
  }
  auto& encodable_previous_email = list[1];
  if (!encodable_previous_email.IsNull()) {
    decoded.set_previous_email(std::get<std::string>(encodable_previous_email));
  }
  return decoded;
}

// PigeonActionCodeInfo

PigeonActionCodeInfo::PigeonActionCodeInfo(
    const ActionCodeInfoOperation& operation,
    const PigeonActionCodeInfoData& data)
    : operation_(operation),
      data_(std::make_unique<PigeonActionCodeInfoData>(data)) {}

PigeonActionCodeInfo::PigeonActionCodeInfo(const PigeonActionCodeInfo& other)
    : operation_(other.operation_),
      data_(std::make_unique<PigeonActionCodeInfoData>(*other.data_)) {}

PigeonActionCodeInfo& PigeonActionCodeInfo::operator=(
    const PigeonActionCodeInfo& other) {
  operation_ = other.operation_;
  data_ = std::make_unique<PigeonActionCodeInfoData>(*other.data_);
  return *this;
}

const ActionCodeInfoOperation& PigeonActionCodeInfo::operation() const {
  return operation_;
}

void PigeonActionCodeInfo::set_operation(
    const ActionCodeInfoOperation& value_arg) {
  operation_ = value_arg;
}

const PigeonActionCodeInfoData& PigeonActionCodeInfo::data() const {
  return *data_;
}

void PigeonActionCodeInfo::set_data(const PigeonActionCodeInfoData& value_arg) {
  data_ = std::make_unique<PigeonActionCodeInfoData>(value_arg);
}

EncodableList PigeonActionCodeInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue((int)operation_));
  list.push_back(CustomEncodableValue(*data_));
  return list;
}

PigeonActionCodeInfo PigeonActionCodeInfo::FromEncodableList(
    const EncodableList& list) {
  PigeonActionCodeInfo decoded(
      (ActionCodeInfoOperation)(std::get<int32_t>(list[0])),
      std::any_cast<const PigeonActionCodeInfoData&>(
          std::get<CustomEncodableValue>(list[1])));
  return decoded;
}

// PigeonAdditionalUserInfo

PigeonAdditionalUserInfo::PigeonAdditionalUserInfo(bool is_new_user)
    : is_new_user_(is_new_user) {}

PigeonAdditionalUserInfo::PigeonAdditionalUserInfo(
    bool is_new_user, const std::string* provider_id,
    const std::string* username, const std::string* authorization_code,
    const EncodableMap* profile)
    : is_new_user_(is_new_user),
      provider_id_(provider_id ? std::optional<std::string>(*provider_id)
                               : std::nullopt),
      username_(username ? std::optional<std::string>(*username)
                         : std::nullopt),
      authorization_code_(authorization_code
                              ? std::optional<std::string>(*authorization_code)
                              : std::nullopt),
      profile_(profile ? std::optional<EncodableMap>(*profile) : std::nullopt) {
}

bool PigeonAdditionalUserInfo::is_new_user() const { return is_new_user_; }

void PigeonAdditionalUserInfo::set_is_new_user(bool value_arg) {
  is_new_user_ = value_arg;
}

const std::string* PigeonAdditionalUserInfo::provider_id() const {
  return provider_id_ ? &(*provider_id_) : nullptr;
}

void PigeonAdditionalUserInfo::set_provider_id(
    const std::string_view* value_arg) {
  provider_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonAdditionalUserInfo::set_provider_id(std::string_view value_arg) {
  provider_id_ = value_arg;
}

const std::string* PigeonAdditionalUserInfo::username() const {
  return username_ ? &(*username_) : nullptr;
}

void PigeonAdditionalUserInfo::set_username(const std::string_view* value_arg) {
  username_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonAdditionalUserInfo::set_username(std::string_view value_arg) {
  username_ = value_arg;
}

const std::string* PigeonAdditionalUserInfo::authorization_code() const {
  return authorization_code_ ? &(*authorization_code_) : nullptr;
}

void PigeonAdditionalUserInfo::set_authorization_code(
    const std::string_view* value_arg) {
  authorization_code_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonAdditionalUserInfo::set_authorization_code(
    std::string_view value_arg) {
  authorization_code_ = value_arg;
}

const EncodableMap* PigeonAdditionalUserInfo::profile() const {
  return profile_ ? &(*profile_) : nullptr;
}

void PigeonAdditionalUserInfo::set_profile(const EncodableMap* value_arg) {
  profile_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonAdditionalUserInfo::set_profile(const EncodableMap& value_arg) {
  profile_ = value_arg;
}

EncodableList PigeonAdditionalUserInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(is_new_user_));
  list.push_back(provider_id_ ? EncodableValue(*provider_id_)
                              : EncodableValue());
  list.push_back(username_ ? EncodableValue(*username_) : EncodableValue());
  list.push_back(authorization_code_ ? EncodableValue(*authorization_code_)
                                     : EncodableValue());
  list.push_back(profile_ ? EncodableValue(*profile_) : EncodableValue());
  return list;
}

PigeonAdditionalUserInfo PigeonAdditionalUserInfo::FromEncodableList(
    const EncodableList& list) {
  PigeonAdditionalUserInfo decoded(std::get<bool>(list[0]));
  auto& encodable_provider_id = list[1];
  if (!encodable_provider_id.IsNull()) {
    decoded.set_provider_id(std::get<std::string>(encodable_provider_id));
  }
  auto& encodable_username = list[2];
  if (!encodable_username.IsNull()) {
    decoded.set_username(std::get<std::string>(encodable_username));
  }
  auto& encodable_authorization_code = list[3];
  if (!encodable_authorization_code.IsNull()) {
    decoded.set_authorization_code(
        std::get<std::string>(encodable_authorization_code));
  }
  auto& encodable_profile = list[4];
  if (!encodable_profile.IsNull()) {
    decoded.set_profile(std::get<EncodableMap>(encodable_profile));
  }
  return decoded;
}

// PigeonAuthCredential

PigeonAuthCredential::PigeonAuthCredential(const std::string& provider_id,
                                           const std::string& sign_in_method,
                                           int64_t native_id)
    : provider_id_(provider_id),
      sign_in_method_(sign_in_method),
      native_id_(native_id) {}

PigeonAuthCredential::PigeonAuthCredential(const std::string& provider_id,
                                           const std::string& sign_in_method,
                                           int64_t native_id,
                                           const std::string* access_token)
    : provider_id_(provider_id),
      sign_in_method_(sign_in_method),
      native_id_(native_id),
      access_token_(access_token ? std::optional<std::string>(*access_token)
                                 : std::nullopt) {}

const std::string& PigeonAuthCredential::provider_id() const {
  return provider_id_;
}

void PigeonAuthCredential::set_provider_id(std::string_view value_arg) {
  provider_id_ = value_arg;
}

const std::string& PigeonAuthCredential::sign_in_method() const {
  return sign_in_method_;
}

void PigeonAuthCredential::set_sign_in_method(std::string_view value_arg) {
  sign_in_method_ = value_arg;
}

int64_t PigeonAuthCredential::native_id() const { return native_id_; }

void PigeonAuthCredential::set_native_id(int64_t value_arg) {
  native_id_ = value_arg;
}

const std::string* PigeonAuthCredential::access_token() const {
  return access_token_ ? &(*access_token_) : nullptr;
}

void PigeonAuthCredential::set_access_token(const std::string_view* value_arg) {
  access_token_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonAuthCredential::set_access_token(std::string_view value_arg) {
  access_token_ = value_arg;
}

EncodableList PigeonAuthCredential::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(provider_id_));
  list.push_back(EncodableValue(sign_in_method_));
  list.push_back(EncodableValue(native_id_));
  list.push_back(access_token_ ? EncodableValue(*access_token_)
                               : EncodableValue());
  return list;
}

PigeonAuthCredential PigeonAuthCredential::FromEncodableList(
    const EncodableList& list) {
  PigeonAuthCredential decoded(std::get<std::string>(list[0]),
                               std::get<std::string>(list[1]),
                               list[2].LongValue());
  auto& encodable_access_token = list[3];
  if (!encodable_access_token.IsNull()) {
    decoded.set_access_token(std::get<std::string>(encodable_access_token));
  }
  return decoded;
}

// PigeonUserInfo

PigeonUserInfo::PigeonUserInfo(const std::string& uid, bool is_anonymous,
                               bool is_email_verified)
    : uid_(uid),
      is_anonymous_(is_anonymous),
      is_email_verified_(is_email_verified) {}

PigeonUserInfo::PigeonUserInfo(
    const std::string& uid, const std::string* email,
    const std::string* display_name, const std::string* photo_url,
    const std::string* phone_number, bool is_anonymous, bool is_email_verified,
    const std::string* provider_id, const std::string* tenant_id,
    const std::string* refresh_token, const int64_t* creation_timestamp,
    const int64_t* last_sign_in_timestamp)
    : uid_(uid),
      email_(email ? std::optional<std::string>(*email) : std::nullopt),
      display_name_(display_name ? std::optional<std::string>(*display_name)
                                 : std::nullopt),
      photo_url_(photo_url ? std::optional<std::string>(*photo_url)
                           : std::nullopt),
      phone_number_(phone_number ? std::optional<std::string>(*phone_number)
                                 : std::nullopt),
      is_anonymous_(is_anonymous),
      is_email_verified_(is_email_verified),
      provider_id_(provider_id ? std::optional<std::string>(*provider_id)
                               : std::nullopt),
      tenant_id_(tenant_id ? std::optional<std::string>(*tenant_id)
                           : std::nullopt),
      refresh_token_(refresh_token ? std::optional<std::string>(*refresh_token)
                                   : std::nullopt),
      creation_timestamp_(creation_timestamp
                              ? std::optional<int64_t>(*creation_timestamp)
                              : std::nullopt),
      last_sign_in_timestamp_(
          last_sign_in_timestamp
              ? std::optional<int64_t>(*last_sign_in_timestamp)
              : std::nullopt) {}

const std::string& PigeonUserInfo::uid() const { return uid_; }

void PigeonUserInfo::set_uid(std::string_view value_arg) { uid_ = value_arg; }

const std::string* PigeonUserInfo::email() const {
  return email_ ? &(*email_) : nullptr;
}

void PigeonUserInfo::set_email(const std::string_view* value_arg) {
  email_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_email(std::string_view value_arg) {
  email_ = value_arg;
}

const std::string* PigeonUserInfo::display_name() const {
  return display_name_ ? &(*display_name_) : nullptr;
}

void PigeonUserInfo::set_display_name(const std::string_view* value_arg) {
  display_name_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_display_name(std::string_view value_arg) {
  display_name_ = value_arg;
}

const std::string* PigeonUserInfo::photo_url() const {
  return photo_url_ ? &(*photo_url_) : nullptr;
}

void PigeonUserInfo::set_photo_url(const std::string_view* value_arg) {
  photo_url_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_photo_url(std::string_view value_arg) {
  photo_url_ = value_arg;
}

const std::string* PigeonUserInfo::phone_number() const {
  return phone_number_ ? &(*phone_number_) : nullptr;
}

void PigeonUserInfo::set_phone_number(const std::string_view* value_arg) {
  phone_number_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_phone_number(std::string_view value_arg) {
  phone_number_ = value_arg;
}

bool PigeonUserInfo::is_anonymous() const { return is_anonymous_; }

void PigeonUserInfo::set_is_anonymous(bool value_arg) {
  is_anonymous_ = value_arg;
}

bool PigeonUserInfo::is_email_verified() const { return is_email_verified_; }

void PigeonUserInfo::set_is_email_verified(bool value_arg) {
  is_email_verified_ = value_arg;
}

const std::string* PigeonUserInfo::provider_id() const {
  return provider_id_ ? &(*provider_id_) : nullptr;
}

void PigeonUserInfo::set_provider_id(const std::string_view* value_arg) {
  provider_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_provider_id(std::string_view value_arg) {
  provider_id_ = value_arg;
}

const std::string* PigeonUserInfo::tenant_id() const {
  return tenant_id_ ? &(*tenant_id_) : nullptr;
}

void PigeonUserInfo::set_tenant_id(const std::string_view* value_arg) {
  tenant_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_tenant_id(std::string_view value_arg) {
  tenant_id_ = value_arg;
}

const std::string* PigeonUserInfo::refresh_token() const {
  return refresh_token_ ? &(*refresh_token_) : nullptr;
}

void PigeonUserInfo::set_refresh_token(const std::string_view* value_arg) {
  refresh_token_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_refresh_token(std::string_view value_arg) {
  refresh_token_ = value_arg;
}

const int64_t* PigeonUserInfo::creation_timestamp() const {
  return creation_timestamp_ ? &(*creation_timestamp_) : nullptr;
}

void PigeonUserInfo::set_creation_timestamp(const int64_t* value_arg) {
  creation_timestamp_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_creation_timestamp(int64_t value_arg) {
  creation_timestamp_ = value_arg;
}

const int64_t* PigeonUserInfo::last_sign_in_timestamp() const {
  return last_sign_in_timestamp_ ? &(*last_sign_in_timestamp_) : nullptr;
}

void PigeonUserInfo::set_last_sign_in_timestamp(const int64_t* value_arg) {
  last_sign_in_timestamp_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonUserInfo::set_last_sign_in_timestamp(int64_t value_arg) {
  last_sign_in_timestamp_ = value_arg;
}

EncodableList PigeonUserInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(12);
  list.push_back(EncodableValue(uid_));
  list.push_back(email_ ? EncodableValue(*email_) : EncodableValue());
  list.push_back(display_name_ ? EncodableValue(*display_name_)
                               : EncodableValue());
  list.push_back(photo_url_ ? EncodableValue(*photo_url_) : EncodableValue());
  list.push_back(phone_number_ ? EncodableValue(*phone_number_)
                               : EncodableValue());
  list.push_back(EncodableValue(is_anonymous_));
  list.push_back(EncodableValue(is_email_verified_));
  list.push_back(provider_id_ ? EncodableValue(*provider_id_)
                              : EncodableValue());
  list.push_back(tenant_id_ ? EncodableValue(*tenant_id_) : EncodableValue());
  list.push_back(refresh_token_ ? EncodableValue(*refresh_token_)
                                : EncodableValue());
  list.push_back(creation_timestamp_ ? EncodableValue(*creation_timestamp_)
                                     : EncodableValue());
  list.push_back(last_sign_in_timestamp_
                     ? EncodableValue(*last_sign_in_timestamp_)
                     : EncodableValue());
  return list;
}

PigeonUserInfo PigeonUserInfo::FromEncodableList(const EncodableList& list) {
  PigeonUserInfo decoded(std::get<std::string>(list[0]),
                         std::get<bool>(list[5]), std::get<bool>(list[6]));
  auto& encodable_email = list[1];
  if (!encodable_email.IsNull()) {
    decoded.set_email(std::get<std::string>(encodable_email));
  }
  auto& encodable_display_name = list[2];
  if (!encodable_display_name.IsNull()) {
    decoded.set_display_name(std::get<std::string>(encodable_display_name));
  }
  auto& encodable_photo_url = list[3];
  if (!encodable_photo_url.IsNull()) {
    decoded.set_photo_url(std::get<std::string>(encodable_photo_url));
  }
  auto& encodable_phone_number = list[4];
  if (!encodable_phone_number.IsNull()) {
    decoded.set_phone_number(std::get<std::string>(encodable_phone_number));
  }
  auto& encodable_provider_id = list[7];
  if (!encodable_provider_id.IsNull()) {
    decoded.set_provider_id(std::get<std::string>(encodable_provider_id));
  }
  auto& encodable_tenant_id = list[8];
  if (!encodable_tenant_id.IsNull()) {
    decoded.set_tenant_id(std::get<std::string>(encodable_tenant_id));
  }
  auto& encodable_refresh_token = list[9];
  if (!encodable_refresh_token.IsNull()) {
    decoded.set_refresh_token(std::get<std::string>(encodable_refresh_token));
  }
  auto& encodable_creation_timestamp = list[10];
  if (!encodable_creation_timestamp.IsNull()) {
    decoded.set_creation_timestamp(encodable_creation_timestamp.LongValue());
  }
  auto& encodable_last_sign_in_timestamp = list[11];
  if (!encodable_last_sign_in_timestamp.IsNull()) {
    decoded.set_last_sign_in_timestamp(
        encodable_last_sign_in_timestamp.LongValue());
  }
  return decoded;
}

// PigeonUserDetails

PigeonUserDetails::PigeonUserDetails(const PigeonUserInfo& user_info,
                                     const EncodableList& provider_data)
    : user_info_(std::make_unique<PigeonUserInfo>(user_info)),
      provider_data_(provider_data) {}

PigeonUserDetails::PigeonUserDetails(const PigeonUserDetails& other)
    : user_info_(std::make_unique<PigeonUserInfo>(*other.user_info_)),
      provider_data_(other.provider_data_) {}

PigeonUserDetails& PigeonUserDetails::operator=(
    const PigeonUserDetails& other) {
  user_info_ = std::make_unique<PigeonUserInfo>(*other.user_info_);
  provider_data_ = other.provider_data_;
  return *this;
}

const PigeonUserInfo& PigeonUserDetails::user_info() const {
  return *user_info_;
}

void PigeonUserDetails::set_user_info(const PigeonUserInfo& value_arg) {
  user_info_ = std::make_unique<PigeonUserInfo>(value_arg);
}

const EncodableList& PigeonUserDetails::provider_data() const {
  return provider_data_;
}

void PigeonUserDetails::set_provider_data(const EncodableList& value_arg) {
  provider_data_ = value_arg;
}

EncodableList PigeonUserDetails::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(CustomEncodableValue(*user_info_));
  list.push_back(EncodableValue(provider_data_));
  return list;
}

PigeonUserDetails PigeonUserDetails::FromEncodableList(
    const EncodableList& list) {
  PigeonUserDetails decoded(std::any_cast<const PigeonUserInfo&>(
                                std::get<CustomEncodableValue>(list[0])),
                            std::get<EncodableList>(list[1]));
  return decoded;
}

// PigeonUserCredential

PigeonUserCredential::PigeonUserCredential() {}

PigeonUserCredential::PigeonUserCredential(
    const PigeonUserDetails* user,
    const PigeonAdditionalUserInfo* additional_user_info,
    const PigeonAuthCredential* credential)
    : user_(user ? std::make_unique<PigeonUserDetails>(*user) : nullptr),
      additional_user_info_(additional_user_info
                                ? std::make_unique<PigeonAdditionalUserInfo>(
                                      *additional_user_info)
                                : nullptr),
      credential_(credential
                      ? std::make_unique<PigeonAuthCredential>(*credential)
                      : nullptr) {}

PigeonUserCredential::PigeonUserCredential(const PigeonUserCredential& other)
    : user_(other.user_ ? std::make_unique<PigeonUserDetails>(*other.user_)
                        : nullptr),
      additional_user_info_(other.additional_user_info_
                                ? std::make_unique<PigeonAdditionalUserInfo>(
                                      *other.additional_user_info_)
                                : nullptr),
      credential_(other.credential_ ? std::make_unique<PigeonAuthCredential>(
                                          *other.credential_)
                                    : nullptr) {}

PigeonUserCredential& PigeonUserCredential::operator=(
    const PigeonUserCredential& other) {
  user_ =
      other.user_ ? std::make_unique<PigeonUserDetails>(*other.user_) : nullptr;
  additional_user_info_ = other.additional_user_info_
                              ? std::make_unique<PigeonAdditionalUserInfo>(
                                    *other.additional_user_info_)
                              : nullptr;
  credential_ = other.credential_
                    ? std::make_unique<PigeonAuthCredential>(*other.credential_)
                    : nullptr;
  return *this;
}

const PigeonUserDetails* PigeonUserCredential::user() const {
  return user_.get();
}

void PigeonUserCredential::set_user(const PigeonUserDetails* value_arg) {
  user_ = value_arg ? std::make_unique<PigeonUserDetails>(*value_arg) : nullptr;
}

void PigeonUserCredential::set_user(const PigeonUserDetails& value_arg) {
  user_ = std::make_unique<PigeonUserDetails>(value_arg);
}

const PigeonAdditionalUserInfo* PigeonUserCredential::additional_user_info()
    const {
  return additional_user_info_.get();
}

void PigeonUserCredential::set_additional_user_info(
    const PigeonAdditionalUserInfo* value_arg) {
  additional_user_info_ =
      value_arg ? std::make_unique<PigeonAdditionalUserInfo>(*value_arg)
                : nullptr;
}

void PigeonUserCredential::set_additional_user_info(
    const PigeonAdditionalUserInfo& value_arg) {
  additional_user_info_ = std::make_unique<PigeonAdditionalUserInfo>(value_arg);
}

const PigeonAuthCredential* PigeonUserCredential::credential() const {
  return credential_.get();
}

void PigeonUserCredential::set_credential(
    const PigeonAuthCredential* value_arg) {
  credential_ =
      value_arg ? std::make_unique<PigeonAuthCredential>(*value_arg) : nullptr;
}

void PigeonUserCredential::set_credential(
    const PigeonAuthCredential& value_arg) {
  credential_ = std::make_unique<PigeonAuthCredential>(value_arg);
}

EncodableList PigeonUserCredential::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(user_ ? CustomEncodableValue(*user_) : EncodableValue());
  list.push_back(additional_user_info_
                     ? CustomEncodableValue(*additional_user_info_)
                     : EncodableValue());
  list.push_back(credential_ ? CustomEncodableValue(*credential_)
                             : EncodableValue());
  return list;
}

PigeonUserCredential PigeonUserCredential::FromEncodableList(
    const EncodableList& list) {
  PigeonUserCredential decoded;
  auto& encodable_user = list[0];
  if (!encodable_user.IsNull()) {
    decoded.set_user(std::any_cast<const PigeonUserDetails&>(
        std::get<CustomEncodableValue>(encodable_user)));
  }
  auto& encodable_additional_user_info = list[1];
  if (!encodable_additional_user_info.IsNull()) {
    decoded.set_additional_user_info(
        std::any_cast<const PigeonAdditionalUserInfo&>(
            std::get<CustomEncodableValue>(encodable_additional_user_info)));
  }
  auto& encodable_credential = list[2];
  if (!encodable_credential.IsNull()) {
    decoded.set_credential(std::any_cast<const PigeonAuthCredential&>(
        std::get<CustomEncodableValue>(encodable_credential)));
  }
  return decoded;
}

// PigeonActionCodeSettings

PigeonActionCodeSettings::PigeonActionCodeSettings(const std::string& url,
                                                   bool handle_code_in_app,
                                                   bool android_install_app)
    : url_(url),
      handle_code_in_app_(handle_code_in_app),
      android_install_app_(android_install_app) {}

PigeonActionCodeSettings::PigeonActionCodeSettings(
    const std::string& url, const std::string* dynamic_link_domain,
    bool handle_code_in_app, const std::string* i_o_s_bundle_id,
    const std::string* android_package_name, bool android_install_app,
    const std::string* android_minimum_version, const std::string* link_domain)
    : url_(url),
      dynamic_link_domain_(
          dynamic_link_domain ? std::optional<std::string>(*dynamic_link_domain)
                              : std::nullopt),
      handle_code_in_app_(handle_code_in_app),
      i_o_s_bundle_id_(i_o_s_bundle_id
                           ? std::optional<std::string>(*i_o_s_bundle_id)
                           : std::nullopt),
      android_package_name_(android_package_name ? std::optional<std::string>(
                                                       *android_package_name)
                                                 : std::nullopt),
      android_install_app_(android_install_app),
      android_minimum_version_(
          android_minimum_version
              ? std::optional<std::string>(*android_minimum_version)
              : std::nullopt),
      link_domain_(link_domain ? std::optional<std::string>(*link_domain)
                               : std::nullopt) {}

const std::string& PigeonActionCodeSettings::url() const { return url_; }

void PigeonActionCodeSettings::set_url(std::string_view value_arg) {
  url_ = value_arg;
}

const std::string* PigeonActionCodeSettings::dynamic_link_domain() const {
  return dynamic_link_domain_ ? &(*dynamic_link_domain_) : nullptr;
}

void PigeonActionCodeSettings::set_dynamic_link_domain(
    const std::string_view* value_arg) {
  dynamic_link_domain_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeSettings::set_dynamic_link_domain(
    std::string_view value_arg) {
  dynamic_link_domain_ = value_arg;
}

bool PigeonActionCodeSettings::handle_code_in_app() const {
  return handle_code_in_app_;
}

void PigeonActionCodeSettings::set_handle_code_in_app(bool value_arg) {
  handle_code_in_app_ = value_arg;
}

const std::string* PigeonActionCodeSettings::i_o_s_bundle_id() const {
  return i_o_s_bundle_id_ ? &(*i_o_s_bundle_id_) : nullptr;
}

void PigeonActionCodeSettings::set_i_o_s_bundle_id(
    const std::string_view* value_arg) {
  i_o_s_bundle_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeSettings::set_i_o_s_bundle_id(std::string_view value_arg) {
  i_o_s_bundle_id_ = value_arg;
}

const std::string* PigeonActionCodeSettings::android_package_name() const {
  return android_package_name_ ? &(*android_package_name_) : nullptr;
}

void PigeonActionCodeSettings::set_android_package_name(
    const std::string_view* value_arg) {
  android_package_name_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeSettings::set_android_package_name(
    std::string_view value_arg) {
  android_package_name_ = value_arg;
}

bool PigeonActionCodeSettings::android_install_app() const {
  return android_install_app_;
}

void PigeonActionCodeSettings::set_android_install_app(bool value_arg) {
  android_install_app_ = value_arg;
}

const std::string* PigeonActionCodeSettings::android_minimum_version() const {
  return android_minimum_version_ ? &(*android_minimum_version_) : nullptr;
}

void PigeonActionCodeSettings::set_android_minimum_version(
    const std::string_view* value_arg) {
  android_minimum_version_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeSettings::set_android_minimum_version(
    std::string_view value_arg) {
  android_minimum_version_ = value_arg;
}

const std::string* PigeonActionCodeSettings::link_domain() const {
  return link_domain_ ? &(*link_domain_) : nullptr;
}

void PigeonActionCodeSettings::set_link_domain(
    const std::string_view* value_arg) {
  link_domain_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonActionCodeSettings::set_link_domain(std::string_view value_arg) {
  link_domain_ = value_arg;
}

EncodableList PigeonActionCodeSettings::ToEncodableList() const {
  EncodableList list;
  list.reserve(8);
  list.push_back(EncodableValue(url_));
  list.push_back(dynamic_link_domain_ ? EncodableValue(*dynamic_link_domain_)
                                      : EncodableValue());
  list.push_back(EncodableValue(handle_code_in_app_));
  list.push_back(i_o_s_bundle_id_ ? EncodableValue(*i_o_s_bundle_id_)
                                  : EncodableValue());
  list.push_back(android_package_name_ ? EncodableValue(*android_package_name_)
                                       : EncodableValue());
  list.push_back(EncodableValue(android_install_app_));
  list.push_back(android_minimum_version_
                     ? EncodableValue(*android_minimum_version_)
                     : EncodableValue());
  list.push_back(link_domain_ ? EncodableValue(*link_domain_)
                              : EncodableValue());
  return list;
}

PigeonActionCodeSettings PigeonActionCodeSettings::FromEncodableList(
    const EncodableList& list) {
  PigeonActionCodeSettings decoded(std::get<std::string>(list[0]),
                                   std::get<bool>(list[2]),
                                   std::get<bool>(list[5]));
  auto& encodable_dynamic_link_domain = list[1];
  if (!encodable_dynamic_link_domain.IsNull()) {
    decoded.set_dynamic_link_domain(
        std::get<std::string>(encodable_dynamic_link_domain));
  }
  auto& encodable_i_o_s_bundle_id = list[3];
  if (!encodable_i_o_s_bundle_id.IsNull()) {
    decoded.set_i_o_s_bundle_id(
        std::get<std::string>(encodable_i_o_s_bundle_id));
  }
  auto& encodable_android_package_name = list[4];
  if (!encodable_android_package_name.IsNull()) {
    decoded.set_android_package_name(
        std::get<std::string>(encodable_android_package_name));
  }
  auto& encodable_android_minimum_version = list[6];
  if (!encodable_android_minimum_version.IsNull()) {
    decoded.set_android_minimum_version(
        std::get<std::string>(encodable_android_minimum_version));
  }
  auto& encodable_link_domain = list[7];
  if (!encodable_link_domain.IsNull()) {
    decoded.set_link_domain(std::get<std::string>(encodable_link_domain));
  }
  return decoded;
}

// PigeonFirebaseAuthSettings

PigeonFirebaseAuthSettings::PigeonFirebaseAuthSettings(
    bool app_verification_disabled_for_testing)
    : app_verification_disabled_for_testing_(
          app_verification_disabled_for_testing) {}

PigeonFirebaseAuthSettings::PigeonFirebaseAuthSettings(
    bool app_verification_disabled_for_testing,
    const std::string* user_access_group, const std::string* phone_number,
    const std::string* sms_code, const bool* force_recaptcha_flow)
    : app_verification_disabled_for_testing_(
          app_verification_disabled_for_testing),
      user_access_group_(user_access_group
                             ? std::optional<std::string>(*user_access_group)
                             : std::nullopt),
      phone_number_(phone_number ? std::optional<std::string>(*phone_number)
                                 : std::nullopt),
      sms_code_(sms_code ? std::optional<std::string>(*sms_code)
                         : std::nullopt),
      force_recaptcha_flow_(force_recaptcha_flow
                                ? std::optional<bool>(*force_recaptcha_flow)
                                : std::nullopt) {}

bool PigeonFirebaseAuthSettings::app_verification_disabled_for_testing() const {
  return app_verification_disabled_for_testing_;
}

void PigeonFirebaseAuthSettings::set_app_verification_disabled_for_testing(
    bool value_arg) {
  app_verification_disabled_for_testing_ = value_arg;
}

const std::string* PigeonFirebaseAuthSettings::user_access_group() const {
  return user_access_group_ ? &(*user_access_group_) : nullptr;
}

void PigeonFirebaseAuthSettings::set_user_access_group(
    const std::string_view* value_arg) {
  user_access_group_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonFirebaseAuthSettings::set_user_access_group(
    std::string_view value_arg) {
  user_access_group_ = value_arg;
}

const std::string* PigeonFirebaseAuthSettings::phone_number() const {
  return phone_number_ ? &(*phone_number_) : nullptr;
}

void PigeonFirebaseAuthSettings::set_phone_number(
    const std::string_view* value_arg) {
  phone_number_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonFirebaseAuthSettings::set_phone_number(std::string_view value_arg) {
  phone_number_ = value_arg;
}

const std::string* PigeonFirebaseAuthSettings::sms_code() const {
  return sms_code_ ? &(*sms_code_) : nullptr;
}

void PigeonFirebaseAuthSettings::set_sms_code(
    const std::string_view* value_arg) {
  sms_code_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonFirebaseAuthSettings::set_sms_code(std::string_view value_arg) {
  sms_code_ = value_arg;
}

const bool* PigeonFirebaseAuthSettings::force_recaptcha_flow() const {
  return force_recaptcha_flow_ ? &(*force_recaptcha_flow_) : nullptr;
}

void PigeonFirebaseAuthSettings::set_force_recaptcha_flow(
    const bool* value_arg) {
  force_recaptcha_flow_ =
      value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void PigeonFirebaseAuthSettings::set_force_recaptcha_flow(bool value_arg) {
  force_recaptcha_flow_ = value_arg;
}

EncodableList PigeonFirebaseAuthSettings::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(app_verification_disabled_for_testing_));
  list.push_back(user_access_group_ ? EncodableValue(*user_access_group_)
                                    : EncodableValue());
  list.push_back(phone_number_ ? EncodableValue(*phone_number_)
                               : EncodableValue());
  list.push_back(sms_code_ ? EncodableValue(*sms_code_) : EncodableValue());
  list.push_back(force_recaptcha_flow_ ? EncodableValue(*force_recaptcha_flow_)
                                       : EncodableValue());
  return list;
}

PigeonFirebaseAuthSettings PigeonFirebaseAuthSettings::FromEncodableList(
    const EncodableList& list) {
  PigeonFirebaseAuthSettings decoded(std::get<bool>(list[0]));
  auto& encodable_user_access_group = list[1];
  if (!encodable_user_access_group.IsNull()) {
    decoded.set_user_access_group(
        std::get<std::string>(encodable_user_access_group));
  }
  auto& encodable_phone_number = list[2];
  if (!encodable_phone_number.IsNull()) {
    decoded.set_phone_number(std::get<std::string>(encodable_phone_number));
  }
  auto& encodable_sms_code = list[3];
  if (!encodable_sms_code.IsNull()) {
    decoded.set_sms_code(std::get<std::string>(encodable_sms_code));
  }
  auto& encodable_force_recaptcha_flow = list[4];
  if (!encodable_force_recaptcha_flow.IsNull()) {
    decoded.set_force_recaptcha_flow(
        std::get<bool>(encodable_force_recaptcha_flow));
  }
  return decoded;
}

// PigeonSignInProvider

PigeonSignInProvider::PigeonSignInProvider(const std::string& provider_id)
    : provider_id_(provider_id) {}

PigeonSignInProvider::PigeonSignInProvider(
    const std::string& provider_id, const EncodableList* scopes,
    const EncodableMap* custom_parameters)
    : provider_id_(provider_id),
      scopes_(scopes ? std::optional<EncodableList>(*scopes) : std::nullopt),
      custom_parameters_(custom_parameters
                             ? std::optional<EncodableMap>(*custom_parameters)
                             : std::nullopt) {}

const std::string& PigeonSignInProvider::provider_id() const {
  return provider_id_;
}

void PigeonSignInProvider::set_provider_id(std::string_view value_arg) {
  provider_id_ = value_arg;
}

const EncodableList* PigeonSignInProvider::scopes() const {
  return scopes_ ? &(*scopes_) : nullptr;
}

void PigeonSignInProvider::set_scopes(const EncodableList* value_arg) {
  scopes_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void PigeonSignInProvider::set_scopes(const EncodableList& value_arg) {
  scopes_ = value_arg;
}

const EncodableMap* PigeonSignInProvider::custom_parameters() const {
  return custom_parameters_ ? &(*custom_parameters_) : nullptr;
}

void PigeonSignInProvider::set_custom_parameters(
    const EncodableMap* value_arg) {
  custom_parameters_ =
      value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonSignInProvider::set_custom_parameters(
    const EncodableMap& value_arg) {
  custom_parameters_ = value_arg;
}

EncodableList PigeonSignInProvider::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(provider_id_));
  list.push_back(scopes_ ? EncodableValue(*scopes_) : EncodableValue());
  list.push_back(custom_parameters_ ? EncodableValue(*custom_parameters_)
                                    : EncodableValue());
  return list;
}

PigeonSignInProvider PigeonSignInProvider::FromEncodableList(
    const EncodableList& list) {
  PigeonSignInProvider decoded(std::get<std::string>(list[0]));
  auto& encodable_scopes = list[1];
  if (!encodable_scopes.IsNull()) {
    decoded.set_scopes(std::get<EncodableList>(encodable_scopes));
  }
  auto& encodable_custom_parameters = list[2];
  if (!encodable_custom_parameters.IsNull()) {
    decoded.set_custom_parameters(
        std::get<EncodableMap>(encodable_custom_parameters));
  }
  return decoded;
}

// PigeonVerifyPhoneNumberRequest

PigeonVerifyPhoneNumberRequest::PigeonVerifyPhoneNumberRequest(int64_t timeout)
    : timeout_(timeout) {}

PigeonVerifyPhoneNumberRequest::PigeonVerifyPhoneNumberRequest(
    const std::string* phone_number, int64_t timeout,
    const int64_t* force_resending_token,
    const std::string* auto_retrieved_sms_code_for_testing,
    const std::string* multi_factor_info_id,
    const std::string* multi_factor_session_id)
    : phone_number_(phone_number ? std::optional<std::string>(*phone_number)
                                 : std::nullopt),
      timeout_(timeout),
      force_resending_token_(
          force_resending_token ? std::optional<int64_t>(*force_resending_token)
                                : std::nullopt),
      auto_retrieved_sms_code_for_testing_(
          auto_retrieved_sms_code_for_testing
              ? std::optional<std::string>(*auto_retrieved_sms_code_for_testing)
              : std::nullopt),
      multi_factor_info_id_(multi_factor_info_id ? std::optional<std::string>(
                                                       *multi_factor_info_id)
                                                 : std::nullopt),
      multi_factor_session_id_(
          multi_factor_session_id
              ? std::optional<std::string>(*multi_factor_session_id)
              : std::nullopt) {}

const std::string* PigeonVerifyPhoneNumberRequest::phone_number() const {
  return phone_number_ ? &(*phone_number_) : nullptr;
}

void PigeonVerifyPhoneNumberRequest::set_phone_number(
    const std::string_view* value_arg) {
  phone_number_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonVerifyPhoneNumberRequest::set_phone_number(
    std::string_view value_arg) {
  phone_number_ = value_arg;
}

int64_t PigeonVerifyPhoneNumberRequest::timeout() const { return timeout_; }

void PigeonVerifyPhoneNumberRequest::set_timeout(int64_t value_arg) {
  timeout_ = value_arg;
}

const int64_t* PigeonVerifyPhoneNumberRequest::force_resending_token() const {
  return force_resending_token_ ? &(*force_resending_token_) : nullptr;
}

void PigeonVerifyPhoneNumberRequest::set_force_resending_token(
    const int64_t* value_arg) {
  force_resending_token_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonVerifyPhoneNumberRequest::set_force_resending_token(
    int64_t value_arg) {
  force_resending_token_ = value_arg;
}

const std::string*
PigeonVerifyPhoneNumberRequest::auto_retrieved_sms_code_for_testing() const {
  return auto_retrieved_sms_code_for_testing_
             ? &(*auto_retrieved_sms_code_for_testing_)
             : nullptr;
}

void PigeonVerifyPhoneNumberRequest::set_auto_retrieved_sms_code_for_testing(
    const std::string_view* value_arg) {
  auto_retrieved_sms_code_for_testing_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonVerifyPhoneNumberRequest::set_auto_retrieved_sms_code_for_testing(
    std::string_view value_arg) {
  auto_retrieved_sms_code_for_testing_ = value_arg;
}

const std::string* PigeonVerifyPhoneNumberRequest::multi_factor_info_id()
    const {
  return multi_factor_info_id_ ? &(*multi_factor_info_id_) : nullptr;
}

void PigeonVerifyPhoneNumberRequest::set_multi_factor_info_id(
    const std::string_view* value_arg) {
  multi_factor_info_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonVerifyPhoneNumberRequest::set_multi_factor_info_id(
    std::string_view value_arg) {
  multi_factor_info_id_ = value_arg;
}

const std::string* PigeonVerifyPhoneNumberRequest::multi_factor_session_id()
    const {
  return multi_factor_session_id_ ? &(*multi_factor_session_id_) : nullptr;
}

void PigeonVerifyPhoneNumberRequest::set_multi_factor_session_id(
    const std::string_view* value_arg) {
  multi_factor_session_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonVerifyPhoneNumberRequest::set_multi_factor_session_id(
    std::string_view value_arg) {
  multi_factor_session_id_ = value_arg;
}

EncodableList PigeonVerifyPhoneNumberRequest::ToEncodableList() const {
  EncodableList list;
  list.reserve(6);
  list.push_back(phone_number_ ? EncodableValue(*phone_number_)
                               : EncodableValue());
  list.push_back(EncodableValue(timeout_));
  list.push_back(force_resending_token_
                     ? EncodableValue(*force_resending_token_)
                     : EncodableValue());
  list.push_back(auto_retrieved_sms_code_for_testing_
                     ? EncodableValue(*auto_retrieved_sms_code_for_testing_)
                     : EncodableValue());
  list.push_back(multi_factor_info_id_ ? EncodableValue(*multi_factor_info_id_)
                                       : EncodableValue());
  list.push_back(multi_factor_session_id_
                     ? EncodableValue(*multi_factor_session_id_)
                     : EncodableValue());
  return list;
}

PigeonVerifyPhoneNumberRequest
PigeonVerifyPhoneNumberRequest::FromEncodableList(const EncodableList& list) {
  PigeonVerifyPhoneNumberRequest decoded(list[1].LongValue());
  auto& encodable_phone_number = list[0];
  if (!encodable_phone_number.IsNull()) {
    decoded.set_phone_number(std::get<std::string>(encodable_phone_number));
  }
  auto& encodable_force_resending_token = list[2];
  if (!encodable_force_resending_token.IsNull()) {
    decoded.set_force_resending_token(
        encodable_force_resending_token.LongValue());
  }
  auto& encodable_auto_retrieved_sms_code_for_testing = list[3];
  if (!encodable_auto_retrieved_sms_code_for_testing.IsNull()) {
    decoded.set_auto_retrieved_sms_code_for_testing(
        std::get<std::string>(encodable_auto_retrieved_sms_code_for_testing));
  }
  auto& encodable_multi_factor_info_id = list[4];
  if (!encodable_multi_factor_info_id.IsNull()) {
    decoded.set_multi_factor_info_id(
        std::get<std::string>(encodable_multi_factor_info_id));
  }
  auto& encodable_multi_factor_session_id = list[5];
  if (!encodable_multi_factor_session_id.IsNull()) {
    decoded.set_multi_factor_session_id(
        std::get<std::string>(encodable_multi_factor_session_id));
  }
  return decoded;
}

// PigeonIdTokenResult

PigeonIdTokenResult::PigeonIdTokenResult() {}

PigeonIdTokenResult::PigeonIdTokenResult(
    const std::string* token, const int64_t* expiration_timestamp,
    const int64_t* auth_timestamp, const int64_t* issued_at_timestamp,
    const std::string* sign_in_provider, const EncodableMap* claims,
    const std::string* sign_in_second_factor)
    : token_(token ? std::optional<std::string>(*token) : std::nullopt),
      expiration_timestamp_(expiration_timestamp
                                ? std::optional<int64_t>(*expiration_timestamp)
                                : std::nullopt),
      auth_timestamp_(auth_timestamp ? std::optional<int64_t>(*auth_timestamp)
                                     : std::nullopt),
      issued_at_timestamp_(issued_at_timestamp
                               ? std::optional<int64_t>(*issued_at_timestamp)
                               : std::nullopt),
      sign_in_provider_(sign_in_provider
                            ? std::optional<std::string>(*sign_in_provider)
                            : std::nullopt),
      claims_(claims ? std::optional<EncodableMap>(*claims) : std::nullopt),
      sign_in_second_factor_(sign_in_second_factor ? std::optional<std::string>(
                                                         *sign_in_second_factor)
                                                   : std::nullopt) {}

const std::string* PigeonIdTokenResult::token() const {
  return token_ ? &(*token_) : nullptr;
}

void PigeonIdTokenResult::set_token(const std::string_view* value_arg) {
  token_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_token(std::string_view value_arg) {
  token_ = value_arg;
}

const int64_t* PigeonIdTokenResult::expiration_timestamp() const {
  return expiration_timestamp_ ? &(*expiration_timestamp_) : nullptr;
}

void PigeonIdTokenResult::set_expiration_timestamp(const int64_t* value_arg) {
  expiration_timestamp_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_expiration_timestamp(int64_t value_arg) {
  expiration_timestamp_ = value_arg;
}

const int64_t* PigeonIdTokenResult::auth_timestamp() const {
  return auth_timestamp_ ? &(*auth_timestamp_) : nullptr;
}

void PigeonIdTokenResult::set_auth_timestamp(const int64_t* value_arg) {
  auth_timestamp_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_auth_timestamp(int64_t value_arg) {
  auth_timestamp_ = value_arg;
}

const int64_t* PigeonIdTokenResult::issued_at_timestamp() const {
  return issued_at_timestamp_ ? &(*issued_at_timestamp_) : nullptr;
}

void PigeonIdTokenResult::set_issued_at_timestamp(const int64_t* value_arg) {
  issued_at_timestamp_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_issued_at_timestamp(int64_t value_arg) {
  issued_at_timestamp_ = value_arg;
}

const std::string* PigeonIdTokenResult::sign_in_provider() const {
  return sign_in_provider_ ? &(*sign_in_provider_) : nullptr;
}

void PigeonIdTokenResult::set_sign_in_provider(
    const std::string_view* value_arg) {
  sign_in_provider_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_sign_in_provider(std::string_view value_arg) {
  sign_in_provider_ = value_arg;
}

const EncodableMap* PigeonIdTokenResult::claims() const {
  return claims_ ? &(*claims_) : nullptr;
}

void PigeonIdTokenResult::set_claims(const EncodableMap* value_arg) {
  claims_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_claims(const EncodableMap& value_arg) {
  claims_ = value_arg;
}

const std::string* PigeonIdTokenResult::sign_in_second_factor() const {
  return sign_in_second_factor_ ? &(*sign_in_second_factor_) : nullptr;
}

void PigeonIdTokenResult::set_sign_in_second_factor(
    const std::string_view* value_arg) {
  sign_in_second_factor_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonIdTokenResult::set_sign_in_second_factor(
    std::string_view value_arg) {
  sign_in_second_factor_ = value_arg;
}

EncodableList PigeonIdTokenResult::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(token_ ? EncodableValue(*token_) : EncodableValue());
  list.push_back(expiration_timestamp_ ? EncodableValue(*expiration_timestamp_)
                                       : EncodableValue());
  list.push_back(auth_timestamp_ ? EncodableValue(*auth_timestamp_)
                                 : EncodableValue());
  list.push_back(issued_at_timestamp_ ? EncodableValue(*issued_at_timestamp_)
                                      : EncodableValue());
  list.push_back(sign_in_provider_ ? EncodableValue(*sign_in_provider_)
                                   : EncodableValue());
  list.push_back(claims_ ? EncodableValue(*claims_) : EncodableValue());
  list.push_back(sign_in_second_factor_
                     ? EncodableValue(*sign_in_second_factor_)
                     : EncodableValue());
  return list;
}

PigeonIdTokenResult PigeonIdTokenResult::FromEncodableList(
    const EncodableList& list) {
  PigeonIdTokenResult decoded;
  auto& encodable_token = list[0];
  if (!encodable_token.IsNull()) {
    decoded.set_token(std::get<std::string>(encodable_token));
  }
  auto& encodable_expiration_timestamp = list[1];
  if (!encodable_expiration_timestamp.IsNull()) {
    decoded.set_expiration_timestamp(
        encodable_expiration_timestamp.LongValue());
  }
  auto& encodable_auth_timestamp = list[2];
  if (!encodable_auth_timestamp.IsNull()) {
    decoded.set_auth_timestamp(encodable_auth_timestamp.LongValue());
  }
  auto& encodable_issued_at_timestamp = list[3];
  if (!encodable_issued_at_timestamp.IsNull()) {
    decoded.set_issued_at_timestamp(encodable_issued_at_timestamp.LongValue());
  }
  auto& encodable_sign_in_provider = list[4];
  if (!encodable_sign_in_provider.IsNull()) {
    decoded.set_sign_in_provider(
        std::get<std::string>(encodable_sign_in_provider));
  }
  auto& encodable_claims = list[5];
  if (!encodable_claims.IsNull()) {
    decoded.set_claims(std::get<EncodableMap>(encodable_claims));
  }
  auto& encodable_sign_in_second_factor = list[6];
  if (!encodable_sign_in_second_factor.IsNull()) {
    decoded.set_sign_in_second_factor(
        std::get<std::string>(encodable_sign_in_second_factor));
  }
  return decoded;
}

// PigeonUserProfile

PigeonUserProfile::PigeonUserProfile(bool display_name_changed,
                                     bool photo_url_changed)
    : display_name_changed_(display_name_changed),
      photo_url_changed_(photo_url_changed) {}

PigeonUserProfile::PigeonUserProfile(const std::string* display_name,
                                     const std::string* photo_url,
                                     bool display_name_changed,
                                     bool photo_url_changed)
    : display_name_(display_name ? std::optional<std::string>(*display_name)
                                 : std::nullopt),
      photo_url_(photo_url ? std::optional<std::string>(*photo_url)
                           : std::nullopt),
      display_name_changed_(display_name_changed),
      photo_url_changed_(photo_url_changed) {}

const std::string* PigeonUserProfile::display_name() const {
  return display_name_ ? &(*display_name_) : nullptr;
}

void PigeonUserProfile::set_display_name(const std::string_view* value_arg) {
  display_name_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserProfile::set_display_name(std::string_view value_arg) {
  display_name_ = value_arg;
}

const std::string* PigeonUserProfile::photo_url() const {
  return photo_url_ ? &(*photo_url_) : nullptr;
}

void PigeonUserProfile::set_photo_url(const std::string_view* value_arg) {
  photo_url_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonUserProfile::set_photo_url(std::string_view value_arg) {
  photo_url_ = value_arg;
}

bool PigeonUserProfile::display_name_changed() const {
  return display_name_changed_;
}

void PigeonUserProfile::set_display_name_changed(bool value_arg) {
  display_name_changed_ = value_arg;
}

bool PigeonUserProfile::photo_url_changed() const { return photo_url_changed_; }

void PigeonUserProfile::set_photo_url_changed(bool value_arg) {
  photo_url_changed_ = value_arg;
}

EncodableList PigeonUserProfile::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(display_name_ ? EncodableValue(*display_name_)
                               : EncodableValue());
  list.push_back(photo_url_ ? EncodableValue(*photo_url_) : EncodableValue());
  list.push_back(EncodableValue(display_name_changed_));
  list.push_back(EncodableValue(photo_url_changed_));
  return list;
}

PigeonUserProfile PigeonUserProfile::FromEncodableList(
    const EncodableList& list) {
  PigeonUserProfile decoded(std::get<bool>(list[2]), std::get<bool>(list[3]));
  auto& encodable_display_name = list[0];
  if (!encodable_display_name.IsNull()) {
    decoded.set_display_name(std::get<std::string>(encodable_display_name));
  }
  auto& encodable_photo_url = list[1];
  if (!encodable_photo_url.IsNull()) {
    decoded.set_photo_url(std::get<std::string>(encodable_photo_url));
  }
  return decoded;
}

// PigeonTotpSecret

PigeonTotpSecret::PigeonTotpSecret(const std::string& secret_key)
    : secret_key_(secret_key) {}

PigeonTotpSecret::PigeonTotpSecret(
    const int64_t* code_interval_seconds, const int64_t* code_length,
    const int64_t* enrollment_completion_deadline,
    const std::string* hashing_algorithm, const std::string& secret_key)
    : code_interval_seconds_(
          code_interval_seconds ? std::optional<int64_t>(*code_interval_seconds)
                                : std::nullopt),
      code_length_(code_length ? std::optional<int64_t>(*code_length)
                               : std::nullopt),
      enrollment_completion_deadline_(
          enrollment_completion_deadline
              ? std::optional<int64_t>(*enrollment_completion_deadline)
              : std::nullopt),
      hashing_algorithm_(hashing_algorithm
                             ? std::optional<std::string>(*hashing_algorithm)
                             : std::nullopt),
      secret_key_(secret_key) {}

const int64_t* PigeonTotpSecret::code_interval_seconds() const {
  return code_interval_seconds_ ? &(*code_interval_seconds_) : nullptr;
}

void PigeonTotpSecret::set_code_interval_seconds(const int64_t* value_arg) {
  code_interval_seconds_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonTotpSecret::set_code_interval_seconds(int64_t value_arg) {
  code_interval_seconds_ = value_arg;
}

const int64_t* PigeonTotpSecret::code_length() const {
  return code_length_ ? &(*code_length_) : nullptr;
}

void PigeonTotpSecret::set_code_length(const int64_t* value_arg) {
  code_length_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonTotpSecret::set_code_length(int64_t value_arg) {
  code_length_ = value_arg;
}

const int64_t* PigeonTotpSecret::enrollment_completion_deadline() const {
  return enrollment_completion_deadline_ ? &(*enrollment_completion_deadline_)
                                         : nullptr;
}

void PigeonTotpSecret::set_enrollment_completion_deadline(
    const int64_t* value_arg) {
  enrollment_completion_deadline_ =
      value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PigeonTotpSecret::set_enrollment_completion_deadline(int64_t value_arg) {
  enrollment_completion_deadline_ = value_arg;
}

const std::string* PigeonTotpSecret::hashing_algorithm() const {
  return hashing_algorithm_ ? &(*hashing_algorithm_) : nullptr;
}

void PigeonTotpSecret::set_hashing_algorithm(
    const std::string_view* value_arg) {
  hashing_algorithm_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PigeonTotpSecret::set_hashing_algorithm(std::string_view value_arg) {
  hashing_algorithm_ = value_arg;
}

const std::string& PigeonTotpSecret::secret_key() const { return secret_key_; }

void PigeonTotpSecret::set_secret_key(std::string_view value_arg) {
  secret_key_ = value_arg;
}

EncodableList PigeonTotpSecret::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(code_interval_seconds_
                     ? EncodableValue(*code_interval_seconds_)
                     : EncodableValue());
  list.push_back(code_length_ ? EncodableValue(*code_length_)
                              : EncodableValue());
  list.push_back(enrollment_completion_deadline_
                     ? EncodableValue(*enrollment_completion_deadline_)
                     : EncodableValue());
  list.push_back(hashing_algorithm_ ? EncodableValue(*hashing_algorithm_)
                                    : EncodableValue());
  list.push_back(EncodableValue(secret_key_));
  return list;
}

PigeonTotpSecret PigeonTotpSecret::FromEncodableList(
    const EncodableList& list) {
  PigeonTotpSecret decoded(std::get<std::string>(list[4]));
  auto& encodable_code_interval_seconds = list[0];
  if (!encodable_code_interval_seconds.IsNull()) {
    decoded.set_code_interval_seconds(
        encodable_code_interval_seconds.LongValue());
  }
  auto& encodable_code_length = list[1];
  if (!encodable_code_length.IsNull()) {
    decoded.set_code_length(encodable_code_length.LongValue());
  }
  auto& encodable_enrollment_completion_deadline = list[2];
  if (!encodable_enrollment_completion_deadline.IsNull()) {
    decoded.set_enrollment_completion_deadline(
        encodable_enrollment_completion_deadline.LongValue());
  }
  auto& encodable_hashing_algorithm = list[3];
  if (!encodable_hashing_algorithm.IsNull()) {
    decoded.set_hashing_algorithm(
        std::get<std::string>(encodable_hashing_algorithm));
  }
  return decoded;
}

FirebaseAuthHostApiCodecSerializer::FirebaseAuthHostApiCodecSerializer() {}

EncodableValue FirebaseAuthHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AuthPigeonFirebaseApp::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(PigeonActionCodeInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(PigeonActionCodeInfoData::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(PigeonActionCodeSettings::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(PigeonAdditionalUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(PigeonAuthCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(PigeonFirebaseAuthSettings::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(PigeonIdTokenResult::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(PigeonMultiFactorInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(PigeonMultiFactorSession::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(
          PigeonPhoneMultiFactorAssertion::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(PigeonSignInProvider::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(PigeonTotpSecret::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 141:
      return CustomEncodableValue(PigeonUserCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 142:
      return CustomEncodableValue(PigeonUserDetails::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 143:
      return CustomEncodableValue(PigeonUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 144:
      return CustomEncodableValue(PigeonUserProfile::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 145:
      return CustomEncodableValue(
          PigeonVerifyPhoneNumberRequest::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void FirebaseAuthHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AuthPigeonFirebaseApp)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(std::any_cast<AuthPigeonFirebaseApp>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeInfo)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeInfoData)) {
      stream->WriteByte(130);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeInfoData>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeSettings)) {
      stream->WriteByte(131);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeSettings>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonAdditionalUserInfo)) {
      stream->WriteByte(132);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAdditionalUserInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonAuthCredential)) {
      stream->WriteByte(133);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAuthCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonFirebaseAuthSettings)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(
                     std::any_cast<PigeonFirebaseAuthSettings>(*custom_value)
                         .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonIdTokenResult)) {
      stream->WriteByte(135);
      WriteValue(
          EncodableValue(std::any_cast<PigeonIdTokenResult>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorInfo)) {
      stream->WriteByte(136);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorSession)) {
      stream->WriteByte(137);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorSession>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonPhoneMultiFactorAssertion)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<PigeonPhoneMultiFactorAssertion>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonSignInProvider)) {
      stream->WriteByte(139);
      WriteValue(
          EncodableValue(std::any_cast<PigeonSignInProvider>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonTotpSecret)) {
      stream->WriteByte(140);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonTotpSecret>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserCredential)) {
      stream->WriteByte(141);
      WriteValue(
          EncodableValue(std::any_cast<PigeonUserCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserDetails)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<PigeonUserDetails>(*custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserInfo)) {
      stream->WriteByte(143);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonUserInfo>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserProfile)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<PigeonUserProfile>(*custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonVerifyPhoneNumberRequest)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<PigeonVerifyPhoneNumberRequest>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by FirebaseAuthHostApi.
const flutter::StandardMessageCodec& FirebaseAuthHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &FirebaseAuthHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `FirebaseAuthHostApi` to handle messages through the
// `binary_messenger`.
void FirebaseAuthHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                FirebaseAuthHostApi* api) {
  FirebaseAuthHostApi::SetUp(binary_messenger, api, "");
}

void FirebaseAuthHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                FirebaseAuthHostApi* api,
                                const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.registerIdTokenListener" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->RegisterIdTokenListener(
                  app_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.registerAuthStateListener" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->RegisterAuthStateListener(
                  app_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthHostApi.useEmulator" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_host_arg = args.at(1);
              if (encodable_host_arg.IsNull()) {
                reply(WrapError("host_arg unexpectedly null."));
                return;
              }
              const auto& host_arg = std::get<std::string>(encodable_host_arg);
              const auto& encodable_port_arg = args.at(2);
              if (encodable_port_arg.IsNull()) {
                reply(WrapError("port_arg unexpectedly null."));
                return;
              }
              const int64_t port_arg = encodable_port_arg.LongValue();
              api->UseEmulator(app_arg, host_arg, port_arg,
                               [reply](std::optional<FlutterError>&& output) {
                                 if (output.has_value()) {
                                   reply(WrapError(output.value()));
                                   return;
                                 }
                                 EncodableList wrapped;
                                 wrapped.push_back(EncodableValue());
                                 reply(EncodableValue(std::move(wrapped)));
                               });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.applyActionCode" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_code_arg = args.at(1);
              if (encodable_code_arg.IsNull()) {
                reply(WrapError("code_arg unexpectedly null."));
                return;
              }
              const auto& code_arg = std::get<std::string>(encodable_code_arg);
              api->ApplyActionCode(
                  app_arg, code_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.checkActionCode" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_code_arg = args.at(1);
              if (encodable_code_arg.IsNull()) {
                reply(WrapError("code_arg unexpectedly null."));
                return;
              }
              const auto& code_arg = std::get<std::string>(encodable_code_arg);
              api->CheckActionCode(
                  app_arg, code_arg,
                  [reply](ErrorOr<PigeonActionCodeInfo>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.confirmPasswordReset" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_code_arg = args.at(1);
              if (encodable_code_arg.IsNull()) {
                reply(WrapError("code_arg unexpectedly null."));
                return;
              }
              const auto& code_arg = std::get<std::string>(encodable_code_arg);
              const auto& encodable_new_password_arg = args.at(2);
              if (encodable_new_password_arg.IsNull()) {
                reply(WrapError("new_password_arg unexpectedly null."));
                return;
              }
              const auto& new_password_arg =
                  std::get<std::string>(encodable_new_password_arg);
              api->ConfirmPasswordReset(
                  app_arg, code_arg, new_password_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.createUserWithEmailAndPassword" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              const auto& encodable_password_arg = args.at(2);
              if (encodable_password_arg.IsNull()) {
                reply(WrapError("password_arg unexpectedly null."));
                return;
              }
              const auto& password_arg =
                  std::get<std::string>(encodable_password_arg);
              api->CreateUserWithEmailAndPassword(
                  app_arg, email_arg, password_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInAnonymously" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->SignInAnonymously(
                  app_arg, [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInWithCredential" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_input_arg = args.at(1);
              if (encodable_input_arg.IsNull()) {
                reply(WrapError("input_arg unexpectedly null."));
                return;
              }
              const auto& input_arg =
                  std::get<EncodableMap>(encodable_input_arg);
              api->SignInWithCredential(
                  app_arg, input_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInWithCustomToken" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_token_arg = args.at(1);
              if (encodable_token_arg.IsNull()) {
                reply(WrapError("token_arg unexpectedly null."));
                return;
              }
              const auto& token_arg =
                  std::get<std::string>(encodable_token_arg);
              api->SignInWithCustomToken(
                  app_arg, token_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInWithEmailAndPassword" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              const auto& encodable_password_arg = args.at(2);
              if (encodable_password_arg.IsNull()) {
                reply(WrapError("password_arg unexpectedly null."));
                return;
              }
              const auto& password_arg =
                  std::get<std::string>(encodable_password_arg);
              api->SignInWithEmailAndPassword(
                  app_arg, email_arg, password_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInWithEmailLink" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              const auto& encodable_email_link_arg = args.at(2);
              if (encodable_email_link_arg.IsNull()) {
                reply(WrapError("email_link_arg unexpectedly null."));
                return;
              }
              const auto& email_link_arg =
                  std::get<std::string>(encodable_email_link_arg);
              api->SignInWithEmailLink(
                  app_arg, email_arg, email_link_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.signInWithProvider" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_sign_in_provider_arg = args.at(1);
              if (encodable_sign_in_provider_arg.IsNull()) {
                reply(WrapError("sign_in_provider_arg unexpectedly null."));
                return;
              }
              const auto& sign_in_provider_arg =
                  std::any_cast<const PigeonSignInProvider&>(
                      std::get<CustomEncodableValue>(
                          encodable_sign_in_provider_arg));
              api->SignInWithProvider(
                  app_arg, sign_in_provider_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthHostApi.signOut" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->SignOut(app_arg,
                           [reply](std::optional<FlutterError>&& output) {
                             if (output.has_value()) {
                               reply(WrapError(output.value()));
                               return;
                             }
                             EncodableList wrapped;
                             wrapped.push_back(EncodableValue());
                             reply(EncodableValue(std::move(wrapped)));
                           });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.fetchSignInMethodsForEmail" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              api->FetchSignInMethodsForEmail(
                  app_arg, email_arg, [reply](ErrorOr<EncodableList>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.sendPasswordResetEmail" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              const auto& encodable_action_code_settings_arg = args.at(2);
              // IF CODE REGENERATED, PLEASE REINSERT THIS. IF ARG IS NULL, APP
              // CRASHES
              const PigeonActionCodeSettings* action_code_settings_arg =
                  nullptr;
              if (!encodable_action_code_settings_arg.IsNull()) {
                action_code_settings_arg =
                    &(std::any_cast<const PigeonActionCodeSettings&>(
                        std::get<CustomEncodableValue>(
                            encodable_action_code_settings_arg)));
              }
              api->SendPasswordResetEmail(
                  app_arg, email_arg, action_code_settings_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.sendSignInLinkToEmail" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_email_arg = args.at(1);
              if (encodable_email_arg.IsNull()) {
                reply(WrapError("email_arg unexpectedly null."));
                return;
              }
              const auto& email_arg =
                  std::get<std::string>(encodable_email_arg);
              const auto& encodable_action_code_settings_arg = args.at(2);
              if (encodable_action_code_settings_arg.IsNull()) {
                reply(WrapError("action_code_settings_arg unexpectedly null."));
                return;
              }
              const auto& action_code_settings_arg =
                  std::any_cast<const PigeonActionCodeSettings&>(
                      std::get<CustomEncodableValue>(
                          encodable_action_code_settings_arg));
              api->SendSignInLinkToEmail(
                  app_arg, email_arg, action_code_settings_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.setLanguageCode" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_language_code_arg = args.at(1);
              const auto* language_code_arg =
                  std::get_if<std::string>(&encodable_language_code_arg);
              api->SetLanguageCode(app_arg, language_code_arg,
                                   [reply](ErrorOr<std::string>&& output) {
                                     if (output.has_error()) {
                                       reply(WrapError(output.error()));
                                       return;
                                     }
                                     EncodableList wrapped;
                                     wrapped.push_back(EncodableValue(
                                         std::move(output).TakeValue()));
                                     reply(EncodableValue(std::move(wrapped)));
                                   });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthHostApi.setSettings" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_settings_arg = args.at(1);
              if (encodable_settings_arg.IsNull()) {
                reply(WrapError("settings_arg unexpectedly null."));
                return;
              }
              const auto& settings_arg =
                  std::any_cast<const PigeonFirebaseAuthSettings&>(
                      std::get<CustomEncodableValue>(encodable_settings_arg));
              api->SetSettings(app_arg, settings_arg,
                               [reply](std::optional<FlutterError>&& output) {
                                 if (output.has_value()) {
                                   reply(WrapError(output.value()));
                                   return;
                                 }
                                 EncodableList wrapped;
                                 wrapped.push_back(EncodableValue());
                                 reply(EncodableValue(std::move(wrapped)));
                               });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.verifyPasswordResetCode" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_code_arg = args.at(1);
              if (encodable_code_arg.IsNull()) {
                reply(WrapError("code_arg unexpectedly null."));
                return;
              }
              const auto& code_arg = std::get<std::string>(encodable_code_arg);
              api->VerifyPasswordResetCode(
                  app_arg, code_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.verifyPhoneNumber" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_request_arg = args.at(1);
              if (encodable_request_arg.IsNull()) {
                reply(WrapError("request_arg unexpectedly null."));
                return;
              }
              const auto& request_arg =
                  std::any_cast<const PigeonVerifyPhoneNumberRequest&>(
                      std::get<CustomEncodableValue>(encodable_request_arg));
              api->VerifyPhoneNumber(
                  app_arg, request_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthHostApi.revokeTokenWithAuthorizationCode" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_authorization_code_arg = args.at(1);
              if (encodable_authorization_code_arg.IsNull()) {
                reply(WrapError("authorization_code_arg unexpectedly null."));
                return;
              }
              const auto& authorization_code_arg =
                  std::get<std::string>(encodable_authorization_code_arg);
              api->RevokeTokenWithAuthorizationCode(
                  app_arg, authorization_code_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue FirebaseAuthHostApi::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue FirebaseAuthHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

FirebaseAuthUserHostApiCodecSerializer::
    FirebaseAuthUserHostApiCodecSerializer() {}

EncodableValue FirebaseAuthUserHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AuthPigeonFirebaseApp::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(PigeonActionCodeInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(PigeonActionCodeInfoData::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(PigeonActionCodeSettings::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(PigeonAdditionalUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(PigeonAuthCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(PigeonFirebaseAuthSettings::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(PigeonIdTokenResult::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(PigeonMultiFactorInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(PigeonMultiFactorSession::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(
          PigeonPhoneMultiFactorAssertion::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(PigeonSignInProvider::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(PigeonTotpSecret::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 141:
      return CustomEncodableValue(PigeonUserCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 142:
      return CustomEncodableValue(PigeonUserDetails::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 143:
      return CustomEncodableValue(PigeonUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 144:
      return CustomEncodableValue(PigeonUserProfile::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 145:
      return CustomEncodableValue(
          PigeonVerifyPhoneNumberRequest::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void FirebaseAuthUserHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AuthPigeonFirebaseApp)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(std::any_cast<AuthPigeonFirebaseApp>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeInfo)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeInfoData)) {
      stream->WriteByte(130);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeInfoData>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonActionCodeSettings)) {
      stream->WriteByte(131);
      WriteValue(
          EncodableValue(std::any_cast<PigeonActionCodeSettings>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonAdditionalUserInfo)) {
      stream->WriteByte(132);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAdditionalUserInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonAuthCredential)) {
      stream->WriteByte(133);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAuthCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonFirebaseAuthSettings)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(
                     std::any_cast<PigeonFirebaseAuthSettings>(*custom_value)
                         .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonIdTokenResult)) {
      stream->WriteByte(135);
      WriteValue(
          EncodableValue(std::any_cast<PigeonIdTokenResult>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorInfo)) {
      stream->WriteByte(136);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorSession)) {
      stream->WriteByte(137);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorSession>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonPhoneMultiFactorAssertion)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<PigeonPhoneMultiFactorAssertion>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonSignInProvider)) {
      stream->WriteByte(139);
      WriteValue(
          EncodableValue(std::any_cast<PigeonSignInProvider>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonTotpSecret)) {
      stream->WriteByte(140);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonTotpSecret>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserCredential)) {
      stream->WriteByte(141);
      WriteValue(
          EncodableValue(std::any_cast<PigeonUserCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserDetails)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<PigeonUserDetails>(*custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserInfo)) {
      stream->WriteByte(143);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonUserInfo>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserProfile)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<PigeonUserProfile>(*custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonVerifyPhoneNumberRequest)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<PigeonVerifyPhoneNumberRequest>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by FirebaseAuthUserHostApi.
const flutter::StandardMessageCodec& FirebaseAuthUserHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &FirebaseAuthUserHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `FirebaseAuthUserHostApi` to handle messages through
// the `binary_messenger`.
void FirebaseAuthUserHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                    FirebaseAuthUserHostApi* api) {
  FirebaseAuthUserHostApi::SetUp(binary_messenger, api, "");
}

void FirebaseAuthUserHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                    FirebaseAuthUserHostApi* api,
                                    const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthUserHostApi.delete" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->Delete(app_arg,
                          [reply](std::optional<FlutterError>&& output) {
                            if (output.has_value()) {
                              reply(WrapError(output.value()));
                              return;
                            }
                            EncodableList wrapped;
                            wrapped.push_back(EncodableValue());
                            reply(EncodableValue(std::move(wrapped)));
                          });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.getIdToken" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_force_refresh_arg = args.at(1);
              if (encodable_force_refresh_arg.IsNull()) {
                reply(WrapError("force_refresh_arg unexpectedly null."));
                return;
              }
              const auto& force_refresh_arg =
                  std::get<bool>(encodable_force_refresh_arg);
              api->GetIdToken(app_arg, force_refresh_arg,
                              [reply](ErrorOr<PigeonIdTokenResult>&& output) {
                                if (output.has_error()) {
                                  reply(WrapError(output.error()));
                                  return;
                                }
                                EncodableList wrapped;
                                wrapped.push_back(CustomEncodableValue(
                                    std::move(output).TakeValue()));
                                reply(EncodableValue(std::move(wrapped)));
                              });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.linkWithCredential" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_input_arg = args.at(1);
              if (encodable_input_arg.IsNull()) {
                reply(WrapError("input_arg unexpectedly null."));
                return;
              }
              const auto& input_arg =
                  std::get<EncodableMap>(encodable_input_arg);
              api->LinkWithCredential(
                  app_arg, input_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.linkWithProvider" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_sign_in_provider_arg = args.at(1);
              if (encodable_sign_in_provider_arg.IsNull()) {
                reply(WrapError("sign_in_provider_arg unexpectedly null."));
                return;
              }
              const auto& sign_in_provider_arg =
                  std::any_cast<const PigeonSignInProvider&>(
                      std::get<CustomEncodableValue>(
                          encodable_sign_in_provider_arg));
              api->LinkWithProvider(
                  app_arg, sign_in_provider_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.reauthenticateWithCredential" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_input_arg = args.at(1);
              if (encodable_input_arg.IsNull()) {
                reply(WrapError("input_arg unexpectedly null."));
                return;
              }
              const auto& input_arg =
                  std::get<EncodableMap>(encodable_input_arg);
              api->ReauthenticateWithCredential(
                  app_arg, input_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.reauthenticateWithProvider" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_sign_in_provider_arg = args.at(1);
              if (encodable_sign_in_provider_arg.IsNull()) {
                reply(WrapError("sign_in_provider_arg unexpectedly null."));
                return;
              }
              const auto& sign_in_provider_arg =
                  std::any_cast<const PigeonSignInProvider&>(
                      std::get<CustomEncodableValue>(
                          encodable_sign_in_provider_arg));
              api->ReauthenticateWithProvider(
                  app_arg, sign_in_provider_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthUserHostApi.reload" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->Reload(
                  app_arg, [reply](ErrorOr<PigeonUserDetails>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.sendEmailVerification" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_action_code_settings_arg = args.at(1);
              // IF CODE REGENERATED, PLEASE REINSERT THIS. IF ARG IS NULL, APP
              // CRASHES
              const PigeonActionCodeSettings* action_code_settings_arg =
                  nullptr;
              if (!encodable_action_code_settings_arg.IsNull()) {
                action_code_settings_arg =
                    &(std::any_cast<const PigeonActionCodeSettings&>(
                        std::get<CustomEncodableValue>(
                            encodable_action_code_settings_arg)));
              }
              api->SendEmailVerification(
                  app_arg, action_code_settings_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.FirebaseAuthUserHostApi.unlink" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_provider_id_arg = args.at(1);
              if (encodable_provider_id_arg.IsNull()) {
                reply(WrapError("provider_id_arg unexpectedly null."));
                return;
              }
              const auto& provider_id_arg =
                  std::get<std::string>(encodable_provider_id_arg);
              api->Unlink(app_arg, provider_id_arg,
                          [reply](ErrorOr<PigeonUserCredential>&& output) {
                            if (output.has_error()) {
                              reply(WrapError(output.error()));
                              return;
                            }
                            EncodableList wrapped;
                            wrapped.push_back(CustomEncodableValue(
                                std::move(output).TakeValue()));
                            reply(EncodableValue(std::move(wrapped)));
                          });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.updateEmail" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_new_email_arg = args.at(1);
              if (encodable_new_email_arg.IsNull()) {
                reply(WrapError("new_email_arg unexpectedly null."));
                return;
              }
              const auto& new_email_arg =
                  std::get<std::string>(encodable_new_email_arg);
              api->UpdateEmail(app_arg, new_email_arg,
                               [reply](ErrorOr<PigeonUserDetails>&& output) {
                                 if (output.has_error()) {
                                   reply(WrapError(output.error()));
                                   return;
                                 }
                                 EncodableList wrapped;
                                 wrapped.push_back(CustomEncodableValue(
                                     std::move(output).TakeValue()));
                                 reply(EncodableValue(std::move(wrapped)));
                               });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.updatePassword" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_new_password_arg = args.at(1);
              if (encodable_new_password_arg.IsNull()) {
                reply(WrapError("new_password_arg unexpectedly null."));
                return;
              }
              const auto& new_password_arg =
                  std::get<std::string>(encodable_new_password_arg);
              api->UpdatePassword(app_arg, new_password_arg,
                                  [reply](ErrorOr<PigeonUserDetails>&& output) {
                                    if (output.has_error()) {
                                      reply(WrapError(output.error()));
                                      return;
                                    }
                                    EncodableList wrapped;
                                    wrapped.push_back(CustomEncodableValue(
                                        std::move(output).TakeValue()));
                                    reply(EncodableValue(std::move(wrapped)));
                                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.updatePhoneNumber" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_input_arg = args.at(1);
              if (encodable_input_arg.IsNull()) {
                reply(WrapError("input_arg unexpectedly null."));
                return;
              }
              const auto& input_arg =
                  std::get<EncodableMap>(encodable_input_arg);
              api->UpdatePhoneNumber(
                  app_arg, input_arg,
                  [reply](ErrorOr<PigeonUserDetails>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.updateProfile" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_profile_arg = args.at(1);
              if (encodable_profile_arg.IsNull()) {
                reply(WrapError("profile_arg unexpectedly null."));
                return;
              }
              const auto& profile_arg = std::any_cast<const PigeonUserProfile&>(
                  std::get<CustomEncodableValue>(encodable_profile_arg));
              api->UpdateProfile(app_arg, profile_arg,
                                 [reply](ErrorOr<PigeonUserDetails>&& output) {
                                   if (output.has_error()) {
                                     reply(WrapError(output.error()));
                                     return;
                                   }
                                   EncodableList wrapped;
                                   wrapped.push_back(CustomEncodableValue(
                                       std::move(output).TakeValue()));
                                   reply(EncodableValue(std::move(wrapped)));
                                 });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "FirebaseAuthUserHostApi.verifyBeforeUpdateEmail" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_new_email_arg = args.at(1);
              if (encodable_new_email_arg.IsNull()) {
                reply(WrapError("new_email_arg unexpectedly null."));
                return;
              }
              const auto& new_email_arg =
                  std::get<std::string>(encodable_new_email_arg);
              const auto& encodable_action_code_settings_arg = args.at(2);
              // IF CODE REGENERATED, PLEASE REINSERT THIS. IF ARG IS NULL, APP
              // CRASHES
              const PigeonActionCodeSettings* action_code_settings_arg =
                  nullptr;
              if (!encodable_action_code_settings_arg.IsNull()) {
                action_code_settings_arg =
                    &(std::any_cast<const PigeonActionCodeSettings&>(
                        std::get<CustomEncodableValue>(
                            encodable_action_code_settings_arg)));
              }
              api->VerifyBeforeUpdateEmail(
                  app_arg, new_email_arg, action_code_settings_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue FirebaseAuthUserHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue FirebaseAuthUserHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

MultiFactorUserHostApiCodecSerializer::MultiFactorUserHostApiCodecSerializer() {
}

EncodableValue MultiFactorUserHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AuthPigeonFirebaseApp::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(PigeonMultiFactorInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(PigeonMultiFactorSession::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(
          PigeonPhoneMultiFactorAssertion::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MultiFactorUserHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AuthPigeonFirebaseApp)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(std::any_cast<AuthPigeonFirebaseApp>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorInfo)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonMultiFactorSession)) {
      stream->WriteByte(130);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorSession>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonPhoneMultiFactorAssertion)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<PigeonPhoneMultiFactorAssertion>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by MultiFactorUserHostApi.
const flutter::StandardMessageCodec& MultiFactorUserHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &MultiFactorUserHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `MultiFactorUserHostApi` to handle messages through
// the `binary_messenger`.
void MultiFactorUserHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                   MultiFactorUserHostApi* api) {
  MultiFactorUserHostApi::SetUp(binary_messenger, api, "");
}

void MultiFactorUserHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                   MultiFactorUserHostApi* api,
                                   const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorUserHostApi.enrollPhone" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_assertion_arg = args.at(1);
              if (encodable_assertion_arg.IsNull()) {
                reply(WrapError("assertion_arg unexpectedly null."));
                return;
              }
              const auto& assertion_arg =
                  std::any_cast<const PigeonPhoneMultiFactorAssertion&>(
                      std::get<CustomEncodableValue>(encodable_assertion_arg));
              const auto& encodable_display_name_arg = args.at(2);
              const auto* display_name_arg =
                  std::get_if<std::string>(&encodable_display_name_arg);
              api->EnrollPhone(app_arg, assertion_arg, display_name_arg,
                               [reply](std::optional<FlutterError>&& output) {
                                 if (output.has_value()) {
                                   reply(WrapError(output.value()));
                                   return;
                                 }
                                 EncodableList wrapped;
                                 wrapped.push_back(EncodableValue());
                                 reply(EncodableValue(std::move(wrapped)));
                               });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorUserHostApi.enrollTotp" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_assertion_id_arg = args.at(1);
              if (encodable_assertion_id_arg.IsNull()) {
                reply(WrapError("assertion_id_arg unexpectedly null."));
                return;
              }
              const auto& assertion_id_arg =
                  std::get<std::string>(encodable_assertion_id_arg);
              const auto& encodable_display_name_arg = args.at(2);
              const auto* display_name_arg =
                  std::get_if<std::string>(&encodable_display_name_arg);
              api->EnrollTotp(app_arg, assertion_id_arg, display_name_arg,
                              [reply](std::optional<FlutterError>&& output) {
                                if (output.has_value()) {
                                  reply(WrapError(output.value()));
                                  return;
                                }
                                EncodableList wrapped;
                                wrapped.push_back(EncodableValue());
                                reply(EncodableValue(std::move(wrapped)));
                              });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorUserHostApi.getSession" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->GetSession(
                  app_arg, [reply](ErrorOr<PigeonMultiFactorSession>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_auth_platform_"
                                  "interface.MultiFactorUserHostApi.unenroll" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              const auto& encodable_factor_uid_arg = args.at(1);
              if (encodable_factor_uid_arg.IsNull()) {
                reply(WrapError("factor_uid_arg unexpectedly null."));
                return;
              }
              const auto& factor_uid_arg =
                  std::get<std::string>(encodable_factor_uid_arg);
              api->Unenroll(app_arg, factor_uid_arg,
                            [reply](std::optional<FlutterError>&& output) {
                              if (output.has_value()) {
                                reply(WrapError(output.value()));
                                return;
                              }
                              EncodableList wrapped;
                              wrapped.push_back(EncodableValue());
                              reply(EncodableValue(std::move(wrapped)));
                            });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorUserHostApi.getEnrolledFactors" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_arg = args.at(0);
              if (encodable_app_arg.IsNull()) {
                reply(WrapError("app_arg unexpectedly null."));
                return;
              }
              const auto& app_arg = std::any_cast<const AuthPigeonFirebaseApp&>(
                  std::get<CustomEncodableValue>(encodable_app_arg));
              api->GetEnrolledFactors(
                  app_arg, [reply](ErrorOr<EncodableList>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MultiFactorUserHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue MultiFactorUserHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

MultiFactoResolverHostApiCodecSerializer::
    MultiFactoResolverHostApiCodecSerializer() {}

EncodableValue MultiFactoResolverHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(PigeonAdditionalUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(PigeonAuthCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(
          PigeonPhoneMultiFactorAssertion::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(PigeonUserCredential::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(PigeonUserDetails::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(PigeonUserInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MultiFactoResolverHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(PigeonAdditionalUserInfo)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAdditionalUserInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonAuthCredential)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<PigeonAuthCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonPhoneMultiFactorAssertion)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<PigeonPhoneMultiFactorAssertion>(
                                    *custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserCredential)) {
      stream->WriteByte(131);
      WriteValue(
          EncodableValue(std::any_cast<PigeonUserCredential>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserDetails)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<PigeonUserDetails>(*custom_value)
                                    .ToEncodableList()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonUserInfo)) {
      stream->WriteByte(133);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonUserInfo>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by MultiFactoResolverHostApi.
const flutter::StandardMessageCodec& MultiFactoResolverHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &MultiFactoResolverHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `MultiFactoResolverHostApi` to handle messages through
// the `binary_messenger`.
void MultiFactoResolverHostApi::SetUp(
    flutter::BinaryMessenger* binary_messenger,
    MultiFactoResolverHostApi* api) {
  MultiFactoResolverHostApi::SetUp(binary_messenger, api, "");
}

void MultiFactoResolverHostApi::SetUp(
    flutter::BinaryMessenger* binary_messenger, MultiFactoResolverHostApi* api,
    const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactoResolverHostApi.resolveSignIn" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_resolver_id_arg = args.at(0);
              if (encodable_resolver_id_arg.IsNull()) {
                reply(WrapError("resolver_id_arg unexpectedly null."));
                return;
              }
              const auto& resolver_id_arg =
                  std::get<std::string>(encodable_resolver_id_arg);
              const auto& encodable_assertion_arg = args.at(1);
              const auto* assertion_arg =
                  &(std::any_cast<const PigeonPhoneMultiFactorAssertion&>(
                      std::get<CustomEncodableValue>(encodable_assertion_arg)));
              const auto& encodable_totp_assertion_id_arg = args.at(2);
              const auto* totp_assertion_id_arg =
                  std::get_if<std::string>(&encodable_totp_assertion_id_arg);
              api->ResolveSignIn(
                  resolver_id_arg, assertion_arg, totp_assertion_id_arg,
                  [reply](ErrorOr<PigeonUserCredential>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MultiFactoResolverHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue MultiFactoResolverHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

MultiFactorTotpHostApiCodecSerializer::MultiFactorTotpHostApiCodecSerializer() {
}

EncodableValue MultiFactorTotpHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(PigeonTotpSecret::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MultiFactorTotpHostApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(PigeonTotpSecret)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(
              std::any_cast<PigeonTotpSecret>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by MultiFactorTotpHostApi.
const flutter::StandardMessageCodec& MultiFactorTotpHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &MultiFactorTotpHostApiCodecSerializer::GetInstance());
}

// Sets up an instance of `MultiFactorTotpHostApi` to handle messages through
// the `binary_messenger`.
void MultiFactorTotpHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                   MultiFactorTotpHostApi* api) {
  MultiFactorTotpHostApi::SetUp(binary_messenger, api, "");
}

void MultiFactorTotpHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                   MultiFactorTotpHostApi* api,
                                   const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorTotpHostApi.generateSecret" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_session_id_arg = args.at(0);
              if (encodable_session_id_arg.IsNull()) {
                reply(WrapError("session_id_arg unexpectedly null."));
                return;
              }
              const auto& session_id_arg =
                  std::get<std::string>(encodable_session_id_arg);
              api->GenerateSecret(
                  session_id_arg, [reply](ErrorOr<PigeonTotpSecret>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorTotpHostApi.getAssertionForEnrollment" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_secret_key_arg = args.at(0);
              if (encodable_secret_key_arg.IsNull()) {
                reply(WrapError("secret_key_arg unexpectedly null."));
                return;
              }
              const auto& secret_key_arg =
                  std::get<std::string>(encodable_secret_key_arg);
              const auto& encodable_one_time_password_arg = args.at(1);
              if (encodable_one_time_password_arg.IsNull()) {
                reply(WrapError("one_time_password_arg unexpectedly null."));
                return;
              }
              const auto& one_time_password_arg =
                  std::get<std::string>(encodable_one_time_password_arg);
              api->GetAssertionForEnrollment(
                  secret_key_arg, one_time_password_arg,
                  [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorTotpHostApi.getAssertionForSignIn" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_enrollment_id_arg = args.at(0);
              if (encodable_enrollment_id_arg.IsNull()) {
                reply(WrapError("enrollment_id_arg unexpectedly null."));
                return;
              }
              const auto& enrollment_id_arg =
                  std::get<std::string>(encodable_enrollment_id_arg);
              const auto& encodable_one_time_password_arg = args.at(1);
              if (encodable_one_time_password_arg.IsNull()) {
                reply(WrapError("one_time_password_arg unexpectedly null."));
                return;
              }
              const auto& one_time_password_arg =
                  std::get<std::string>(encodable_one_time_password_arg);
              api->GetAssertionForSignIn(
                  enrollment_id_arg, one_time_password_arg,
                  [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MultiFactorTotpHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue MultiFactorTotpHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

/// The codec used by MultiFactorTotpSecretHostApi.
const flutter::StandardMessageCodec& MultiFactorTotpSecretHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `MultiFactorTotpSecretHostApi` to handle messages
// through the `binary_messenger`.
void MultiFactorTotpSecretHostApi::SetUp(
    flutter::BinaryMessenger* binary_messenger,
    MultiFactorTotpSecretHostApi* api) {
  MultiFactorTotpSecretHostApi::SetUp(binary_messenger, api, "");
}

void MultiFactorTotpSecretHostApi::SetUp(
    flutter::BinaryMessenger* binary_messenger,
    MultiFactorTotpSecretHostApi* api,
    const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorTotpSecretHostApi.generateQrCodeUrl" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_secret_key_arg = args.at(0);
              if (encodable_secret_key_arg.IsNull()) {
                reply(WrapError("secret_key_arg unexpectedly null."));
                return;
              }
              const auto& secret_key_arg =
                  std::get<std::string>(encodable_secret_key_arg);
              const auto& encodable_account_name_arg = args.at(1);
              const auto* account_name_arg =
                  std::get_if<std::string>(&encodable_account_name_arg);
              const auto& encodable_issuer_arg = args.at(2);
              const auto* issuer_arg =
                  std::get_if<std::string>(&encodable_issuer_arg);
              api->GenerateQrCodeUrl(
                  secret_key_arg, account_name_arg, issuer_arg,
                  [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "MultiFactorTotpSecretHostApi.openInOtpApp" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_secret_key_arg = args.at(0);
              if (encodable_secret_key_arg.IsNull()) {
                reply(WrapError("secret_key_arg unexpectedly null."));
                return;
              }
              const auto& secret_key_arg =
                  std::get<std::string>(encodable_secret_key_arg);
              const auto& encodable_qr_code_url_arg = args.at(1);
              if (encodable_qr_code_url_arg.IsNull()) {
                reply(WrapError("qr_code_url_arg unexpectedly null."));
                return;
              }
              const auto& qr_code_url_arg =
                  std::get<std::string>(encodable_qr_code_url_arg);
              api->OpenInOtpApp(secret_key_arg, qr_code_url_arg,
                                [reply](std::optional<FlutterError>&& output) {
                                  if (output.has_value()) {
                                    reply(WrapError(output.value()));
                                    return;
                                  }
                                  EncodableList wrapped;
                                  wrapped.push_back(EncodableValue());
                                  reply(EncodableValue(std::move(wrapped)));
                                });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MultiFactorTotpSecretHostApi::WrapError(
    std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue MultiFactorTotpSecretHostApi::WrapError(
    const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

GenerateInterfacesCodecSerializer::GenerateInterfacesCodecSerializer() {}

EncodableValue GenerateInterfacesCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(PigeonMultiFactorInfo::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void GenerateInterfacesCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(PigeonMultiFactorInfo)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(std::any_cast<PigeonMultiFactorInfo>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by GenerateInterfaces.
const flutter::StandardMessageCodec& GenerateInterfaces::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &GenerateInterfacesCodecSerializer::GetInstance());
}

// Sets up an instance of `GenerateInterfaces` to handle messages through the
// `binary_messenger`.
void GenerateInterfaces::SetUp(flutter::BinaryMessenger* binary_messenger,
                               GenerateInterfaces* api) {
  GenerateInterfaces::SetUp(binary_messenger, api, "");
}

void GenerateInterfaces::SetUp(flutter::BinaryMessenger* binary_messenger,
                               GenerateInterfaces* api,
                               const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_auth_platform_interface."
        "GenerateInterfaces.pigeonInterface" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_info_arg = args.at(0);
              if (encodable_info_arg.IsNull()) {
                reply(WrapError("info_arg unexpectedly null."));
                return;
              }
              const auto& info_arg =
                  std::any_cast<const PigeonMultiFactorInfo&>(
                      std::get<CustomEncodableValue>(encodable_info_arg));
              std::optional<FlutterError> output =
                  api->PigeonInterface(info_arg);
              if (output.has_value()) {
                reply(WrapError(output.value()));
                return;
              }
              EncodableList wrapped;
              wrapped.push_back(EncodableValue());
              reply(EncodableValue(std::move(wrapped)));
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue GenerateInterfaces::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue GenerateInterfaces::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

}  // namespace firebase_auth_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/windows/messages.g.h

**크기**: 61919 bytes | **라인 수**: 1482 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v19.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#ifndef PIGEON_MESSAGES_G_H_
#define PIGEON_MESSAGES_G_H_
#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace firebase_auth_windows {

// Generated class from Pigeon.

class FlutterError {
 public:
  explicit FlutterError(const std::string& code) : code_(code) {}
  explicit FlutterError(const std::string& code, const std::string& message)
      : code_(code), message_(message) {}
  explicit FlutterError(const std::string& code, const std::string& message,
                        const flutter::EncodableValue& details)
      : code_(code), message_(message), details_(details) {}

  const std::string& code() const { return code_; }
  const std::string& message() const { return message_; }
  const flutter::EncodableValue& details() const { return details_; }

 private:
  std::string code_;
  std::string message_;
  flutter::EncodableValue details_;
};

template <class T>
class ErrorOr {
 public:
  ErrorOr(const T& rhs) : v_(rhs) {}
  ErrorOr(const T&& rhs) : v_(std::move(rhs)) {}
  ErrorOr(const FlutterError& rhs) : v_(rhs) {}
  ErrorOr(const FlutterError&& rhs) : v_(std::move(rhs)) {}

  bool has_error() const { return std::holds_alternative<FlutterError>(v_); }
  const T& value() const { return std::get<T>(v_); };
  const FlutterError& error() const { return std::get<FlutterError>(v_); };

 private:
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthUserHostApi;
  friend class MultiFactorUserHostApi;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpSecretHostApi;
  friend class GenerateInterfaces;
  ErrorOr() = default;
  T TakeValue() && { return std::get<T>(std::move(v_)); }

  std::variant<T, FlutterError> v_;
};

// The type of operation that generated the action code from calling
// [checkActionCode].
enum class ActionCodeInfoOperation {
  // Unknown operation.
  unknown = 0,
  // Password reset code generated via [sendPasswordResetEmail].
  passwordReset = 1,
  // Email verification code generated via [User.sendEmailVerification].
  verifyEmail = 2,
  // Email change revocation code generated via [User.updateEmail].
  recoverEmail = 3,
  // Email sign in code generated via [sendSignInLinkToEmail].
  emailSignIn = 4,
  // Verify and change email code generated via [User.verifyBeforeUpdateEmail].
  verifyAndChangeEmail = 5,
  // Action code for reverting second factor addition.
  revertSecondFactorAddition = 6
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonMultiFactorSession {
 public:
  // Constructs an object setting all fields.
  explicit PigeonMultiFactorSession(const std::string& id);

  const std::string& id() const;
  void set_id(std::string_view value_arg);

 private:
  static PigeonMultiFactorSession FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string id_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonPhoneMultiFactorAssertion {
 public:
  // Constructs an object setting all fields.
  explicit PigeonPhoneMultiFactorAssertion(
      const std::string& verification_id, const std::string& verification_code);

  const std::string& verification_id() const;
  void set_verification_id(std::string_view value_arg);

  const std::string& verification_code() const;
  void set_verification_code(std::string_view value_arg);

 private:
  static PigeonPhoneMultiFactorAssertion FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string verification_id_;
  std::string verification_code_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonMultiFactorInfo {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonMultiFactorInfo(double enrollment_timestamp,
                                 const std::string& uid);

  // Constructs an object setting all fields.
  explicit PigeonMultiFactorInfo(const std::string* display_name,
                                 double enrollment_timestamp,
                                 const std::string* factor_id,
                                 const std::string& uid,
                                 const std::string* phone_number);

  const std::string* display_name() const;
  void set_display_name(const std::string_view* value_arg);
  void set_display_name(std::string_view value_arg);

  double enrollment_timestamp() const;
  void set_enrollment_timestamp(double value_arg);

  const std::string* factor_id() const;
  void set_factor_id(const std::string_view* value_arg);
  void set_factor_id(std::string_view value_arg);

  const std::string& uid() const;
  void set_uid(std::string_view value_arg);

  const std::string* phone_number() const;
  void set_phone_number(const std::string_view* value_arg);
  void set_phone_number(std::string_view value_arg);

 private:
  static PigeonMultiFactorInfo FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<std::string> display_name_;
  double enrollment_timestamp_;
  std::optional<std::string> factor_id_;
  std::string uid_;
  std::optional<std::string> phone_number_;
};

// Generated class from Pigeon that represents data sent in messages.
class AuthPigeonFirebaseApp {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit AuthPigeonFirebaseApp(const std::string& app_name);

  // Constructs an object setting all fields.
  explicit AuthPigeonFirebaseApp(const std::string& app_name,
                                 const std::string* tenant_id,
                                 const std::string* custom_auth_domain);

  const std::string& app_name() const;
  void set_app_name(std::string_view value_arg);

  const std::string* tenant_id() const;
  void set_tenant_id(const std::string_view* value_arg);
  void set_tenant_id(std::string_view value_arg);

  const std::string* custom_auth_domain() const;
  void set_custom_auth_domain(const std::string_view* value_arg);
  void set_custom_auth_domain(std::string_view value_arg);

 private:
  static AuthPigeonFirebaseApp FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string app_name_;
  std::optional<std::string> tenant_id_;
  std::optional<std::string> custom_auth_domain_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonActionCodeInfoData {
 public:
  // Constructs an object setting all non-nullable fields.
  PigeonActionCodeInfoData();

  // Constructs an object setting all fields.
  explicit PigeonActionCodeInfoData(const std::string* email,
                                    const std::string* previous_email);

  const std::string* email() const;
  void set_email(const std::string_view* value_arg);
  void set_email(std::string_view value_arg);

  const std::string* previous_email() const;
  void set_previous_email(const std::string_view* value_arg);
  void set_previous_email(std::string_view value_arg);

 private:
  static PigeonActionCodeInfoData FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class PigeonActionCodeInfo;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<std::string> email_;
  std::optional<std::string> previous_email_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonActionCodeInfo {
 public:
  // Constructs an object setting all fields.
  explicit PigeonActionCodeInfo(const ActionCodeInfoOperation& operation,
                                const PigeonActionCodeInfoData& data);

  ~PigeonActionCodeInfo() = default;
  PigeonActionCodeInfo(const PigeonActionCodeInfo& other);
  PigeonActionCodeInfo& operator=(const PigeonActionCodeInfo& other);
  PigeonActionCodeInfo(PigeonActionCodeInfo&& other) = default;
  PigeonActionCodeInfo& operator=(PigeonActionCodeInfo&& other) noexcept =
      default;
  const ActionCodeInfoOperation& operation() const;
  void set_operation(const ActionCodeInfoOperation& value_arg);

  const PigeonActionCodeInfoData& data() const;
  void set_data(const PigeonActionCodeInfoData& value_arg);

 private:
  static PigeonActionCodeInfo FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  ActionCodeInfoOperation operation_;
  std::unique_ptr<PigeonActionCodeInfoData> data_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonAdditionalUserInfo {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonAdditionalUserInfo(bool is_new_user);

  // Constructs an object setting all fields.
  explicit PigeonAdditionalUserInfo(bool is_new_user,
                                    const std::string* provider_id,
                                    const std::string* username,
                                    const std::string* authorization_code,
                                    const flutter::EncodableMap* profile);

  bool is_new_user() const;
  void set_is_new_user(bool value_arg);

  const std::string* provider_id() const;
  void set_provider_id(const std::string_view* value_arg);
  void set_provider_id(std::string_view value_arg);

  const std::string* username() const;
  void set_username(const std::string_view* value_arg);
  void set_username(std::string_view value_arg);

  const std::string* authorization_code() const;
  void set_authorization_code(const std::string_view* value_arg);
  void set_authorization_code(std::string_view value_arg);

  const flutter::EncodableMap* profile() const;
  void set_profile(const flutter::EncodableMap* value_arg);
  void set_profile(const flutter::EncodableMap& value_arg);

 private:
  static PigeonAdditionalUserInfo FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class PigeonUserCredential;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  bool is_new_user_;
  std::optional<std::string> provider_id_;
  std::optional<std::string> username_;
  std::optional<std::string> authorization_code_;
  std::optional<flutter::EncodableMap> profile_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonAuthCredential {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonAuthCredential(const std::string& provider_id,
                                const std::string& sign_in_method,
                                int64_t native_id);

  // Constructs an object setting all fields.
  explicit PigeonAuthCredential(const std::string& provider_id,
                                const std::string& sign_in_method,
                                int64_t native_id,
                                const std::string* access_token);

  const std::string& provider_id() const;
  void set_provider_id(std::string_view value_arg);

  const std::string& sign_in_method() const;
  void set_sign_in_method(std::string_view value_arg);

  int64_t native_id() const;
  void set_native_id(int64_t value_arg);

  const std::string* access_token() const;
  void set_access_token(const std::string_view* value_arg);
  void set_access_token(std::string_view value_arg);

 private:
  static PigeonAuthCredential FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class PigeonUserCredential;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string provider_id_;
  std::string sign_in_method_;
  int64_t native_id_;
  std::optional<std::string> access_token_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonUserInfo {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonUserInfo(const std::string& uid, bool is_anonymous,
                          bool is_email_verified);

  // Constructs an object setting all fields.
  explicit PigeonUserInfo(
      const std::string& uid, const std::string* email,
      const std::string* display_name, const std::string* photo_url,
      const std::string* phone_number, bool is_anonymous,
      bool is_email_verified, const std::string* provider_id,
      const std::string* tenant_id, const std::string* refresh_token,
      const int64_t* creation_timestamp, const int64_t* last_sign_in_timestamp);

  const std::string& uid() const;
  void set_uid(std::string_view value_arg);

  const std::string* email() const;
  void set_email(const std::string_view* value_arg);
  void set_email(std::string_view value_arg);

  const std::string* display_name() const;
  void set_display_name(const std::string_view* value_arg);
  void set_display_name(std::string_view value_arg);

  const std::string* photo_url() const;
  void set_photo_url(const std::string_view* value_arg);
  void set_photo_url(std::string_view value_arg);

  const std::string* phone_number() const;
  void set_phone_number(const std::string_view* value_arg);
  void set_phone_number(std::string_view value_arg);

  bool is_anonymous() const;
  void set_is_anonymous(bool value_arg);

  bool is_email_verified() const;
  void set_is_email_verified(bool value_arg);

  const std::string* provider_id() const;
  void set_provider_id(const std::string_view* value_arg);
  void set_provider_id(std::string_view value_arg);

  const std::string* tenant_id() const;
  void set_tenant_id(const std::string_view* value_arg);
  void set_tenant_id(std::string_view value_arg);

  const std::string* refresh_token() const;
  void set_refresh_token(const std::string_view* value_arg);
  void set_refresh_token(std::string_view value_arg);

  const int64_t* creation_timestamp() const;
  void set_creation_timestamp(const int64_t* value_arg);
  void set_creation_timestamp(int64_t value_arg);

  const int64_t* last_sign_in_timestamp() const;
  void set_last_sign_in_timestamp(const int64_t* value_arg);
  void set_last_sign_in_timestamp(int64_t value_arg);

  flutter::EncodableList ToEncodableList() const;

 private:
  static PigeonUserInfo FromEncodableList(const flutter::EncodableList& list);
  friend class PigeonUserDetails;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string uid_;
  std::optional<std::string> email_;
  std::optional<std::string> display_name_;
  std::optional<std::string> photo_url_;
  std::optional<std::string> phone_number_;
  bool is_anonymous_;
  bool is_email_verified_;
  std::optional<std::string> provider_id_;
  std::optional<std::string> tenant_id_;
  std::optional<std::string> refresh_token_;
  std::optional<int64_t> creation_timestamp_;
  std::optional<int64_t> last_sign_in_timestamp_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonUserDetails {
 public:
  // Constructs an object setting all fields.
  explicit PigeonUserDetails(const PigeonUserInfo& user_info,
                             const flutter::EncodableList& provider_data);

  ~PigeonUserDetails() = default;
  PigeonUserDetails(const PigeonUserDetails& other);
  PigeonUserDetails& operator=(const PigeonUserDetails& other);
  PigeonUserDetails(PigeonUserDetails&& other) = default;
  PigeonUserDetails& operator=(PigeonUserDetails&& other) noexcept = default;
  const PigeonUserInfo& user_info() const;
  void set_user_info(const PigeonUserInfo& value_arg);

  const flutter::EncodableList& provider_data() const;
  void set_provider_data(const flutter::EncodableList& value_arg);

  static PigeonUserDetails FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;

 private:
  friend class PigeonUserCredential;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::unique_ptr<PigeonUserInfo> user_info_;
  flutter::EncodableList provider_data_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonUserCredential {
 public:
  // Constructs an object setting all non-nullable fields.
  PigeonUserCredential();

  // Constructs an object setting all fields.
  explicit PigeonUserCredential(
      const PigeonUserDetails* user,
      const PigeonAdditionalUserInfo* additional_user_info,
      const PigeonAuthCredential* credential);

  ~PigeonUserCredential() = default;
  PigeonUserCredential(const PigeonUserCredential& other);
  PigeonUserCredential& operator=(const PigeonUserCredential& other);
  PigeonUserCredential(PigeonUserCredential&& other) = default;
  PigeonUserCredential& operator=(PigeonUserCredential&& other) noexcept =
      default;
  const PigeonUserDetails* user() const;
  void set_user(const PigeonUserDetails* value_arg);
  void set_user(const PigeonUserDetails& value_arg);

  const PigeonAdditionalUserInfo* additional_user_info() const;
  void set_additional_user_info(const PigeonAdditionalUserInfo* value_arg);
  void set_additional_user_info(const PigeonAdditionalUserInfo& value_arg);

  const PigeonAuthCredential* credential() const;
  void set_credential(const PigeonAuthCredential* value_arg);
  void set_credential(const PigeonAuthCredential& value_arg);

 private:
  static PigeonUserCredential FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::unique_ptr<PigeonUserDetails> user_;
  std::unique_ptr<PigeonAdditionalUserInfo> additional_user_info_;
  std::unique_ptr<PigeonAuthCredential> credential_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonActionCodeSettings {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonActionCodeSettings(const std::string& url,
                                    bool handle_code_in_app,
                                    bool android_install_app);

  // Constructs an object setting all fields.
  explicit PigeonActionCodeSettings(const std::string& url,
                                    const std::string* dynamic_link_domain,
                                    bool handle_code_in_app,
                                    const std::string* i_o_s_bundle_id,
                                    const std::string* android_package_name,
                                    bool android_install_app,
                                    const std::string* android_minimum_version,
                                    const std::string* link_domain);

  const std::string& url() const;
  void set_url(std::string_view value_arg);

  const std::string* dynamic_link_domain() const;
  void set_dynamic_link_domain(const std::string_view* value_arg);
  void set_dynamic_link_domain(std::string_view value_arg);

  bool handle_code_in_app() const;
  void set_handle_code_in_app(bool value_arg);

  const std::string* i_o_s_bundle_id() const;
  void set_i_o_s_bundle_id(const std::string_view* value_arg);
  void set_i_o_s_bundle_id(std::string_view value_arg);

  const std::string* android_package_name() const;
  void set_android_package_name(const std::string_view* value_arg);
  void set_android_package_name(std::string_view value_arg);

  bool android_install_app() const;
  void set_android_install_app(bool value_arg);

  const std::string* android_minimum_version() const;
  void set_android_minimum_version(const std::string_view* value_arg);
  void set_android_minimum_version(std::string_view value_arg);

  const std::string* link_domain() const;
  void set_link_domain(const std::string_view* value_arg);
  void set_link_domain(std::string_view value_arg);

 private:
  static PigeonActionCodeSettings FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string url_;
  std::optional<std::string> dynamic_link_domain_;
  bool handle_code_in_app_;
  std::optional<std::string> i_o_s_bundle_id_;
  std::optional<std::string> android_package_name_;
  bool android_install_app_;
  std::optional<std::string> android_minimum_version_;
  std::optional<std::string> link_domain_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonFirebaseAuthSettings {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonFirebaseAuthSettings(
      bool app_verification_disabled_for_testing);

  // Constructs an object setting all fields.
  explicit PigeonFirebaseAuthSettings(
      bool app_verification_disabled_for_testing,
      const std::string* user_access_group, const std::string* phone_number,
      const std::string* sms_code, const bool* force_recaptcha_flow);

  bool app_verification_disabled_for_testing() const;
  void set_app_verification_disabled_for_testing(bool value_arg);

  const std::string* user_access_group() const;
  void set_user_access_group(const std::string_view* value_arg);
  void set_user_access_group(std::string_view value_arg);

  const std::string* phone_number() const;
  void set_phone_number(const std::string_view* value_arg);
  void set_phone_number(std::string_view value_arg);

  const std::string* sms_code() const;
  void set_sms_code(const std::string_view* value_arg);
  void set_sms_code(std::string_view value_arg);

  const bool* force_recaptcha_flow() const;
  void set_force_recaptcha_flow(const bool* value_arg);
  void set_force_recaptcha_flow(bool value_arg);

 private:
  static PigeonFirebaseAuthSettings FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  bool app_verification_disabled_for_testing_;
  std::optional<std::string> user_access_group_;
  std::optional<std::string> phone_number_;
  std::optional<std::string> sms_code_;
  std::optional<bool> force_recaptcha_flow_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonSignInProvider {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonSignInProvider(const std::string& provider_id);

  // Constructs an object setting all fields.
  explicit PigeonSignInProvider(const std::string& provider_id,
                                const flutter::EncodableList* scopes,
                                const flutter::EncodableMap* custom_parameters);

  const std::string& provider_id() const;
  void set_provider_id(std::string_view value_arg);

  const flutter::EncodableList* scopes() const;
  void set_scopes(const flutter::EncodableList* value_arg);
  void set_scopes(const flutter::EncodableList& value_arg);

  const flutter::EncodableMap* custom_parameters() const;
  void set_custom_parameters(const flutter::EncodableMap* value_arg);
  void set_custom_parameters(const flutter::EncodableMap& value_arg);

 private:
  static PigeonSignInProvider FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::string provider_id_;
  std::optional<flutter::EncodableList> scopes_;
  std::optional<flutter::EncodableMap> custom_parameters_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonVerifyPhoneNumberRequest {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonVerifyPhoneNumberRequest(int64_t timeout);

  // Constructs an object setting all fields.
  explicit PigeonVerifyPhoneNumberRequest(
      const std::string* phone_number, int64_t timeout,
      const int64_t* force_resending_token,
      const std::string* auto_retrieved_sms_code_for_testing,
      const std::string* multi_factor_info_id,
      const std::string* multi_factor_session_id);

  const std::string* phone_number() const;
  void set_phone_number(const std::string_view* value_arg);
  void set_phone_number(std::string_view value_arg);

  int64_t timeout() const;
  void set_timeout(int64_t value_arg);

  const int64_t* force_resending_token() const;
  void set_force_resending_token(const int64_t* value_arg);
  void set_force_resending_token(int64_t value_arg);

  const std::string* auto_retrieved_sms_code_for_testing() const;
  void set_auto_retrieved_sms_code_for_testing(
      const std::string_view* value_arg);
  void set_auto_retrieved_sms_code_for_testing(std::string_view value_arg);

  const std::string* multi_factor_info_id() const;
  void set_multi_factor_info_id(const std::string_view* value_arg);
  void set_multi_factor_info_id(std::string_view value_arg);

  const std::string* multi_factor_session_id() const;
  void set_multi_factor_session_id(const std::string_view* value_arg);
  void set_multi_factor_session_id(std::string_view value_arg);

 private:
  static PigeonVerifyPhoneNumberRequest FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<std::string> phone_number_;
  int64_t timeout_;
  std::optional<int64_t> force_resending_token_;
  std::optional<std::string> auto_retrieved_sms_code_for_testing_;
  std::optional<std::string> multi_factor_info_id_;
  std::optional<std::string> multi_factor_session_id_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonIdTokenResult {
 public:
  // Constructs an object setting all non-nullable fields.
  PigeonIdTokenResult();

  // Constructs an object setting all fields.
  explicit PigeonIdTokenResult(const std::string* token,
                               const int64_t* expiration_timestamp,
                               const int64_t* auth_timestamp,
                               const int64_t* issued_at_timestamp,
                               const std::string* sign_in_provider,
                               const flutter::EncodableMap* claims,
                               const std::string* sign_in_second_factor);

  const std::string* token() const;
  void set_token(const std::string_view* value_arg);
  void set_token(std::string_view value_arg);

  const int64_t* expiration_timestamp() const;
  void set_expiration_timestamp(const int64_t* value_arg);
  void set_expiration_timestamp(int64_t value_arg);

  const int64_t* auth_timestamp() const;
  void set_auth_timestamp(const int64_t* value_arg);
  void set_auth_timestamp(int64_t value_arg);

  const int64_t* issued_at_timestamp() const;
  void set_issued_at_timestamp(const int64_t* value_arg);
  void set_issued_at_timestamp(int64_t value_arg);

  const std::string* sign_in_provider() const;
  void set_sign_in_provider(const std::string_view* value_arg);
  void set_sign_in_provider(std::string_view value_arg);

  const flutter::EncodableMap* claims() const;
  void set_claims(const flutter::EncodableMap* value_arg);
  void set_claims(const flutter::EncodableMap& value_arg);

  const std::string* sign_in_second_factor() const;
  void set_sign_in_second_factor(const std::string_view* value_arg);
  void set_sign_in_second_factor(std::string_view value_arg);

 private:
  static PigeonIdTokenResult FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<std::string> token_;
  std::optional<int64_t> expiration_timestamp_;
  std::optional<int64_t> auth_timestamp_;
  std::optional<int64_t> issued_at_timestamp_;
  std::optional<std::string> sign_in_provider_;
  std::optional<flutter::EncodableMap> claims_;
  std::optional<std::string> sign_in_second_factor_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonUserProfile {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonUserProfile(bool display_name_changed, bool photo_url_changed);

  // Constructs an object setting all fields.
  explicit PigeonUserProfile(const std::string* display_name,
                             const std::string* photo_url,
                             bool display_name_changed, bool photo_url_changed);

  const std::string* display_name() const;
  void set_display_name(const std::string_view* value_arg);
  void set_display_name(std::string_view value_arg);

  const std::string* photo_url() const;
  void set_photo_url(const std::string_view* value_arg);
  void set_photo_url(std::string_view value_arg);

  bool display_name_changed() const;
  void set_display_name_changed(bool value_arg);

  bool photo_url_changed() const;
  void set_photo_url_changed(bool value_arg);

 private:
  static PigeonUserProfile FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<std::string> display_name_;
  std::optional<std::string> photo_url_;
  bool display_name_changed_;
  bool photo_url_changed_;
};

// Generated class from Pigeon that represents data sent in messages.
class PigeonTotpSecret {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit PigeonTotpSecret(const std::string& secret_key);

  // Constructs an object setting all fields.
  explicit PigeonTotpSecret(const int64_t* code_interval_seconds,
                            const int64_t* code_length,
                            const int64_t* enrollment_completion_deadline,
                            const std::string* hashing_algorithm,
                            const std::string& secret_key);

  const int64_t* code_interval_seconds() const;
  void set_code_interval_seconds(const int64_t* value_arg);
  void set_code_interval_seconds(int64_t value_arg);

  const int64_t* code_length() const;
  void set_code_length(const int64_t* value_arg);
  void set_code_length(int64_t value_arg);

  const int64_t* enrollment_completion_deadline() const;
  void set_enrollment_completion_deadline(const int64_t* value_arg);
  void set_enrollment_completion_deadline(int64_t value_arg);

  const std::string* hashing_algorithm() const;
  void set_hashing_algorithm(const std::string_view* value_arg);
  void set_hashing_algorithm(std::string_view value_arg);

  const std::string& secret_key() const;
  void set_secret_key(std::string_view value_arg);

 private:
  static PigeonTotpSecret FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseAuthHostApi;
  friend class FirebaseAuthHostApiCodecSerializer;
  friend class FirebaseAuthUserHostApi;
  friend class FirebaseAuthUserHostApiCodecSerializer;
  friend class MultiFactorUserHostApi;
  friend class MultiFactorUserHostApiCodecSerializer;
  friend class MultiFactoResolverHostApi;
  friend class MultiFactoResolverHostApiCodecSerializer;
  friend class MultiFactorTotpHostApi;
  friend class MultiFactorTotpHostApiCodecSerializer;
  friend class MultiFactorTotpSecretHostApi;
  friend class MultiFactorTotpSecretHostApiCodecSerializer;
  friend class GenerateInterfaces;
  friend class GenerateInterfacesCodecSerializer;
  std::optional<int64_t> code_interval_seconds_;
  std::optional<int64_t> code_length_;
  std::optional<int64_t> enrollment_completion_deadline_;
  std::optional<std::string> hashing_algorithm_;
  std::string secret_key_;
};

class FirebaseAuthHostApiCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  FirebaseAuthHostApiCodecSerializer();
  inline static FirebaseAuthHostApiCodecSerializer& GetInstance() {
    static FirebaseAuthHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class FirebaseAuthHostApi {
 public:
  FirebaseAuthHostApi(const FirebaseAuthHostApi&) = delete;
  FirebaseAuthHostApi& operator=(const FirebaseAuthHostApi&) = delete;
  virtual ~FirebaseAuthHostApi() {}
  virtual void RegisterIdTokenListener(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void RegisterAuthStateListener(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void UseEmulator(
      const AuthPigeonFirebaseApp& app, const std::string& host, int64_t port,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void ApplyActionCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void CheckActionCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(ErrorOr<PigeonActionCodeInfo> reply)> result) = 0;
  virtual void ConfirmPasswordReset(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      const std::string& new_password,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void CreateUserWithEmailAndPassword(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& password,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInAnonymously(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInWithCustomToken(
      const AuthPigeonFirebaseApp& app, const std::string& token,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInWithEmailAndPassword(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& password,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInWithEmailLink(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const std::string& email_link,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignInWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void SignOut(
      const AuthPigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void FetchSignInMethodsForEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;
  virtual void SendPasswordResetEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SendSignInLinkToEmail(
      const AuthPigeonFirebaseApp& app, const std::string& email,
      const PigeonActionCodeSettings& action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SetLanguageCode(
      const AuthPigeonFirebaseApp& app, const std::string* language_code,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void SetSettings(
      const AuthPigeonFirebaseApp& app,
      const PigeonFirebaseAuthSettings& settings,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void VerifyPasswordResetCode(
      const AuthPigeonFirebaseApp& app, const std::string& code,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void VerifyPhoneNumber(
      const AuthPigeonFirebaseApp& app,
      const PigeonVerifyPhoneNumberRequest& request,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void RevokeTokenWithAuthorizationCode(
      const AuthPigeonFirebaseApp& app, const std::string& authorization_code,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;

  // The codec used by FirebaseAuthHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `FirebaseAuthHostApi` to handle messages through the
  // `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAuthHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAuthHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  FirebaseAuthHostApi() = default;
};
class FirebaseAuthUserHostApiCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  FirebaseAuthUserHostApiCodecSerializer();
  inline static FirebaseAuthUserHostApiCodecSerializer& GetInstance() {
    static FirebaseAuthUserHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class FirebaseAuthUserHostApi {
 public:
  FirebaseAuthUserHostApi(const FirebaseAuthUserHostApi&) = delete;
  FirebaseAuthUserHostApi& operator=(const FirebaseAuthUserHostApi&) = delete;
  virtual ~FirebaseAuthUserHostApi() {}
  virtual void Delete(
      const AuthPigeonFirebaseApp& app,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void GetIdToken(
      const AuthPigeonFirebaseApp& app, bool force_refresh,
      std::function<void(ErrorOr<PigeonIdTokenResult> reply)> result) = 0;
  virtual void LinkWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void LinkWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void ReauthenticateWithCredential(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void ReauthenticateWithProvider(
      const AuthPigeonFirebaseApp& app,
      const PigeonSignInProvider& sign_in_provider,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void Reload(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) = 0;
  virtual void SendEmailVerification(
      const AuthPigeonFirebaseApp& app,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void Unlink(
      const AuthPigeonFirebaseApp& app, const std::string& provider_id,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;
  virtual void UpdateEmail(
      const AuthPigeonFirebaseApp& app, const std::string& new_email,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) = 0;
  virtual void UpdatePassword(
      const AuthPigeonFirebaseApp& app, const std::string& new_password,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) = 0;
  virtual void UpdatePhoneNumber(
      const AuthPigeonFirebaseApp& app, const flutter::EncodableMap& input,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) = 0;
  virtual void UpdateProfile(
      const AuthPigeonFirebaseApp& app, const PigeonUserProfile& profile,
      std::function<void(ErrorOr<PigeonUserDetails> reply)> result) = 0;
  virtual void VerifyBeforeUpdateEmail(
      const AuthPigeonFirebaseApp& app, const std::string& new_email,
      const PigeonActionCodeSettings* action_code_settings,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;

  // The codec used by FirebaseAuthUserHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `FirebaseAuthUserHostApi` to handle messages through
  // the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAuthUserHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAuthUserHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  FirebaseAuthUserHostApi() = default;
};
class MultiFactorUserHostApiCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  MultiFactorUserHostApiCodecSerializer();
  inline static MultiFactorUserHostApiCodecSerializer& GetInstance() {
    static MultiFactorUserHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class MultiFactorUserHostApi {
 public:
  MultiFactorUserHostApi(const MultiFactorUserHostApi&) = delete;
  MultiFactorUserHostApi& operator=(const MultiFactorUserHostApi&) = delete;
  virtual ~MultiFactorUserHostApi() {}
  virtual void EnrollPhone(
      const AuthPigeonFirebaseApp& app,
      const PigeonPhoneMultiFactorAssertion& assertion,
      const std::string* display_name,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void EnrollTotp(
      const AuthPigeonFirebaseApp& app, const std::string& assertion_id,
      const std::string* display_name,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void GetSession(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<PigeonMultiFactorSession> reply)> result) = 0;
  virtual void Unenroll(
      const AuthPigeonFirebaseApp& app, const std::string& factor_uid,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void GetEnrolledFactors(
      const AuthPigeonFirebaseApp& app,
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;

  // The codec used by MultiFactorUserHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `MultiFactorUserHostApi` to handle messages through
  // the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorUserHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorUserHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  MultiFactorUserHostApi() = default;
};
class MultiFactoResolverHostApiCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  MultiFactoResolverHostApiCodecSerializer();
  inline static MultiFactoResolverHostApiCodecSerializer& GetInstance() {
    static MultiFactoResolverHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class MultiFactoResolverHostApi {
 public:
  MultiFactoResolverHostApi(const MultiFactoResolverHostApi&) = delete;
  MultiFactoResolverHostApi& operator=(const MultiFactoResolverHostApi&) =
      delete;
  virtual ~MultiFactoResolverHostApi() {}
  virtual void ResolveSignIn(
      const std::string& resolver_id,
      const PigeonPhoneMultiFactorAssertion* assertion,
      const std::string* totp_assertion_id,
      std::function<void(ErrorOr<PigeonUserCredential> reply)> result) = 0;

  // The codec used by MultiFactoResolverHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `MultiFactoResolverHostApi` to handle messages
  // through the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactoResolverHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactoResolverHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  MultiFactoResolverHostApi() = default;
};
class MultiFactorTotpHostApiCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  MultiFactorTotpHostApiCodecSerializer();
  inline static MultiFactorTotpHostApiCodecSerializer& GetInstance() {
    static MultiFactorTotpHostApiCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class MultiFactorTotpHostApi {
 public:
  MultiFactorTotpHostApi(const MultiFactorTotpHostApi&) = delete;
  MultiFactorTotpHostApi& operator=(const MultiFactorTotpHostApi&) = delete;
  virtual ~MultiFactorTotpHostApi() {}
  virtual void GenerateSecret(
      const std::string& session_id,
      std::function<void(ErrorOr<PigeonTotpSecret> reply)> result) = 0;
  virtual void GetAssertionForEnrollment(
      const std::string& secret_key, const std::string& one_time_password,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void GetAssertionForSignIn(
      const std::string& enrollment_id, const std::string& one_time_password,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;

  // The codec used by MultiFactorTotpHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `MultiFactorTotpHostApi` to handle messages through
  // the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorTotpHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorTotpHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  MultiFactorTotpHostApi() = default;
};
// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class MultiFactorTotpSecretHostApi {
 public:
  MultiFactorTotpSecretHostApi(const MultiFactorTotpSecretHostApi&) = delete;
  MultiFactorTotpSecretHostApi& operator=(const MultiFactorTotpSecretHostApi&) =
      delete;
  virtual ~MultiFactorTotpSecretHostApi() {}
  virtual void GenerateQrCodeUrl(
      const std::string& secret_key, const std::string* account_name,
      const std::string* issuer,
      std::function<void(ErrorOr<std::string> reply)> result) = 0;
  virtual void OpenInOtpApp(
      const std::string& secret_key, const std::string& qr_code_url,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;

  // The codec used by MultiFactorTotpSecretHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `MultiFactorTotpSecretHostApi` to handle messages
  // through the `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorTotpSecretHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    MultiFactorTotpSecretHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  MultiFactorTotpSecretHostApi() = default;
};
class GenerateInterfacesCodecSerializer
    : public flutter::StandardCodecSerializer {
 public:
  GenerateInterfacesCodecSerializer();
  inline static GenerateInterfacesCodecSerializer& GetInstance() {
    static GenerateInterfacesCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Only used to generate the object interface that are use outside of the Pigeon
// interface
//
// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class GenerateInterfaces {
 public:
  GenerateInterfaces(const GenerateInterfaces&) = delete;
  GenerateInterfaces& operator=(const GenerateInterfaces&) = delete;
  virtual ~GenerateInterfaces() {}
  virtual std::optional<FlutterError> PigeonInterface(
      const PigeonMultiFactorInfo& info) = 0;

  // The codec used by GenerateInterfaces.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `GenerateInterfaces` to handle messages through the
  // `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    GenerateInterfaces* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    GenerateInterfaces* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  GenerateInterfaces() = default;
};
}  // namespace firebase_auth_windows
#endif  // PIGEON_MESSAGES_G_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/CHANGELOG.md

**크기**: 64431 bytes | **라인 수**: 1554 | **타입**: text

```
## 6.1.0

 - **FEAT**(auth): TOTP macOS support ([#17513](https://github.com/firebase/flutterfire/issues/17513)). ([41890d62](https://github.com/firebase/flutterfire/commit/41890d62a49258df097c19fd3b90e0b5de181526))

## 6.0.2

 - Update a dependency to the latest release.

## 6.0.1

 - **FIX**(auth,apple): Move FirebaseAuth imports to implementation files ([#17607](https://github.com/firebase/flutterfire/issues/17607)). ([0c3ccd37](https://github.com/firebase/flutterfire/commit/0c3ccd3722038a47e656b0a703a0395a78befc5b))

## 6.0.0

> Note: This release has breaking changes.

 - **FEAT**(auth): validatePassword method/PasswordPolicy Support ([#17439](https://github.com/firebase/flutterfire/issues/17439)). ([9a032b34](https://github.com/firebase/flutterfire/commit/9a032b344d6a22c1e3a181ae27e511939f2d8972))
 - **BREAKING** **FEAT**: bump iOS SDK to version 12.0.0 ([#17549](https://github.com/firebase/flutterfire/issues/17549)). ([b2619e68](https://github.com/firebase/flutterfire/commit/b2619e685fec897513483df1d7be347b64f95606))
 - **BREAKING** **FEAT**(auth): remove deprecated functions ([#17562](https://github.com/firebase/flutterfire/issues/17562)). ([d50aad95](https://github.com/firebase/flutterfire/commit/d50aad954443904d64d4ebd4442ebc63ed702986))
 - **BREAKING** **FEAT**: bump Android SDK to version 34.0.0 ([#17554](https://github.com/firebase/flutterfire/issues/17554)). ([a5bdc051](https://github.com/firebase/flutterfire/commit/a5bdc051d40ee44e39cf0b8d2a7801bc6f618b67))

## Removed Methods

- `ActionCodeSettings.dynamicLinkDomain` - Firebase Dynamic Links is deprecated and will be shut down
- `MicrosoftAuthProvider.credential()` - Use `signInWithProvider(MicrosoftAuthProvider)` instead
- `FirebaseAuth.instanceFor()` persistence parameter - Use `setPersistence()` instead
- `FirebaseAuth.fetchSignInMethodsForEmail()` - Removed for security best practices
- `User.updateEmail()` - Use `verifyBeforeUpdateEmail()` instead

## Migration Guide

### ActionCodeSettings
```dart
// Before
ActionCodeSettings(
  url: 'https://example.com',
  dynamicLinkDomain: 'example.page.link',
)

// After
ActionCodeSettings(
  url: 'https://example.com',
  linkDomain: 'your-custom-domain.com', // Use custom Firebase Hosting domain
)
```

### Microsoft Authentication
```dart
// Before
final credential = MicrosoftAuthProvider.credential(accessToken);
await FirebaseAuth.instance.signInWithCredential(credential);

// After
final provider = MicrosoftAuthProvider();
await FirebaseAuth.instance.signInWithProvider(provider);
```

### FirebaseAuth Instance
```dart
// Before
FirebaseAuth.instanceFor(app: app, persistence: Persistence.local);

// After
final auth = FirebaseAuth.instanceFor(app: app);
auth.setPersistence(Persistence.local);
```

### Email Updates
```dart
// Before
await user.updateEmail('new@email.com');

// After
await user.verifyBeforeUpdateEmail('new@email.com');
```

### Email Sign-in Methods
The `fetchSignInMethodsForEmail()` method has been removed for security reasons. Consider implementing alternative authentication flows that don't require email enumeration.

## 5.7.0

 - **FEAT**(auth,macos): add support for `publish` and `addApplicationDelegate` on macOS FlutterPluginRegistrar ([#17518](https://github.com/firebase/flutterfire/issues/17518)). ([376bb6ea](https://github.com/firebase/flutterfire/commit/376bb6ea8878df3f25cc1416fe26ace2203fd793))

## 5.6.2

 - Update a dependency to the latest release.

## 5.6.1

 - Update a dependency to the latest release.

## 5.6.0

 - **FEAT**(auth): add support for initializeRecaptchaConfig ([#17365](https://github.com/firebase/flutterfire/issues/17365)). ([73f9028e](https://github.com/firebase/flutterfire/commit/73f9028e114874fddc8a4f76f22b247504a95a02))

## 5.5.4

 - **FIX**(auth,apple): prevent EXC_BAD_ACCESS crash in Apple Sign-In completion handler ([#17273](https://github.com/firebase/flutterfire/issues/17273)). ([cc7d28ae](https://github.com/firebase/flutterfire/commit/cc7d28ae09036464f7ece6a2637bae6a3c7a292d))
 - **DOCS**(firebase_auth): Removed duplicates; fixed typos; removed "unnecessary use of a null check" ([#16815](https://github.com/firebase/flutterfire/issues/16815)). ([0eb17e13](https://github.com/firebase/flutterfire/commit/0eb17e13587ebfe5c8d64cbba9c0a2ccd0b7ce90))

## 5.5.3

 - **FIX**(auth,iOS): include missing email and credential in account-exists-with-different-credential error ([#17180](https://github.com/firebase/flutterfire/issues/17180)). ([2a0bdc64](https://github.com/firebase/flutterfire/commit/2a0bdc64086e99f8a98bd18b472b36bcfe05a9a4))

## 5.5.2

 - Update a dependency to the latest release.

## 5.5.1

 - Update a dependency to the latest release.

## 5.5.0

 - **FEAT**(auth): support for `linkDomain` in `ActionCodeSettings` ([#17099](https://github.com/firebase/flutterfire/issues/17099)). ([090cdb20](https://github.com/firebase/flutterfire/commit/090cdb2078dc66e58aa4b1a3ef9a48101467b6ac))

## 5.4.2

 - Update a dependency to the latest release.

## 5.4.1

 - Update a dependency to the latest release.

## 5.4.0


 - **FIX**: Remove dart:io imports for analytics, auth and app check ([#16827](https://github.com/firebase/flutterfire/issues/16827)). ([8c7f57c4](https://github.com/firebase/flutterfire/commit/8c7f57c4a181b8cae3b0d2ba564682ad7d68f484))
 - **FIX**(firebase_auth): Fix `std::variant` compiler errors with VS 2022 17.12 ([#16840](https://github.com/firebase/flutterfire/issues/16840)). ([b88b71f4](https://github.com/firebase/flutterfire/commit/b88b71f45c856eb0ff2d2caefb8b6aa367e91418))
 - **FEAT**(auth): Swift Package Manager support ([#16773](https://github.com/firebase/flutterfire/issues/16773)). ([69abbe19](https://github.com/firebase/flutterfire/commit/69abbe19bb37e6eb450b0b5123a74c2d68a761c7))

## 5.3.4

 - **FIX**(auth,android): `signInWithProvider()` for non-default instances ([#13522](https://github.com/firebase/flutterfire/issues/13522)). ([fe016a44](https://github.com/firebase/flutterfire/commit/fe016a4487993c8aa444e15c9881fe355b5f6624))

## 5.3.3

 - Update a dependency to the latest release.

## 5.3.2

 - **FIX**(auth,apple): set nullability on pigeon parser method ([#13571](https://github.com/firebase/flutterfire/issues/13571)). ([7e8a1b2e](https://github.com/firebase/flutterfire/commit/7e8a1b2e5be454b168d942056c4abb7f8e92a9a8))

## 5.3.1

 - **FIX**(all,apple): use modular headers to import ([#13400](https://github.com/firebase/flutterfire/issues/13400)). ([d7d2d4b9](https://github.com/firebase/flutterfire/commit/d7d2d4b93e7c00226027fffde46699f3d5388a41))

## 5.3.0

 - **FEAT**(fdc): Initial Release of Data Connect ([#13313](https://github.com/firebase/flutterfire/issues/13313)). ([603a6726](https://github.com/firebase/flutterfire/commit/603a67261a2f7cbdd6ef594bfaef480aeb820683))

## 5.2.1

 - Update a dependency to the latest release.

## 5.2.0

 - **FEAT**: bump iOS SDK to version 11.0.0 ([#13158](https://github.com/firebase/flutterfire/issues/13158)). ([c0e0c997](https://github.com/firebase/flutterfire/commit/c0e0c99703ea394d1bb873ac225c5fe3539b002d))
 - **DOCS**: remove reference to flutter.io and firebase.flutter.dev ([#13152](https://github.com/firebase/flutterfire/issues/13152)). ([5f0874b9](https://github.com/firebase/flutterfire/commit/5f0874b91e28a203dd62d37d391e5760c91f5729))

## 5.1.4

 - **FIX**(firebase_auth): added supporting rawNonce for OAuth credential on Windows platform ([#13086](https://github.com/firebase/flutterfire/issues/13086)). ([12e87de9](https://github.com/firebase/flutterfire/commit/12e87de93ddc39d41a6a634d7d03766b3e36996a))

## 5.1.3

 - **DOCS**(auth): add information about error codes for email/password functions ([#13100](https://github.com/firebase/flutterfire/issues/13100)). ([aeafc356](https://github.com/firebase/flutterfire/commit/aeafc356953a0531003f765e766ffcff2387401d))

## 5.1.2

 - **DOCS**(auth): add information about error codes for `verifyBeforeUpdateEmail` ([#13036](https://github.com/firebase/flutterfire/issues/13036)). ([8ef7421d](https://github.com/firebase/flutterfire/commit/8ef7421d6a524938087769537ac70ec249096ed4))

## 5.1.1

 - **FIX**(auth,apple): bug with cached `AuthCredential`, hash key was producing different value ([#12957](https://github.com/firebase/flutterfire/issues/12957)). ([ef0077e3](https://github.com/firebase/flutterfire/commit/ef0077e37744360264eb60d6eea4359a5cc13227))
 - **FIX**(auth,windows): fix a crash that could happen when using `sendEmailVerification` or `sendPasswordResetEmail` ([#12946](https://github.com/firebase/flutterfire/issues/12946)). ([a1008290](https://github.com/firebase/flutterfire/commit/a100829087dbf83ea59e73c3811d87b67e2a4012))
 - **DOCS**: Update documentation for auth/user-not-found exception to reflect email enumeration protection ([#12964](https://github.com/firebase/flutterfire/issues/12964)). ([125f8209](https://github.com/firebase/flutterfire/commit/125f820971331ec75e7fe59cff3b296c42c7d8f3))

## 5.1.0

 - **FIX**(auth,ios): fix the parsing of an error that could specifically happen when using MicrosoftProvider ([#12920](https://github.com/firebase/flutterfire/issues/12920)). ([3b415e64](https://github.com/firebase/flutterfire/commit/3b415e641e6107b131a170277bbc1fa0e2908e27))
 - **FEAT**(auth,apple): create a credential with `idToken`, `rawNonce` & `appleFullPersonName` ([#12356](https://github.com/firebase/flutterfire/issues/12356)). ([17793080](https://github.com/firebase/flutterfire/commit/177930802ca13a3af1610968e54b8ce79f0781ca))

## 5.0.0

> Note: This release has breaking changes.

 - **BREAKING** **REFACTOR**: android plugins require `minSdk 21`, auth requires `minSdk 23` ahead of android BOM `>=33.0.0` ([#12873](https://github.com/firebase/flutterfire/issues/12873)). ([52accfc6](https://github.com/firebase/flutterfire/commit/52accfc6c39d6360d9c0f36efe369ede990b7362))
 - **BREAKING** **REFACTOR**: bump all iOS deployment targets to iOS 13 ahead of Firebase iOS SDK `v11` breaking change ([#12872](https://github.com/firebase/flutterfire/issues/12872)). ([de0cea2c](https://github.com/firebase/flutterfire/commit/de0cea2c3c36694a76361be784255986fac84a43))
 - **BREAKING** **REFACTOR**(auth): remove deprecated API ahead of breaking change release ([#12859](https://github.com/firebase/flutterfire/issues/12859)). ([995fa7e1](https://github.com/firebase/flutterfire/commit/995fa7e19540fe52ba75a66865823c8ca86b6657))

## 4.20.0

 - **FIX**(auth,android): remove unnecessary error type guarding ([#12816](https://github.com/firebase/flutterfire/issues/12816)). ([7d4c200a](https://github.com/firebase/flutterfire/commit/7d4c200ac6f06a50c2e7ee852aea2c9fa7bcb0ff))
 - **FEAT**(auth,windows): `verifyBeforeUpdateEmail()` API  support ([#12825](https://github.com/firebase/flutterfire/issues/12825)). ([111b1ad9](https://github.com/firebase/flutterfire/commit/111b1ad91e985b0462532bc579e64342b7f46fe2))
 - **FEAT**(auth): update Pigeon version to 19 ([#12828](https://github.com/firebase/flutterfire/issues/12828)). ([5e76153f](https://github.com/firebase/flutterfire/commit/5e76153fbcd337a26e83abc2b43b651ab6c501bc))
 - **FEAT**: bump CPP SDK to version 11.10.0 ([#12749](https://github.com/firebase/flutterfire/issues/12749)). ([2e410a23](https://github.com/firebase/flutterfire/commit/2e410a232758292baa70f8e78464bd3c62ec0373))

## 4.19.6

 - **FIX**(auth,android): allow nullable `accessToken` when creating `OAuthProvider` ([#12795](https://github.com/firebase/flutterfire/issues/12795)). ([490319d4](https://github.com/firebase/flutterfire/commit/490319d4c046917bdd227c19fd37185d63076b4a))

## 4.19.5

 - **FIX**(auth,windows): allow `idToken` and `accessToken` to be nullable to stop windows crashing for `signInWithCredential()` ([#12688](https://github.com/firebase/flutterfire/issues/12688)). ([ca9f92d0](https://github.com/firebase/flutterfire/commit/ca9f92d05f717b46c80307987f560454b90a4d67))

## 4.19.4

 - Update a dependency to the latest release.

## 4.19.3

 - **FIX**(auth,ios): Give more details on internal error when calling `sendSignInLinkToEmail`. ([#12671](https://github.com/firebase/flutterfire/issues/12671)). ([2b086029](https://github.com/firebase/flutterfire/commit/2b0860296bf577c99810643bb286b7219ee9291f))

## 4.19.2

 - Update a dependency to the latest release.

## 4.19.1

 - Update a dependency to the latest release.

## 4.19.0

 - **FEAT**(android): Bump `compileSdk` version of Android plugins to latest stable (34) ([#12566](https://github.com/firebase/flutterfire/issues/12566)). ([e891fab2](https://github.com/firebase/flutterfire/commit/e891fab291e9beebc223000b133a6097e066a7fc))

## 4.18.0

 - **FIX**(auth,android): fixing an issue that could cause `getEnrolledFactors` to return an empty list if signing out in the same app session ([#12488](https://github.com/firebase/flutterfire/issues/12488)). ([04280a31](https://github.com/firebase/flutterfire/commit/04280a31310dbbe51a8e619f031f5190d02e695d))
 - **FEAT**(firebase_auth): add custom auth domain setter to Firebase Auth ([#12218](https://github.com/firebase/flutterfire/issues/12218)). ([e1297800](https://github.com/firebase/flutterfire/commit/e12978009e0fd785f267db560972ab0bbe021fcb))
 - **FEAT**(auth,windows): add support for oAuth with credentials on Windows ([#12154](https://github.com/firebase/flutterfire/issues/12154)). ([cc708e6f](https://github.com/firebase/flutterfire/commit/cc708e6fdce6053772da0f08c9872e1dbe9899b1))

## 4.17.9

 - Update a dependency to the latest release.

## 4.17.8

 - Update a dependency to the latest release.

## 4.17.7

 - Update a dependency to the latest release.

## 4.17.6

 - Update a dependency to the latest release.

## 4.17.5

 - Update a dependency to the latest release.

## 4.17.4

 - Update a dependency to the latest release.

## 4.17.3

 - Update a dependency to the latest release.

## 4.17.2

 - **FIX**(auth,web): fix null safety issue in typing JS Interop ([#12250](https://github.com/firebase/flutterfire/issues/12250)). ([d0d30405](https://github.com/firebase/flutterfire/commit/d0d30405a895ae221603ddd158b1cb1636312fb4))

## 4.17.1

 - Update a dependency to the latest release.

## 4.17.0

 - **FIX**(auth): deprecate `updateEmail()` & `fetchSignInMethodsForEmail()` ([#12143](https://github.com/firebase/flutterfire/issues/12143)). ([dcfd9e80](https://github.com/firebase/flutterfire/commit/dcfd9e801c3231d17821355df5865b179cf0bf11))
 - **FEAT**(auth,apple): Game Center sign-in support ([#12228](https://github.com/firebase/flutterfire/issues/12228)). ([ac625ec7](https://github.com/firebase/flutterfire/commit/ac625ec7a2ceb8c7ef78180f3bcaa8294cf06a2e))
 - **FEAT**(auth,android): Play Games provider sign-in support ([#12201](https://github.com/firebase/flutterfire/issues/12201)). ([1fb9019d](https://github.com/firebase/flutterfire/commit/1fb9019de1fd832223aa56139d98c1194b2d5efa))
 - **FEAT**(auth,windows): add support for `creationTime` and `lastSignInTime` ([#12116](https://github.com/firebase/flutterfire/issues/12116)). ([387e9434](https://github.com/firebase/flutterfire/commit/387e94343a237d0976bdfa4f5c0e20c6922456fa))

## 4.16.0

 - **FIX**(auth,windows): fix a parsing issue of the Pigeon message on Windows for sendPasswordResetEmail ([#12082](https://github.com/firebase/flutterfire/issues/12082)). ([17c4ab12](https://github.com/firebase/flutterfire/commit/17c4ab128650c8e7a4f7e3cea0c55d1fea0998fd))
 - **FEAT**: allow users to disable automatic host mapping ([#11962](https://github.com/firebase/flutterfire/issues/11962)). ([13c1ce33](https://github.com/firebase/flutterfire/commit/13c1ce333b8cd113241a1f7ac07181c1c76194bc))

## 4.15.3

 - **FIX**(auth): return email address if one is returned by the auth exception ([#11978](https://github.com/firebase/flutterfire/issues/11978)). ([ceee304d](https://github.com/firebase/flutterfire/commit/ceee304dd87cd66e34a7f7fa67c9961b72c10e72))

## 4.15.2

 - Update a dependency to the latest release.

## 4.15.1

 - Update a dependency to the latest release.

## 4.15.0

 - **FEAT**(auth): add support for custom domains on mobile ([#11925](https://github.com/firebase/flutterfire/issues/11925)). ([552119c7](https://github.com/firebase/flutterfire/commit/552119c78e2750a929c6226de22f9f6d8df948a4))

## 4.14.1

 - **FIX**(auth,apple): need to cache `AuthCredential` on native in case Dart exception passes `AuthCredential` back to user for sign-in ([#11889](https://github.com/firebase/flutterfire/issues/11889)). ([9c09f224](https://github.com/firebase/flutterfire/commit/9c09f22416f549e3b80bc7e618b07c1c3c24ee31))
 - **FIX**(auth,web): use the device language when using `setLanguageCode` with null ([#11905](https://github.com/firebase/flutterfire/issues/11905)). ([f9322b6f](https://github.com/firebase/flutterfire/commit/f9322b6f25cd9520c5e033361e63a4db3f375a15))
 - **FIX**(auth): add proper error message when trying to access the multifactor object on an unsupported platform ([#11894](https://github.com/firebase/flutterfire/issues/11894)). ([27d1c47d](https://github.com/firebase/flutterfire/commit/27d1c47d1168198e9fa296fcff52feb1f0a345d2))

## 4.14.0

 - **FEAT**(auth,windows): add Windows support for Google Sign In ([#11861](https://github.com/firebase/flutterfire/issues/11861)). ([cde57d05](https://github.com/firebase/flutterfire/commit/cde57d059e099913efc994db27141540a2a981d1))

## 4.13.0

 - **FEAT**(firebase_auth): export `AuthProvider` from `firebase_auth_interface` ([#11470](https://github.com/firebase/flutterfire/issues/11470)). ([39881e7e](https://github.com/firebase/flutterfire/commit/39881e7e4671faa94b274d980aad81829e6e0bfc))
 - **FEAT**(windows): add platform logging for core, auth, firestore and storage ([#11790](https://github.com/firebase/flutterfire/issues/11790)). ([e7d428d1](https://github.com/firebase/flutterfire/commit/e7d428d14be1535a2d579d4b2d376fbb81f06742))

## 4.12.1

 - Update a dependency to the latest release.

## 4.12.0

 - **FEAT**(storage,windows): Add windows support ([#11617](https://github.com/firebase/flutterfire/issues/11617)). ([87ea02c8](https://github.com/firebase/flutterfire/commit/87ea02c8ae03eb351636cf202961ad0df6caebd8))

## 4.11.1

 - **FIX**(ios): fix clashing filenames between Auth and Firestore ([#11731](https://github.com/firebase/flutterfire/issues/11731)). ([8770cafc](https://github.com/firebase/flutterfire/commit/8770cafccccb11607b5530311e3150ac08cd172e))

## 4.11.0

 - **FIX**(auth): ensure `PigeonAuthCredential` is passed back to Dart side within try/catch ([#11683](https://github.com/firebase/flutterfire/issues/11683)). ([d42c3396](https://github.com/firebase/flutterfire/commit/d42c33969b096a9825af21c624f8d93aebede8b2))
 - **FEAT**: Full support of AGP 8 ([#11699](https://github.com/firebase/flutterfire/issues/11699)). ([bdb5b270](https://github.com/firebase/flutterfire/commit/bdb5b27084d225809883bdaa6aa5954650551927))
 - **FEAT**(firestore,windows): add support to Windows ([#11516](https://github.com/firebase/flutterfire/issues/11516)). ([e51d2a2d](https://github.com/firebase/flutterfire/commit/e51d2a2d287f4162f5a67d8200f1bf57fc2afe14))

## 4.10.1

 - Update a dependency to the latest release.

## 4.10.0

 - **FIX**(auth): deprecate `FirebaseAuth.instanceFor`'s `persistence` parameter ([#11259](https://github.com/firebase/flutterfire/issues/11259)). ([a1966e82](https://github.com/firebase/flutterfire/commit/a1966e82c15f13119cb28a262a57c67b4f2b8d3b))
 - **FIX**(auth,apple): `fetchSignInMethodsForEmail` if value is `nil`, pass empty array. ([#11596](https://github.com/firebase/flutterfire/issues/11596)). ([6d261cc9](https://github.com/firebase/flutterfire/commit/6d261cc9a147befbfd203004aff8565492567f58))
 - **FEAT**(core,windows): Change the windows plugin compiling way ([#11594](https://github.com/firebase/flutterfire/issues/11594)). ([3dab95e0](https://github.com/firebase/flutterfire/commit/3dab95e01f7f71680aff84db4e9dccfe1e77643b))
 - **FEAT**(auth,windows): add Windows support to auth plugin ([#11089](https://github.com/firebase/flutterfire/issues/11089)). ([0cedfc85](https://github.com/firebase/flutterfire/commit/0cedfc8580bedd9e21b262537e643dbace0d7114))
 - **DOCS**: firebase_auth description ([#11292](https://github.com/firebase/flutterfire/issues/11292)). ([d9e05713](https://github.com/firebase/flutterfire/commit/d9e057137dffca09ea293b5df7292d7b7b21ca99))
 - **DOCS**(auth): update the incorrect "getting started" link ([#11440](https://github.com/firebase/flutterfire/issues/11440)). ([5db956dc](https://github.com/firebase/flutterfire/commit/5db956dc935dfec5be28e0463f7e8499a20d5577))

## 4.9.0

 - **FEAT**(auth): TOTP (time-based one-time password) support for multi-factor authentication ([#11420](https://github.com/firebase/flutterfire/issues/11420)). ([3cc1243c](https://github.com/firebase/flutterfire/commit/3cc1243c94368de44d3a5c4be96b905a0a37b963))

## 4.8.0

 - **FEAT**(auth): `revokeTokenWithAuthorizationCode()` implementation for revoking Apple sign-in token ([#11454](https://github.com/firebase/flutterfire/issues/11454)). ([92de98c9](https://github.com/firebase/flutterfire/commit/92de98c9e62f2bf20712dbfed22dd39f6883eb58))

## 4.7.3

 - **FIX**(auth): rename import header to "firebase_auth_messages.g.h". ([#11472](https://github.com/firebase/flutterfire/issues/11472)). ([693a6f3c](https://github.com/firebase/flutterfire/commit/693a6f3cba3620933b905a964126406ae6ae3374))
 - **FIX**(firebase_auth): Fix forceRefresh parameter conversion before calling native API ([#11464](https://github.com/firebase/flutterfire/issues/11464)). ([86639876](https://github.com/firebase/flutterfire/commit/86639876b8e9138af740a1c74c122fcdb5c4566d))
 - **FIX**(auth): set the tenant id on iOS `FIRAuth` instance ([#11427](https://github.com/firebase/flutterfire/issues/11427)). ([15f3cf5d](https://github.com/firebase/flutterfire/commit/15f3cf5d9b86f287fac22370ea09abf9e773ea60))
 - **FIX**(firebase_auth,android): Remove implicit default locale used in error message ([#11321](https://github.com/firebase/flutterfire/issues/11321)). ([3a20f41c](https://github.com/firebase/flutterfire/commit/3a20f41c0d8a4d61d789874d7bb16d6ef710c9d1))

## 4.7.2

 - **FIX**(auth): fix MFA issue where the error wouldn't be properly caught ([#11370](https://github.com/firebase/flutterfire/issues/11370)). ([72fef03f](https://github.com/firebase/flutterfire/commit/72fef03f775702aaf9a2ce0c6b31aea2a3c200a9))
 - **FIX**(auth,android): `getIdToken()` `IllegalStateException` crash fix ([#11362](https://github.com/firebase/flutterfire/issues/11362)). ([e925b4c9](https://github.com/firebase/flutterfire/commit/e925b4c9a937d90de0bdfb59ffa005938b3862dd))
 - **FIX**(auth,apple): pass in Firebase auth instance for correct app when using Provider sign in ([#11284](https://github.com/firebase/flutterfire/issues/11284)). ([1cffae79](https://github.com/firebase/flutterfire/commit/1cffae79ded28808ba55f2f4c9c1b47817987999))

## 4.7.1

 - **FIX**(auth,android): Fix crash on Android where detaching from engine ([#11296](https://github.com/firebase/flutterfire/issues/11296)). ([d0a37332](https://github.com/firebase/flutterfire/commit/d0a373323a818d5005a58e95042b7ea3652ead50))
 - **FIX**(auth,ios): fix scoping of import for message.g.h, could cause incompatibility with other packages ([#11300](https://github.com/firebase/flutterfire/issues/11300)). ([91ccc57d](https://github.com/firebase/flutterfire/commit/91ccc57d4b40b1b7a77dc0d871f9ff7d3f24ba13))

## 4.7.0

 - **FEAT**(auth): move to Pigeon for Platform channels ([#10802](https://github.com/firebase/flutterfire/issues/10802)). ([43e5b20b](https://github.com/firebase/flutterfire/commit/43e5b20b14799102a6544a4763476eaba44b9cfb))

## 4.6.3

 - Update a dependency to the latest release.

## 4.6.2

 - Update a dependency to the latest release.

## 4.6.1

 - Update a dependency to the latest release.

## 4.6.0

 - **FEAT**: update dependency constraints to `sdk: '>=2.18.0 <4.0.0'` `flutter: '>=3.3.0'` ([#10946](https://github.com/firebase/flutterfire/issues/10946)). ([2772d10f](https://github.com/firebase/flutterfire/commit/2772d10fe510dcc28ec2d37a26b266c935699fa6))
 - **FEAT**: update libraries to be compatible with Flutter 3.10.0 ([#10944](https://github.com/firebase/flutterfire/issues/10944)). ([e1f5a5ea](https://github.com/firebase/flutterfire/commit/e1f5a5ea798c54f19d1d2f7b8f2250f8819f44b7))

## 4.5.0

 - **FIX**: add support for AGP 8.0 ([#10901](https://github.com/firebase/flutterfire/issues/10901)). ([a3b96735](https://github.com/firebase/flutterfire/commit/a3b967354294c295a9be8d699a6adb7f4b1dba7f))
 - **FEAT**: upgrade to dart 3 compatible dependencies ([#10890](https://github.com/firebase/flutterfire/issues/10890)). ([4bd7e59b](https://github.com/firebase/flutterfire/commit/4bd7e59b1f2b09a2230c49830159342dd4592041))

## 4.4.2

 - Update a dependency to the latest release.

## 4.4.1

 - Update a dependency to the latest release.

## 4.4.0

 - **FEAT**(auth,ios): automatically save the Apple Sign In display name ([#10652](https://github.com/firebase/flutterfire/issues/10652)). ([257f1ffb](https://github.com/firebase/flutterfire/commit/257f1ffbce7abd458df91d8e4b6422d83b5b849f))
 - **FEAT**: bump dart sdk constraint to 2.18 ([#10618](https://github.com/firebase/flutterfire/issues/10618)). ([f80948a2](https://github.com/firebase/flutterfire/commit/f80948a28b62eead358bdb900d5a0dfb97cebb33))

## 4.3.0

 - **FIX**(auth): fix an issue where unenroll would not throw a FirebaseException ([#10572](https://github.com/firebase/flutterfire/issues/10572)). ([8dba33e1](https://github.com/firebase/flutterfire/commit/8dba33e1a95f03d70d527885aa58ce23622e359f))
 - **FEAT**(auth): improve error handling when Email enumeration feature is on ([#10591](https://github.com/firebase/flutterfire/issues/10591)). ([ff083025](https://github.com/firebase/flutterfire/commit/ff083025b724d683cc3a9ed5f4a4987c43663589))

## 4.2.10

 - **FIX**(auth,web): fix currentUser being null when using emulator or named instance ([#10565](https://github.com/firebase/flutterfire/issues/10565)). ([11e8644d](https://github.com/firebase/flutterfire/commit/11e8644df402a5abbb0d0c37714879272dec024c))

## 4.2.9

 - Update a dependency to the latest release.

## 4.2.8

 - Update a dependency to the latest release.

## 4.2.7

 - Update a dependency to the latest release.

## 4.2.6

 - **REFACTOR**: upgrade project to remove warnings from Flutter 3.7 ([#10344](https://github.com/firebase/flutterfire/issues/10344)). ([e0087c84](https://github.com/firebase/flutterfire/commit/e0087c845c7526c11a4241a26d39d4673b0ad29d))

## 4.2.5

 - **FIX**: fix a null pointer exception that could occur when removing an even listener ([#10210](https://github.com/firebase/flutterfire/issues/10210)). ([72d2e973](https://github.com/firebase/flutterfire/commit/72d2e97363d89d716963dd224a2b9578ba446624))

## 4.2.4

 - Update a dependency to the latest release.

## 4.2.3

 - Update a dependency to the latest release.

## 4.2.2

 - Update a dependency to the latest release.

## 4.2.1

 - Update a dependency to the latest release.

## 4.2.0

 - **FEAT**: improve error message when user cancels a sign in with a provider ([#10060](https://github.com/firebase/flutterfire/issues/10060)). ([6631da6b](https://github.com/firebase/flutterfire/commit/6631da6b6b165a0c1e3260d744df1d60f3c7abe0))

## 4.1.5

 - **FIX**: Apple Sign In on a secondary app doesnt sign in the correct Firebase Auth instance ([#10018](https://github.com/firebase/flutterfire/issues/10018)). ([f746d5da](https://github.com/firebase/flutterfire/commit/f746d5da0c784e28f08b9fcedfce18933a9e448e))

## 4.1.4

 - **FIX**: tentative fix for null pointer exception in `parseUserInfoList` ([#9960](https://github.com/firebase/flutterfire/issues/9960)). ([dad17407](https://github.com/firebase/flutterfire/commit/dad1740792b893920867528039a9c54398ae7e3e))

## 4.1.3

 - **FIX**: fix reauthenticateWithProvider on iOS with Sign In With Apple that would throw a linked exception ([#9919](https://github.com/firebase/flutterfire/issues/9919)). ([7318a8f3](https://github.com/firebase/flutterfire/commit/7318a8f32de07bd47026d3e07b80b4bab5df1e6a))

## 4.1.2

 - Update a dependency to the latest release.

## 4.1.1

 - Update a dependency to the latest release.

## 4.1.0

 - **REFACTOR**: add `verify` to `QueryPlatform` and change internal `verifyToken` API to `verify` ([#9711](https://github.com/firebase/flutterfire/issues/9711)). ([c99a842f](https://github.com/firebase/flutterfire/commit/c99a842f3e3f5f10246e73f51530cc58c42b49a3))
 - **FIX**: properly propagate the `FirebaseAuthMultiFactorException` for all reauthenticate and link methods ([#9700](https://github.com/firebase/flutterfire/issues/9700)). ([9ad97c82](https://github.com/firebase/flutterfire/commit/9ad97c82ead0f5c6f1307625374c34e0dcde730b))
 - **FEAT**: expose reauthenticateWithRedirect and reauthenticateWithPopup ([#9696](https://github.com/firebase/flutterfire/issues/9696)). ([2a1f910f](https://github.com/firebase/flutterfire/commit/2a1f910ff6cab21a126c62fd4322a14ec263b629))

## 4.0.2

 - Update a dependency to the latest release.

## 4.0.1

- Update a dependency to the latest release.

## 4.0.0

> Note: This release has breaking changes.

 - **BREAKING** **FEAT**: Firebase iOS SDK version: `10.0.0` ([#9708](https://github.com/firebase/flutterfire/issues/9708)). ([9627c56a](https://github.com/firebase/flutterfire/commit/9627c56a37d657d0250b6f6b87d0fec1c31d4ba3))

## 3.11.2

 - **DOCS**: update `setSettings()` inline documentation ([#9655](https://github.com/firebase/flutterfire/issues/9655)). ([39ca0029](https://github.com/firebase/flutterfire/commit/39ca00299ec5c6e0f2dc9b0b5a8d71b8d59d51d4))

## 3.11.1

 - **FIX**: fix an iOS crash when using Sign In With Apple due to invalid return of nil instead of NSNull ([#9644](https://github.com/firebase/flutterfire/issues/9644)). ([3f76b53f](https://github.com/firebase/flutterfire/commit/3f76b53f375f4398652abfa7c9236571ee0bd87f))

## 3.11.0

 - **FEAT**: add OAuth Access Token support to sign in with providers ([#9593](https://github.com/firebase/flutterfire/issues/9593)). ([cb6661bb](https://github.com/firebase/flutterfire/commit/cb6661bbc701031d6f920ace3a6efc8e8d56aa4c))
 - **FEAT**: add `linkWithRedirect` to the web ([#9580](https://github.com/firebase/flutterfire/issues/9580)). ([d834b90f](https://github.com/firebase/flutterfire/commit/d834b90f29fc1929a195d7d546170e4ea03c6ab1))

## 3.10.0

 - **FIX**: fix path of generated Pigeon files to prevent name collision ([#9569](https://github.com/firebase/flutterfire/issues/9569)). ([71bde27d](https://github.com/firebase/flutterfire/commit/71bde27d4e613096f121abb16d7ea8483c3fbcd8))
 - **FEAT**: add `reauthenticateWithProvider` ([#9570](https://github.com/firebase/flutterfire/issues/9570)). ([dad6b481](https://github.com/firebase/flutterfire/commit/dad6b4813c682e35315dda3965ea8aaf5ba030e8))

## 3.9.0

 - **REFACTOR**: deprecate `signInWithAuthProvider` in favor of `signInWithProvider` ([#9542](https://github.com/firebase/flutterfire/issues/9542)). ([ca340ea1](https://github.com/firebase/flutterfire/commit/ca340ea19c8dbb340f083e48cf1b0de36f7d64c4))
 - **FEAT**: add `linkWithProvider` to support for linking auth providers ([#9535](https://github.com/firebase/flutterfire/issues/9535)). ([1ac14fb1](https://github.com/firebase/flutterfire/commit/1ac14fb147f83cf5c7874004a9dc61838dce8da8))

## 3.8.0

 - **FIX**: remove default scopes on iOS for Sign in With Apple ([#9477](https://github.com/firebase/flutterfire/issues/9477)). ([3fe02b29](https://github.com/firebase/flutterfire/commit/3fe02b2937135ea6d576c7e445da5f4266ff0fdf))
 - **FEAT**: add Twitter login for Android, iOS and Web ([#9421](https://github.com/firebase/flutterfire/issues/9421)). ([0bc6e6d5](https://github.com/firebase/flutterfire/commit/0bc6e6d5333e6be0d5749a083206f3f5bb79a7ba))
 - **FEAT**: add Yahoo as provider for iOS, Android and Web ([#9443](https://github.com/firebase/flutterfire/issues/9443)). ([6c3108a7](https://github.com/firebase/flutterfire/commit/6c3108a767aca3b1a844b2b5da04b2da45bc9fbd))
 - **DOCS**: fix typo "appearance" in `platform_interface_firebase_auth.dart` ([#9472](https://github.com/firebase/flutterfire/issues/9472)). ([323b917b](https://github.com/firebase/flutterfire/commit/323b917b5eecf0e5161a61c66f6cabac5b23e1b8))

## 3.7.0

 - **FEAT**: add Microsoft login for Android, iOS and Web ([#9415](https://github.com/firebase/flutterfire/issues/9415)). ([1610ce8a](https://github.com/firebase/flutterfire/commit/1610ce8ac96d6da202ef014e9a3dfeb4acfacec9))
 - **FEAT**: add Sign in with Apple directly in Firebase Auth for Android, iOS 13+ and Web ([#9408](https://github.com/firebase/flutterfire/issues/9408)). ([da36b986](https://github.com/firebase/flutterfire/commit/da36b9861b7d635382705b4893eed85fd672125c))

## 3.6.4

 - **FIX**: fix an error where MultifactorInfo factorId could be null on iOS ([#9367](https://github.com/firebase/flutterfire/issues/9367)). ([88bded11](https://github.com/firebase/flutterfire/commit/88bded119607473c7546154ac8bdd149a2d3f21f))

## 3.6.3

 - **FIX**: use correct UTC time from server for `currentUser?.metadata.creationTime` & `currentUser?.metadata.lastSignInTime` ([#9248](https://github.com/firebase/flutterfire/issues/9248)). ([a6204128](https://github.com/firebase/flutterfire/commit/a6204128edf1f54ac734385d0ed6214d50cebd1b))
 - **DOCS**: explicit mention that `refreshToken` is empty string on native platforms on the `User`instance ([#9183](https://github.com/firebase/flutterfire/issues/9183)). ([1aa1c163](https://github.com/firebase/flutterfire/commit/1aa1c1638edc632dedf8de0f02127e26b1a86e17))

## 3.6.2

 - **DOCS**: update `getIdTokenResult` inline documentation ([#9150](https://github.com/firebase/flutterfire/issues/9150)). ([519518ce](https://github.com/firebase/flutterfire/commit/519518ce3ed36580e35713e791281b251018201c))

## 3.6.1

 - Update a dependency to the latest release.

## 3.6.0

 - **FIX**: pass `Persistence` value to `FirebaseAuth.instanceFor(app: app, persistence: persistence)` for setting persistence on Web platform ([#9138](https://github.com/firebase/flutterfire/issues/9138)). ([ae7ebaf8](https://github.com/firebase/flutterfire/commit/ae7ebaf8e304a2676b2acfa68aadf0538468b4a0))
 - **FIX**: fix crash on Android where detaching from engine was not properly resetting the Pigeon handler ([#9218](https://github.com/firebase/flutterfire/issues/9218)). ([96d35df0](https://github.com/firebase/flutterfire/commit/96d35df09914fbe40515fdcd20b17a802f37270d))
 - **FEAT**: expose the missing MultiFactor classes through the universal package ([#9194](https://github.com/firebase/flutterfire/issues/9194)). ([d8bf8185](https://github.com/firebase/flutterfire/commit/d8bf818528c3705350cdb1b4675d600ba1d29d14))

## 3.5.1

 - Update a dependency to the latest release.

## 3.5.0

 - **FEAT**: add all providers available to MFA ([#9159](https://github.com/firebase/flutterfire/issues/9159)). ([5a03a859](https://github.com/firebase/flutterfire/commit/5a03a859385f0b06ad9afe8e8c706c046976b8d8))
 - **FEAT**: add phone MFA ([#9044](https://github.com/firebase/flutterfire/issues/9044)). ([1b85c8b7](https://github.com/firebase/flutterfire/commit/1b85c8b7fbcc3f21767f23981cb35061772d483f))

## 3.4.2

 - Update a dependency to the latest release.

## 3.4.1

 - **FIX**: bump `firebase_core_platform_interface` version to fix previous release. ([bea70ea5](https://github.com/firebase/flutterfire/commit/bea70ea5cbbb62cbfd2a7a74ae3a07cb12b3ee5a))

## 3.4.0

 - **FIX**: Web recaptcha hover removed after use. (#8812). ([790e450e](https://github.com/firebase/flutterfire/commit/790e450e8d6acd2fc50e0232c77a152430c7b3ea))
 - **FIX**: java.util.ConcurrentModificationException (#8967). ([dc6c04ae](https://github.com/firebase/flutterfire/commit/dc6c04aeb4fc535a8ccadf9c11fb4d5dc413606d))
 - **FEAT**: update GitHub sign in implementation (#8976). ([ffd3b019](https://github.com/firebase/flutterfire/commit/ffd3b019c3158c66476671d9a9df245035cc2295))

## 3.3.20

 - **REFACTOR**: use `firebase.google.com` link for `homepage` in `pubspec.yaml` (#8729). ([43df32d4](https://github.com/firebase/flutterfire/commit/43df32d457a28523f5956a2252dafd47856ac756))
 - **REFACTOR**: use "firebase" instead of "FirebaseExtended" as organisation in all links for this repository (#8791). ([d90b8357](https://github.com/firebase/flutterfire/commit/d90b8357db01d65e753021358668f0b129713e6b))
 - **FIX**: update firebase_auth example to not be dependent on an emulator (#8601). ([bdc9772e](https://github.com/firebase/flutterfire/commit/bdc9772ec8a3fb6609b66c42166d6d132ddb67d9))
 - **DOCS**: fix two typos. (#8876). ([7390d5c5](https://github.com/firebase/flutterfire/commit/7390d5c51e61aeb4d59c0d74093921fad3f35083))
 - **DOCS**: point to "firebase.google" domain for hyperlinks in the usage section of `README.md` files (#8814). ([78006e0d](https://github.com/firebase/flutterfire/commit/78006e0d5b9dce8038ce3606a43ddcbc8a4a71b9))

## 3.3.19

 - **DOCS**: use camel case style for "FlutterFire" in `README.md` (#8748). ([c6ff0b21](https://github.com/firebase/flutterfire/commit/c6ff0b21352eb0f9a9a576ca7ef737d203292a58))

## 3.3.18

 - Update a dependency to the latest release.

## 3.3.17

 - Update a dependency to the latest release.

## 3.3.16

 - **REFACTOR**: remove deprecated `Tasks.call()` API from Android. (#8452). ([3e92496b](https://github.com/firebase/flutterfire/commit/3e92496b2783ec149258c22d3167c5388dcb1c40))

## 3.3.15

 - **FIX**: Use iterator instead of enhanced for loop on android. (#8498). ([027c75a6](https://github.com/firebase/flutterfire/commit/027c75a60b39a40e6a3edc12edc51487cc954503))

## 3.3.14

 - Update a dependency to the latest release.

## 3.3.13

 - Update a dependency to the latest release.

## 3.3.12

 - Update a dependency to the latest release.

## 3.3.11

 - **FIX**: Update APN token once auth plugin has been initialized on `iOS`. (#8201). ([ab6239dd](https://github.com/firebase/flutterfire/commit/ab6239ddf5cb14211b76bced04ec52203919a57a))

## 3.3.10

 - **FIX**: return correct error code for linkWithCredential `provider-already-linked` on Android (#8245). ([ae090719](https://github.com/firebase/flutterfire/commit/ae090719ebbb0873cf227f76004feeae9a7d0580))
 - **FIX**: Fixed bug that sets email to `nil` on `iOS` when the `User` has no provider. (#8209). ([fb646438](https://github.com/firebase/flutterfire/commit/fb646438f219b0f0f7c6a8c52e2b9daa4afc833e))

## 3.3.9

 - **FIX**: update all Dart SDK version constraints to Dart >= 2.16.0 (#8184). ([df4a5bab](https://github.com/firebase/flutterfire/commit/df4a5bab3c029399b4f257a5dd658d302efe3908))

## 3.3.8

 - Update a dependency to the latest release.

## 3.3.7

 - **DOCS**: Update documentation for `currentUser` property to make expectations clearer. (#7843). ([59bb47c2](https://github.com/firebase/flutterfire/commit/59bb47c2490fbd641a1fcc26f2f888e8f4f02671))

## 3.3.6

 - Update a dependency to the latest release.

## 3.3.5

 - **FIX**: bump Android `compileSdkVersion` to 31 (#7726). ([a9562bac](https://github.com/firebase/flutterfire/commit/a9562bac60ba927fb3664a47a7f7eaceb277dca6))

## 3.3.4

 - **REFACTOR**: fix all `unnecessary_import` analyzer issues introduced with Flutter 2.8. ([7f0e82c9](https://github.com/firebase/flutterfire/commit/7f0e82c978a3f5a707dd95c7e9136a3e106ff75e))

## 3.3.3

 - Update a dependency to the latest release.

## 3.3.2

 - **DOCS**: Fix typos and remove unused imports (#7504).

## 3.3.1

 - Update a dependency to the latest release.

## 3.3.0

 - **REFACTOR**: migrate remaining examples & e2e tests to null-safety (#7393).
 - **FEAT**: automatically inject Firebase JS SDKs (#7359).

## 3.2.0

 - **FEAT**: support initializing default `FirebaseApp` instances from Dart (#6549).

## 3.1.5

 - Update a dependency to the latest release.

## 3.1.4

 - **REFACTOR**: remove deprecated Flutter Android v1 Embedding usages, including in example app (#7158).
 - **STYLE**: macOS & iOS; explicitly include header that defines `TARGET_OS_OSX` (#7116).

## 3.1.3

 - **REFACTOR**: migrate example app to null-safety (#7111).

## 3.1.2

 - **FIX**: allow setLanguage to accept null (#7050).
 - **CHORE**: remove google-signin plugin temporarily to fix CI (#7047).

## 3.1.1

 - **FIX**: use Locale.ROOT while processing error code (#6946).

## 3.1.0

 - **FEAT**: expose linkWithPopup() & correctly parse credentials in exceptions (#6562).

## 3.0.2

 - **STYLE**: enable additional lint rules (#6832).
 - **FIX**: precise error message is propagated (#6793).
 - **FIX**: Use angle bracket import consistently when importing Firebase.h for iOS (#5891).
 - **FIX**: stop idTokenChanges & userChanges firing twice on initial listen (#6560).

## 3.0.1

 - **FIX**: reinstate deprecated emulator apis (#6626).

## 3.0.0

> Note: This release has breaking changes.

 - **FEAT**: setSettings now possible for android (#6367).
 - **DOCS**: phone provider account linking update (#6465).
 - **CHORE**: update v2 embedding support (#6506).
 - **CHORE**: verifyPhoneNumber() example (#6476).
 - **CHORE**: rm deprecated jcenter repository (#6431).
 - **BREAKING** **FEAT**: use<product>Emulator(host, port) API update (#6439).

## 2.0.0

> Note: This release has breaking changes.

 - **FEAT**: setSettings now possible for android (#6367).
 - **DOCS**: phone provider account linking update (#6465).
 - **CHORE**: verifyPhoneNumber() example (#6476).
 - **CHORE**: rm deprecated jcenter repository (#6431).
 - **BREAKING** **FEAT**: useAuthEmulator(host, port) API update.

## 1.4.1

 - Update a dependency to the latest release.

## 1.4.0

 - **FEAT**: add tenantId support  (#5736).

## 1.3.0

 - **FEAT**: add User.updateDisplayName and User.updatePhotoURL (#6213).
 - **DOCS**: Add Flutter Favorite badge (#6190).

## 1.2.0

 - **FEAT**: upgrade Firebase JS SDK version to 8.6.1.
 - **FIX**: podspec osx version checking script should use a version range instead of a single fixed version.

## 1.1.4

 - **FIX**: correctly cleanup Dictionary handlers (#6101).
 - **DOCS**: Update the documentation of sendPasswordResetEmail (#6051).
 - **CHORE**: publish packages (#6022).
 - **CHORE**: publish packages.

## 1.1.3

 - **FIX**: Fix firebase_auth not being registered as a plugin (#5987).
 - **CI**: refactor to use Firebase Auth emulator (#5939).

## 1.1.2

 - **FIX**: fixed an issue where Web could not connect to the Firebase Auth emulator (#5940).
 - **FIX**: Import all necessary headers from the header file. (#5890).
 - **FIX**: Move communication to EventChannels (#4643).
 - **DOCS**: remove implicit-cast in the doc of AuthProviders (#5862).

## 1.1.1

 - **FIX**: ensure web is initialized before sending stream events (#5766).
 - **DOCS**: Add UserInfoCard widget in auth example SignInPage (#4635).
 - **CI**: fix analyzer issues in example.
 - **CHORE**: update Web plugins to use Firebase JS SDK version 8.4.1 (#4464).

## 1.1.0

 - **FEAT**: PhoneAuthProvider.credential and PhoneAuthProvider.credentialFromToken now return a PhoneAuthCredential (#5675).
 - **CHORE**: update drive dependency (#5740).

## 1.0.3

 - **DOCS**: userChanges clarification (#5698).

## 1.0.2

 - Update a dependency to the latest release.

## 1.0.1

 - **DOCS**: note that auth emulator is not supported for web (#5169).

## 1.0.0

 - Graduate package to a stable release. See pre-releases prior to this version for changelog entries.

## 1.0.0-1.0.nullsafety.0

 - Bump "firebase_auth" to `1.0.0-1.0.nullsafety.0`.

## 0.21.0-1.1.nullsafety.3

 - Update a dependency to the latest release.

## 0.21.0-1.1.nullsafety.2

 - **TESTS**: update mockito API usage in tests

## 0.21.0-1.1.nullsafety.1

 - **REFACTOR**: pubspec & dependency updates (#4932).

## 0.21.0-1.1.nullsafety.0

 - **FEAT**: implement support for `useEmulator` (#4263).

## 0.21.0-1.0.nullsafety.0

 - **FIX**: bump firebase_core_* package versions to updated NNBD versioning format (#4832).

## 0.21.0-nullsafety.0

 - **FEAT**: Migrated to null safety (#4633)

## 0.20.0+1

 - **FIX**: package compatibility.

## 0.20.0

> Note: This release has breaking changes.

 - **FIX**: null pointer exception if user metadata null (#4622).
 - **FEAT**: add check on podspec to assist upgrading users deployment target.
 - **BUILD**: commit Podfiles with 10.12 deployment target.
 - **BUILD**: remove default sdk version, version should always come from firebase_core, or be user defined.
 - **BUILD**: set macOS deployment target to 10.12 (from 10.11).
 - **BREAKING** **BUILD**: set osx min supported platform version to 10.12.

## 0.19.0+1

 - Update a dependency to the latest release.

## 0.19.0

> Note: This release has breaking changes.

 - **CHORE**: harmonize dependencies and version handling.
 - **BREAKING** **REFACTOR**: remove all currently deprecated APIs.
 - **BREAKING** **FEAT**: forward port to firebase-ios-sdk v7.3.0.
   - Due to this SDK upgrade, iOS 10 is now the minimum supported version by FlutterFire. Please update your build target version.

## 0.18.4+1

 - Update a dependency to the latest release.

## 0.18.4

 - **FEAT**: bump android `com.android.tools.build` & `'com.google.gms:google-services` versions (#4269).
 - **DOCS**: Fixed two typos in method documentation (#4219).

## 0.18.3+1

 - **TEST**: Explicitly opt-out from null safety.
 - **FIX**: stop authStateChange firing twice for initial event (#4099).
 - **FIX**: updated email link signin to use latest format for ActionCodeSettings (#3425).
 - **CHORE**: add missing dependency to example app.
 - **CHORE**: bump gradle wrapper to 5.6.4 (#4158).

## 0.18.3

 - **FEAT**: migrate firebase interop files to local repository (#3973).
 - **FEAT**: bump `compileSdkVersion` to 29 in preparation for upcoming Play Store requirement.
 - **FEAT** [WEB] adds support for `EmailAuthProvider.credentialWithLink`
 - **FEAT** [WEB] adds support for `FirebaseAuth.setSettings`
 - **FEAT** [WEB] adds support for `User.tenantId`
 - **FEAT** [WEB] `FirebaseAuthException` now supports `email` & `credential` properties
 - **FEAT** [WEB] `ActionCodeInfo` now supports `previousEmail` field

## 0.18.2

 - **FEAT**: bump compileSdkVersion to 29 (#3975).
 - **FEAT**: update Firebase iOS SDK version to 6.33.0 (from 6.26.0).

## 0.18.1+2

 - **FIX**: on iOS use sendEmailVerificationWithActionCodeSettings instead of sendEmailVerificationWithCompletion (#3686).
 - **DOCS**: README updates (#3768).

## 0.18.1+1

 - **FIX**: Optional params for "signInWithCredential" method are converted to "nil" if "null" for iOS (#3731).

## 0.18.1

 - **FIX**: local dependencies in example apps (#3319).
 - **FIX**: fix IdTokenResult timestamps (web, ios) (#3357).
 - **FIX**: pub.dev score fixes (#3318).
 - **FIX**: use unknown APNS token type (#3345).
 - **FIX**: update FLTFirebaseAuthPlugin.m (#3360).
 - **FIX**: use correct FIRAuth instance on listeners (#3316).
 - **FEAT**: add support for linkWithPhoneNumber (#3436).
 - **FEAT**: use named arguments for ActionCodeSettings (#3269).
 - **FEAT**: implement signInWithPhoneNumber on web (#3205).
 - **FEAT**: expose smsCode (android only) (#3308).
 - **DOCS**: fixed signOut method documentation (#3342).

## 0.18.0+1

* Fixed an Android issue where certain network related Firebase Auth error codes would come through as `unknown`. [(#3217)](https://github.com/firebase/flutterfire/pull/3217)
* Added missing deprecations: `FirebaseUser` class and `photoUrl` getter.
* Bump `firebase_auth_platform_interface` dependency to fix an assertion issue when creating Google sign-in credentials.
* Bump `firebase_auth_web` dependency to `^0.3.0+1`.

## 0.18.0

Overall, Firebase Auth has been heavily reworked to bring it inline with the federated plugin setup along with adding new features, documentation and many more unit and end-to-end tests. The API has mainly been kept the same, however there are some breaking changes.

### General

- **BREAKING**: The `FirebaseUser` class has been renamed to `User`.
- **BREAKING**: The `AuthResult` class has been renamed to `UserCredential`.
- **NEW**: The `ActionCodeSettings` class is now consumable on all supporting methods.
  - **NEW**: Added support for the `dynamicLinkDomain` property.
- **NEW**: Added a new `FirebaseAuthException` class (extends `FirebaseException`).
  - All errors are now returned as a `FirebaseAuthException`, allowing you to access the code & message associated with the error.
  - In addition, it is now possible to access the `email` and `credential` properties on exceptions if they exist.

### `FirebaseAuth`

- **BREAKING**: Accessing the current user via `currentUser()` is now synchronous via the `currentUser` getter.
- **BREAKING**: `isSignInWithEmailLink()` is now synchronous.
- **DEPRECATED**: `FirebaseAuth.fromApp()` is now deprecated in favor of `FirebaseAuth.instanceFor()`.
- **DEPRECATED**: `onAuthStateChanged` has been deprecated in favor of `authStateChanges()`.
- **NEW**: Added support for `idTokenChanges()` stream listener.
- **NEW**: Added support for `userChanges()` stream listener.
  - The purpose of this API is to allow users to subscribe to all user events without having to manually hydrate app state in cases where a manual reload was required (e.g. `updateProfile()`).
- **NEW**: Added support for `applyActionCode()`.
- **NEW**: Added support for `checkActionCode()`.
- **NEW**: Added support for `verifyPasswordResetCode()`.
- **NEW**: Added support for accessing the current language code via the `languageCode` getter.
- **NEW**: `setLanguageCode()` now supports providing a `null` value.
  - On web platforms, if `null` is provided the Firebase projects default language will be set.
  - On native platforms, if `null` is provided the device language will be used.
- **NEW**: `verifyPhoneNumber()` exposes a `autoRetrievedSmsCodeForTesting` property.
  - This allows developers to test automatic SMS code resolution on Android devices during development.
- **NEW** (iOS): `appVerificationDisabledForTesting`  setting can now be set for iOS.
  - This allows developers to skip ReCaptcha verification when testing phone authentication.
- **NEW** (iOS): `userAccessGroup` setting can now be set for iOS & MacOS.
  - This allows developers to share authentication states across multiple apps or extensions on iOS & MacOS. For more information see the [Firebase iOS SDK documentation](https://firebase.google.com/docs/auth/ios/single-sign-on).

### `User`

- **BREAKING**: Removed the `UpdateUserInfo` class when using `updateProfile` in favor of named arguments.
- **NEW**: Added support for `getIdTokenResult()`.
- **NEW**: Added support for `verifyBeforeUpdateEmail()`.
- **FIX**: Fixed several iOS crashes when the Firebase SDK returned `nil` property values.
- **FIX**: Fixed an issue on Web & iOS where a users email address would still show after unlinking the email/password provider.

### `UserCredential`

- **NEW**: Added support for accessing the users `AuthCredential` via the `credential` property.

### `AuthProvider` & `AuthCredential`

- **DEPRECATED**: All sub-class (e.g. `GoogleAuthProvider`) `getCredential()` methods have been deprecated in favor of `credential()`.
  - **DEPRECATED**:  `EmailAuthProvider.getCredentialWithLink()` has been deprecated in favor of `EmailAuthProvider.credentialWithLink()`.
- **NEW**: Supporting providers can now assign scope and custom request parameters.
  - The scope and parameters will be used on web platforms when triggering a redirect or popup via `signInWithPopup()` or `signInWithRedirect()`.

## 0.17.0-dev.2

* Update plugin and example to use the same core.

## 0.17.0-dev.1

* Depend on `firebase_core` pre-release versions.

## 0.16.1+2

* Update README to make it clear which authentication options are possible.

## 0.16.1+1

* Fix bug #2656 (verifyPhoneNumber always use the default FirebaseApp, not the configured one)

## 0.16.1

* Update lower bound of dart dependency to 2.0.0.

## 0.16.0

* Migrate to Android v2 embedding.

## 0.15.5+3

* Fix for missing UserAgent.h compilation failures.

## 0.15.5+2

* Update the platform interface dependency to 1.1.7 and update tests.

## 0.15.5+1

* Make the pedantic dev_dependency explicit.

## 0.15.5

* Add macOS support

## 0.15.4+1

* Fix fallthrough bug in Android code.

## 0.15.4

* Add support for `confirmPasswordReset` on Android and iOS.

## 0.15.3+1

* Add integration instructions for the `web` platform.

## 0.15.3

* Add support for OAuth Authentication for iOS and Android to solve generic providers authentication.

## 0.15.2

* Add web support by default.
* Require Flutter SDK 1.12.13+hotfix.4 or later.

## 0.15.1+1

* Remove the deprecated `author:` field from pubspec.yaml
* Migrate the plugin to the pubspec platforms manifest.
* Bump the minimum Flutter version to 1.10.0.

## 0.15.1

* Migrate to use `firebase_auth_platform_interface`.

## 0.15.0+2

*  Update homepage since this package was moved.

## 0.15.0+1

*  Added missing ERROR_WRONG_PASSWORD Exception to the `reauthenticateWithCredential` docs.

## 0.15.0

* Fixed `NoSuchMethodError` in `reauthenticateWithCredential`.
* Fixed `IdTokenResult` analyzer warnings.
* Reduced visibility of `IdTokenResult` constructor.

## 0.14.0+10

* Formatted lists in member documentations for better readability.

## 0.14.0+9

* Fix the behavior of `getIdToken` to use the `refresh` parameter instead of always refreshing.

## 0.14.0+8

* Updated README instructions for contributing for consistency with other Flutterfire plugins.

## 0.14.0+7

* Remove AndroidX warning.

## 0.14.0+6

* Update example app with correct const constructors.

## 0.14.0+5

* On iOS, `fetchSignInMethodsForEmail` now returns an empty list when the email
  cannot be found, matching the Android behavior.

## 0.14.0+4

* Fixed "Register a user" example code snippet in README.md.

## 0.14.0+3

* Update documentation to reflect new repository location.
* Update unit tests to call `TestWidgetsFlutterBinding.ensureInitialized`.
* Remove executable bit on LICENSE file.

## 0.14.0+2

* Reduce compiler warnings on iOS port by replacing `int` with `long` backing in returned timestamps.

## 0.14.0+1

* Add dependency on `androidx.annotation:annotation:1.0.0`.

## 0.14.0

* Added new `IdTokenResult` class.
* **Breaking Change**. `getIdToken()` method now returns `IdTokenResult` instead of a token `String`.
  Use the `token` property of `IdTokenResult` to retrieve the token `String`.
* Added integration testing for `getIdToken()`.

## 0.13.1+1

* Update authentication example in README.

## 0.13.1

* Fixed a crash on iOS when sign-in fails.
* Additional integration testing.
* Updated documentation for `FirebaseUser.delete()` to include error codes.
* Updated Firebase project to match other Flutterfire apps.

## 0.13.0

* **Breaking change**: Replace `FirebaseUserMetadata.creationTimestamp` and
  `FirebaseUserMetadata.lastSignInTimestamp` with `creationTime` and `lastSignInTime`.
  Previously on iOS `creationTimestamp` and `lastSignInTimestamp` returned in
  seconds and on Android in milliseconds. Now, both platforms provide values as a
  `DateTime`.

## 0.12.0+1

* Fixes iOS sign-in exceptions when `additionalUserInfo` is `nil` or has `nil` fields.
* Additional integration testing.

## 0.12.0

* Added new `AuthResult` and `AdditionalUserInfo` classes.
* **Breaking Change**. Sign-in methods now return `AuthResult` instead of `FirebaseUser`.
  Retrieve the `FirebaseUser` using the `user` property of `AuthResult`.

## 0.11.1+12

* Update google-services Android gradle plugin to 4.3.0 in documentation and examples.

## 0.11.1+11

* On iOS, `getIdToken()` now uses the `refresh` parameter instead of always using `true`.

## 0.11.1+10

* On Android, `providerData` now includes `UserInfo` for the phone authentication provider.

## 0.11.1+9

* Update README to clarify importance of filling out all fields for OAuth consent screen.

## 0.11.1+8

* Automatically register for iOS notifications, ensuring that phone authentication
  will work even if Firebase method swizzling is disabled.

## 0.11.1+7

* Automatically use version from pubspec.yaml when reporting usage to Firebase.

## 0.11.1+6

* Add documentation of support email requirement to README.

## 0.11.1+5

* Fix `updatePhoneNumberCredential` on Android.

## 0.11.1+4

* Fix `updatePhoneNumberCredential` on iOS.

## 0.11.1+3

* Add missing template type parameter to `invokeMethod` calls.
* Bump minimum Flutter version to 1.5.0.
* Replace invokeMethod with invokeMapMethod wherever necessary.
* FirebaseUser private constructor takes `Map<String, dynamic>` instead of `Map<dynamic, dynamic>`.

## 0.11.1+2

* Suppress deprecation warning for BinaryMessages. See: https://github.com/flutter/flutter/issues/33446

## 0.11.1+1

* Updated the error code documentation for `linkWithCredential`.

## 0.11.1

* Support for `updatePhoneNumberCredential`.

## 0.11.0

* **Breaking change**: `linkWithCredential` is now a function of `FirebaseUser`instead of
  `FirebaseAuth`.
* Added test for newer `linkWithCredential` function.

## 0.10.0+1

* Increase Firebase/Auth CocoaPod dependency to '~> 6.0'.

## 0.10.0

* Update firebase_dynamic_links dependency.
* Update Android dependencies to latest.

## 0.9.0

* **Breaking change**: `PhoneVerificationCompleted` now provides an `AuthCredential` that can
  be used with `signInWithCredential` or `linkWithCredential` instead of signing in automatically.
* **Breaking change**: Remove internal counter `nextHandle` from public API.

## 0.8.4+5

* Increase Firebase/Auth CocoaPod dependency to '~> 5.19'.

## 0.8.4+4

* Update FirebaseAuth CocoaPod dependency to ensure availability of `FIRAuthErrorUserInfoNameKey`.

## 0.8.4+3

* Updated deprecated API usage on iOS to use non-deprecated versions.
* Updated FirebaseAuth CocoaPod dependency to ensure a minimum version of 5.0.

## 0.8.4+2

* Fixes an error in the documentation of createUserWithEmailAndPassword.

## 0.8.4+1

* Adds credential for email authentication with link.

## 0.8.4

* Adds support for email link authentication.

## 0.8.3

* Make providerId 'const String' to use in 'case' statement.

## 0.8.2+1

* Fixed bug where `PhoneCodeAutoRetrievalTimeout` callback was never called.

## 0.8.2

* Fixed `linkWithCredential` on Android.

## 0.8.1+5

* Added a driver test.

## 0.8.1+4

* Update README.
* Update the example app with separate pages for registration and sign-in.

## 0.8.1+3

* Reduce compiler warnings in Android plugin
* Raise errors early when accessing methods that require a Firebase User

## 0.8.1+2

* Log messages about automatic configuration of the default app are now less confusing.

## 0.8.1+1

* Remove categories.

## 0.8.1

* Fixes Firebase auth phone sign-in for Android.

## 0.8.0+3

* Log a more detailed warning at build time about the previous AndroidX
  migration.

## 0.8.0+2

* Update Google sign-in example in the README.

## 0.8.0+1

* Update a broken dependency.

## 0.8.0

* **Breaking change**. Migrate from the deprecated original Android Support
  Library to AndroidX. This shouldn't result in any functional changes, but it
  requires any Android apps using this plugin to [also
  migrate](https://developer.android.com/jetpack/androidx/migrate) if they're
  using the original support library.

## 0.7.0

* Introduce third-party auth provider classes that generate `AuthCredential`s
* **Breaking Change** Signing in, linking, and reauthenticating now require an `AuthCredential`
* **Breaking Change** Unlinking now uses providerId
* **Breaking Change** Moved reauthentication to FirebaseUser

## 0.6.7

* `FirebaseAuth` and `FirebaseUser` are now fully documented.
* `PlatformExceptions` now report error codes as stated in docs.
* Credentials can now be unlinked from Accounts with new methods on `FirebaseUser`.

## 0.6.6

* Users can now reauthenticate in response to operations that require a recent sign-in.

## 0.6.5

* Fixing async method `verifyPhoneNumber`, that would never return even in a successful call.

## 0.6.4

* Added support for Github signin and linking Github accounts to existing users.

## 0.6.3

* Add multi app support.

## 0.6.2+1

* Bump Android dependencies to latest.

## 0.6.2

* Add access to user metadata.

## 0.6.1

* Adding support for linkWithTwitterCredential in FirebaseAuth.

## 0.6.0

* Added support for `updatePassword` in `FirebaseUser`.
* **Breaking Change** Moved `updateEmail` and `updateProfile` to `FirebaseUser`.
  This brings the `firebase_auth` package inline with other implementations and documentation.

## 0.5.20

* Replaced usages of guava's: ImmutableList and ImmutableMap with platform
Collections.unmodifiableList() and Collections.unmodifiableMap().

## 0.5.19

* Update test package dependency to pick up Dart 2 support.
* Modified dependency on google_sign_in to point to a published
  version instead of a relative path.

## 0.5.18

* Adding support for updateEmail in FirebaseAuth.

## 0.5.17

* Adding support for FirebaseUser.delete.

## 0.5.16

* Adding support for setLanguageCode in FirebaseAuth.

## 0.5.15

* Bump Android and Firebase dependency versions.

## 0.5.14

* Fixed handling of auto phone number verification.

## 0.5.13

* Add support for phone number authentication.

## 0.5.12

* Fixed ArrayIndexOutOfBoundsException in handleStopListeningAuthState

## 0.5.11

* Updated Gradle tooling to match Android Studio 3.1.2.

## 0.5.10

* Updated iOS implementation to reflect Firebase API changes.

## 0.5.9

* Added support for signing in with a Twitter account.

## 0.5.8

* Added support to reload firebase user

## 0.5.7

* Added support to sendEmailVerification

## 0.5.6

* Added support for linkWithFacebookCredential

## 0.5.5

* Updated Google Play Services dependencies to version 15.0.0.

## 0.5.4

* Simplified podspec for Cocoapods 1.5.0, avoiding link issues in app archives.

## 0.5.3

* Secure fetchProvidersForEmail (no providers)

## 0.5.2

* Fixed Dart 2 type error in fetchProvidersForEmail.

## 0.5.1

* Added support to fetchProvidersForEmail

## 0.5.0

* **Breaking change**. Set SDK constraints to match the Flutter beta release.

## 0.4.7

* Fixed Dart 2 type errors.

## 0.4.6

* Fixed Dart 2 type errors.

## 0.4.5

* Enabled use in Swift projects.

## 0.4.4

* Added support for sendPasswordResetEmail

## 0.4.3

* Moved to the io.flutter.plugins organization.

## 0.4.2

* Added support for changing user data

## 0.4.1

* Simplified and upgraded Android project template to Android SDK 27.
* Updated package description.

## 0.4.0

* **Breaking change**. Upgraded to Gradle 4.1 and Android Studio Gradle plugin
  3.0.1. Older Flutter projects need to upgrade their Gradle setup as well in
  order to use this version of the plugin. Instructions can be found
  [here](https://github.com/flutter/flutter/wiki/Updating-Flutter-projects-to-Gradle-4.1-and-Android-Studio-Gradle-plugin-3.0.1).
* Relaxed GMS dependency to [11.4.0,12.0[

## 0.3.2

* Added FLT prefix to iOS types
* Change GMS dependency to 11.4.+

## 0.3.1

* Change GMS dependency to 11.+

## 0.3.0

* **Breaking Change**: Method FirebaseUser getToken was renamed to getIdToken.

## 0.2.5

* Added support for linkWithCredential with Google credential

## 0.2.4

* Added support for `signInWithCustomToken`
* Added `Stream<FirebaseUser> onAuthStateChanged` event to listen when the user change

## 0.2.3+1

* Aligned author name with rest of repo.

## 0.2.3

* Remove dependency on Google/SignIn

## 0.2.2

* Remove dependency on FirebaseUI

## 0.2.1

* Added support for linkWithEmailAndPassword

## 0.2.0

* **Breaking Change**: Method currentUser is async now.

## 0.1.2

* Added support for signInWithFacebook

## 0.1.1

* Updated to Firebase SDK to always use latest patch version for 11.0.x builds

## 0.1.0

* Updated to Firebase SDK Version 11.0.1
* **Breaking Change**: You need to add a maven section with the "https://maven.google.com" endpoint to the repository section of your `android/build.gradle`. For example:
```gradle
allprojects {
    repositories {
        jcenter()
        maven {                              // NEW
            url "https://maven.google.com"   // NEW
        }                                    // NEW
    }
}
```

## 0.0.4

* Add method getToken() to FirebaseUser

## 0.0.3+1

* Updated README.md

## 0.0.3

* Added support for createUserWithEmailAndPassword, signInWithEmailAndPassword, and signOut Firebase methods

## 0.0.2+1

* Updated README.md

## 0.0.2

* Bump buildToolsVersion to 25.0.3

## 0.0.1

* Initial Release

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/README.md

**크기**: 1376 bytes | **라인 수**: 27 | **타입**: text

```
[<img src="https://raw.githubusercontent.com/firebase/flutterfire/main/.github/images/flutter_favorite.png" width="200" />](https://flutter.dev/docs/development/packages-and-plugins/favorites)

# Firebase Auth for Flutter
[![pub package](https://img.shields.io/pub/v/firebase_auth.svg)](https://pub.dev/packages/firebase_auth)

A Flutter plugin to use the [Firebase Authentication API](https://firebase.google.com/products/auth/).

To learn more about Firebase Auth, please visit the [Firebase website](https://firebase.google.com/products/auth)

## Getting Started

To get started with Firebase Auth for Flutter, please [see the documentation](https://firebase.google.com/docs/auth/flutter/start).

## Usage

To use this plugin, please visit the [Authentication Usage documentation](https://firebase.google.com/docs/auth/flutter/manage-users)

## Issues and feedback

Please file FlutterFire specific issues, bugs, or feature requests in our [issue tracker](https://github.com/firebase/flutterfire/issues/new).

Plugin issues that are not specific to FlutterFire can be filed in the [Flutter issue tracker](https://github.com/flutter/flutter/issues/new).

To contribute a change to this plugin,
please review our [contribution guide](https://github.com/firebase/flutterfire/blob/main/CONTRIBUTING.md)
and open a [pull request](https://github.com/firebase/flutterfire/pulls).

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_auth/pubspec.yaml

**크기**: 1202 bytes | **라인 수**: 52 | **타입**: text

```
name: firebase_auth
description: Flutter plugin for Firebase Auth, enabling
  authentication using passwords, phone numbers and identity providers
  like Google, Facebook and Twitter.
homepage: https://firebase.google.com/docs/auth
repository: https://github.com/firebase/flutterfire/tree/main/packages/firebase_auth/firebase_auth
version: 6.1.0
topics:
  - firebase
  - authentication
  - identity
  - sign-in
  - sign-up

false_secrets:
  - example/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.16.0'

dependencies:
  firebase_auth_platform_interface: ^8.1.2
  firebase_auth_web: ^6.0.3
  firebase_core: ^4.1.1
  firebase_core_platform_interface: ^6.0.1
  flutter:
    sdk: flutter
  meta: ^1.8.0
dev_dependencies:
  async: ^2.5.0
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0
  plugin_platform_interface: ^2.1.3

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.auth
        pluginClass: FlutterFirebaseAuthPlugin
      ios:
        pluginClass: FLTFirebaseAuthPlugin
      macos:
        pluginClass: FLTFirebaseAuthPlugin
      web:
        default_package: firebase_auth_web
      windows:
        pluginClass: FirebaseAuthPluginCApi


```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/java/io/flutter/plugins/firebase/core/FlutterFirebaseCorePlugin.java

**크기**: 11328 bytes | **라인 수**: 303 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
package io.flutter.plugins.firebase.core;

import static io.flutter.plugins.firebase.core.FlutterFirebasePlugin.cachedThreadPool;

import android.content.Context;
import android.os.Looper;
import androidx.annotation.NonNull;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.TaskCompletionSource;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import io.flutter.embedding.engine.plugins.FlutterPlugin;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Flutter plugin implementation controlling the entrypoint for the Firebase SDK.
 *
 * <p>Instantiate this in an add to app scenario to gracefully handle activity and context changes.
 */
public class FlutterFirebaseCorePlugin
    implements FlutterPlugin,
        GeneratedAndroidFirebaseCore.FirebaseCoreHostApi,
        GeneratedAndroidFirebaseCore.FirebaseAppHostApi {
  private Context applicationContext;
  private boolean coreInitialized = false;

  public static Map<String, String> customAuthDomain = new HashMap<>();

  @Override
  public void onAttachedToEngine(FlutterPluginBinding binding) {
    GeneratedAndroidFirebaseCore.FirebaseCoreHostApi.setUp(binding.getBinaryMessenger(), this);
    GeneratedAndroidFirebaseCore.FirebaseAppHostApi.setUp(binding.getBinaryMessenger(), this);
    applicationContext = binding.getApplicationContext();
  }

  @Override
  public void onDetachedFromEngine(@NonNull FlutterPluginBinding binding) {
    applicationContext = null;
    GeneratedAndroidFirebaseCore.FirebaseCoreHostApi.setUp(binding.getBinaryMessenger(), null);
    GeneratedAndroidFirebaseCore.FirebaseAppHostApi.setUp(binding.getBinaryMessenger(), null);
  }

  private GeneratedAndroidFirebaseCore.CoreFirebaseOptions firebaseOptionsToMap(
      FirebaseOptions options) {
    GeneratedAndroidFirebaseCore.CoreFirebaseOptions.Builder firebaseOptions =
        new GeneratedAndroidFirebaseCore.CoreFirebaseOptions.Builder();

    firebaseOptions.setApiKey(options.getApiKey());
    firebaseOptions.setAppId(options.getApplicationId());
    if (options.getGcmSenderId() != null) {
      firebaseOptions.setMessagingSenderId(options.getGcmSenderId());
    }
    if (options.getProjectId() != null) {
      firebaseOptions.setProjectId(options.getProjectId());
    }
    firebaseOptions.setDatabaseURL(options.getDatabaseUrl());
    firebaseOptions.setStorageBucket(options.getStorageBucket());
    firebaseOptions.setTrackingId(options.getGaTrackingId());

    return firebaseOptions.build();
  }

  private Task<GeneratedAndroidFirebaseCore.CoreInitializeResponse> firebaseAppToMap(
      FirebaseApp firebaseApp) {
    TaskCompletionSource<GeneratedAndroidFirebaseCore.CoreInitializeResponse> taskCompletionSource =
        new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            GeneratedAndroidFirebaseCore.CoreInitializeResponse.Builder initializeResponse =
                new GeneratedAndroidFirebaseCore.CoreInitializeResponse.Builder();

            initializeResponse.setName(firebaseApp.getName());
            initializeResponse.setOptions(firebaseOptionsToMap(firebaseApp.getOptions()));

            initializeResponse.setIsAutomaticDataCollectionEnabled(
                firebaseApp.isDataCollectionDefaultEnabled());
            initializeResponse.setPluginConstants(
                Tasks.await(
                    FlutterFirebasePluginRegistry.getPluginConstantsForFirebaseApp(firebaseApp)));

            taskCompletionSource.setResult(initializeResponse.build());
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  private <T> void listenToResponse(
      TaskCompletionSource<T> taskCompletionSource, GeneratedAndroidFirebaseCore.Result<T> result) {
    taskCompletionSource
        .getTask()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success(task.getResult());
              } else {
                Exception exception = task.getException();
                result.error(exception);
              }
            });
  }

  private void listenToVoidResponse(
      TaskCompletionSource<Void> taskCompletionSource,
      GeneratedAndroidFirebaseCore.VoidResult result) {
    taskCompletionSource
        .getTask()
        .addOnCompleteListener(
            task -> {
              if (task.isSuccessful()) {
                result.success();
              } else {
                Exception exception = task.getException();
                result.error(exception);
              }
            });
  }

  @Override
  public void initializeApp(
      @NonNull String appName,
      @NonNull GeneratedAndroidFirebaseCore.CoreFirebaseOptions initializeAppRequest,
      GeneratedAndroidFirebaseCore.Result<GeneratedAndroidFirebaseCore.CoreInitializeResponse>
          result) {
    TaskCompletionSource<GeneratedAndroidFirebaseCore.CoreInitializeResponse> taskCompletionSource =
        new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {

            FirebaseOptions options =
                new FirebaseOptions.Builder()
                    .setApiKey(initializeAppRequest.getApiKey())
                    .setApplicationId(initializeAppRequest.getAppId())
                    .setDatabaseUrl(initializeAppRequest.getDatabaseURL())
                    .setGcmSenderId(initializeAppRequest.getMessagingSenderId())
                    .setProjectId(initializeAppRequest.getProjectId())
                    .setStorageBucket(initializeAppRequest.getStorageBucket())
                    .setGaTrackingId(initializeAppRequest.getTrackingId())
                    .build();
            // TODO(Salakar) hacky workaround a bug with FirebaseInAppMessaging causing the error:
            //    Can't create handler inside thread Thread[pool-3-thread-1,5,main] that has not called Looper.prepare()
            //     at com.google.firebase.inappmessaging.internal.ForegroundNotifier.<init>(ForegroundNotifier.java:61)
            try {
              Looper.prepare();
            } catch (Exception e) {
              // do nothing
            }

            if (initializeAppRequest.getAuthDomain() != null) {
              customAuthDomain.put(appName, initializeAppRequest.getAuthDomain());
            }

            FirebaseApp firebaseApp =
                FirebaseApp.initializeApp(applicationContext, options, appName);
            taskCompletionSource.setResult(Tasks.await(firebaseAppToMap(firebaseApp)));
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToResponse(taskCompletionSource, result);
  }

  @Override
  public void initializeCore(
      GeneratedAndroidFirebaseCore.Result<List<GeneratedAndroidFirebaseCore.CoreInitializeResponse>>
          result) {
    TaskCompletionSource<List<GeneratedAndroidFirebaseCore.CoreInitializeResponse>>
        taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            if (!coreInitialized) {
              coreInitialized = true;
            } else {
              Tasks.await(FlutterFirebasePluginRegistry.didReinitializeFirebaseCore());
            }

            List<FirebaseApp> firebaseApps = FirebaseApp.getApps(applicationContext);
            List<GeneratedAndroidFirebaseCore.CoreInitializeResponse> firebaseAppsList =
                new ArrayList<>(firebaseApps.size());

            for (FirebaseApp firebaseApp : firebaseApps) {
              firebaseAppsList.add(Tasks.await(firebaseAppToMap(firebaseApp)));
            }

            taskCompletionSource.setResult(firebaseAppsList);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToResponse(taskCompletionSource, result);
  }

  @Override
  public void optionsFromResource(
      GeneratedAndroidFirebaseCore.Result<GeneratedAndroidFirebaseCore.CoreFirebaseOptions>
          result) {
    TaskCompletionSource<GeneratedAndroidFirebaseCore.CoreFirebaseOptions> taskCompletionSource =
        new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            final FirebaseOptions options = FirebaseOptions.fromResource(applicationContext);
            if (options == null) {
              taskCompletionSource.setException(
                  new Exception(
                      "Failed to load FirebaseOptions from resource. Check that you have defined values.xml correctly."));
              return;
            }
            taskCompletionSource.setResult(firebaseOptionsToMap(options));
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToResponse(taskCompletionSource, result);
  }

  @Override
  public void setAutomaticDataCollectionEnabled(
      @NonNull String appName,
      @NonNull Boolean enabled,
      GeneratedAndroidFirebaseCore.VoidResult result) {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseApp firebaseApp = FirebaseApp.getInstance(appName);
            firebaseApp.setDataCollectionDefaultEnabled(enabled);

            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToVoidResponse(taskCompletionSource, result);
  }

  @Override
  public void setAutomaticResourceManagementEnabled(
      @NonNull String appName,
      @NonNull Boolean enabled,
      GeneratedAndroidFirebaseCore.VoidResult result) {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseApp firebaseApp = FirebaseApp.getInstance(appName);
            firebaseApp.setAutomaticResourceManagementEnabled(enabled);

            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToVoidResponse(taskCompletionSource, result);
  }

  @Override
  public void delete(@NonNull String appName, GeneratedAndroidFirebaseCore.VoidResult result) {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            FirebaseApp firebaseApp = FirebaseApp.getInstance(appName);
            try {
              firebaseApp.delete();
            } catch (IllegalStateException appNotFoundException) {
              // Ignore app not found exceptions.
            }

            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    listenToVoidResponse(taskCompletionSource, result);
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/java/io/flutter/plugins/firebase/core/FlutterFirebaseCoreRegistrar.java

**크기**: 746 bytes | **라인 수**: 22 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package io.flutter.plugins.firebase.core;

import androidx.annotation.Keep;
import com.google.firebase.components.Component;
import com.google.firebase.components.ComponentRegistrar;
import com.google.firebase.platforminfo.LibraryVersionComponent;
import java.util.Collections;
import java.util.List;

@Keep
public class FlutterFirebaseCoreRegistrar implements ComponentRegistrar {
  @Override
  public List<Component<?>> getComponents() {
    return Collections.singletonList(
        LibraryVersionComponent.create(BuildConfig.LIBRARY_NAME, BuildConfig.LIBRARY_VERSION));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/java/io/flutter/plugins/firebase/core/FlutterFirebasePlugin.java

**크기**: 1522 bytes | **라인 수**: 36 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
package io.flutter.plugins.firebase.core;

import androidx.annotation.Keep;
import com.google.android.gms.tasks.Task;
import com.google.firebase.FirebaseApp;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Keep
public interface FlutterFirebasePlugin {
  // A shared ExecutorService used by all FlutterFire Plugins for their GMS Tasks.
  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();

  /**
   * FlutterFire plugins implementing FlutterFirebasePlugin must provide this method to provide it's
   * constants that are initialized during FirebaseCore.initializeApp in Dart.
   *
   * @param firebaseApp The Firebase App that the plugin should return constants for.
   * @return A task returning the discovered constants for the plugin for the provided Firebase App.
   */
  Task<Map<String, Object>> getPluginConstantsForFirebaseApp(FirebaseApp firebaseApp);

  /**
   * FlutterFire plugins implementing FlutterFirebasePlugin should provide this method to be
   * notified when FirebaseCore#initializeCore was called again (first time is ignored).
   *
   * <p>This can be used by plugins to know when they might need to cleanup previous resources
   * between Hot Restarts as `initializeCore` can only be called once in Dart.
   */
  Task<Void> didReinitializeFirebaseCore();
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/java/io/flutter/plugins/firebase/core/FlutterFirebasePluginRegistry.java

**크기**: 3649 bytes | **라인 수**: 94 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
package io.flutter.plugins.firebase.core;

import static io.flutter.plugins.firebase.core.FlutterFirebasePlugin.cachedThreadPool;

import androidx.annotation.Keep;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.TaskCompletionSource;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.FirebaseApp;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;

@Keep
public class FlutterFirebasePluginRegistry {

  private static final Map<String, FlutterFirebasePlugin> registeredPlugins = new WeakHashMap<>();

  /**
   * Register a Flutter Firebase plugin with the Firebase plugin registry.
   *
   * @param channelName The MethodChannel name for the plugin to be registered, for example:
   *     `plugins.flutter.io/firebase_core`
   * @param flutterFirebasePlugin A FlutterPlugin that implements FlutterFirebasePlugin.
   */
  public static void registerPlugin(
      String channelName, FlutterFirebasePlugin flutterFirebasePlugin) {
    registeredPlugins.put(channelName, flutterFirebasePlugin);
  }

  /**
   * Each FlutterFire plugin implementing FlutterFirebasePlugin provides this method allowing it's
   * constants to be initialized during FirebaseCore.initializeApp in Dart. Here we call this method
   * on each of the registered plugins and gather their constants for use in Dart.
   *
   * @param firebaseApp The Firebase App that the plugin should return constants for.
   * @return A task returning the discovered constants for each plugin (using channelName as the Map
   *     key) for the provided Firebase App.
   */
  static Task<Map<String, Object>> getPluginConstantsForFirebaseApp(FirebaseApp firebaseApp) {
    TaskCompletionSource<Map<String, Object>> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            Map<String, Object> pluginConstants = new HashMap<>(registeredPlugins.size());

            for (Map.Entry<String, FlutterFirebasePlugin> entry : registeredPlugins.entrySet()) {
              String channelName = entry.getKey();
              FlutterFirebasePlugin plugin = entry.getValue();
              pluginConstants.put(
                  channelName, Tasks.await(plugin.getPluginConstantsForFirebaseApp(firebaseApp)));
            }

            taskCompletionSource.setResult(pluginConstants);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }

  /**
   * Each FlutterFire plugin implementing this method are notified that FirebaseCore#initializeCore
   * was called again.
   *
   * <p>This is used by plugins to know if they need to cleanup previous resources between Hot
   * Restarts as `initializeCore` can only be called once in Dart.
   */
  static Task<Void> didReinitializeFirebaseCore() {
    TaskCompletionSource<Void> taskCompletionSource = new TaskCompletionSource<>();

    cachedThreadPool.execute(
        () -> {
          try {
            for (Map.Entry<String, FlutterFirebasePlugin> entry : registeredPlugins.entrySet()) {
              FlutterFirebasePlugin plugin = entry.getValue();
              Tasks.await(plugin.didReinitializeFirebaseCore());
            }

            taskCompletionSource.setResult(null);
          } catch (Exception e) {
            taskCompletionSource.setException(e);
          }
        });

    return taskCompletionSource.getTask();
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/java/io/flutter/plugins/firebase/core/GeneratedAndroidFirebaseCore.java

**크기**: 30783 bytes | **라인 수**: 907 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package io.flutter.plugins.firebase.core;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class GeneratedAndroidFirebaseCore {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
          "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  @Target(METHOD)
  @Retention(CLASS)
  @interface CanIgnoreReturnValue {}

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class CoreFirebaseOptions {
    private @NonNull String apiKey;

    public @NonNull String getApiKey() {
      return apiKey;
    }

    public void setApiKey(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"apiKey\" is null.");
      }
      this.apiKey = setterArg;
    }

    private @NonNull String appId;

    public @NonNull String getAppId() {
      return appId;
    }

    public void setAppId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"appId\" is null.");
      }
      this.appId = setterArg;
    }

    private @NonNull String messagingSenderId;

    public @NonNull String getMessagingSenderId() {
      return messagingSenderId;
    }

    public void setMessagingSenderId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"messagingSenderId\" is null.");
      }
      this.messagingSenderId = setterArg;
    }

    private @NonNull String projectId;

    public @NonNull String getProjectId() {
      return projectId;
    }

    public void setProjectId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"projectId\" is null.");
      }
      this.projectId = setterArg;
    }

    private @Nullable String authDomain;

    public @Nullable String getAuthDomain() {
      return authDomain;
    }

    public void setAuthDomain(@Nullable String setterArg) {
      this.authDomain = setterArg;
    }

    private @Nullable String databaseURL;

    public @Nullable String getDatabaseURL() {
      return databaseURL;
    }

    public void setDatabaseURL(@Nullable String setterArg) {
      this.databaseURL = setterArg;
    }

    private @Nullable String storageBucket;

    public @Nullable String getStorageBucket() {
      return storageBucket;
    }

    public void setStorageBucket(@Nullable String setterArg) {
      this.storageBucket = setterArg;
    }

    private @Nullable String measurementId;

    public @Nullable String getMeasurementId() {
      return measurementId;
    }

    public void setMeasurementId(@Nullable String setterArg) {
      this.measurementId = setterArg;
    }

    private @Nullable String trackingId;

    public @Nullable String getTrackingId() {
      return trackingId;
    }

    public void setTrackingId(@Nullable String setterArg) {
      this.trackingId = setterArg;
    }

    private @Nullable String deepLinkURLScheme;

    public @Nullable String getDeepLinkURLScheme() {
      return deepLinkURLScheme;
    }

    public void setDeepLinkURLScheme(@Nullable String setterArg) {
      this.deepLinkURLScheme = setterArg;
    }

    private @Nullable String androidClientId;

    public @Nullable String getAndroidClientId() {
      return androidClientId;
    }

    public void setAndroidClientId(@Nullable String setterArg) {
      this.androidClientId = setterArg;
    }

    private @Nullable String iosClientId;

    public @Nullable String getIosClientId() {
      return iosClientId;
    }

    public void setIosClientId(@Nullable String setterArg) {
      this.iosClientId = setterArg;
    }

    private @Nullable String iosBundleId;

    public @Nullable String getIosBundleId() {
      return iosBundleId;
    }

    public void setIosBundleId(@Nullable String setterArg) {
      this.iosBundleId = setterArg;
    }

    private @Nullable String appGroupId;

    public @Nullable String getAppGroupId() {
      return appGroupId;
    }

    public void setAppGroupId(@Nullable String setterArg) {
      this.appGroupId = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoreFirebaseOptions() {}

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      CoreFirebaseOptions that = (CoreFirebaseOptions) o;
      return apiKey.equals(that.apiKey)
          && appId.equals(that.appId)
          && messagingSenderId.equals(that.messagingSenderId)
          && projectId.equals(that.projectId)
          && Objects.equals(authDomain, that.authDomain)
          && Objects.equals(databaseURL, that.databaseURL)
          && Objects.equals(storageBucket, that.storageBucket)
          && Objects.equals(measurementId, that.measurementId)
          && Objects.equals(trackingId, that.trackingId)
          && Objects.equals(deepLinkURLScheme, that.deepLinkURLScheme)
          && Objects.equals(androidClientId, that.androidClientId)
          && Objects.equals(iosClientId, that.iosClientId)
          && Objects.equals(iosBundleId, that.iosBundleId)
          && Objects.equals(appGroupId, that.appGroupId);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          apiKey,
          appId,
          messagingSenderId,
          projectId,
          authDomain,
          databaseURL,
          storageBucket,
          measurementId,
          trackingId,
          deepLinkURLScheme,
          androidClientId,
          iosClientId,
          iosBundleId,
          appGroupId);
    }

    public static final class Builder {

      private @Nullable String apiKey;

      @CanIgnoreReturnValue
      public @NonNull Builder setApiKey(@NonNull String setterArg) {
        this.apiKey = setterArg;
        return this;
      }

      private @Nullable String appId;

      @CanIgnoreReturnValue
      public @NonNull Builder setAppId(@NonNull String setterArg) {
        this.appId = setterArg;
        return this;
      }

      private @Nullable String messagingSenderId;

      @CanIgnoreReturnValue
      public @NonNull Builder setMessagingSenderId(@NonNull String setterArg) {
        this.messagingSenderId = setterArg;
        return this;
      }

      private @Nullable String projectId;

      @CanIgnoreReturnValue
      public @NonNull Builder setProjectId(@NonNull String setterArg) {
        this.projectId = setterArg;
        return this;
      }

      private @Nullable String authDomain;

      @CanIgnoreReturnValue
      public @NonNull Builder setAuthDomain(@Nullable String setterArg) {
        this.authDomain = setterArg;
        return this;
      }

      private @Nullable String databaseURL;

      @CanIgnoreReturnValue
      public @NonNull Builder setDatabaseURL(@Nullable String setterArg) {
        this.databaseURL = setterArg;
        return this;
      }

      private @Nullable String storageBucket;

      @CanIgnoreReturnValue
      public @NonNull Builder setStorageBucket(@Nullable String setterArg) {
        this.storageBucket = setterArg;
        return this;
      }

      private @Nullable String measurementId;

      @CanIgnoreReturnValue
      public @NonNull Builder setMeasurementId(@Nullable String setterArg) {
        this.measurementId = setterArg;
        return this;
      }

      private @Nullable String trackingId;

      @CanIgnoreReturnValue
      public @NonNull Builder setTrackingId(@Nullable String setterArg) {
        this.trackingId = setterArg;
        return this;
      }

      private @Nullable String deepLinkURLScheme;

      @CanIgnoreReturnValue
      public @NonNull Builder setDeepLinkURLScheme(@Nullable String setterArg) {
        this.deepLinkURLScheme = setterArg;
        return this;
      }

      private @Nullable String androidClientId;

      @CanIgnoreReturnValue
      public @NonNull Builder setAndroidClientId(@Nullable String setterArg) {
        this.androidClientId = setterArg;
        return this;
      }

      private @Nullable String iosClientId;

      @CanIgnoreReturnValue
      public @NonNull Builder setIosClientId(@Nullable String setterArg) {
        this.iosClientId = setterArg;
        return this;
      }

      private @Nullable String iosBundleId;

      @CanIgnoreReturnValue
      public @NonNull Builder setIosBundleId(@Nullable String setterArg) {
        this.iosBundleId = setterArg;
        return this;
      }

      private @Nullable String appGroupId;

      @CanIgnoreReturnValue
      public @NonNull Builder setAppGroupId(@Nullable String setterArg) {
        this.appGroupId = setterArg;
        return this;
      }

      public @NonNull CoreFirebaseOptions build() {
        CoreFirebaseOptions pigeonReturn = new CoreFirebaseOptions();
        pigeonReturn.setApiKey(apiKey);
        pigeonReturn.setAppId(appId);
        pigeonReturn.setMessagingSenderId(messagingSenderId);
        pigeonReturn.setProjectId(projectId);
        pigeonReturn.setAuthDomain(authDomain);
        pigeonReturn.setDatabaseURL(databaseURL);
        pigeonReturn.setStorageBucket(storageBucket);
        pigeonReturn.setMeasurementId(measurementId);
        pigeonReturn.setTrackingId(trackingId);
        pigeonReturn.setDeepLinkURLScheme(deepLinkURLScheme);
        pigeonReturn.setAndroidClientId(androidClientId);
        pigeonReturn.setIosClientId(iosClientId);
        pigeonReturn.setIosBundleId(iosBundleId);
        pigeonReturn.setAppGroupId(appGroupId);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<>(14);
      toListResult.add(apiKey);
      toListResult.add(appId);
      toListResult.add(messagingSenderId);
      toListResult.add(projectId);
      toListResult.add(authDomain);
      toListResult.add(databaseURL);
      toListResult.add(storageBucket);
      toListResult.add(measurementId);
      toListResult.add(trackingId);
      toListResult.add(deepLinkURLScheme);
      toListResult.add(androidClientId);
      toListResult.add(iosClientId);
      toListResult.add(iosBundleId);
      toListResult.add(appGroupId);
      return toListResult;
    }

    static @NonNull CoreFirebaseOptions fromList(@NonNull ArrayList<Object> pigeonVar_list) {
      CoreFirebaseOptions pigeonResult = new CoreFirebaseOptions();
      Object apiKey = pigeonVar_list.get(0);
      pigeonResult.setApiKey((String) apiKey);
      Object appId = pigeonVar_list.get(1);
      pigeonResult.setAppId((String) appId);
      Object messagingSenderId = pigeonVar_list.get(2);
      pigeonResult.setMessagingSenderId((String) messagingSenderId);
      Object projectId = pigeonVar_list.get(3);
      pigeonResult.setProjectId((String) projectId);
      Object authDomain = pigeonVar_list.get(4);
      pigeonResult.setAuthDomain((String) authDomain);
      Object databaseURL = pigeonVar_list.get(5);
      pigeonResult.setDatabaseURL((String) databaseURL);
      Object storageBucket = pigeonVar_list.get(6);
      pigeonResult.setStorageBucket((String) storageBucket);
      Object measurementId = pigeonVar_list.get(7);
      pigeonResult.setMeasurementId((String) measurementId);
      Object trackingId = pigeonVar_list.get(8);
      pigeonResult.setTrackingId((String) trackingId);
      Object deepLinkURLScheme = pigeonVar_list.get(9);
      pigeonResult.setDeepLinkURLScheme((String) deepLinkURLScheme);
      Object androidClientId = pigeonVar_list.get(10);
      pigeonResult.setAndroidClientId((String) androidClientId);
      Object iosClientId = pigeonVar_list.get(11);
      pigeonResult.setIosClientId((String) iosClientId);
      Object iosBundleId = pigeonVar_list.get(12);
      pigeonResult.setIosBundleId((String) iosBundleId);
      Object appGroupId = pigeonVar_list.get(13);
      pigeonResult.setAppGroupId((String) appGroupId);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class CoreInitializeResponse {
    private @NonNull String name;

    public @NonNull String getName() {
      return name;
    }

    public void setName(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"name\" is null.");
      }
      this.name = setterArg;
    }

    private @NonNull CoreFirebaseOptions options;

    public @NonNull CoreFirebaseOptions getOptions() {
      return options;
    }

    public void setOptions(@NonNull CoreFirebaseOptions setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"options\" is null.");
      }
      this.options = setterArg;
    }

    private @Nullable Boolean isAutomaticDataCollectionEnabled;

    public @Nullable Boolean getIsAutomaticDataCollectionEnabled() {
      return isAutomaticDataCollectionEnabled;
    }

    public void setIsAutomaticDataCollectionEnabled(@Nullable Boolean setterArg) {
      this.isAutomaticDataCollectionEnabled = setterArg;
    }

    private @NonNull Map<String, Object> pluginConstants;

    public @NonNull Map<String, Object> getPluginConstants() {
      return pluginConstants;
    }

    public void setPluginConstants(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pluginConstants\" is null.");
      }
      this.pluginConstants = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoreInitializeResponse() {}

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      CoreInitializeResponse that = (CoreInitializeResponse) o;
      return name.equals(that.name)
          && options.equals(that.options)
          && Objects.equals(isAutomaticDataCollectionEnabled, that.isAutomaticDataCollectionEnabled)
          && pluginConstants.equals(that.pluginConstants);
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, options, isAutomaticDataCollectionEnabled, pluginConstants);
    }

    public static final class Builder {

      private @Nullable String name;

      @CanIgnoreReturnValue
      public @NonNull Builder setName(@NonNull String setterArg) {
        this.name = setterArg;
        return this;
      }

      private @Nullable CoreFirebaseOptions options;

      @CanIgnoreReturnValue
      public @NonNull Builder setOptions(@NonNull CoreFirebaseOptions setterArg) {
        this.options = setterArg;
        return this;
      }

      private @Nullable Boolean isAutomaticDataCollectionEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setIsAutomaticDataCollectionEnabled(@Nullable Boolean setterArg) {
        this.isAutomaticDataCollectionEnabled = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> pluginConstants;

      @CanIgnoreReturnValue
      public @NonNull Builder setPluginConstants(@NonNull Map<String, Object> setterArg) {
        this.pluginConstants = setterArg;
        return this;
      }

      public @NonNull CoreInitializeResponse build() {
        CoreInitializeResponse pigeonReturn = new CoreInitializeResponse();
        pigeonReturn.setName(name);
        pigeonReturn.setOptions(options);
        pigeonReturn.setIsAutomaticDataCollectionEnabled(isAutomaticDataCollectionEnabled);
        pigeonReturn.setPluginConstants(pluginConstants);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<>(4);
      toListResult.add(name);
      toListResult.add(options);
      toListResult.add(isAutomaticDataCollectionEnabled);
      toListResult.add(pluginConstants);
      return toListResult;
    }

    static @NonNull CoreInitializeResponse fromList(@NonNull ArrayList<Object> pigeonVar_list) {
      CoreInitializeResponse pigeonResult = new CoreInitializeResponse();
      Object name = pigeonVar_list.get(0);
      pigeonResult.setName((String) name);
      Object options = pigeonVar_list.get(1);
      pigeonResult.setOptions((CoreFirebaseOptions) options);
      Object isAutomaticDataCollectionEnabled = pigeonVar_list.get(2);
      pigeonResult.setIsAutomaticDataCollectionEnabled((Boolean) isAutomaticDataCollectionEnabled);
      Object pluginConstants = pigeonVar_list.get(3);
      pigeonResult.setPluginConstants((Map<String, Object>) pluginConstants);
      return pigeonResult;
    }
  }

  private static class PigeonCodec extends StandardMessageCodec {
    public static final PigeonCodec INSTANCE = new PigeonCodec();

    private PigeonCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 129:
          return CoreFirebaseOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CoreInitializeResponse.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CoreFirebaseOptions) {
        stream.write(129);
        writeValue(stream, ((CoreFirebaseOptions) value).toList());
      } else if (value instanceof CoreInitializeResponse) {
        stream.write(130);
        writeValue(stream, ((CoreInitializeResponse) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Asynchronous error handling return type for non-nullable API method returns. */
  public interface Result<T> {
    /** Success case callback method for handling returns. */
    void success(@NonNull T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for nullable API method returns. */
  public interface NullableResult<T> {
    /** Success case callback method for handling returns. */
    void success(@Nullable T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for void API method returns. */
  public interface VoidResult {
    /** Success case callback method for handling returns. */
    void success();

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface FirebaseCoreHostApi {

    void initializeApp(
        @NonNull String appName,
        @NonNull CoreFirebaseOptions initializeAppRequest,
        @NonNull Result<CoreInitializeResponse> result);

    void initializeCore(@NonNull Result<List<CoreInitializeResponse>> result);

    void optionsFromResource(@NonNull Result<CoreFirebaseOptions> result);

    /** The codec used by FirebaseCoreHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return PigeonCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `FirebaseCoreHostApi` to handle messages through the
     * `binaryMessenger`.
     */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable FirebaseCoreHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable FirebaseCoreHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseCoreHostApi.initializeApp"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String appNameArg = (String) args.get(0);
                CoreFirebaseOptions initializeAppRequestArg = (CoreFirebaseOptions) args.get(1);
                Result<CoreInitializeResponse> resultCallback =
                    new Result<CoreInitializeResponse>() {
                      public void success(CoreInitializeResponse result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.initializeApp(appNameArg, initializeAppRequestArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseCoreHostApi.initializeCore"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                Result<List<CoreInitializeResponse>> resultCallback =
                    new Result<List<CoreInitializeResponse>>() {
                      public void success(List<CoreInitializeResponse> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.initializeCore(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseCoreHostApi.optionsFromResource"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                Result<CoreFirebaseOptions> resultCallback =
                    new Result<CoreFirebaseOptions>() {
                      public void success(CoreFirebaseOptions result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.optionsFromResource(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface FirebaseAppHostApi {

    void setAutomaticDataCollectionEnabled(
        @NonNull String appName, @NonNull Boolean enabled, @NonNull VoidResult result);

    void setAutomaticResourceManagementEnabled(
        @NonNull String appName, @NonNull Boolean enabled, @NonNull VoidResult result);

    void delete(@NonNull String appName, @NonNull VoidResult result);

    /** The codec used by FirebaseAppHostApi. */
    static @NonNull MessageCodec<Object> getCodec() {
      return PigeonCodec.INSTANCE;
    }
    /**
     * Sets up an instance of `FirebaseAppHostApi` to handle messages through the `binaryMessenger`.
     */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable FirebaseAppHostApi api) {
      setUp(binaryMessenger, "", api);
    }

    static void setUp(
        @NonNull BinaryMessenger binaryMessenger,
        @NonNull String messageChannelSuffix,
        @Nullable FirebaseAppHostApi api) {
      messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseAppHostApi.setAutomaticDataCollectionEnabled"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String appNameArg = (String) args.get(0);
                Boolean enabledArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setAutomaticDataCollectionEnabled(appNameArg, enabledArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseAppHostApi.setAutomaticResourceManagementEnabled"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String appNameArg = (String) args.get(0);
                Boolean enabledArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setAutomaticResourceManagementEnabled(appNameArg, enabledArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger,
                "dev.flutter.pigeon.firebase_core_platform_interface.FirebaseAppHostApi.delete"
                    + messageChannelSuffix,
                getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String appNameArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.delete(appNameArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/android/src/main/AndroidManifest.xml

**크기**: 508 bytes | **라인 수**: 12 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="io.flutter.plugins.firebase.core">

    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data
                android:name="com.google.firebase.components:io.flutter.plugins.firebase.core.FlutterFirebaseCoreRegistrar"
                android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/debug/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/kotlin/io/flutter/plugins/firebasecoreexample/MainActivity.kt

**크기**: 139 bytes | **라인 수**: 6 | **타입**: text

```
package io.flutter.plugins.firebasecoreexample

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/res/drawable/launch_background.xml

**크기**: 434 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/res/drawable-v21/launch_background.xml

**크기**: 438 bytes | **라인 수**: 13 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/res/values/styles.xml

**크기**: 996 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/res/values-night/styles.xml

**크기**: 995 bytes | **라인 수**: 19 | **타입**: text

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/main/AndroidManifest.xml

**크기**: 2207 bytes | **라인 수**: 46 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="firebasecoreexample"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/src/profile/AndroidManifest.xml

**크기**: 378 bytes | **라인 수**: 8 | **타입**: text

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/android/app/google-services.json

**크기**: 19379 bytes | **라인 수**: 615 | **타입**: text

```
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dataconnect.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 2519 bytes | **라인 수**: 123 | **타입**: text

```
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json

**크기**: 391 bytes | **라인 수**: 24 | **타입**: text

```
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md

**크기**: 336 bytes | **라인 수**: 5 | **타입**: text

```
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/AppDelegate.h

**크기**: 103 bytes | **라인 수**: 7 | **타입**: text

```
#import <Flutter/Flutter.h>
#import <UIKit/UIKit.h>

@interface AppDelegate : FlutterAppDelegate

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/AppDelegate.m

**크기**: 422 bytes | **라인 수**: 14 | **타입**: text

```
#import "AppDelegate.h"
#import "GeneratedPluginRegistrant.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  [GeneratedPluginRegistrant registerWithRegistry:self];
  // Override point for customization after application launch.
  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/ios/Runner/main.m

**크기**: 226 bytes | **라인 수**: 10 | **타입**: text

```
#import <Flutter/Flutter.h>
#import <UIKit/UIKit.h>
#import "AppDelegate.h"

int main(int argc, char *argv[]) {
  @autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/lib/firebase_options.dart

**크기**: 3500 bytes | **라인 수**: 93 | **타입**: text

```
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      // TODO(Lyokone): Remove when FlutterFire CLI updated
      case TargetPlatform.windows:
        return android;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:0d4ed619c031c0ac3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/lib/main.dart

**크기**: 3213 bytes | **라인 수**: 107 | **타입**: text

```
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  String get name => 'foo';

  Future<void> initializeDefault() async {
    FirebaseApp app = await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('Initialized default app $app');
  }

  Future<void> initializeDefaultFromAndroidResource() async {
    if (defaultTargetPlatform != TargetPlatform.android || kIsWeb) {
      print('Not running on Android, skipping');
      return;
    }
    FirebaseApp app = await Firebase.initializeApp();
    print('Initialized default app $app from Android resource');
  }

  Future<void> initializeSecondary() async {
    FirebaseApp app = await Firebase.initializeApp(
      name: name,
      options: DefaultFirebaseOptions.currentPlatform,
    );

    print('Initialized $app');
  }

  void apps() {
    final List<FirebaseApp> apps = Firebase.apps;
    print('Currently initialized apps: $apps');
  }

  void options() {
    final FirebaseApp app = Firebase.app();
    final options = app.options;
    print('Current options for app ${app.name}: $options');
  }

  Future<void> delete() async {
    final FirebaseApp app = Firebase.app(name);
    await app.delete();
    print('App $name deleted');
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Firebase Core example app'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              ElevatedButton(
                onPressed: initializeDefault,
                child: const Text('Initialize default app'),
              ),
              if (defaultTargetPlatform == TargetPlatform.android && !kIsWeb)
                ElevatedButton(
                  onPressed: initializeDefaultFromAndroidResource,
                  child: const Text(
                    'Initialize default app from Android resources',
                  ),
                ),
              ElevatedButton(
                onPressed: initializeSecondary,
                child: const Text('Initialize secondary app'),
              ),
              ElevatedButton(
                onPressed: apps,
                child: const Text('List apps'),
              ),
              ElevatedButton(
                onPressed: options,
                child: const Text('List default options'),
              ),
              ElevatedButton(
                onPressed: delete,
                child: const Text('Delete secondary app'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json

**크기**: 1291 bytes | **라인 수**: 69 | **타입**: text

```
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/macos/Runner/AppDelegate.swift

**크기**: 311 bytes | **라인 수**: 14 | **타입**: text

```
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/macos/Runner/MainFlutterWindow.swift

**크기**: 393 bytes | **라인 수**: 16 | **타입**: text

```
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController.init()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/web/index.html

**크기**: 1236 bytes | **라인 수**: 39 | **타입**: text

```
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="flutterfire_core">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>flutterfire_core</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/web/manifest.json

**크기**: 928 bytes | **라인 수**: 36 | **타입**: text

```
{
    "name": "flutterfire_core",
    "short_name": "flutterfire_core",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/flutter/CMakeLists.txt

**크기**: 3742 bytes | **라인 수**: 110 | **타입**: text

```
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/CMakeLists.txt

**크기**: 1796 bytes | **라인 수**: 41 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/flutter_window.cpp

**크기**: 2061 bytes | **라인 수**: 69 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() { this->Show(); });

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/flutter_window.h

**크기**: 1152 bytes | **라인 수**: 40 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/main.cpp

**크기**: 1485 bytes | **라인 수**: 47 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t* command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments = GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"firebase_core_example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/resource.h

**크기**: 604 bytes | **라인 수**: 23 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON 101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE 102
#define _APS_NEXT_COMMAND_VALUE 40001
#define _APS_NEXT_CONTROL_VALUE 1001
#define _APS_NEXT_SYMED_VALUE 101
#endif
#endif

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/utils.cpp

**크기**: 1923 bytes | **라인 수**: 68 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE* unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length =
      ::WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, -1,
                            nullptr, 0, nullptr, nullptr);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string, -1, utf8_string.data(),
      target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/utils.h

**크기**: 896 bytes | **라인 수**: 26 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/win32_window.cpp

**크기**: 8584 bytes | **라인 수**: 285 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See:
/// https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
    L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] =
    L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() { ++g_active_window_count; }

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title, const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() { return ShowWindow(window_handle_, SW_SHOWNORMAL); }

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window, UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd, UINT const message, WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() { return window_handle_; }

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result =
      RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                  kGetPreferredBrightnessRegValue, RRF_RT_REG_DWORD, nullptr,
                  &light_mode, &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/runner/win32_window.h

**크기**: 3683 bytes | **라인 수**: 107 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window, UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responsponds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window, UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/windows/CMakeLists.txt

**크기**: 3927 bytes | **라인 수**: 102 | **타입**: text

```
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(firebase_core_example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "firebase_core_example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/README.md

**크기**: 578 bytes | **라인 수**: 17 | **타입**: text

```
# firebase_core_example

Demonstrates how to use the firebase_core plugin.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://flutter.dev/docs/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://flutter.dev/docs/cookbook)

For help getting started with Flutter, view our
[online documentation](https://flutter.dev/docs), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/analysis_options.yaml

**크기**: 328 bytes | **라인 수**: 11 | **타입**: text

```
# Copyright 2021 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# in the LICENSE file.

include: ../../../../analysis_options.yaml
linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/example/pubspec.yaml

**크기**: 235 bytes | **라인 수**: 14 | **타입**: text

```
name: firebase_core_example
description: Demonstrates how to use the firebase_core plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  firebase_core: ^4.1.1
  flutter:
    sdk: flutter

flutter:
  uses-material-design: true

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebaseCorePlugin.h

**크기**: 626 bytes | **라인 수**: 25 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "FLTFirebasePlugin.h"
#if __has_include("include/messages.g.h")
#import "include/messages.g.h"
#else
#import "messages.g.h"
#endif

@interface FLTFirebaseCorePlugin
    : FLTFirebasePlugin <FlutterPlugin, FLTFirebasePlugin, FirebaseCoreHostApi, FirebaseAppHostApi>

+ (NSString *)getCustomDomain:(NSString *)appName;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebasePlugin.h

**크기**: 5707 bytes | **라인 수**: 169 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Note: Don't use <Firebase/Firebase.h> umbrella header here - will cause a
// build
//       failure on MacOS builds (Flutter MacOS uses Swift) when this file is
//       included in other Flutter plugins like Firestore with an error of
//       "Include of non-modular header inside framework module".
#import <FirebaseCore/FirebaseCore.h>
#import <Foundation/Foundation.h>
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

/**
 * Block that is capable of sending a success response to a method call
 * operation. Use this for returning success data to a Method call.
 */
typedef void (^FLTFirebaseMethodCallSuccessBlock)(id _Nullable result);

/**
 * Block that is capable of sending an error response to a method call
 * operation. Use this for returning error information to a Method call.
 */
typedef void (^FLTFirebaseMethodCallErrorBlock)(NSString *_Nullable code,
                                                NSString *_Nullable message,
                                                NSDictionary *_Nullable details,
                                                NSError *_Nullable error);

/**
 * A protocol that all FlutterFire plugins should implement.
 */
@protocol FLTFirebasePlugin <NSObject>
/**
 * FlutterFire plugins implementing FLTFirebasePlugin should provide this method
 * to be notified when FirebaseCore#initializeCore was called again (first time
 * is ignored).
 *
 * This can be used by plugins to know when they might need to cleanup previous
 * resources between Hot Restarts as `initializeCore` can only be called once in
 * Dart.
 */
@required
- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion;

/**
 * FlutterFire plugins implementing FLTFirebasePlugin must provide this method
 * to provide it's constants that are initialized during
 * FirebaseCore.initializeApp in Dart.
 *
 * @param registrar A helper providing application context and methods for
 *     registering callbacks.
 */
@required
- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp;

/**
 * The Firebase library name of the plugin, used by
 * [FIRApp registerLibrary:firebaseLibraryName withVersion:] to
 * register this plugin with the Firebase backend.
 *
 * Usually this is provided by the 'LIBRARY_NAME' preprocessor definition
 * defined in the plugins .podspec file.
 */
@required
- (NSString *_Nonnull)firebaseLibraryName;

/**
 * The Firebase library version of the plugin, used by
 * FIRApp registerLibrary:withVersion:firebaseLibraryVersion] to
 * register this plugin with the Firebase backend.
 *
 * Usually this is provided by the 'LIBRARY_VERSION' preprocessor definition
 * defined in the plugins .podspec file.
 */
@required
- (NSString *_Nonnull)firebaseLibraryVersion;

/**
 * FlutterFire plugins implementing FLTFirebasePlugin must provide this method
 * to provide its main method channel name, used by FirebaseCore.initializeApp
 * in Dart to identify constants specific to a plugin.
 */
@required
- (NSString *_Nonnull)flutterChannelName;
@end

/**
 * An interface represent a returned result from a Flutter Method Call.
 */
@interface FLTFirebaseMethodCallResult : NSObject
+ (instancetype _Nonnull)createWithSuccess:(FLTFirebaseMethodCallSuccessBlock _Nonnull)successBlock
                             andErrorBlock:(FLTFirebaseMethodCallErrorBlock _Nonnull)errorBlock;

/**
 * Submit a result indicating a successful method call.
 *
 * E.g.: `result.success(nil);`
 */
@property(readonly, nonatomic) FLTFirebaseMethodCallSuccessBlock _Nonnull success;

/**
 * Submit a result indicating a failed method call.
 *
 * E.g.: `result.error(@"code", @"message", nil);`
 */
@property(readonly, nonatomic) FLTFirebaseMethodCallErrorBlock _Nonnull error;

@end

@interface FLTFirebasePlugin : NSObject
/**
 * Creates a standardized instance of FlutterError using the values returned
 * through FLTFirebaseMethodCallErrorBlock.
 *
 * @param code Error Code.
 * @param message Error Message.
 * @param details Optional dictionary of additional key/values to return to
 * Dart.
 * @param error Optional NSError that this error relates to.
 *
 * @return FlutterError
 */
+ (FlutterError *_Nonnull)createFlutterErrorFromCode:(NSString *_Nonnull)code
                                             message:(NSString *_Nonnull)message
                                     optionalDetails:(NSDictionary *_Nullable)details
                                  andOptionalNSError:(NSError *_Nullable)error;

/**
 * Converts the '[DEFAULT]' app name used in dart and other SDKs to the
 * '__FIRAPP_DEFAULT' iOS equivalent.
 *
 * If name is not '[DEFAULT]' then just returns the same name that was passed
 * in.
 *
 * @param appName The name of the Firebase App.
 *
 * @return NSString
 */
+ (NSString *_Nonnull)firebaseAppNameFromDartName:(NSString *_Nonnull)appName;

/**
 * Converts the '__FIRAPP_DEFAULT' app name used in iOS to '[DEFAULT]' - used in
 * Dart & other SDKs.
 *
 * If name is not '__FIRAPP_DEFAULT' then just returns the same name that was
 * passed in.
 *
 * @param appName The name of the Firebase App.
 *
 * @return NSString
 */
+ (NSString *_Nonnull)firebaseAppNameFromIosName:(NSString *_Nonnull)appName;

/**
 * Retrieves a FIRApp instance based on the app name provided from Dart code.
 *
 * @param appName The name of the Firebase App.
 *
 * @return FIRApp - returns nil if Firebase app does not exist.
 */
+ (FIRApp *_Nullable)firebaseAppNamed:(NSString *_Nonnull)appName;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebasePluginRegistry.h

**크기**: 1672 bytes | **라인 수**: 49 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <Foundation/Foundation.h>
#import "FLTFirebasePlugin.h"

@interface FLTFirebasePluginRegistry : NSObject
/**
 * Get the shared singleton instance of the plugin registry.
 *
 * @return FLTFirebasePluginRegistry
 */
+ (instancetype _Nonnull)sharedInstance;

/**
 * Register a FlutterFire plugin with the plugin registry.
 *
 * Plugins must conform to the FLTFirebasePlugin protocol.
 *
 * @param firebasePlugin id<FLTFirebasePlugin>
 */
- (void)registerFirebasePlugin:(id<FLTFirebasePlugin> _Nonnull)firebasePlugin;

/**
 * Each FlutterFire plugin implementing FLTFirebasePlugin provides this method,
 * allowing it's constants to be initialized during FirebaseCore.initializeApp
 * in Dart. Here we call this method on each of the registered plugins and
 * gather their constants for use in Dart.
 *
 * Constants for specific plugins are stored using the Flutter plugins channel
 * name as the key.
 *
 * @param firebaseApp FIRApp Firebase App instance these constants relate to.
 * @return NSDictionary Dictionary of plugins and their constants.
 */
- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp;

/**
 * Each FlutterFire plugin implementing this method are notified that
 * FirebaseCore#initializeCore was called again.
 *
 * This is used by plugins to know if they need to cleanup previous
 * resources between Hot Restarts as `initializeCore` can only be called once in
 * Dart.
 */
- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/include/firebase_core/dummy.h

**크기**: 216 bytes | **라인 수**: 4 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/include/firebase_core/messages.g.h

**크기**: 5344 bytes | **라인 수**: 104 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

@class CoreFirebaseOptions;
@class CoreInitializeResponse;

@interface CoreFirebaseOptions : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithApiKey:(NSString *)apiKey
                         appId:(NSString *)appId
             messagingSenderId:(NSString *)messagingSenderId
                     projectId:(NSString *)projectId
                    authDomain:(nullable NSString *)authDomain
                   databaseURL:(nullable NSString *)databaseURL
                 storageBucket:(nullable NSString *)storageBucket
                 measurementId:(nullable NSString *)measurementId
                    trackingId:(nullable NSString *)trackingId
             deepLinkURLScheme:(nullable NSString *)deepLinkURLScheme
               androidClientId:(nullable NSString *)androidClientId
                   iosClientId:(nullable NSString *)iosClientId
                   iosBundleId:(nullable NSString *)iosBundleId
                    appGroupId:(nullable NSString *)appGroupId;
@property(nonatomic, copy) NSString *apiKey;
@property(nonatomic, copy) NSString *appId;
@property(nonatomic, copy) NSString *messagingSenderId;
@property(nonatomic, copy) NSString *projectId;
@property(nonatomic, copy, nullable) NSString *authDomain;
@property(nonatomic, copy, nullable) NSString *databaseURL;
@property(nonatomic, copy, nullable) NSString *storageBucket;
@property(nonatomic, copy, nullable) NSString *measurementId;
@property(nonatomic, copy, nullable) NSString *trackingId;
@property(nonatomic, copy, nullable) NSString *deepLinkURLScheme;
@property(nonatomic, copy, nullable) NSString *androidClientId;
@property(nonatomic, copy, nullable) NSString *iosClientId;
@property(nonatomic, copy, nullable) NSString *iosBundleId;
@property(nonatomic, copy, nullable) NSString *appGroupId;
@end

@interface CoreInitializeResponse : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithName:(NSString *)name
                             options:(CoreFirebaseOptions *)options
    isAutomaticDataCollectionEnabled:(nullable NSNumber *)isAutomaticDataCollectionEnabled
                     pluginConstants:(NSDictionary<NSString *, id> *)pluginConstants;
@property(nonatomic, copy) NSString *name;
@property(nonatomic, strong) CoreFirebaseOptions *options;
@property(nonatomic, strong, nullable) NSNumber *isAutomaticDataCollectionEnabled;
@property(nonatomic, copy) NSDictionary<NSString *, id> *pluginConstants;
@end

/// The codec used by all APIs.
NSObject<FlutterMessageCodec> *nullGetMessagesCodec(void);

@protocol FirebaseCoreHostApi
- (void)initializeAppAppName:(NSString *)appName
        initializeAppRequest:(CoreFirebaseOptions *)initializeAppRequest
                  completion:(void (^)(CoreInitializeResponse *_Nullable,
                                       FlutterError *_Nullable))completion;
- (void)initializeCoreWithCompletion:(void (^)(NSArray<CoreInitializeResponse *> *_Nullable,
                                               FlutterError *_Nullable))completion;
- (void)optionsFromResourceWithCompletion:(void (^)(CoreFirebaseOptions *_Nullable,
                                                    FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseCoreHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                     NSObject<FirebaseCoreHostApi> *_Nullable api);

extern void SetUpFirebaseCoreHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                               NSObject<FirebaseCoreHostApi> *_Nullable api,
                                               NSString *messageChannelSuffix);

@protocol FirebaseAppHostApi
- (void)setAutomaticDataCollectionEnabledAppName:(NSString *)appName
                                         enabled:(BOOL)enabled
                                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setAutomaticResourceManagementEnabledAppName:(NSString *)appName
                                             enabled:(BOOL)enabled
                                          completion:(void (^)(FlutterError *_Nullable))completion;
- (void)deleteAppName:(NSString *)appName completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAppHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<FirebaseAppHostApi> *_Nullable api);

extern void SetUpFirebaseAppHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<FirebaseAppHostApi> *_Nullable api,
                                              NSString *messageChannelSuffix);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/FLTFirebaseCorePlugin.m

**크기**: 9145 bytes | **라인 수**: 258 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebaseCorePlugin.h")
#import "include/firebase_core/FLTFirebaseCorePlugin.h"
#else
#import "include/FLTFirebaseCorePlugin.h"
#endif

#if __has_include("include/firebase_core/FLTFirebasePluginRegistry.h")
#import "include/firebase_core/FLTFirebasePluginRegistry.h"
#else
#import "include/FLTFirebasePluginRegistry.h"
#endif

#if __has_include("include/firebase_core/messages.g.h")
#import "include/firebase_core/messages.g.h"
#else
#import "include/messages.g.h"
#endif

@implementation FLTFirebaseCorePlugin {
  BOOL _coreInitialized;
}

#pragma mark - FlutterPlugin

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FLTFirebaseCorePlugin *sharedInstance = [self sharedInstance];
#if TARGET_OS_OSX
#else
  [registrar publish:sharedInstance];
#endif
  SetUpFirebaseCoreHostApi(registrar.messenger, sharedInstance);
  SetUpFirebaseAppHostApi(registrar.messenger, sharedInstance);
}

// Returns a singleton instance of the Firebase Core plugin.
+ (instancetype)sharedInstance {
  static dispatch_once_t onceToken;
  static FLTFirebaseCorePlugin *instance;

  dispatch_once(&onceToken, ^{
    instance = [[FLTFirebaseCorePlugin alloc] init];
    // Register with the Flutter Firebase plugin registry.
    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:instance];

    // Initialize default Firebase app, but only if the plist file options
    // exist.
    //  - If it is missing then there is no default app discovered in Dart and
    //  Dart throws an error.
    //  - Without this the iOS/MacOS app would crash immediately on calling
    //  [FIRApp configure] without
    //    providing helpful context about the crash to the user.
    //
    // Default app exists check is for backwards compatibility of legacy
    // FlutterFire plugins that call [FIRApp configure]; themselves internally.
    FIROptions *options = [FIROptions defaultOptions];
    if (options != nil && [FIRApp allApps][@"__FIRAPP_DEFAULT"] == nil) {
      [FIRApp configureWithOptions:options];
    }
  });

  return instance;
}

static NSMutableDictionary<NSString *, NSString *> *customAuthDomains;

// Initialize static properties

+ (void)initialize {
  if (self == [FLTFirebaseCorePlugin self]) {
    customAuthDomains = [[NSMutableDictionary alloc] init];
  }
}

+ (NSString *)getCustomDomain:(NSString *)appName {
  return customAuthDomains[appName];
}

#pragma mark - Helpers

- (CoreFirebaseOptions *)optionsFromFIROptions:(FIROptions *)options {
  CoreFirebaseOptions *pigeonOptions = [CoreFirebaseOptions alloc];
  pigeonOptions.apiKey = (id)options.APIKey ?: [NSNull null];
  pigeonOptions.appId = (id)options.googleAppID ?: [NSNull null];
  pigeonOptions.messagingSenderId = (id)options.GCMSenderID ?: [NSNull null];
  pigeonOptions.projectId = (id)options.projectID ?: [NSNull null];
  pigeonOptions.databaseURL = (id)options.databaseURL ?: [NSNull null];
  pigeonOptions.storageBucket = (id)options.storageBucket ?: [NSNull null];
  pigeonOptions.deepLinkURLScheme = [NSNull null];
  pigeonOptions.iosBundleId = (id)options.bundleID ?: [NSNull null];
  pigeonOptions.iosClientId = (id)options.clientID ?: [NSNull null];
  pigeonOptions.appGroupId = (id)options.appGroupID ?: [NSNull null];
  return pigeonOptions;
}

- (CoreInitializeResponse *)initializeResponseFromFIRApp:(FIRApp *)firebaseApp {
  NSString *appNameDart = [FLTFirebasePlugin firebaseAppNameFromIosName:firebaseApp.name];
  CoreInitializeResponse *response = [CoreInitializeResponse alloc];
  response.name = appNameDart;
  response.options = [self optionsFromFIROptions:firebaseApp.options];
  response.isAutomaticDataCollectionEnabled = @(firebaseApp.isDataCollectionDefaultEnabled);
  response.pluginConstants =
      [[FLTFirebasePluginRegistry sharedInstance] pluginConstantsForFIRApp:firebaseApp];

  return response;
}

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^)(void))completion {
  completion();
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *)firebase_app {
  return @{};
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  // The pigeon channel depends on each function
  return @"dev.flutter.pigeon.FirebaseCoreHostApi.initializeApp";
}

#pragma mark - API

- (void)initializeAppAppName:(nonnull NSString *)appName
        initializeAppRequest:(nonnull CoreFirebaseOptions *)initializeAppRequest
                  completion:(nonnull void (^)(CoreInitializeResponse *_Nullable,
                                               FlutterError *_Nullable))completion {
  NSString *appNameIos = [FLTFirebasePlugin firebaseAppNameFromDartName:appName];

  if ([FLTFirebasePlugin firebaseAppNamed:appNameIos]) {
    completion([self initializeResponseFromFIRApp:[FLTFirebasePlugin firebaseAppNamed:appNameIos]],
               nil);
    return;
  }

  NSString *appId = initializeAppRequest.appId;
  NSString *messagingSenderId = initializeAppRequest.messagingSenderId;
  FIROptions *options = [[FIROptions alloc] initWithGoogleAppID:appId
                                                    GCMSenderID:messagingSenderId];

  options.APIKey = initializeAppRequest.apiKey;
  options.projectID = initializeAppRequest.projectId;

  // kFirebaseOptionsDatabaseUrl
  if (![initializeAppRequest.databaseURL isEqual:[NSNull null]]) {
    options.databaseURL = initializeAppRequest.databaseURL;
  }

  // kFirebaseOptionsStorageBucket
  if (![options.storageBucket isEqual:[NSNull null]]) {
    options.storageBucket = initializeAppRequest.storageBucket;
  }

  // kFirebaseOptionsIosBundleId
  if (![initializeAppRequest.iosBundleId isEqual:[NSNull null]]) {
    options.bundleID = initializeAppRequest.iosBundleId;
  }

  // kFirebaseOptionsIosClientId
  if (![initializeAppRequest.iosClientId isEqual:[NSNull null]]) {
    options.clientID = initializeAppRequest.iosClientId;
  }

  // kFirebaseOptionsAppGroupId
  if (![initializeAppRequest.appGroupId isEqual:[NSNull null]]) {
    options.appGroupID = initializeAppRequest.appGroupId;
  }

  if (initializeAppRequest.authDomain != nil) {
    customAuthDomains[appNameIos] = initializeAppRequest.authDomain;
  }

  [FIRApp configureWithName:appNameIos options:options];

  completion([self initializeResponseFromFIRApp:[FIRApp appNamed:appNameIos]], nil);
}

- (void)initializeCoreWithCompletion:(nonnull void (^)(NSArray<CoreInitializeResponse *> *_Nullable,
                                                       FlutterError *_Nullable))completion {
  void (^initializeCoreBlock)(void) = ^void() {
    NSDictionary<NSString *, FIRApp *> *firebaseApps = [FIRApp allApps];
    NSMutableArray *firebaseAppsArray = [NSMutableArray arrayWithCapacity:firebaseApps.count];

    for (NSString *appName in firebaseApps) {
      FIRApp *firebaseApp = firebaseApps[appName];
      [firebaseAppsArray addObject:[self initializeResponseFromFIRApp:firebaseApp]];
    }

    completion(firebaseAppsArray, nil);
  };

  if (!_coreInitialized) {
    _coreInitialized = YES;
    initializeCoreBlock();
  } else {
    [[FLTFirebasePluginRegistry sharedInstance] didReinitializeFirebaseCore:initializeCoreBlock];
  }
}

- (void)optionsFromResourceWithCompletion:(nonnull void (^)(CoreFirebaseOptions *_Nullable,
                                                            FlutterError *_Nullable))completion {
  // Unsupported on iOS/MacOS.
  completion(nil, nil);
}

- (void)deleteAppName:(nonnull NSString *)appName
           completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRApp *firebaseApp = [FLTFirebasePlugin firebaseAppNamed:appName];

  if (firebaseApp) {
    [firebaseApp deleteApp:^(BOOL success) {
      if (success) {
        completion(nil);
      } else {
        completion([FlutterError errorWithCode:@"delete-failed"
                                       message:@"Failed to delete a Firebase app instance."
                                       details:nil]);
      }
    }];
  } else {
    completion(nil);
  }
}

- (void)setAutomaticDataCollectionEnabledAppName:(nonnull NSString *)appName
                                         enabled:(BOOL)enabled
                                      completion:
                                          (nonnull void (^)(FlutterError *_Nullable))completion {
  FIRApp *firebaseApp = [FLTFirebasePlugin firebaseAppNamed:appName];
  if (firebaseApp) {
    [firebaseApp setDataCollectionDefaultEnabled:enabled];
  }

  completion(nil);
}

- (void)setAutomaticResourceManagementEnabledAppName:(nonnull NSString *)appName
                                             enabled:(BOOL)enabled
                                          completion:(nonnull void (^)(FlutterError *_Nullable))
                                                         completion {
  // Unsupported on iOS/MacOS.
  completion(nil);
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/FLTFirebasePlugin.m

**크기**: 2435 bytes | **라인 수**: 64 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebasePlugin.h")
#import "include/firebase_core/FLTFirebasePlugin.h"
#else
#import "include/FLTFirebasePlugin.h"
#endif

// Firebase default app name.
NSString *_Nonnull const kFIRDefaultAppNameIOS = @"__FIRAPP_DEFAULT";
NSString *_Nonnull const kFIRDefaultAppNameDart = @"[DEFAULT]";

@interface FLTFirebaseMethodCallResult ()
@property(readwrite, nonatomic) FLTFirebaseMethodCallErrorBlock error;
@property(readwrite, nonatomic) FLTFirebaseMethodCallSuccessBlock success;
@end
@implementation FLTFirebaseMethodCallResult

+ (instancetype)createWithSuccess:(FLTFirebaseMethodCallSuccessBlock)successBlock
                    andErrorBlock:(FLTFirebaseMethodCallErrorBlock)errorBlock {
  FLTFirebaseMethodCallResult *methodCallResult = [[FLTFirebaseMethodCallResult alloc] init];
  methodCallResult.error = errorBlock;
  methodCallResult.success = successBlock;
  return methodCallResult;
}

@end

@implementation FLTFirebasePlugin
+ (FlutterError *_Nonnull)createFlutterErrorFromCode:(NSString *_Nonnull)code
                                             message:(NSString *_Nonnull)message
                                     optionalDetails:(NSDictionary *_Nullable)details
                                  andOptionalNSError:(NSError *_Nullable)error {
  NSMutableDictionary *detailsDict = [NSMutableDictionary dictionaryWithDictionary:details ?: @{}];
  if (error != nil) {
    detailsDict[@"nativeErrorCode"] = [@(error.code) stringValue];
    detailsDict[@"nativeErrorMessage"] = error.localizedDescription;
  }
  return [FlutterError errorWithCode:code message:message details:detailsDict];
}

+ (NSString *)firebaseAppNameFromDartName:(NSString *_Nonnull)appName {
  NSString *appNameIOS = appName;
  if ([kFIRDefaultAppNameDart isEqualToString:appName]) {
    appNameIOS = kFIRDefaultAppNameIOS;
  }
  return appNameIOS;
}

+ (NSString *_Nonnull)firebaseAppNameFromIosName:(NSString *_Nonnull)appName {
  NSString *appNameDart = appName;
  if ([kFIRDefaultAppNameIOS isEqualToString:appName]) {
    appNameDart = kFIRDefaultAppNameDart;
  }
  return appNameDart;
}

+ (FIRApp *_Nullable)firebaseAppNamed:(NSString *_Nonnull)appName {
  return [FIRApp allApps][[self firebaseAppNameFromDartName:appName]];
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/FLTFirebasePluginRegistry.m

**크기**: 2430 bytes | **라인 수**: 80 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebasePluginRegistry.h")
#import "include/firebase_core/FLTFirebasePluginRegistry.h"
#else
#import "include/FLTFirebasePluginRegistry.h"
#endif

#if __has_include(<FirebaseCore/FIRAppInternal.h>)
#import <FirebaseCore/FIRAppInternal.h>
#define REGISTER_LIB
#elif __has_include(<FirebaseCoreExtension/FIRAppInternal.h>)
#import <FirebaseCoreExtension/FIRAppInternal.h>
#define REGISTER_LIB
#endif

@implementation FLTFirebasePluginRegistry {
  NSMutableDictionary<NSString *, id<FLTFirebasePlugin>> *registeredPlugins;
}

- (instancetype)init {
  self = [super init];
  if (self) {
    registeredPlugins = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (instancetype)sharedInstance {
  static dispatch_once_t onceToken;
  static FLTFirebasePluginRegistry *instance;

  dispatch_once(&onceToken, ^{
    instance = [[FLTFirebasePluginRegistry alloc] init];
  });

  return instance;
}

- (void)registerFirebasePlugin:(id<FLTFirebasePlugin>)firebasePlugin {
  // Register the library with the Firebase backend.
#ifdef REGISTER_LIB
  [FIRApp registerLibrary:[firebasePlugin firebaseLibraryName]
              withVersion:[firebasePlugin firebaseLibraryVersion]];
#endif
  // Store the plugin delegate for later usage.
  registeredPlugins[[firebasePlugin flutterChannelName]] = firebasePlugin;
}

- (NSDictionary *)pluginConstantsForFIRApp:(FIRApp *)firebaseApp {
  NSString *pluginFlutterChannelName;
  NSMutableDictionary *pluginConstants = [NSMutableDictionary dictionary];

  for (pluginFlutterChannelName in registeredPlugins) {
    pluginConstants[pluginFlutterChannelName] =
        [registeredPlugins[pluginFlutterChannelName] pluginConstantsForFIRApp:firebaseApp];
  }

  return pluginConstants;
}

- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion {
  __block int pluginsCompleted = 0;
  NSUInteger pluginsCount = [self->registeredPlugins allKeys].count;
  void (^allPluginsCompletion)(void) = ^void() {
    pluginsCompleted++;
    if (pluginsCompleted == pluginsCount) {
      completion();
    }
  };

  for (NSString *pluginFlutterChannelName in registeredPlugins) {
    [registeredPlugins[pluginFlutterChannelName] didReinitializeFirebaseCore:allPluginsCompletion];
  }
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/dummy.m

**크기**: 216 bytes | **라인 수**: 4 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Sources/firebase_core/messages.g.m

**크기**: 17238 bytes | **라인 수**: 390 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#if __has_include("include/firebase_core/messages.g.h")
#import "include/firebase_core/messages.g.h"
#else
#import "include/messages.g.h"
#endif

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray<id> *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static id GetNullableObjectAtIndex(NSArray<id> *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface CoreFirebaseOptions ()
+ (CoreFirebaseOptions *)fromList:(NSArray<id> *)list;
+ (nullable CoreFirebaseOptions *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface CoreInitializeResponse ()
+ (CoreInitializeResponse *)fromList:(NSArray<id> *)list;
+ (nullable CoreInitializeResponse *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@implementation CoreFirebaseOptions
+ (instancetype)makeWithApiKey:(NSString *)apiKey
                         appId:(NSString *)appId
             messagingSenderId:(NSString *)messagingSenderId
                     projectId:(NSString *)projectId
                    authDomain:(nullable NSString *)authDomain
                   databaseURL:(nullable NSString *)databaseURL
                 storageBucket:(nullable NSString *)storageBucket
                 measurementId:(nullable NSString *)measurementId
                    trackingId:(nullable NSString *)trackingId
             deepLinkURLScheme:(nullable NSString *)deepLinkURLScheme
               androidClientId:(nullable NSString *)androidClientId
                   iosClientId:(nullable NSString *)iosClientId
                   iosBundleId:(nullable NSString *)iosBundleId
                    appGroupId:(nullable NSString *)appGroupId {
  CoreFirebaseOptions *pigeonResult = [[CoreFirebaseOptions alloc] init];
  pigeonResult.apiKey = apiKey;
  pigeonResult.appId = appId;
  pigeonResult.messagingSenderId = messagingSenderId;
  pigeonResult.projectId = projectId;
  pigeonResult.authDomain = authDomain;
  pigeonResult.databaseURL = databaseURL;
  pigeonResult.storageBucket = storageBucket;
  pigeonResult.measurementId = measurementId;
  pigeonResult.trackingId = trackingId;
  pigeonResult.deepLinkURLScheme = deepLinkURLScheme;
  pigeonResult.androidClientId = androidClientId;
  pigeonResult.iosClientId = iosClientId;
  pigeonResult.iosBundleId = iosBundleId;
  pigeonResult.appGroupId = appGroupId;
  return pigeonResult;
}
+ (CoreFirebaseOptions *)fromList:(NSArray<id> *)list {
  CoreFirebaseOptions *pigeonResult = [[CoreFirebaseOptions alloc] init];
  pigeonResult.apiKey = GetNullableObjectAtIndex(list, 0);
  pigeonResult.appId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.messagingSenderId = GetNullableObjectAtIndex(list, 2);
  pigeonResult.projectId = GetNullableObjectAtIndex(list, 3);
  pigeonResult.authDomain = GetNullableObjectAtIndex(list, 4);
  pigeonResult.databaseURL = GetNullableObjectAtIndex(list, 5);
  pigeonResult.storageBucket = GetNullableObjectAtIndex(list, 6);
  pigeonResult.measurementId = GetNullableObjectAtIndex(list, 7);
  pigeonResult.trackingId = GetNullableObjectAtIndex(list, 8);
  pigeonResult.deepLinkURLScheme = GetNullableObjectAtIndex(list, 9);
  pigeonResult.androidClientId = GetNullableObjectAtIndex(list, 10);
  pigeonResult.iosClientId = GetNullableObjectAtIndex(list, 11);
  pigeonResult.iosBundleId = GetNullableObjectAtIndex(list, 12);
  pigeonResult.appGroupId = GetNullableObjectAtIndex(list, 13);
  return pigeonResult;
}
+ (nullable CoreFirebaseOptions *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [CoreFirebaseOptions fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.apiKey ?: [NSNull null],
    self.appId ?: [NSNull null],
    self.messagingSenderId ?: [NSNull null],
    self.projectId ?: [NSNull null],
    self.authDomain ?: [NSNull null],
    self.databaseURL ?: [NSNull null],
    self.storageBucket ?: [NSNull null],
    self.measurementId ?: [NSNull null],
    self.trackingId ?: [NSNull null],
    self.deepLinkURLScheme ?: [NSNull null],
    self.androidClientId ?: [NSNull null],
    self.iosClientId ?: [NSNull null],
    self.iosBundleId ?: [NSNull null],
    self.appGroupId ?: [NSNull null],
  ];
}
@end

@implementation CoreInitializeResponse
+ (instancetype)makeWithName:(NSString *)name
                             options:(CoreFirebaseOptions *)options
    isAutomaticDataCollectionEnabled:(nullable NSNumber *)isAutomaticDataCollectionEnabled
                     pluginConstants:(NSDictionary<NSString *, id> *)pluginConstants {
  CoreInitializeResponse *pigeonResult = [[CoreInitializeResponse alloc] init];
  pigeonResult.name = name;
  pigeonResult.options = options;
  pigeonResult.isAutomaticDataCollectionEnabled = isAutomaticDataCollectionEnabled;
  pigeonResult.pluginConstants = pluginConstants;
  return pigeonResult;
}
+ (CoreInitializeResponse *)fromList:(NSArray<id> *)list {
  CoreInitializeResponse *pigeonResult = [[CoreInitializeResponse alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.options = GetNullableObjectAtIndex(list, 1);
  pigeonResult.isAutomaticDataCollectionEnabled = GetNullableObjectAtIndex(list, 2);
  pigeonResult.pluginConstants = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable CoreInitializeResponse *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [CoreInitializeResponse fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.name ?: [NSNull null],
    self.options ?: [NSNull null],
    self.isAutomaticDataCollectionEnabled ?: [NSNull null],
    self.pluginConstants ?: [NSNull null],
  ];
}
@end

@interface nullMessagesPigeonCodecReader : FlutterStandardReader
@end
@implementation nullMessagesPigeonCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 129:
      return [CoreFirebaseOptions fromList:[self readValue]];
    case 130:
      return [CoreInitializeResponse fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface nullMessagesPigeonCodecWriter : FlutterStandardWriter
@end
@implementation nullMessagesPigeonCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[CoreFirebaseOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[CoreInitializeResponse class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface nullMessagesPigeonCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation nullMessagesPigeonCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[nullMessagesPigeonCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[nullMessagesPigeonCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *nullGetMessagesCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    nullMessagesPigeonCodecReaderWriter *readerWriter =
        [[nullMessagesPigeonCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}
void SetUpFirebaseCoreHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FirebaseCoreHostApi> *api) {
  SetUpFirebaseCoreHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseCoreHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FirebaseCoreHostApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseCoreHostApi.initializeApp",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeAppAppName:
                                                  initializeAppRequest:completion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(initializeAppAppName:initializeAppRequest:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        CoreFirebaseOptions *arg_initializeAppRequest = GetNullableObjectAtIndex(args, 1);
        [api initializeAppAppName:arg_appName
             initializeAppRequest:arg_initializeAppRequest
                       completion:^(CoreInitializeResponse *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseCoreHostApi.initializeCore",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeCoreWithCompletion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(initializeCoreWithCompletion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api initializeCoreWithCompletion:^(NSArray<CoreInitializeResponse *> *_Nullable output,
                                            FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_core_platform_interface."
                                             @"FirebaseCoreHostApi.optionsFromResource",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(optionsFromResourceWithCompletion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(optionsFromResourceWithCompletion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api optionsFromResourceWithCompletion:^(CoreFirebaseOptions *_Nullable output,
                                                 FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
void SetUpFirebaseAppHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                             NSObject<FirebaseAppHostApi> *api) {
  SetUpFirebaseAppHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAppHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<FirebaseAppHostApi> *api,
                                       NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_core_platform_interface."
                                          @"FirebaseAppHostApi.setAutomaticDataCollectionEnabled",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (setAutomaticDataCollectionEnabledAppName:enabled:completion:)],
                @"FirebaseAppHostApi api (%@) doesn't respond to "
                @"@selector(setAutomaticDataCollectionEnabledAppName:enabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        BOOL arg_enabled = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api setAutomaticDataCollectionEnabledAppName:arg_appName
                                              enabled:arg_enabled
                                           completion:^(FlutterError *_Nullable error) {
                                             callback(wrapResult(nil, error));
                                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:
                                      @"%@%@",
                                      @"dev.flutter.pigeon.firebase_core_platform_interface."
                                      @"FirebaseAppHostApi.setAutomaticResourceManagementEnabled",
                                      messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (setAutomaticResourceManagementEnabledAppName:enabled:completion:)],
                @"FirebaseAppHostApi api (%@) doesn't respond to "
                @"@selector(setAutomaticResourceManagementEnabledAppName:enabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        BOOL arg_enabled = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api setAutomaticResourceManagementEnabledAppName:arg_appName
                                                  enabled:arg_enabled
                                               completion:^(FlutterError *_Nullable error) {
                                                 callback(wrapResult(nil, error));
                                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseAppHostApi.delete",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(deleteAppName:completion:)],
          @"FirebaseAppHostApi api (%@) doesn't respond to @selector(deleteAppName:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        [api deleteAppName:arg_appName
                completion:^(FlutterError *_Nullable error) {
                  callback(wrapResult(nil, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_core/Package.swift

**크기**: 4647 bytes | **라인 수**: 132 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let firebaseCoreDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadPubspecVersion() throws -> String {
  let pubspecPath = NSString.path(withComponents: [
    firebaseCoreDirectory,
    "..",
    "..",
    "pubspec.yaml",
  ])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    if let versionLine = yamlString.split(separator: "\n")
      .first(where: { $0.starts(with: "version:") }) {
      let version = versionLine.split(separator: ":")[1].trimmingCharacters(in: .whitespaces)
      return version.replacingOccurrences(of: "+", with: "-")
    } else {
      throw ConfigurationError.invalidFormat("No version line found in pubspec.yaml")
    }
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    firebaseCoreDirectory,
    "..",
    "firebase_sdk_version.rb",
  ])
  do {
    let content = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
    let pattern = #"def firebase_sdk_version!\(\)\n\s+'([^']+)'\nend"#
    if let regex = try? NSRegularExpression(pattern: pattern, options: []),
       let match = regex.firstMatch(
         in: content,
         range: NSRange(content.startIndex..., in: content)
       ) {
      if let versionRange = Range(match.range(at: 1), in: content) {
        return String(content[versionRange])
      } else {
        throw ConfigurationError.invalidFormat("Invalid format in firebase_sdk_version.rb")
      }
    } else {
      throw ConfigurationError.parsingError("No match found in firebase_sdk_version.rb")
    }
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing firebase_sdk_version.rb: \(error)")
  }
}

let library_version_string: String
let firebase_sdk_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version_string = try loadPubspecVersion()
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

// TODO: - we can try using existing firebase_core tag once flutterfire/Package.swift is part of release cycle
// but I don't think it'll work as Swift versioning requires version-[tag name]
guard let shared_spm_version = Version("\(library_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(library_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "firebase_core",
  platforms: [
    .iOS("15.0"),
  ],
  products: [
    .library(name: "firebase-core", targets: ["firebase_core"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "firebase_core",
      dependencies: [
        // No product for firebase-core so we pull in the smallest one
        .product(name: "FirebaseInstallations", package: "firebase-ios-sdk"),
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      exclude: [
        // These are now pulled in as a remote dependency from FlutterFire repo
        "FLTFirebaseCorePlugin.m",
        "FLTFirebasePlugin.m",
        "FLTFirebasePluginRegistry.m",
        "messages.g.m",
        "include/firebase_core/FLTFirebaseCorePlugin.h",
        "include/firebase_core/messages.g.h",
        "include/firebase_core/FLTFirebasePlugin.h",
        "include/firebase_core/FLTFirebasePluginRegistry.h",
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/firebase_core"),
        .define("LIBRARY_VERSION", to: "\"\(library_version_string)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-core\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/ios/firebase_sdk_version.rb

**크기**: 99 bytes | **라인 수**: 5 | **타입**: text

```
# https://firebase.google.com/support/release-notes/ios
def firebase_sdk_version!()
  '12.2.0'
end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/lib/src/firebase.dart

**크기**: 3526 bytes | **라인 수**: 100 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// The entry point for accessing Firebase.
class Firebase {
  // Ensures end-users cannot initialize the class.
  Firebase._();

  // Cached & lazily loaded instance of [FirebasePlatform].
  // Avoids a [MethodChannelFirebase] being initialized until the user
  // starts using Firebase.
  // The property is visible for testing to allow tests to set a mock
  // instance directly as a static property since the class is not initialized.
  @visibleForTesting
  // ignore: public_member_api_docs
  static FirebasePlatform? delegatePackingProperty;

  static FirebasePlatform get _delegate {
    return delegatePackingProperty ??= FirebasePlatform.instance;
  }

  /// Returns a list of all [FirebaseApp] instances that have been created.
  static List<FirebaseApp> get apps {
    return _delegate.apps.map(FirebaseApp._).toList(growable: false);
  }

  /// Initializes a new [FirebaseApp] instance by [name] and [options] and returns
  /// the created app. This method should be called before any usage of FlutterFire plugins.
  ///
  /// The default app instance can be initialized here simply by passing no "name" as an argument
  /// in both Dart & manual initialization flows.
  /// If you have a `google-services.json` file in your android project or a `GoogleService-Info.plist` file in your iOS+ project,
  /// it will automatically create a default (named "[DEFAULT]") app instance on the native platform. However, you will still need to call this method
  /// before using any FlutterFire plugins.
  static Future<FirebaseApp> initializeApp({
    String? name,
    FirebaseOptions? options,
    String? demoProjectId,
  }) async {
    if (demoProjectId != null) {
      late final String platformString;
      if (defaultTargetPlatform == TargetPlatform.android) {
        platformString = 'android';
      } else if (defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.macOS) {
        platformString = 'ios';
      } else {
        // We use 'web' as the default platform for unknown platforms.
        platformString = 'web';
      }
      FirebaseAppPlatform app = await _delegate.initializeApp(
        options: FirebaseOptions(
          apiKey: '',
          appId: '1:1:$platformString:1',
          messagingSenderId: '',
          projectId: demoProjectId,
        ),
      );

      return FirebaseApp._(app);
    }
    FirebaseAppPlatform app = await _delegate.initializeApp(
      name: name,
      options: options,
    );

    return FirebaseApp._(app);
  }

  /// Returns a [FirebaseApp] instance.
  ///
  /// If no name is provided, the default app instance is returned.
  /// Throws if the app does not exist.
  static FirebaseApp app([String name = defaultFirebaseAppName]) {
    FirebaseAppPlatform app = _delegate.app(name);

    return FirebaseApp._(app);
  }

  // TODO(rrousselGit): remove ==/hashCode
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Firebase) return false;
    return other.hashCode == hashCode;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => toString().hashCode;

  @override
  String toString() => '$Firebase';
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/lib/src/firebase_app.dart

**크기**: 2513 bytes | **라인 수**: 75 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// Represents a single Firebase app instance.
///
/// You can get an instance by calling [Firebase.app()].
class FirebaseApp {
  /// A [FirebaseApp] instance can only be accessed from a call to `app()` on
  /// [FirebaseCore].
  ///
  /// This constructor ensures that the delegate instance it is
  /// constructed with is one which extends [FirebaseAppPlatform].
  FirebaseApp._(this._delegate) {
    FirebaseAppPlatform.verify(_delegate);
  }

  final FirebaseAppPlatform _delegate;

  /// Deletes this app and frees up system resources.
  ///
  /// Once deleted, any plugin functionality using this app instance will throw
  /// an error.
  ///
  /// Deleting the default app is not possible and throws an exception.
  Future<void> delete() async {
    await _delegate.delete();
  }

  /// The name of this [FirebaseApp].
  String get name => _delegate.name;

  /// The [FirebaseOptions] this app was created with.
  FirebaseOptions get options => _delegate.options;

  /// Returns whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// Automatic data collection can be enabled or disabled via `setAutomaticDataCollectionEnabled`.
  bool get isAutomaticDataCollectionEnabled =>
      _delegate.isAutomaticDataCollectionEnabled;

  /// Sets whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// To check whether it is currently enabled or not, call [isAutomaticDataCollectionEnabled].
  Future<void> setAutomaticDataCollectionEnabled(bool enabled) {
    return _delegate.setAutomaticDataCollectionEnabled(enabled);
  }

  /// Sets whether automatic resource management is enabled or disabled for this
  /// app.
  Future<void> setAutomaticResourceManagementEnabled(bool enabled) {
    return _delegate.setAutomaticResourceManagementEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! FirebaseApp) return false;
    return other.name == name && other.options == options;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(name, options);

  @override
  String toString() => '$FirebaseApp($name)';
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/lib/src/port_mapping.dart

**크기**: 631 bytes | **라인 수**: 19 | **타입**: text

```
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_core.dart';

String getMappedHost(String originalHost) {
  String mappedHost = originalHost;

  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    if (mappedHost == 'localhost' || mappedHost == '127.0.0.1') {
      // ignore: avoid_print
      print('Mapping Auth Emulator host "$mappedHost" to "10.0.2.2".');
      mappedHost = '10.0.2.2';
    }
  }
  return mappedHost;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/lib/firebase_core.dart

**크기**: 643 bytes | **라인 수**: 16 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    hide MethodChannelFirebaseApp, MethodChannelFirebase;
import 'package:flutter/foundation.dart';

export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseOptions, defaultFirebaseAppName, FirebaseException;

part 'src/firebase.dart';
part 'src/firebase_app.dart';
part 'src/port_mapping.dart';

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebaseCorePlugin.h

**크기**: 626 bytes | **라인 수**: 25 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#import "FLTFirebasePlugin.h"
#if __has_include("include/messages.g.h")
#import "include/messages.g.h"
#else
#import "messages.g.h"
#endif

@interface FLTFirebaseCorePlugin
    : FLTFirebasePlugin <FlutterPlugin, FLTFirebasePlugin, FirebaseCoreHostApi, FirebaseAppHostApi>

+ (NSString *)getCustomDomain:(NSString *)appName;

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebasePlugin.h

**크기**: 5707 bytes | **라인 수**: 169 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Note: Don't use <Firebase/Firebase.h> umbrella header here - will cause a
// build
//       failure on MacOS builds (Flutter MacOS uses Swift) when this file is
//       included in other Flutter plugins like Firestore with an error of
//       "Include of non-modular header inside framework module".
#import <FirebaseCore/FirebaseCore.h>
#import <Foundation/Foundation.h>
#import <TargetConditionals.h>

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

/**
 * Block that is capable of sending a success response to a method call
 * operation. Use this for returning success data to a Method call.
 */
typedef void (^FLTFirebaseMethodCallSuccessBlock)(id _Nullable result);

/**
 * Block that is capable of sending an error response to a method call
 * operation. Use this for returning error information to a Method call.
 */
typedef void (^FLTFirebaseMethodCallErrorBlock)(NSString *_Nullable code,
                                                NSString *_Nullable message,
                                                NSDictionary *_Nullable details,
                                                NSError *_Nullable error);

/**
 * A protocol that all FlutterFire plugins should implement.
 */
@protocol FLTFirebasePlugin <NSObject>
/**
 * FlutterFire plugins implementing FLTFirebasePlugin should provide this method
 * to be notified when FirebaseCore#initializeCore was called again (first time
 * is ignored).
 *
 * This can be used by plugins to know when they might need to cleanup previous
 * resources between Hot Restarts as `initializeCore` can only be called once in
 * Dart.
 */
@required
- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion;

/**
 * FlutterFire plugins implementing FLTFirebasePlugin must provide this method
 * to provide it's constants that are initialized during
 * FirebaseCore.initializeApp in Dart.
 *
 * @param registrar A helper providing application context and methods for
 *     registering callbacks.
 */
@required
- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp;

/**
 * The Firebase library name of the plugin, used by
 * [FIRApp registerLibrary:firebaseLibraryName withVersion:] to
 * register this plugin with the Firebase backend.
 *
 * Usually this is provided by the 'LIBRARY_NAME' preprocessor definition
 * defined in the plugins .podspec file.
 */
@required
- (NSString *_Nonnull)firebaseLibraryName;

/**
 * The Firebase library version of the plugin, used by
 * FIRApp registerLibrary:withVersion:firebaseLibraryVersion] to
 * register this plugin with the Firebase backend.
 *
 * Usually this is provided by the 'LIBRARY_VERSION' preprocessor definition
 * defined in the plugins .podspec file.
 */
@required
- (NSString *_Nonnull)firebaseLibraryVersion;

/**
 * FlutterFire plugins implementing FLTFirebasePlugin must provide this method
 * to provide its main method channel name, used by FirebaseCore.initializeApp
 * in Dart to identify constants specific to a plugin.
 */
@required
- (NSString *_Nonnull)flutterChannelName;
@end

/**
 * An interface represent a returned result from a Flutter Method Call.
 */
@interface FLTFirebaseMethodCallResult : NSObject
+ (instancetype _Nonnull)createWithSuccess:(FLTFirebaseMethodCallSuccessBlock _Nonnull)successBlock
                             andErrorBlock:(FLTFirebaseMethodCallErrorBlock _Nonnull)errorBlock;

/**
 * Submit a result indicating a successful method call.
 *
 * E.g.: `result.success(nil);`
 */
@property(readonly, nonatomic) FLTFirebaseMethodCallSuccessBlock _Nonnull success;

/**
 * Submit a result indicating a failed method call.
 *
 * E.g.: `result.error(@"code", @"message", nil);`
 */
@property(readonly, nonatomic) FLTFirebaseMethodCallErrorBlock _Nonnull error;

@end

@interface FLTFirebasePlugin : NSObject
/**
 * Creates a standardized instance of FlutterError using the values returned
 * through FLTFirebaseMethodCallErrorBlock.
 *
 * @param code Error Code.
 * @param message Error Message.
 * @param details Optional dictionary of additional key/values to return to
 * Dart.
 * @param error Optional NSError that this error relates to.
 *
 * @return FlutterError
 */
+ (FlutterError *_Nonnull)createFlutterErrorFromCode:(NSString *_Nonnull)code
                                             message:(NSString *_Nonnull)message
                                     optionalDetails:(NSDictionary *_Nullable)details
                                  andOptionalNSError:(NSError *_Nullable)error;

/**
 * Converts the '[DEFAULT]' app name used in dart and other SDKs to the
 * '__FIRAPP_DEFAULT' iOS equivalent.
 *
 * If name is not '[DEFAULT]' then just returns the same name that was passed
 * in.
 *
 * @param appName The name of the Firebase App.
 *
 * @return NSString
 */
+ (NSString *_Nonnull)firebaseAppNameFromDartName:(NSString *_Nonnull)appName;

/**
 * Converts the '__FIRAPP_DEFAULT' app name used in iOS to '[DEFAULT]' - used in
 * Dart & other SDKs.
 *
 * If name is not '__FIRAPP_DEFAULT' then just returns the same name that was
 * passed in.
 *
 * @param appName The name of the Firebase App.
 *
 * @return NSString
 */
+ (NSString *_Nonnull)firebaseAppNameFromIosName:(NSString *_Nonnull)appName;

/**
 * Retrieves a FIRApp instance based on the app name provided from Dart code.
 *
 * @param appName The name of the Firebase App.
 *
 * @return FIRApp - returns nil if Firebase app does not exist.
 */
+ (FIRApp *_Nullable)firebaseAppNamed:(NSString *_Nonnull)appName;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/include/firebase_core/FLTFirebasePluginRegistry.h

**크기**: 1672 bytes | **라인 수**: 49 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <Foundation/Foundation.h>
#import "FLTFirebasePlugin.h"

@interface FLTFirebasePluginRegistry : NSObject
/**
 * Get the shared singleton instance of the plugin registry.
 *
 * @return FLTFirebasePluginRegistry
 */
+ (instancetype _Nonnull)sharedInstance;

/**
 * Register a FlutterFire plugin with the plugin registry.
 *
 * Plugins must conform to the FLTFirebasePlugin protocol.
 *
 * @param firebasePlugin id<FLTFirebasePlugin>
 */
- (void)registerFirebasePlugin:(id<FLTFirebasePlugin> _Nonnull)firebasePlugin;

/**
 * Each FlutterFire plugin implementing FLTFirebasePlugin provides this method,
 * allowing it's constants to be initialized during FirebaseCore.initializeApp
 * in Dart. Here we call this method on each of the registered plugins and
 * gather their constants for use in Dart.
 *
 * Constants for specific plugins are stored using the Flutter plugins channel
 * name as the key.
 *
 * @param firebaseApp FIRApp Firebase App instance these constants relate to.
 * @return NSDictionary Dictionary of plugins and their constants.
 */
- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *_Nonnull)firebaseApp;

/**
 * Each FlutterFire plugin implementing this method are notified that
 * FirebaseCore#initializeCore was called again.
 *
 * This is used by plugins to know if they need to cleanup previous
 * resources between Hot Restarts as `initializeCore` can only be called once in
 * Dart.
 */
- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion;
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/include/firebase_core/messages.g.h

**크기**: 5344 bytes | **라인 수**: 104 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import <Foundation/Foundation.h>

@protocol FlutterBinaryMessenger;
@protocol FlutterMessageCodec;
@class FlutterError;
@class FlutterStandardTypedData;

NS_ASSUME_NONNULL_BEGIN

@class CoreFirebaseOptions;
@class CoreInitializeResponse;

@interface CoreFirebaseOptions : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithApiKey:(NSString *)apiKey
                         appId:(NSString *)appId
             messagingSenderId:(NSString *)messagingSenderId
                     projectId:(NSString *)projectId
                    authDomain:(nullable NSString *)authDomain
                   databaseURL:(nullable NSString *)databaseURL
                 storageBucket:(nullable NSString *)storageBucket
                 measurementId:(nullable NSString *)measurementId
                    trackingId:(nullable NSString *)trackingId
             deepLinkURLScheme:(nullable NSString *)deepLinkURLScheme
               androidClientId:(nullable NSString *)androidClientId
                   iosClientId:(nullable NSString *)iosClientId
                   iosBundleId:(nullable NSString *)iosBundleId
                    appGroupId:(nullable NSString *)appGroupId;
@property(nonatomic, copy) NSString *apiKey;
@property(nonatomic, copy) NSString *appId;
@property(nonatomic, copy) NSString *messagingSenderId;
@property(nonatomic, copy) NSString *projectId;
@property(nonatomic, copy, nullable) NSString *authDomain;
@property(nonatomic, copy, nullable) NSString *databaseURL;
@property(nonatomic, copy, nullable) NSString *storageBucket;
@property(nonatomic, copy, nullable) NSString *measurementId;
@property(nonatomic, copy, nullable) NSString *trackingId;
@property(nonatomic, copy, nullable) NSString *deepLinkURLScheme;
@property(nonatomic, copy, nullable) NSString *androidClientId;
@property(nonatomic, copy, nullable) NSString *iosClientId;
@property(nonatomic, copy, nullable) NSString *iosBundleId;
@property(nonatomic, copy, nullable) NSString *appGroupId;
@end

@interface CoreInitializeResponse : NSObject
/// `init` unavailable to enforce nonnull fields, see the `make` class method.
- (instancetype)init NS_UNAVAILABLE;
+ (instancetype)makeWithName:(NSString *)name
                             options:(CoreFirebaseOptions *)options
    isAutomaticDataCollectionEnabled:(nullable NSNumber *)isAutomaticDataCollectionEnabled
                     pluginConstants:(NSDictionary<NSString *, id> *)pluginConstants;
@property(nonatomic, copy) NSString *name;
@property(nonatomic, strong) CoreFirebaseOptions *options;
@property(nonatomic, strong, nullable) NSNumber *isAutomaticDataCollectionEnabled;
@property(nonatomic, copy) NSDictionary<NSString *, id> *pluginConstants;
@end

/// The codec used by all APIs.
NSObject<FlutterMessageCodec> *nullGetMessagesCodec(void);

@protocol FirebaseCoreHostApi
- (void)initializeAppAppName:(NSString *)appName
        initializeAppRequest:(CoreFirebaseOptions *)initializeAppRequest
                  completion:(void (^)(CoreInitializeResponse *_Nullable,
                                       FlutterError *_Nullable))completion;
- (void)initializeCoreWithCompletion:(void (^)(NSArray<CoreInitializeResponse *> *_Nullable,
                                               FlutterError *_Nullable))completion;
- (void)optionsFromResourceWithCompletion:(void (^)(CoreFirebaseOptions *_Nullable,
                                                    FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseCoreHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                     NSObject<FirebaseCoreHostApi> *_Nullable api);

extern void SetUpFirebaseCoreHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                               NSObject<FirebaseCoreHostApi> *_Nullable api,
                                               NSString *messageChannelSuffix);

@protocol FirebaseAppHostApi
- (void)setAutomaticDataCollectionEnabledAppName:(NSString *)appName
                                         enabled:(BOOL)enabled
                                      completion:(void (^)(FlutterError *_Nullable))completion;
- (void)setAutomaticResourceManagementEnabledAppName:(NSString *)appName
                                             enabled:(BOOL)enabled
                                          completion:(void (^)(FlutterError *_Nullable))completion;
- (void)deleteAppName:(NSString *)appName completion:(void (^)(FlutterError *_Nullable))completion;
@end

extern void SetUpFirebaseAppHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                                    NSObject<FirebaseAppHostApi> *_Nullable api);

extern void SetUpFirebaseAppHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                              NSObject<FirebaseAppHostApi> *_Nullable api,
                                              NSString *messageChannelSuffix);

NS_ASSUME_NONNULL_END

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/include/dummy.h

**크기**: 216 bytes | **라인 수**: 4 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/FLTFirebaseCorePlugin.m

**크기**: 9145 bytes | **라인 수**: 258 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebaseCorePlugin.h")
#import "include/firebase_core/FLTFirebaseCorePlugin.h"
#else
#import "include/FLTFirebaseCorePlugin.h"
#endif

#if __has_include("include/firebase_core/FLTFirebasePluginRegistry.h")
#import "include/firebase_core/FLTFirebasePluginRegistry.h"
#else
#import "include/FLTFirebasePluginRegistry.h"
#endif

#if __has_include("include/firebase_core/messages.g.h")
#import "include/firebase_core/messages.g.h"
#else
#import "include/messages.g.h"
#endif

@implementation FLTFirebaseCorePlugin {
  BOOL _coreInitialized;
}

#pragma mark - FlutterPlugin

+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar> *)registrar {
  FLTFirebaseCorePlugin *sharedInstance = [self sharedInstance];
#if TARGET_OS_OSX
#else
  [registrar publish:sharedInstance];
#endif
  SetUpFirebaseCoreHostApi(registrar.messenger, sharedInstance);
  SetUpFirebaseAppHostApi(registrar.messenger, sharedInstance);
}

// Returns a singleton instance of the Firebase Core plugin.
+ (instancetype)sharedInstance {
  static dispatch_once_t onceToken;
  static FLTFirebaseCorePlugin *instance;

  dispatch_once(&onceToken, ^{
    instance = [[FLTFirebaseCorePlugin alloc] init];
    // Register with the Flutter Firebase plugin registry.
    [[FLTFirebasePluginRegistry sharedInstance] registerFirebasePlugin:instance];

    // Initialize default Firebase app, but only if the plist file options
    // exist.
    //  - If it is missing then there is no default app discovered in Dart and
    //  Dart throws an error.
    //  - Without this the iOS/MacOS app would crash immediately on calling
    //  [FIRApp configure] without
    //    providing helpful context about the crash to the user.
    //
    // Default app exists check is for backwards compatibility of legacy
    // FlutterFire plugins that call [FIRApp configure]; themselves internally.
    FIROptions *options = [FIROptions defaultOptions];
    if (options != nil && [FIRApp allApps][@"__FIRAPP_DEFAULT"] == nil) {
      [FIRApp configureWithOptions:options];
    }
  });

  return instance;
}

static NSMutableDictionary<NSString *, NSString *> *customAuthDomains;

// Initialize static properties

+ (void)initialize {
  if (self == [FLTFirebaseCorePlugin self]) {
    customAuthDomains = [[NSMutableDictionary alloc] init];
  }
}

+ (NSString *)getCustomDomain:(NSString *)appName {
  return customAuthDomains[appName];
}

#pragma mark - Helpers

- (CoreFirebaseOptions *)optionsFromFIROptions:(FIROptions *)options {
  CoreFirebaseOptions *pigeonOptions = [CoreFirebaseOptions alloc];
  pigeonOptions.apiKey = (id)options.APIKey ?: [NSNull null];
  pigeonOptions.appId = (id)options.googleAppID ?: [NSNull null];
  pigeonOptions.messagingSenderId = (id)options.GCMSenderID ?: [NSNull null];
  pigeonOptions.projectId = (id)options.projectID ?: [NSNull null];
  pigeonOptions.databaseURL = (id)options.databaseURL ?: [NSNull null];
  pigeonOptions.storageBucket = (id)options.storageBucket ?: [NSNull null];
  pigeonOptions.deepLinkURLScheme = [NSNull null];
  pigeonOptions.iosBundleId = (id)options.bundleID ?: [NSNull null];
  pigeonOptions.iosClientId = (id)options.clientID ?: [NSNull null];
  pigeonOptions.appGroupId = (id)options.appGroupID ?: [NSNull null];
  return pigeonOptions;
}

- (CoreInitializeResponse *)initializeResponseFromFIRApp:(FIRApp *)firebaseApp {
  NSString *appNameDart = [FLTFirebasePlugin firebaseAppNameFromIosName:firebaseApp.name];
  CoreInitializeResponse *response = [CoreInitializeResponse alloc];
  response.name = appNameDart;
  response.options = [self optionsFromFIROptions:firebaseApp.options];
  response.isAutomaticDataCollectionEnabled = @(firebaseApp.isDataCollectionDefaultEnabled);
  response.pluginConstants =
      [[FLTFirebasePluginRegistry sharedInstance] pluginConstantsForFIRApp:firebaseApp];

  return response;
}

#pragma mark - FLTFirebasePlugin

- (void)didReinitializeFirebaseCore:(void (^)(void))completion {
  completion();
}

- (NSDictionary *_Nonnull)pluginConstantsForFIRApp:(FIRApp *)firebase_app {
  return @{};
}

- (NSString *_Nonnull)firebaseLibraryName {
  return @LIBRARY_NAME;
}

- (NSString *_Nonnull)firebaseLibraryVersion {
  return @LIBRARY_VERSION;
}

- (NSString *_Nonnull)flutterChannelName {
  // The pigeon channel depends on each function
  return @"dev.flutter.pigeon.FirebaseCoreHostApi.initializeApp";
}

#pragma mark - API

- (void)initializeAppAppName:(nonnull NSString *)appName
        initializeAppRequest:(nonnull CoreFirebaseOptions *)initializeAppRequest
                  completion:(nonnull void (^)(CoreInitializeResponse *_Nullable,
                                               FlutterError *_Nullable))completion {
  NSString *appNameIos = [FLTFirebasePlugin firebaseAppNameFromDartName:appName];

  if ([FLTFirebasePlugin firebaseAppNamed:appNameIos]) {
    completion([self initializeResponseFromFIRApp:[FLTFirebasePlugin firebaseAppNamed:appNameIos]],
               nil);
    return;
  }

  NSString *appId = initializeAppRequest.appId;
  NSString *messagingSenderId = initializeAppRequest.messagingSenderId;
  FIROptions *options = [[FIROptions alloc] initWithGoogleAppID:appId
                                                    GCMSenderID:messagingSenderId];

  options.APIKey = initializeAppRequest.apiKey;
  options.projectID = initializeAppRequest.projectId;

  // kFirebaseOptionsDatabaseUrl
  if (![initializeAppRequest.databaseURL isEqual:[NSNull null]]) {
    options.databaseURL = initializeAppRequest.databaseURL;
  }

  // kFirebaseOptionsStorageBucket
  if (![options.storageBucket isEqual:[NSNull null]]) {
    options.storageBucket = initializeAppRequest.storageBucket;
  }

  // kFirebaseOptionsIosBundleId
  if (![initializeAppRequest.iosBundleId isEqual:[NSNull null]]) {
    options.bundleID = initializeAppRequest.iosBundleId;
  }

  // kFirebaseOptionsIosClientId
  if (![initializeAppRequest.iosClientId isEqual:[NSNull null]]) {
    options.clientID = initializeAppRequest.iosClientId;
  }

  // kFirebaseOptionsAppGroupId
  if (![initializeAppRequest.appGroupId isEqual:[NSNull null]]) {
    options.appGroupID = initializeAppRequest.appGroupId;
  }

  if (initializeAppRequest.authDomain != nil) {
    customAuthDomains[appNameIos] = initializeAppRequest.authDomain;
  }

  [FIRApp configureWithName:appNameIos options:options];

  completion([self initializeResponseFromFIRApp:[FIRApp appNamed:appNameIos]], nil);
}

- (void)initializeCoreWithCompletion:(nonnull void (^)(NSArray<CoreInitializeResponse *> *_Nullable,
                                                       FlutterError *_Nullable))completion {
  void (^initializeCoreBlock)(void) = ^void() {
    NSDictionary<NSString *, FIRApp *> *firebaseApps = [FIRApp allApps];
    NSMutableArray *firebaseAppsArray = [NSMutableArray arrayWithCapacity:firebaseApps.count];

    for (NSString *appName in firebaseApps) {
      FIRApp *firebaseApp = firebaseApps[appName];
      [firebaseAppsArray addObject:[self initializeResponseFromFIRApp:firebaseApp]];
    }

    completion(firebaseAppsArray, nil);
  };

  if (!_coreInitialized) {
    _coreInitialized = YES;
    initializeCoreBlock();
  } else {
    [[FLTFirebasePluginRegistry sharedInstance] didReinitializeFirebaseCore:initializeCoreBlock];
  }
}

- (void)optionsFromResourceWithCompletion:(nonnull void (^)(CoreFirebaseOptions *_Nullable,
                                                            FlutterError *_Nullable))completion {
  // Unsupported on iOS/MacOS.
  completion(nil, nil);
}

- (void)deleteAppName:(nonnull NSString *)appName
           completion:(nonnull void (^)(FlutterError *_Nullable))completion {
  FIRApp *firebaseApp = [FLTFirebasePlugin firebaseAppNamed:appName];

  if (firebaseApp) {
    [firebaseApp deleteApp:^(BOOL success) {
      if (success) {
        completion(nil);
      } else {
        completion([FlutterError errorWithCode:@"delete-failed"
                                       message:@"Failed to delete a Firebase app instance."
                                       details:nil]);
      }
    }];
  } else {
    completion(nil);
  }
}

- (void)setAutomaticDataCollectionEnabledAppName:(nonnull NSString *)appName
                                         enabled:(BOOL)enabled
                                      completion:
                                          (nonnull void (^)(FlutterError *_Nullable))completion {
  FIRApp *firebaseApp = [FLTFirebasePlugin firebaseAppNamed:appName];
  if (firebaseApp) {
    [firebaseApp setDataCollectionDefaultEnabled:enabled];
  }

  completion(nil);
}

- (void)setAutomaticResourceManagementEnabledAppName:(nonnull NSString *)appName
                                             enabled:(BOOL)enabled
                                          completion:(nonnull void (^)(FlutterError *_Nullable))
                                                         completion {
  // Unsupported on iOS/MacOS.
  completion(nil);
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/FLTFirebasePlugin.m

**크기**: 2435 bytes | **라인 수**: 64 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebasePlugin.h")
#import "include/firebase_core/FLTFirebasePlugin.h"
#else
#import "include/FLTFirebasePlugin.h"
#endif

// Firebase default app name.
NSString *_Nonnull const kFIRDefaultAppNameIOS = @"__FIRAPP_DEFAULT";
NSString *_Nonnull const kFIRDefaultAppNameDart = @"[DEFAULT]";

@interface FLTFirebaseMethodCallResult ()
@property(readwrite, nonatomic) FLTFirebaseMethodCallErrorBlock error;
@property(readwrite, nonatomic) FLTFirebaseMethodCallSuccessBlock success;
@end
@implementation FLTFirebaseMethodCallResult

+ (instancetype)createWithSuccess:(FLTFirebaseMethodCallSuccessBlock)successBlock
                    andErrorBlock:(FLTFirebaseMethodCallErrorBlock)errorBlock {
  FLTFirebaseMethodCallResult *methodCallResult = [[FLTFirebaseMethodCallResult alloc] init];
  methodCallResult.error = errorBlock;
  methodCallResult.success = successBlock;
  return methodCallResult;
}

@end

@implementation FLTFirebasePlugin
+ (FlutterError *_Nonnull)createFlutterErrorFromCode:(NSString *_Nonnull)code
                                             message:(NSString *_Nonnull)message
                                     optionalDetails:(NSDictionary *_Nullable)details
                                  andOptionalNSError:(NSError *_Nullable)error {
  NSMutableDictionary *detailsDict = [NSMutableDictionary dictionaryWithDictionary:details ?: @{}];
  if (error != nil) {
    detailsDict[@"nativeErrorCode"] = [@(error.code) stringValue];
    detailsDict[@"nativeErrorMessage"] = error.localizedDescription;
  }
  return [FlutterError errorWithCode:code message:message details:detailsDict];
}

+ (NSString *)firebaseAppNameFromDartName:(NSString *_Nonnull)appName {
  NSString *appNameIOS = appName;
  if ([kFIRDefaultAppNameDart isEqualToString:appName]) {
    appNameIOS = kFIRDefaultAppNameIOS;
  }
  return appNameIOS;
}

+ (NSString *_Nonnull)firebaseAppNameFromIosName:(NSString *_Nonnull)appName {
  NSString *appNameDart = appName;
  if ([kFIRDefaultAppNameIOS isEqualToString:appName]) {
    appNameDart = kFIRDefaultAppNameDart;
  }
  return appNameDart;
}

+ (FIRApp *_Nullable)firebaseAppNamed:(NSString *_Nonnull)appName {
  return [FIRApp allApps][[self firebaseAppNameFromDartName:appName]];
}
@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/FLTFirebasePluginRegistry.m

**크기**: 2430 bytes | **라인 수**: 80 | **타입**: text

```
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if __has_include("include/firebase_core/FLTFirebasePluginRegistry.h")
#import "include/firebase_core/FLTFirebasePluginRegistry.h"
#else
#import "include/FLTFirebasePluginRegistry.h"
#endif

#if __has_include(<FirebaseCore/FIRAppInternal.h>)
#import <FirebaseCore/FIRAppInternal.h>
#define REGISTER_LIB
#elif __has_include(<FirebaseCoreExtension/FIRAppInternal.h>)
#import <FirebaseCoreExtension/FIRAppInternal.h>
#define REGISTER_LIB
#endif

@implementation FLTFirebasePluginRegistry {
  NSMutableDictionary<NSString *, id<FLTFirebasePlugin>> *registeredPlugins;
}

- (instancetype)init {
  self = [super init];
  if (self) {
    registeredPlugins = [NSMutableDictionary dictionary];
  }
  return self;
}

+ (instancetype)sharedInstance {
  static dispatch_once_t onceToken;
  static FLTFirebasePluginRegistry *instance;

  dispatch_once(&onceToken, ^{
    instance = [[FLTFirebasePluginRegistry alloc] init];
  });

  return instance;
}

- (void)registerFirebasePlugin:(id<FLTFirebasePlugin>)firebasePlugin {
  // Register the library with the Firebase backend.
#ifdef REGISTER_LIB
  [FIRApp registerLibrary:[firebasePlugin firebaseLibraryName]
              withVersion:[firebasePlugin firebaseLibraryVersion]];
#endif
  // Store the plugin delegate for later usage.
  registeredPlugins[[firebasePlugin flutterChannelName]] = firebasePlugin;
}

- (NSDictionary *)pluginConstantsForFIRApp:(FIRApp *)firebaseApp {
  NSString *pluginFlutterChannelName;
  NSMutableDictionary *pluginConstants = [NSMutableDictionary dictionary];

  for (pluginFlutterChannelName in registeredPlugins) {
    pluginConstants[pluginFlutterChannelName] =
        [registeredPlugins[pluginFlutterChannelName] pluginConstantsForFIRApp:firebaseApp];
  }

  return pluginConstants;
}

- (void)didReinitializeFirebaseCore:(void (^_Nonnull)(void))completion {
  __block int pluginsCompleted = 0;
  NSUInteger pluginsCount = [self->registeredPlugins allKeys].count;
  void (^allPluginsCompletion)(void) = ^void() {
    pluginsCompleted++;
    if (pluginsCompleted == pluginsCount) {
      completion();
    }
  };

  for (NSString *pluginFlutterChannelName in registeredPlugins) {
    [registeredPlugins[pluginFlutterChannelName] didReinitializeFirebaseCore:allPluginsCompletion];
  }
}

@end

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/dummy.m

**크기**: 216 bytes | **라인 수**: 4 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Sources/firebase_core/messages.g.m

**크기**: 17238 bytes | **라인 수**: 390 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#if __has_include("include/firebase_core/messages.g.h")
#import "include/firebase_core/messages.g.h"
#else
#import "include/messages.g.h"
#endif

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray<id> *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static id GetNullableObjectAtIndex(NSArray<id> *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface CoreFirebaseOptions ()
+ (CoreFirebaseOptions *)fromList:(NSArray<id> *)list;
+ (nullable CoreFirebaseOptions *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface CoreInitializeResponse ()
+ (CoreInitializeResponse *)fromList:(NSArray<id> *)list;
+ (nullable CoreInitializeResponse *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@implementation CoreFirebaseOptions
+ (instancetype)makeWithApiKey:(NSString *)apiKey
                         appId:(NSString *)appId
             messagingSenderId:(NSString *)messagingSenderId
                     projectId:(NSString *)projectId
                    authDomain:(nullable NSString *)authDomain
                   databaseURL:(nullable NSString *)databaseURL
                 storageBucket:(nullable NSString *)storageBucket
                 measurementId:(nullable NSString *)measurementId
                    trackingId:(nullable NSString *)trackingId
             deepLinkURLScheme:(nullable NSString *)deepLinkURLScheme
               androidClientId:(nullable NSString *)androidClientId
                   iosClientId:(nullable NSString *)iosClientId
                   iosBundleId:(nullable NSString *)iosBundleId
                    appGroupId:(nullable NSString *)appGroupId {
  CoreFirebaseOptions *pigeonResult = [[CoreFirebaseOptions alloc] init];
  pigeonResult.apiKey = apiKey;
  pigeonResult.appId = appId;
  pigeonResult.messagingSenderId = messagingSenderId;
  pigeonResult.projectId = projectId;
  pigeonResult.authDomain = authDomain;
  pigeonResult.databaseURL = databaseURL;
  pigeonResult.storageBucket = storageBucket;
  pigeonResult.measurementId = measurementId;
  pigeonResult.trackingId = trackingId;
  pigeonResult.deepLinkURLScheme = deepLinkURLScheme;
  pigeonResult.androidClientId = androidClientId;
  pigeonResult.iosClientId = iosClientId;
  pigeonResult.iosBundleId = iosBundleId;
  pigeonResult.appGroupId = appGroupId;
  return pigeonResult;
}
+ (CoreFirebaseOptions *)fromList:(NSArray<id> *)list {
  CoreFirebaseOptions *pigeonResult = [[CoreFirebaseOptions alloc] init];
  pigeonResult.apiKey = GetNullableObjectAtIndex(list, 0);
  pigeonResult.appId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.messagingSenderId = GetNullableObjectAtIndex(list, 2);
  pigeonResult.projectId = GetNullableObjectAtIndex(list, 3);
  pigeonResult.authDomain = GetNullableObjectAtIndex(list, 4);
  pigeonResult.databaseURL = GetNullableObjectAtIndex(list, 5);
  pigeonResult.storageBucket = GetNullableObjectAtIndex(list, 6);
  pigeonResult.measurementId = GetNullableObjectAtIndex(list, 7);
  pigeonResult.trackingId = GetNullableObjectAtIndex(list, 8);
  pigeonResult.deepLinkURLScheme = GetNullableObjectAtIndex(list, 9);
  pigeonResult.androidClientId = GetNullableObjectAtIndex(list, 10);
  pigeonResult.iosClientId = GetNullableObjectAtIndex(list, 11);
  pigeonResult.iosBundleId = GetNullableObjectAtIndex(list, 12);
  pigeonResult.appGroupId = GetNullableObjectAtIndex(list, 13);
  return pigeonResult;
}
+ (nullable CoreFirebaseOptions *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [CoreFirebaseOptions fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.apiKey ?: [NSNull null],
    self.appId ?: [NSNull null],
    self.messagingSenderId ?: [NSNull null],
    self.projectId ?: [NSNull null],
    self.authDomain ?: [NSNull null],
    self.databaseURL ?: [NSNull null],
    self.storageBucket ?: [NSNull null],
    self.measurementId ?: [NSNull null],
    self.trackingId ?: [NSNull null],
    self.deepLinkURLScheme ?: [NSNull null],
    self.androidClientId ?: [NSNull null],
    self.iosClientId ?: [NSNull null],
    self.iosBundleId ?: [NSNull null],
    self.appGroupId ?: [NSNull null],
  ];
}
@end

@implementation CoreInitializeResponse
+ (instancetype)makeWithName:(NSString *)name
                             options:(CoreFirebaseOptions *)options
    isAutomaticDataCollectionEnabled:(nullable NSNumber *)isAutomaticDataCollectionEnabled
                     pluginConstants:(NSDictionary<NSString *, id> *)pluginConstants {
  CoreInitializeResponse *pigeonResult = [[CoreInitializeResponse alloc] init];
  pigeonResult.name = name;
  pigeonResult.options = options;
  pigeonResult.isAutomaticDataCollectionEnabled = isAutomaticDataCollectionEnabled;
  pigeonResult.pluginConstants = pluginConstants;
  return pigeonResult;
}
+ (CoreInitializeResponse *)fromList:(NSArray<id> *)list {
  CoreInitializeResponse *pigeonResult = [[CoreInitializeResponse alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.options = GetNullableObjectAtIndex(list, 1);
  pigeonResult.isAutomaticDataCollectionEnabled = GetNullableObjectAtIndex(list, 2);
  pigeonResult.pluginConstants = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable CoreInitializeResponse *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [CoreInitializeResponse fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.name ?: [NSNull null],
    self.options ?: [NSNull null],
    self.isAutomaticDataCollectionEnabled ?: [NSNull null],
    self.pluginConstants ?: [NSNull null],
  ];
}
@end

@interface nullMessagesPigeonCodecReader : FlutterStandardReader
@end
@implementation nullMessagesPigeonCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 129:
      return [CoreFirebaseOptions fromList:[self readValue]];
    case 130:
      return [CoreInitializeResponse fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface nullMessagesPigeonCodecWriter : FlutterStandardWriter
@end
@implementation nullMessagesPigeonCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[CoreFirebaseOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[CoreInitializeResponse class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface nullMessagesPigeonCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation nullMessagesPigeonCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[nullMessagesPigeonCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[nullMessagesPigeonCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *nullGetMessagesCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    nullMessagesPigeonCodecReaderWriter *readerWriter =
        [[nullMessagesPigeonCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}
void SetUpFirebaseCoreHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FirebaseCoreHostApi> *api) {
  SetUpFirebaseCoreHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseCoreHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FirebaseCoreHostApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseCoreHostApi.initializeApp",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeAppAppName:
                                                  initializeAppRequest:completion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(initializeAppAppName:initializeAppRequest:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        CoreFirebaseOptions *arg_initializeAppRequest = GetNullableObjectAtIndex(args, 1);
        [api initializeAppAppName:arg_appName
             initializeAppRequest:arg_initializeAppRequest
                       completion:^(CoreInitializeResponse *_Nullable output,
                                    FlutterError *_Nullable error) {
                         callback(wrapResult(output, error));
                       }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseCoreHostApi.initializeCore",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeCoreWithCompletion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(initializeCoreWithCompletion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api initializeCoreWithCompletion:^(NSArray<CoreInitializeResponse *> *_Nullable output,
                                            FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:@"%@%@",
                                             @"dev.flutter.pigeon.firebase_core_platform_interface."
                                             @"FirebaseCoreHostApi.optionsFromResource",
                                             messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(optionsFromResourceWithCompletion:)],
                @"FirebaseCoreHostApi api (%@) doesn't respond to "
                @"@selector(optionsFromResourceWithCompletion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api optionsFromResourceWithCompletion:^(CoreFirebaseOptions *_Nullable output,
                                                 FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
void SetUpFirebaseAppHostApi(id<FlutterBinaryMessenger> binaryMessenger,
                             NSObject<FirebaseAppHostApi> *api) {
  SetUpFirebaseAppHostApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFirebaseAppHostApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                       NSObject<FirebaseAppHostApi> *api,
                                       NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString stringWithFormat:@"%@%@",
                                          @"dev.flutter.pigeon.firebase_core_platform_interface."
                                          @"FirebaseAppHostApi.setAutomaticDataCollectionEnabled",
                                          messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (setAutomaticDataCollectionEnabledAppName:enabled:completion:)],
                @"FirebaseAppHostApi api (%@) doesn't respond to "
                @"@selector(setAutomaticDataCollectionEnabledAppName:enabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        BOOL arg_enabled = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api setAutomaticDataCollectionEnabledAppName:arg_appName
                                              enabled:arg_enabled
                                           completion:^(FlutterError *_Nullable error) {
                                             callback(wrapResult(nil, error));
                                           }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:
                                      @"%@%@",
                                      @"dev.flutter.pigeon.firebase_core_platform_interface."
                                      @"FirebaseAppHostApi.setAutomaticResourceManagementEnabled",
                                      messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector
                     (setAutomaticResourceManagementEnabledAppName:enabled:completion:)],
                @"FirebaseAppHostApi api (%@) doesn't respond to "
                @"@selector(setAutomaticResourceManagementEnabledAppName:enabled:completion:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        BOOL arg_enabled = [GetNullableObjectAtIndex(args, 1) boolValue];
        [api setAutomaticResourceManagementEnabledAppName:arg_appName
                                                  enabled:arg_enabled
                                               completion:^(FlutterError *_Nullable error) {
                                                 callback(wrapResult(nil, error));
                                               }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.firebase_core_platform_"
                                                   @"interface.FirebaseAppHostApi.delete",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(deleteAppName:completion:)],
          @"FirebaseAppHostApi api (%@) doesn't respond to @selector(deleteAppName:completion:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_appName = GetNullableObjectAtIndex(args, 0);
        [api deleteAppName:arg_appName
                completion:^(FlutterError *_Nullable error) {
                  callback(wrapResult(nil, error));
                }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/macos/firebase_core/Package.swift

**크기**: 4671 bytes | **라인 수**: 134 | **타입**: text

```
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import PackageDescription

enum ConfigurationError: Error {
  case fileNotFound(String)
  case parsingError(String)
  case invalidFormat(String)
}

let firebaseCoreDirectory = String(URL(string: #file)!.deletingLastPathComponent().absoluteString
  .dropLast())

func loadPubspecVersion() throws -> String {
  let pubspecPath = NSString.path(withComponents: [
    firebaseCoreDirectory,
    "..",
    "..",
    "pubspec.yaml",
  ])
  do {
    let yamlString = try String(contentsOfFile: pubspecPath, encoding: .utf8)
    if let versionLine = yamlString.split(separator: "\n")
      .first(where: { $0.starts(with: "version:") }) {
      let version = versionLine.split(separator: ":")[1].trimmingCharacters(in: .whitespaces)
      return version.replacingOccurrences(of: "+", with: "-")
    } else {
      throw ConfigurationError.invalidFormat("No version line found in pubspec.yaml")
    }
  } catch {
    throw ConfigurationError.fileNotFound("Error loading or parsing pubspec.yaml: \(error)")
  }
}

func loadFirebaseSDKVersion() throws -> String {
  let firebaseCoreScriptPath = NSString.path(withComponents: [
    firebaseCoreDirectory,
    "..",
    "..",
    "ios",
    "firebase_sdk_version.rb",
  ])
  do {
    let content = try String(contentsOfFile: firebaseCoreScriptPath, encoding: .utf8)
    let pattern = #"def firebase_sdk_version!\(\)\n\s+'([^']+)'\nend"#
    if let regex = try? NSRegularExpression(pattern: pattern, options: []),
       let match = regex.firstMatch(
         in: content,
         range: NSRange(content.startIndex..., in: content)
       ) {
      if let versionRange = Range(match.range(at: 1), in: content) {
        return String(content[versionRange])
      } else {
        throw ConfigurationError.invalidFormat("Invalid format in firebase_sdk_version.rb")
      }
    } else {
      throw ConfigurationError.parsingError("No match found in firebase_sdk_version.rb")
    }
  } catch {
    throw ConfigurationError
      .fileNotFound("Error loading or parsing firebase_sdk_version.rb: \(error)")
  }
}

let library_version_string: String
let firebase_sdk_version_string: String
let shared_spm_tag = "-firebase-core-swift"

do {
  library_version_string = try loadPubspecVersion()
  firebase_sdk_version_string = try loadFirebaseSDKVersion()
} catch {
  fatalError("Failed to load configuration: \(error)")
}

guard let firebase_sdk_version = Version(firebase_sdk_version_string) else {
  fatalError("Invalid Firebase SDK version: \(firebase_sdk_version_string)")
}

// TODO: - we can try using existing firebase_core tag once flutterfire/Package.swift is part of release cycle
// but I don't think it'll work as Swift versioning requires version-[tag name]
guard let shared_spm_version = Version("\(library_version_string)\(shared_spm_tag)") else {
  fatalError("Invalid firebase_core version: \(library_version_string)\(shared_spm_tag)")
}

let package = Package(
  name: "firebase_core",
  platforms: [
    .macOS("10.15"),
  ],
  products: [
    .library(name: "firebase-core", targets: ["firebase_core"]),
  ],
  dependencies: [
    .package(url: "https://github.com/firebase/firebase-ios-sdk", from: firebase_sdk_version),
    .package(url: "https://github.com/firebase/flutterfire", exact: shared_spm_version),
  ],
  targets: [
    .target(
      name: "firebase_core",
      dependencies: [
        // No product for firebase-core so we pull in the smallest one
        .product(name: "FirebaseInstallations", package: "firebase-ios-sdk"),
        .product(name: "firebase-core-shared", package: "flutterfire"),
      ],
      exclude: [
        // These are now pulled in as a remote dependency from FlutterFire repo
        "FLTFirebaseCorePlugin.m",
        "FLTFirebasePlugin.m",
        "FLTFirebasePluginRegistry.m",
        "messages.g.m",
        "include/firebase_core/FLTFirebaseCorePlugin.h",
        "include/firebase_core/messages.g.h",
        "include/firebase_core/FLTFirebasePlugin.h",
        "include/firebase_core/FLTFirebasePluginRegistry.h",
      ],
      resources: [
        .process("Resources"),
      ],
      cSettings: [
        .headerSearchPath("include/firebase_core"),
        .define("LIBRARY_VERSION", to: "\"\(library_version_string)\""),
        .define("LIBRARY_NAME", to: "\"flutter-fire-core\""),
      ]
    ),
  ]
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/test/firebase_core_test.dart

**크기**: 3355 bytes | **라인 수**: 116 | **타입**: text

```
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  group('$FirebaseApp', () {
    final mock = MockFirebaseCore();

    const FirebaseOptions testOptions = FirebaseOptions(
      apiKey: 'apiKey',
      appId: 'appId',
      messagingSenderId: 'messagingSenderId',
      projectId: 'projectId',
    );

    String testAppName = 'testApp';

    setUp(() async {
      clearInteractions(mock);
      Firebase.delegatePackingProperty = mock;

      final FirebaseAppPlatform platformApp =
          FirebaseAppPlatform(testAppName, testOptions);

      when(mock.apps).thenReturn([platformApp]);
      when(mock.app(testAppName)).thenReturn(platformApp);
      when(mock.initializeApp(name: testAppName, options: testOptions))
          .thenAnswer((_) {
        return Future.value(platformApp);
      });
    });

    test('.apps', () {
      List<FirebaseApp> apps = Firebase.apps;
      verify(mock.apps);
      expect(apps[0], Firebase.app(testAppName));
    });

    test('.app()', () {
      FirebaseApp app = Firebase.app(testAppName);
      verify(mock.app(testAppName));

      expect(app.name, testAppName);
      expect(app.options, testOptions);
    });

    test('.initializeApp()', () async {
      FirebaseApp initializedApp =
          await Firebase.initializeApp(name: testAppName, options: testOptions);
      FirebaseApp app = Firebase.app(testAppName);

      expect(initializedApp, app);
      verifyInOrder([
        mock.initializeApp(name: testAppName, options: testOptions),
        mock.app(testAppName),
      ]);
    });
  });
}

class MockFirebaseCore extends Mock
    with
        // ignore: prefer_mixin, plugin_platform_interface needs to migrate to use `mixin`
        MockPlatformInterfaceMixin
    implements
        FirebasePlatform {
  @override
  FirebaseAppPlatform app([String name = defaultFirebaseAppName]) {
    return super.noSuchMethod(
      Invocation.method(#app, [name]),
      returnValue: FakeFirebaseAppPlatform(),
      returnValueForMissingStub: FakeFirebaseAppPlatform(),
    );
  }

  @override
  Future<FirebaseAppPlatform> initializeApp({
    String? name,
    FirebaseOptions? options,
  }) {
    return super.noSuchMethod(
      Invocation.method(
        #initializeApp,
        const [],
        {
          #name: name,
          #options: options,
        },
      ),
      returnValue: Future.value(FakeFirebaseAppPlatform()),
      returnValueForMissingStub: Future.value(FakeFirebaseAppPlatform()),
    );
  }

  @override
  List<FirebaseAppPlatform> get apps {
    return super.noSuchMethod(
      Invocation.getter(#apps),
      returnValue: <FirebaseAppPlatform>[],
      returnValueForMissingStub: <FirebaseAppPlatform>[],
    );
  }
}

// ignore: avoid_implementing_value_types
class FakeFirebaseAppPlatform extends Fake implements FirebaseAppPlatform {}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/include/firebase_core/firebase_core_plugin_c_api.h

**크기**: 730 bytes | **라인 수**: 25 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_C_API_H_
#define FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_C_API_H_

#include <flutter_plugin_registrar.h>

#include <string>
#include <vector>

#ifdef FLUTTER_PLUGIN_IMPL
#define FLUTTER_PLUGIN_EXPORT __declspec(dllexport)
#else
#define FLUTTER_PLUGIN_EXPORT __declspec(dllimport)
#endif

FLUTTER_PLUGIN_EXPORT void FirebaseCorePluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar);

#endif  // FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_C_API_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/CMakeLists.txt

**크기**: 5871 bytes | **라인 수**: 149 | **타입**: text

```
# The Flutter tooling requires that developers have a version of Visual Studio
# installed that includes CMake 3.14 or later. You should not increase this
# version, as doing so will cause the plugin to fail to compile for some
# customers of the plugin.
cmake_minimum_required(VERSION 3.14)

set(FIREBASE_SDK_VERSION "12.7.0")

if (EXISTS $ENV{FIREBASE_CPP_SDK_DIR}/include/firebase/version.h)
    file(READ "$ENV{FIREBASE_CPP_SDK_DIR}/include/firebase/version.h" existing_version)

    string(REGEX MATCH "FIREBASE_VERSION_MAJOR ([0-9]*)" _ ${existing_version})
    set(existing_version_major ${CMAKE_MATCH_1})

    string(REGEX MATCH "FIREBASE_VERSION_MINOR ([0-9]*)" _ ${existing_version})
    set(existing_version_minor ${CMAKE_MATCH_1})

    string(REGEX MATCH "FIREBASE_VERSION_REVISION ([0-9]*)" _ ${existing_version})
    set(existing_version_revision ${CMAKE_MATCH_1})

    set(existing_version "${existing_version_major}.${existing_version_minor}.${existing_version_revision}")
endif()

if(existing_version VERSION_EQUAL FIREBASE_SDK_VERSION)
    message(STATUS "Found Firebase SDK version ${existing_version}")
    set(FIREBASE_CPP_SDK_DIR $ENV{FIREBASE_CPP_SDK_DIR})
else()
    set(firebase_sdk_url "https://dl.google.com/firebase/sdk/cpp/firebase_cpp_sdk_windows_${FIREBASE_SDK_VERSION}.zip")
    set(firebase_sdk_filename "${CMAKE_BINARY_DIR}/firebase_cpp_sdk_windows_${FIREBASE_SDK_VERSION}.zip")
    set(extracted_path "${CMAKE_BINARY_DIR}/extracted")
    if(NOT EXISTS ${firebase_sdk_filename})
        file(DOWNLOAD ${firebase_sdk_url} ${firebase_sdk_filename}
             SHOW_PROGRESS
             STATUS download_status
             LOG download_log)
        list(GET download_status 0 status_code)
        if(NOT status_code EQUAL 0)
            message(FATAL_ERROR "Download failed: ${download_log}")
        endif()
    else()
        message(STATUS "Using cached Firebase SDK zip file")
    endif()

    if(NOT EXISTS ${extracted_path})
        file(MAKE_DIRECTORY ${extracted_path})
        file(ARCHIVE_EXTRACT INPUT ${firebase_sdk_filename}
             DESTINATION ${extracted_path})
    else()
        message(STATUS "Using cached extracted Firebase SDK")
    endif()
    set(FIREBASE_CPP_SDK_DIR "${extracted_path}/firebase_cpp_sdk_windows")
endif()

# Project-level configuration.
set(PROJECT_NAME "firebase_core")
project(${PROJECT_NAME} LANGUAGES CXX)

# This value is used when generating builds using this plugin, so it must
# not be changed
set(PLUGIN_NAME "firebase_core_plugin")

# Any new source files that you add to the plugin should be added here.
list(APPEND PLUGIN_SOURCES
  "firebase_core_plugin.cpp"
  "firebase_core_plugin.h"
  "messages.g.cpp"
  "messages.g.h"
)

# Read version from pubspec.yaml
file(STRINGS "../pubspec.yaml" pubspec_content)
foreach(line ${pubspec_content})
  string(FIND ${line} "version: " has_version)
  
  if("${has_version}" STREQUAL "0")
    string(FIND ${line} ": " version_start_pos)
    math(EXPR version_start_pos "${version_start_pos} + 2")
    string(LENGTH ${line} version_end_pos)
    math(EXPR len "${version_end_pos} - ${version_start_pos}")
    string(SUBSTRING ${line} ${version_start_pos} ${len} PLUGIN_VERSION)
    break()
  endif()
endforeach(line)

configure_file(plugin_version.h.in ${CMAKE_BINARY_DIR}/generated/firebase_core/plugin_version.h)
include_directories(${CMAKE_BINARY_DIR}/generated/)

# Define the plugin library target. Its name must not be changed (see comment
# on PLUGIN_NAME above).
add_library(${PLUGIN_NAME} STATIC
  "include/firebase_core/firebase_core_plugin_c_api.h"
  "firebase_core_plugin_c_api.cpp"
  ${PLUGIN_SOURCES}
  ${CMAKE_BINARY_DIR}/generated/firebase_core/plugin_version.h
)


# Apply a standard set of build settings that are configured in the
# application-level CMakeLists.txt. This can be removed for plugins that want
# full control over build settings.
apply_standard_settings(${PLUGIN_NAME})

# Symbols are hidden by default to reduce the chance of accidental conflicts
# between plugins. This should not be removed; any symbols that should be
# exported should be explicitly exported with the FLUTTER_PLUGIN_EXPORT macro.
set_target_properties(${PLUGIN_NAME} PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_compile_definitions(${PLUGIN_NAME} PUBLIC FLUTTER_PLUGIN_IMPL)

# Enable firebase-cpp-sdk's platform logging api.
target_compile_definitions(${PLUGIN_NAME} PRIVATE -DINTERNAL_EXPERIMENTAL=1)

# Source include directories and library dependencies. Add any plugin-specific
# dependencies here.
if(NOT MSVC_RUNTIME_MODE)
  set(MSVC_RUNTIME_MODE MD)
endif()

add_subdirectory(${FIREBASE_CPP_SDK_DIR} bin/ EXCLUDE_FROM_ALL)
target_include_directories(${PLUGIN_NAME} INTERFACE
  "${FIREBASE_CPP_SDK_DIR}/include")

set(FIREBASE_RELEASE_PATH_LIBS firebase_app firebase_auth firebase_storage firebase_firestore)
foreach(firebase_lib IN ITEMS ${FIREBASE_RELEASE_PATH_LIBS})
    get_target_property(firebase_lib_path ${firebase_lib} IMPORTED_LOCATION)
    string(REPLACE "Debug" "Release" firebase_lib_release_path ${firebase_lib_path})
    set_target_properties(${firebase_lib} PROPERTIES
      IMPORTED_LOCATION_DEBUG "${firebase_lib_path}"
      IMPORTED_LOCATION_RELEASE "${firebase_lib_release_path}"
    )
endforeach()

set(FIREBASE_LIBS firebase_app)
set(ADDITIONAL_LIBS advapi32 ws2_32 crypt32 rpcrt4 ole32 icu)

target_link_libraries(${PLUGIN_NAME} PUBLIC "${FIREBASE_LIBS}" "${ADDITIONAL_LIBS}")

target_include_directories(${PLUGIN_NAME} INTERFACE
  "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(${PLUGIN_NAME} PUBLIC flutter flutter_wrapper_plugin)

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(firebase_core_bundled_libraries
  ""
  PARENT_SCOPE
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/firebase_core_plugin.cpp

**크기**: 5619 bytes | **라인 수**: 170 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "firebase_core_plugin.h"

// This must be included before many other Windows headers.
#include <windows.h>

#include "firebase/app.h"
#include "firebase_core/plugin_version.h"
#include "messages.g.h"

// For getPlatformVersion; remove unless needed for your plugin implementation.
#include <VersionHelpers.h>
#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>
#include <flutter/standard_method_codec.h>

#include <future>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

using ::firebase::App;

namespace firebase_core_windows {

static std::string kLibraryName = "flutter-fire-core";

// static
void FirebaseCorePlugin::RegisterWithRegistrar(
    flutter::PluginRegistrarWindows* registrar) {
  auto plugin = std::make_unique<FirebaseCorePlugin>();

  FirebaseCoreHostApi::SetUp(registrar->messenger(), plugin.get());
  FirebaseAppHostApi::SetUp(registrar->messenger(), plugin.get());

  registrar->AddPlugin(std::move(plugin));

  // Register for platform logging
  App::RegisterLibrary(kLibraryName.c_str(), getPluginVersion().c_str(),
                       nullptr);
}

FirebaseCorePlugin::FirebaseCorePlugin() {}

FirebaseCorePlugin::~FirebaseCorePlugin() = default;

// Convert a CoreFirebaseOptions to a Firebase Options.
firebase::AppOptions CoreFirebaseOptionsToAppOptions(
    const CoreFirebaseOptions& pigeon_options) {
  firebase::AppOptions options;
  options.set_api_key(pigeon_options.api_key().c_str());
  options.set_app_id(pigeon_options.app_id().c_str());
  if (pigeon_options.database_u_r_l() != nullptr) {
    options.set_database_url(pigeon_options.database_u_r_l()->c_str());
  }
  if (pigeon_options.tracking_id() != nullptr) {
    options.set_ga_tracking_id(pigeon_options.tracking_id()->c_str());
  }
  options.set_messaging_sender_id(pigeon_options.messaging_sender_id().c_str());

  options.set_project_id(pigeon_options.project_id().c_str());

  if (pigeon_options.storage_bucket() != nullptr) {
    options.set_storage_bucket(pigeon_options.storage_bucket()->c_str());
  }
  return options;
}

// Convert a AppOptions to CoreFirebaseOptions
CoreFirebaseOptions optionsFromFIROptions(const firebase::AppOptions& options) {
  CoreFirebaseOptions pigeon_options =
      CoreFirebaseOptions(options.api_key(), options.app_id(),
                          options.messaging_sender_id(), options.project_id());
  // AppOptions initialises as empty char so we check to stop empty string to
  // Flutter Same for storage bucket below
  const char* db_url = options.database_url();
  if (db_url != nullptr && db_url[0] != '\0') {
    pigeon_options.set_database_u_r_l(db_url);
  }
  pigeon_options.set_tracking_id(nullptr);

  const char* storage_bucket = options.storage_bucket();
  if (storage_bucket != nullptr && storage_bucket[0] != '\0') {
    pigeon_options.set_storage_bucket(storage_bucket);
  }
  return pigeon_options;
}

// Convert a firebase::App to CoreInitializeResponse
CoreInitializeResponse AppToCoreInitializeResponse(const App& app) {
  flutter::EncodableMap plugin_constants;
  CoreInitializeResponse response = CoreInitializeResponse(
      app.name(), optionsFromFIROptions(app.options()), plugin_constants);
  return response;
}

void FirebaseCorePlugin::InitializeApp(
    const std::string& app_name,
    const CoreFirebaseOptions& initialize_app_request,
    std::function<void(ErrorOr<CoreInitializeResponse> reply)> result) {
  // Create an app
  App* app =
      App::Create(CoreFirebaseOptionsToAppOptions(initialize_app_request),
                  app_name.c_str());

  // Send back the result to Flutter
  result(AppToCoreInitializeResponse(*app));
}

void FirebaseCorePlugin::InitializeCore(
    std::function<void(ErrorOr<flutter::EncodableList> reply)> result) {
  // TODO: Missing function to get the list of currently initialized apps
  std::vector<CoreInitializeResponse> initializedApps;
  std::vector<App*> all_apps = App::GetApps();
  for (const App* app : all_apps) {
    initializedApps.push_back(AppToCoreInitializeResponse(*app));
  }

  flutter::EncodableList encodableList;

  for (const auto& item : initializedApps) {
    encodableList.push_back(flutter::CustomEncodableValue(item));
  }
  result(encodableList);
}

void FirebaseCorePlugin::OptionsFromResource(
    std::function<void(ErrorOr<CoreFirebaseOptions> reply)> result) {}

void FirebaseCorePlugin::SetAutomaticDataCollectionEnabled(
    const std::string& app_name, bool enabled,
    std::function<void(std::optional<FlutterError> reply)> result) {
  App* firebaseApp = App::GetInstance(app_name.c_str());
  if (firebaseApp != nullptr) {
    // TODO: Missing method
  }
  result(std::nullopt);
}

void FirebaseCorePlugin::SetAutomaticResourceManagementEnabled(
    const std::string& app_name, bool enabled,
    std::function<void(std::optional<FlutterError> reply)> result) {
  App* firebaseApp = App::GetInstance(app_name.c_str());
  if (firebaseApp != nullptr) {
    // TODO: Missing method
  }

  result(std::nullopt);
}

void FirebaseCorePlugin::Delete(
    const std::string& app_name,
    std::function<void(std::optional<FlutterError> reply)> result) {
  App* firebaseApp = App::GetInstance(app_name.c_str());
  if (firebaseApp != nullptr) {
    // TODO: Missing method
  }

  result(std::nullopt);
}

}  // namespace firebase_core_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/firebase_core_plugin.h

**크기**: 2096 bytes | **라인 수**: 64 | **타입**: text

```
/*
 * Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

#ifndef FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_H_
#define FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_H_

#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>

#include <map>
#include <memory>

#include "messages.g.h"

namespace firebase_core_windows {

class FirebaseCorePlugin : public flutter::Plugin,
                           public FirebaseCoreHostApi,
                           public FirebaseAppHostApi {
 public:
  static void RegisterWithRegistrar(flutter::PluginRegistrarWindows* registrar);

  FirebaseCorePlugin();

  virtual ~FirebaseCorePlugin();

  // Disallow copy and assign.
  FirebaseCorePlugin(const FirebaseCorePlugin&) = delete;
  FirebaseCorePlugin& operator=(const FirebaseCorePlugin&) = delete;

  // FirebaseCoreHostApi
  virtual void InitializeApp(
      const std::string& app_name,
      const CoreFirebaseOptions& initialize_app_request,
      std::function<void(ErrorOr<CoreInitializeResponse> reply)> result)
      override;
  virtual void InitializeCore(
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result)
      override;
  virtual void OptionsFromResource(
      std::function<void(ErrorOr<CoreFirebaseOptions> reply)> result) override;

  // FirebaseAppHostApi
  virtual void SetAutomaticDataCollectionEnabled(
      const std::string& app_name, bool enabled,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void SetAutomaticResourceManagementEnabled(
      const std::string& app_name, bool enabled,
      std::function<void(std::optional<FlutterError> reply)> result) override;
  virtual void Delete(
      const std::string& app_name,
      std::function<void(std::optional<FlutterError> reply)> result) override;

 private:
  bool coreInitialized = false;
};

}  // namespace firebase_core_windows

#endif  // FLUTTER_PLUGIN_FIREBASE_CORE_PLUGIN_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/firebase_core_plugin_c_api.cpp

**크기**: 693 bytes | **라인 수**: 20 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#include "include/firebase_core/firebase_core_plugin_c_api.h"

#include <flutter/plugin_registrar_windows.h>

#include <string>
#include <vector>

#include "firebase_core_plugin.h"

void FirebaseCorePluginCApiRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar) {
  firebase_core_windows::FirebaseCorePlugin::RegisterWithRegistrar(
      flutter::PluginRegistrarManager::GetInstance()
          ->GetRegistrar<flutter::PluginRegistrarWindows>(registrar));
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/messages.g.cpp

**크기**: 29934 bytes | **라인 수**: 787 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace firebase_core_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// CoreFirebaseOptions

CoreFirebaseOptions::CoreFirebaseOptions(const std::string& api_key,
                                         const std::string& app_id,
                                         const std::string& messaging_sender_id,
                                         const std::string& project_id)
    : api_key_(api_key),
      app_id_(app_id),
      messaging_sender_id_(messaging_sender_id),
      project_id_(project_id) {}

CoreFirebaseOptions::CoreFirebaseOptions(
    const std::string& api_key, const std::string& app_id,
    const std::string& messaging_sender_id, const std::string& project_id,
    const std::string* auth_domain, const std::string* database_u_r_l,
    const std::string* storage_bucket, const std::string* measurement_id,
    const std::string* tracking_id, const std::string* deep_link_u_r_l_scheme,
    const std::string* android_client_id, const std::string* ios_client_id,
    const std::string* ios_bundle_id, const std::string* app_group_id)
    : api_key_(api_key),
      app_id_(app_id),
      messaging_sender_id_(messaging_sender_id),
      project_id_(project_id),
      auth_domain_(auth_domain ? std::optional<std::string>(*auth_domain)
                               : std::nullopt),
      database_u_r_l_(database_u_r_l
                          ? std::optional<std::string>(*database_u_r_l)
                          : std::nullopt),
      storage_bucket_(storage_bucket
                          ? std::optional<std::string>(*storage_bucket)
                          : std::nullopt),
      measurement_id_(measurement_id
                          ? std::optional<std::string>(*measurement_id)
                          : std::nullopt),
      tracking_id_(tracking_id ? std::optional<std::string>(*tracking_id)
                               : std::nullopt),
      deep_link_u_r_l_scheme_(
          deep_link_u_r_l_scheme
              ? std::optional<std::string>(*deep_link_u_r_l_scheme)
              : std::nullopt),
      android_client_id_(android_client_id
                             ? std::optional<std::string>(*android_client_id)
                             : std::nullopt),
      ios_client_id_(ios_client_id ? std::optional<std::string>(*ios_client_id)
                                   : std::nullopt),
      ios_bundle_id_(ios_bundle_id ? std::optional<std::string>(*ios_bundle_id)
                                   : std::nullopt),
      app_group_id_(app_group_id ? std::optional<std::string>(*app_group_id)
                                 : std::nullopt) {}

const std::string& CoreFirebaseOptions::api_key() const { return api_key_; }

void CoreFirebaseOptions::set_api_key(std::string_view value_arg) {
  api_key_ = value_arg;
}

const std::string& CoreFirebaseOptions::app_id() const { return app_id_; }

void CoreFirebaseOptions::set_app_id(std::string_view value_arg) {
  app_id_ = value_arg;
}

const std::string& CoreFirebaseOptions::messaging_sender_id() const {
  return messaging_sender_id_;
}

void CoreFirebaseOptions::set_messaging_sender_id(std::string_view value_arg) {
  messaging_sender_id_ = value_arg;
}

const std::string& CoreFirebaseOptions::project_id() const {
  return project_id_;
}

void CoreFirebaseOptions::set_project_id(std::string_view value_arg) {
  project_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::auth_domain() const {
  return auth_domain_ ? &(*auth_domain_) : nullptr;
}

void CoreFirebaseOptions::set_auth_domain(const std::string_view* value_arg) {
  auth_domain_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_auth_domain(std::string_view value_arg) {
  auth_domain_ = value_arg;
}

const std::string* CoreFirebaseOptions::database_u_r_l() const {
  return database_u_r_l_ ? &(*database_u_r_l_) : nullptr;
}

void CoreFirebaseOptions::set_database_u_r_l(
    const std::string_view* value_arg) {
  database_u_r_l_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_database_u_r_l(std::string_view value_arg) {
  database_u_r_l_ = value_arg;
}

const std::string* CoreFirebaseOptions::storage_bucket() const {
  return storage_bucket_ ? &(*storage_bucket_) : nullptr;
}

void CoreFirebaseOptions::set_storage_bucket(
    const std::string_view* value_arg) {
  storage_bucket_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_storage_bucket(std::string_view value_arg) {
  storage_bucket_ = value_arg;
}

const std::string* CoreFirebaseOptions::measurement_id() const {
  return measurement_id_ ? &(*measurement_id_) : nullptr;
}

void CoreFirebaseOptions::set_measurement_id(
    const std::string_view* value_arg) {
  measurement_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_measurement_id(std::string_view value_arg) {
  measurement_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::tracking_id() const {
  return tracking_id_ ? &(*tracking_id_) : nullptr;
}

void CoreFirebaseOptions::set_tracking_id(const std::string_view* value_arg) {
  tracking_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_tracking_id(std::string_view value_arg) {
  tracking_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::deep_link_u_r_l_scheme() const {
  return deep_link_u_r_l_scheme_ ? &(*deep_link_u_r_l_scheme_) : nullptr;
}

void CoreFirebaseOptions::set_deep_link_u_r_l_scheme(
    const std::string_view* value_arg) {
  deep_link_u_r_l_scheme_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_deep_link_u_r_l_scheme(
    std::string_view value_arg) {
  deep_link_u_r_l_scheme_ = value_arg;
}

const std::string* CoreFirebaseOptions::android_client_id() const {
  return android_client_id_ ? &(*android_client_id_) : nullptr;
}

void CoreFirebaseOptions::set_android_client_id(
    const std::string_view* value_arg) {
  android_client_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_android_client_id(std::string_view value_arg) {
  android_client_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::ios_client_id() const {
  return ios_client_id_ ? &(*ios_client_id_) : nullptr;
}

void CoreFirebaseOptions::set_ios_client_id(const std::string_view* value_arg) {
  ios_client_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_ios_client_id(std::string_view value_arg) {
  ios_client_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::ios_bundle_id() const {
  return ios_bundle_id_ ? &(*ios_bundle_id_) : nullptr;
}

void CoreFirebaseOptions::set_ios_bundle_id(const std::string_view* value_arg) {
  ios_bundle_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_ios_bundle_id(std::string_view value_arg) {
  ios_bundle_id_ = value_arg;
}

const std::string* CoreFirebaseOptions::app_group_id() const {
  return app_group_id_ ? &(*app_group_id_) : nullptr;
}

void CoreFirebaseOptions::set_app_group_id(const std::string_view* value_arg) {
  app_group_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void CoreFirebaseOptions::set_app_group_id(std::string_view value_arg) {
  app_group_id_ = value_arg;
}

EncodableList CoreFirebaseOptions::ToEncodableList() const {
  EncodableList list;
  list.reserve(14);
  list.push_back(EncodableValue(api_key_));
  list.push_back(EncodableValue(app_id_));
  list.push_back(EncodableValue(messaging_sender_id_));
  list.push_back(EncodableValue(project_id_));
  list.push_back(auth_domain_ ? EncodableValue(*auth_domain_)
                              : EncodableValue());
  list.push_back(database_u_r_l_ ? EncodableValue(*database_u_r_l_)
                                 : EncodableValue());
  list.push_back(storage_bucket_ ? EncodableValue(*storage_bucket_)
                                 : EncodableValue());
  list.push_back(measurement_id_ ? EncodableValue(*measurement_id_)
                                 : EncodableValue());
  list.push_back(tracking_id_ ? EncodableValue(*tracking_id_)
                              : EncodableValue());
  list.push_back(deep_link_u_r_l_scheme_
                     ? EncodableValue(*deep_link_u_r_l_scheme_)
                     : EncodableValue());
  list.push_back(android_client_id_ ? EncodableValue(*android_client_id_)
                                    : EncodableValue());
  list.push_back(ios_client_id_ ? EncodableValue(*ios_client_id_)
                                : EncodableValue());
  list.push_back(ios_bundle_id_ ? EncodableValue(*ios_bundle_id_)
                                : EncodableValue());
  list.push_back(app_group_id_ ? EncodableValue(*app_group_id_)
                               : EncodableValue());
  return list;
}

CoreFirebaseOptions CoreFirebaseOptions::FromEncodableList(
    const EncodableList& list) {
  CoreFirebaseOptions decoded(
      std::get<std::string>(list[0]), std::get<std::string>(list[1]),
      std::get<std::string>(list[2]), std::get<std::string>(list[3]));
  auto& encodable_auth_domain = list[4];
  if (!encodable_auth_domain.IsNull()) {
    decoded.set_auth_domain(std::get<std::string>(encodable_auth_domain));
  }
  auto& encodable_database_u_r_l = list[5];
  if (!encodable_database_u_r_l.IsNull()) {
    decoded.set_database_u_r_l(std::get<std::string>(encodable_database_u_r_l));
  }
  auto& encodable_storage_bucket = list[6];
  if (!encodable_storage_bucket.IsNull()) {
    decoded.set_storage_bucket(std::get<std::string>(encodable_storage_bucket));
  }
  auto& encodable_measurement_id = list[7];
  if (!encodable_measurement_id.IsNull()) {
    decoded.set_measurement_id(std::get<std::string>(encodable_measurement_id));
  }
  auto& encodable_tracking_id = list[8];
  if (!encodable_tracking_id.IsNull()) {
    decoded.set_tracking_id(std::get<std::string>(encodable_tracking_id));
  }
  auto& encodable_deep_link_u_r_l_scheme = list[9];
  if (!encodable_deep_link_u_r_l_scheme.IsNull()) {
    decoded.set_deep_link_u_r_l_scheme(
        std::get<std::string>(encodable_deep_link_u_r_l_scheme));
  }
  auto& encodable_android_client_id = list[10];
  if (!encodable_android_client_id.IsNull()) {
    decoded.set_android_client_id(
        std::get<std::string>(encodable_android_client_id));
  }
  auto& encodable_ios_client_id = list[11];
  if (!encodable_ios_client_id.IsNull()) {
    decoded.set_ios_client_id(std::get<std::string>(encodable_ios_client_id));
  }
  auto& encodable_ios_bundle_id = list[12];
  if (!encodable_ios_bundle_id.IsNull()) {
    decoded.set_ios_bundle_id(std::get<std::string>(encodable_ios_bundle_id));
  }
  auto& encodable_app_group_id = list[13];
  if (!encodable_app_group_id.IsNull()) {
    decoded.set_app_group_id(std::get<std::string>(encodable_app_group_id));
  }
  return decoded;
}

// CoreInitializeResponse

CoreInitializeResponse::CoreInitializeResponse(
    const std::string& name, const CoreFirebaseOptions& options,
    const EncodableMap& plugin_constants)
    : name_(name),
      options_(std::make_unique<CoreFirebaseOptions>(options)),
      plugin_constants_(plugin_constants) {}

CoreInitializeResponse::CoreInitializeResponse(
    const std::string& name, const CoreFirebaseOptions& options,
    const bool* is_automatic_data_collection_enabled,
    const EncodableMap& plugin_constants)
    : name_(name),
      options_(std::make_unique<CoreFirebaseOptions>(options)),
      is_automatic_data_collection_enabled_(
          is_automatic_data_collection_enabled
              ? std::optional<bool>(*is_automatic_data_collection_enabled)
              : std::nullopt),
      plugin_constants_(plugin_constants) {}

CoreInitializeResponse::CoreInitializeResponse(
    const CoreInitializeResponse& other)
    : name_(other.name_),
      options_(std::make_unique<CoreFirebaseOptions>(*other.options_)),
      is_automatic_data_collection_enabled_(
          other.is_automatic_data_collection_enabled_
              ? std::optional<bool>(
                    *other.is_automatic_data_collection_enabled_)
              : std::nullopt),
      plugin_constants_(other.plugin_constants_) {}

CoreInitializeResponse& CoreInitializeResponse::operator=(
    const CoreInitializeResponse& other) {
  name_ = other.name_;
  options_ = std::make_unique<CoreFirebaseOptions>(*other.options_);
  is_automatic_data_collection_enabled_ =
      other.is_automatic_data_collection_enabled_;
  plugin_constants_ = other.plugin_constants_;
  return *this;
}

const std::string& CoreInitializeResponse::name() const { return name_; }

void CoreInitializeResponse::set_name(std::string_view value_arg) {
  name_ = value_arg;
}

const CoreFirebaseOptions& CoreInitializeResponse::options() const {
  return *options_;
}

void CoreInitializeResponse::set_options(const CoreFirebaseOptions& value_arg) {
  options_ = std::make_unique<CoreFirebaseOptions>(value_arg);
}

const bool* CoreInitializeResponse::is_automatic_data_collection_enabled()
    const {
  return is_automatic_data_collection_enabled_
             ? &(*is_automatic_data_collection_enabled_)
             : nullptr;
}

void CoreInitializeResponse::set_is_automatic_data_collection_enabled(
    const bool* value_arg) {
  is_automatic_data_collection_enabled_ =
      value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void CoreInitializeResponse::set_is_automatic_data_collection_enabled(
    bool value_arg) {
  is_automatic_data_collection_enabled_ = value_arg;
}

const EncodableMap& CoreInitializeResponse::plugin_constants() const {
  return plugin_constants_;
}

void CoreInitializeResponse::set_plugin_constants(
    const EncodableMap& value_arg) {
  plugin_constants_ = value_arg;
}

EncodableList CoreInitializeResponse::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(name_));
  list.push_back(CustomEncodableValue(*options_));
  list.push_back(is_automatic_data_collection_enabled_
                     ? EncodableValue(*is_automatic_data_collection_enabled_)
                     : EncodableValue());
  list.push_back(EncodableValue(plugin_constants_));
  return list;
}

CoreInitializeResponse CoreInitializeResponse::FromEncodableList(
    const EncodableList& list) {
  CoreInitializeResponse decoded(std::get<std::string>(list[0]),
                                 std::any_cast<const CoreFirebaseOptions&>(
                                     std::get<CustomEncodableValue>(list[1])),
                                 std::get<EncodableMap>(list[3]));
  auto& encodable_is_automatic_data_collection_enabled = list[2];
  if (!encodable_is_automatic_data_collection_enabled.IsNull()) {
    decoded.set_is_automatic_data_collection_enabled(
        std::get<bool>(encodable_is_automatic_data_collection_enabled));
  }
  return decoded;
}

PigeonInternalCodecSerializer::PigeonInternalCodecSerializer() {}

EncodableValue PigeonInternalCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 129: {
      return CustomEncodableValue(CoreFirebaseOptions::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    }
    case 130: {
      return CustomEncodableValue(CoreInitializeResponse::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    }
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void PigeonInternalCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(CoreFirebaseOptions)) {
      stream->WriteByte(129);
      WriteValue(
          EncodableValue(std::any_cast<CoreFirebaseOptions>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(CoreInitializeResponse)) {
      stream->WriteByte(130);
      WriteValue(
          EncodableValue(std::any_cast<CoreInitializeResponse>(*custom_value)
                             .ToEncodableList()),
          stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by FirebaseCoreHostApi.
const flutter::StandardMessageCodec& FirebaseCoreHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &PigeonInternalCodecSerializer::GetInstance());
}

// Sets up an instance of `FirebaseCoreHostApi` to handle messages through the
// `binary_messenger`.
void FirebaseCoreHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                FirebaseCoreHostApi* api) {
  FirebaseCoreHostApi::SetUp(binary_messenger, api, "");
}

void FirebaseCoreHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                FirebaseCoreHostApi* api,
                                const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_core_platform_interface."
        "FirebaseCoreHostApi.initializeApp" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                reply(WrapError("app_name_arg unexpectedly null."));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_initialize_app_request_arg = args.at(1);
              if (encodable_initialize_app_request_arg.IsNull()) {
                reply(
                    WrapError("initialize_app_request_arg unexpectedly null."));
                return;
              }
              const auto& initialize_app_request_arg =
                  std::any_cast<const CoreFirebaseOptions&>(
                      std::get<CustomEncodableValue>(
                          encodable_initialize_app_request_arg));
              api->InitializeApp(
                  app_name_arg, initialize_app_request_arg,
                  [reply](ErrorOr<CoreInitializeResponse>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_core_platform_interface."
        "FirebaseCoreHostApi.initializeCore" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              api->InitializeCore([reply](ErrorOr<EncodableList>&& output) {
                if (output.has_error()) {
                  reply(WrapError(output.error()));
                  return;
                }
                EncodableList wrapped;
                wrapped.push_back(
                    EncodableValue(std::move(output).TakeValue()));
                reply(EncodableValue(std::move(wrapped)));
              });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_core_platform_interface."
        "FirebaseCoreHostApi.optionsFromResource" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              api->OptionsFromResource(
                  [reply](ErrorOr<CoreFirebaseOptions>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue FirebaseCoreHostApi::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue FirebaseCoreHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

/// The codec used by FirebaseAppHostApi.
const flutter::StandardMessageCodec& FirebaseAppHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &PigeonInternalCodecSerializer::GetInstance());
}

// Sets up an instance of `FirebaseAppHostApi` to handle messages through the
// `binary_messenger`.
void FirebaseAppHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                               FirebaseAppHostApi* api) {
  FirebaseAppHostApi::SetUp(binary_messenger, api, "");
}

void FirebaseAppHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                               FirebaseAppHostApi* api,
                               const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_core_platform_interface."
        "FirebaseAppHostApi.setAutomaticDataCollectionEnabled" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                reply(WrapError("app_name_arg unexpectedly null."));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_enabled_arg = args.at(1);
              if (encodable_enabled_arg.IsNull()) {
                reply(WrapError("enabled_arg unexpectedly null."));
                return;
              }
              const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
              api->SetAutomaticDataCollectionEnabled(
                  app_name_arg, enabled_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.firebase_core_platform_interface."
        "FirebaseAppHostApi.setAutomaticResourceManagementEnabled" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                reply(WrapError("app_name_arg unexpectedly null."));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_enabled_arg = args.at(1);
              if (encodable_enabled_arg.IsNull()) {
                reply(WrapError("enabled_arg unexpectedly null."));
                return;
              }
              const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
              api->SetAutomaticResourceManagementEnabled(
                  app_name_arg, enabled_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger,
                                  "dev.flutter.pigeon.firebase_core_platform_"
                                  "interface.FirebaseAppHostApi.delete" +
                                      prepended_suffix,
                                  &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                reply(WrapError("app_name_arg unexpectedly null."));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              api->Delete(app_name_arg,
                          [reply](std::optional<FlutterError>&& output) {
                            if (output.has_value()) {
                              reply(WrapError(output.value()));
                              return;
                            }
                            EncodableList wrapped;
                            wrapped.push_back(EncodableValue());
                            reply(EncodableValue(std::move(wrapped)));
                          });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue FirebaseAppHostApi::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue FirebaseAppHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

}  // namespace firebase_core_windows

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/windows/messages.g.h

**크기**: 11258 bytes | **라인 수**: 284 | **타입**: text

```
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#ifndef PIGEON_MESSAGES_G_H_
#define PIGEON_MESSAGES_G_H_
#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace firebase_core_windows {

// Generated class from Pigeon.

class FlutterError {
 public:
  explicit FlutterError(const std::string& code) : code_(code) {}
  explicit FlutterError(const std::string& code, const std::string& message)
      : code_(code), message_(message) {}
  explicit FlutterError(const std::string& code, const std::string& message,
                        const flutter::EncodableValue& details)
      : code_(code), message_(message), details_(details) {}

  const std::string& code() const { return code_; }
  const std::string& message() const { return message_; }
  const flutter::EncodableValue& details() const { return details_; }

 private:
  std::string code_;
  std::string message_;
  flutter::EncodableValue details_;
};

template <class T>
class ErrorOr {
 public:
  ErrorOr(const T& rhs) : v_(rhs) {}
  ErrorOr(const T&& rhs) : v_(std::move(rhs)) {}
  ErrorOr(const FlutterError& rhs) : v_(rhs) {}
  ErrorOr(const FlutterError&& rhs) : v_(std::move(rhs)) {}

  bool has_error() const { return std::holds_alternative<FlutterError>(v_); }
  const T& value() const { return std::get<T>(v_); };
  const FlutterError& error() const { return std::get<FlutterError>(v_); };

 private:
  friend class FirebaseCoreHostApi;
  friend class FirebaseAppHostApi;
  ErrorOr() = default;
  T TakeValue() && { return std::get<T>(std::move(v_)); }

  std::variant<T, FlutterError> v_;
};

// Generated class from Pigeon that represents data sent in messages.
class CoreFirebaseOptions {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit CoreFirebaseOptions(const std::string& api_key,
                               const std::string& app_id,
                               const std::string& messaging_sender_id,
                               const std::string& project_id);

  // Constructs an object setting all fields.
  explicit CoreFirebaseOptions(
      const std::string& api_key, const std::string& app_id,
      const std::string& messaging_sender_id, const std::string& project_id,
      const std::string* auth_domain, const std::string* database_u_r_l,
      const std::string* storage_bucket, const std::string* measurement_id,
      const std::string* tracking_id, const std::string* deep_link_u_r_l_scheme,
      const std::string* android_client_id, const std::string* ios_client_id,
      const std::string* ios_bundle_id, const std::string* app_group_id);

  const std::string& api_key() const;
  void set_api_key(std::string_view value_arg);

  const std::string& app_id() const;
  void set_app_id(std::string_view value_arg);

  const std::string& messaging_sender_id() const;
  void set_messaging_sender_id(std::string_view value_arg);

  const std::string& project_id() const;
  void set_project_id(std::string_view value_arg);

  const std::string* auth_domain() const;
  void set_auth_domain(const std::string_view* value_arg);
  void set_auth_domain(std::string_view value_arg);

  const std::string* database_u_r_l() const;
  void set_database_u_r_l(const std::string_view* value_arg);
  void set_database_u_r_l(std::string_view value_arg);

  const std::string* storage_bucket() const;
  void set_storage_bucket(const std::string_view* value_arg);
  void set_storage_bucket(std::string_view value_arg);

  const std::string* measurement_id() const;
  void set_measurement_id(const std::string_view* value_arg);
  void set_measurement_id(std::string_view value_arg);

  const std::string* tracking_id() const;
  void set_tracking_id(const std::string_view* value_arg);
  void set_tracking_id(std::string_view value_arg);

  const std::string* deep_link_u_r_l_scheme() const;
  void set_deep_link_u_r_l_scheme(const std::string_view* value_arg);
  void set_deep_link_u_r_l_scheme(std::string_view value_arg);

  const std::string* android_client_id() const;
  void set_android_client_id(const std::string_view* value_arg);
  void set_android_client_id(std::string_view value_arg);

  const std::string* ios_client_id() const;
  void set_ios_client_id(const std::string_view* value_arg);
  void set_ios_client_id(std::string_view value_arg);

  const std::string* ios_bundle_id() const;
  void set_ios_bundle_id(const std::string_view* value_arg);
  void set_ios_bundle_id(std::string_view value_arg);

  const std::string* app_group_id() const;
  void set_app_group_id(const std::string_view* value_arg);
  void set_app_group_id(std::string_view value_arg);

 private:
  static CoreFirebaseOptions FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class CoreInitializeResponse;
  friend class FirebaseCoreHostApi;
  friend class FirebaseAppHostApi;
  friend class PigeonInternalCodecSerializer;
  std::string api_key_;
  std::string app_id_;
  std::string messaging_sender_id_;
  std::string project_id_;
  std::optional<std::string> auth_domain_;
  std::optional<std::string> database_u_r_l_;
  std::optional<std::string> storage_bucket_;
  std::optional<std::string> measurement_id_;
  std::optional<std::string> tracking_id_;
  std::optional<std::string> deep_link_u_r_l_scheme_;
  std::optional<std::string> android_client_id_;
  std::optional<std::string> ios_client_id_;
  std::optional<std::string> ios_bundle_id_;
  std::optional<std::string> app_group_id_;
};

// Generated class from Pigeon that represents data sent in messages.
class CoreInitializeResponse {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit CoreInitializeResponse(
      const std::string& name, const CoreFirebaseOptions& options,
      const flutter::EncodableMap& plugin_constants);

  // Constructs an object setting all fields.
  explicit CoreInitializeResponse(
      const std::string& name, const CoreFirebaseOptions& options,
      const bool* is_automatic_data_collection_enabled,
      const flutter::EncodableMap& plugin_constants);

  ~CoreInitializeResponse() = default;
  CoreInitializeResponse(const CoreInitializeResponse& other);
  CoreInitializeResponse& operator=(const CoreInitializeResponse& other);
  CoreInitializeResponse(CoreInitializeResponse&& other) = default;
  CoreInitializeResponse& operator=(CoreInitializeResponse&& other) noexcept =
      default;
  const std::string& name() const;
  void set_name(std::string_view value_arg);

  const CoreFirebaseOptions& options() const;
  void set_options(const CoreFirebaseOptions& value_arg);

  const bool* is_automatic_data_collection_enabled() const;
  void set_is_automatic_data_collection_enabled(const bool* value_arg);
  void set_is_automatic_data_collection_enabled(bool value_arg);

  const flutter::EncodableMap& plugin_constants() const;
  void set_plugin_constants(const flutter::EncodableMap& value_arg);

 private:
  static CoreInitializeResponse FromEncodableList(
      const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class FirebaseCoreHostApi;
  friend class FirebaseAppHostApi;
  friend class PigeonInternalCodecSerializer;
  std::string name_;
  std::unique_ptr<CoreFirebaseOptions> options_;
  std::optional<bool> is_automatic_data_collection_enabled_;
  flutter::EncodableMap plugin_constants_;
};

class PigeonInternalCodecSerializer : public flutter::StandardCodecSerializer {
 public:
  PigeonInternalCodecSerializer();
  inline static PigeonInternalCodecSerializer& GetInstance() {
    static PigeonInternalCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(const flutter::EncodableValue& value,
                  flutter::ByteStreamWriter* stream) const override;

 protected:
  flutter::EncodableValue ReadValueOfType(
      uint8_t type, flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class FirebaseCoreHostApi {
 public:
  FirebaseCoreHostApi(const FirebaseCoreHostApi&) = delete;
  FirebaseCoreHostApi& operator=(const FirebaseCoreHostApi&) = delete;
  virtual ~FirebaseCoreHostApi() {}
  virtual void InitializeApp(
      const std::string& app_name,
      const CoreFirebaseOptions& initialize_app_request,
      std::function<void(ErrorOr<CoreInitializeResponse> reply)> result) = 0;
  virtual void InitializeCore(
      std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;
  virtual void OptionsFromResource(
      std::function<void(ErrorOr<CoreFirebaseOptions> reply)> result) = 0;

  // The codec used by FirebaseCoreHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `FirebaseCoreHostApi` to handle messages through the
  // `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseCoreHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseCoreHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  FirebaseCoreHostApi() = default;
};
// Generated interface from Pigeon that represents a handler of messages from
// Flutter.
class FirebaseAppHostApi {
 public:
  FirebaseAppHostApi(const FirebaseAppHostApi&) = delete;
  FirebaseAppHostApi& operator=(const FirebaseAppHostApi&) = delete;
  virtual ~FirebaseAppHostApi() {}
  virtual void SetAutomaticDataCollectionEnabled(
      const std::string& app_name, bool enabled,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void SetAutomaticResourceManagementEnabled(
      const std::string& app_name, bool enabled,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;
  virtual void Delete(
      const std::string& app_name,
      std::function<void(std::optional<FlutterError> reply)> result) = 0;

  // The codec used by FirebaseAppHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `FirebaseAppHostApi` to handle messages through the
  // `binary_messenger`.
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAppHostApi* api);
  static void SetUp(flutter::BinaryMessenger* binary_messenger,
                    FirebaseAppHostApi* api,
                    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);

 protected:
  FirebaseAppHostApi() = default;
};
}  // namespace firebase_core_windows
#endif  // PIGEON_MESSAGES_G_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/CHANGELOG.md

**크기**: 47526 bytes | **라인 수**: 922 | **타입**: text

```
## 4.1.1

 - Update a dependency to the latest release.

## 4.1.0

 - **FEAT**: bump Firebase iOS SDK to 12.2.0 ([#17677](https://github.com/firebase/flutterfire/issues/17677)). ([ecd8889d](https://github.com/firebase/flutterfire/commit/ecd8889df76954c8dfa2861e20d6d50d0b6239be))
 - **FEAT**: bump Firebase android SDK to 34.1.0 ([#17668](https://github.com/firebase/flutterfire/issues/17668)). ([2af66ab3](https://github.com/firebase/flutterfire/commit/2af66ab320053f0deb3f010a39a4f88b4adde936))

## 4.0.0

> Note: This release has breaking changes.

 - **BREAKING** **FEAT**: bump iOS SDK to version 12.0.0 ([#17549](https://github.com/firebase/flutterfire/issues/17549)). ([b2619e68](https://github.com/firebase/flutterfire/commit/b2619e685fec897513483df1d7be347b64f95606))
 - **BREAKING** **FEAT**: bump Android SDK to version 34.0.0 ([#17554](https://github.com/firebase/flutterfire/issues/17554)). ([a5bdc051](https://github.com/firebase/flutterfire/commit/a5bdc051d40ee44e39cf0b8d2a7801bc6f618b67))

## 3.15.2

 - **FIX**(core): resolve iOS crash when enabling automatic data collection via `setAutomaticDataCollectionEnabled` ([#17497](https://github.com/firebase/flutterfire/issues/17497)). ([cd8b58d0](https://github.com/firebase/flutterfire/commit/cd8b58d053e34e9840bdbd20fd5aa3f698e5fcfa))

## 3.15.1

 - Update a dependency to the latest release.

## 3.15.0

 - **FIX**(core): bump Pigeon to v25.3.2 ([#17438](https://github.com/firebase/flutterfire/issues/17438)). ([4d24ef53](https://github.com/firebase/flutterfire/commit/4d24ef534464b39dcaef4151c83c78f87b36fb78))
 - **FEAT**: bump iOS SDK to version 11.15.0 ([#17469](https://github.com/firebase/flutterfire/issues/17469)). ([84ca4f2a](https://github.com/firebase/flutterfire/commit/84ca4f2a0f3fbb7270b95f15436e0ebb2606dbfa))
 - **FEAT**: bump Android SDK to version 33.16.0 ([#17470](https://github.com/firebase/flutterfire/issues/17470)). ([f79b786d](https://github.com/firebase/flutterfire/commit/f79b786d69ac037b03ce253236d588e2ff8a5934))

## 3.14.0

 - **FEAT**: bump Firebase iOS SDK to 11.13.0 ([#17378](https://github.com/firebase/flutterfire/issues/17378)). ([10fd1d8f](https://github.com/firebase/flutterfire/commit/10fd1d8f6f8af07dfae27c4bdda7726716f42d7f))

## 3.13.1

 - Update a dependency to the latest release.

## 3.13.0

 - **FEAT**(core,windows): update C++ SDK to 12.7.0 ([#17238](https://github.com/firebase/flutterfire/issues/17238)). ([b0e5843d](https://github.com/firebase/flutterfire/commit/b0e5843dde670063f755fbc4c52f6e2b070935e4))
 - **FEAT**(functions): migrate cloud functions Apple implementation to Swift ([#17232](https://github.com/firebase/flutterfire/issues/17232)). ([9ebc7bc1](https://github.com/firebase/flutterfire/commit/9ebc7bc130757f918dfab9fbc583e5f6c5b3b565))
 - **FEAT**: bump Firebase iOS SDK to 11.10.0 ([#17228](https://github.com/firebase/flutterfire/issues/17228)). ([4573a4d6](https://github.com/firebase/flutterfire/commit/4573a4d69c608e0d022f092a84f4c05d3ce145be))
 - **FEAT**: bump Firebase android SDK to 33.11.0 ([#17217](https://github.com/firebase/flutterfire/issues/17217)). ([0cb8b91e](https://github.com/firebase/flutterfire/commit/0cb8b91ee30afe23bdca37aa748622b600ead2ee))

## 3.12.1

 - Update a dependency to the latest release.

## 3.12.0

 - **FEAT**: bump Firebase iOS SDK to `11.8.0` ([#17093](https://github.com/firebase/flutterfire/issues/17093)). ([52557617](https://github.com/firebase/flutterfire/commit/52557617ccdc7dc6d057fff6cea65baa338057c2))
 - **FEAT**: bump Firebase android SDK to `33.9.0` ([#17092](https://github.com/firebase/flutterfire/issues/17092)). ([cbbb3748](https://github.com/firebase/flutterfire/commit/cbbb3748f192d35c25663bda6fb0f16a74dd71c7))

## 3.11.0

 - **FEAT**: bump Firebase android SDK to `33.8.0` ([#17048](https://github.com/firebase/flutterfire/issues/17048)). ([0befa109](https://github.com/firebase/flutterfire/commit/0befa109970893f79fb50d2b809b95d797fdc416))
 - **FEAT**: bump firebase iOS SDK to `v11.7.0` ([#17011](https://github.com/firebase/flutterfire/issues/17011)). ([2e042ba7](https://github.com/firebase/flutterfire/commit/2e042ba79f0250fd0fb3b7dfcfe07f1fd4d81cad))

## 3.10.1

 - **FIX**(firebase_core): Update google_services_gradle_plugin_version in pubspec ([#16944](https://github.com/firebase/flutterfire/issues/16944)). ([9911deb6](https://github.com/firebase/flutterfire/commit/9911deb61b5a658981a11067154ccf3befce636c))

## 3.10.0

 - **FEAT**: bump firebase iOS SDK to `v11.6.0` ([#16858](https://github.com/firebase/flutterfire/issues/16858)). ([6a42a2d8](https://github.com/firebase/flutterfire/commit/6a42a2d801f7674992de1c1d9557cb800ead9963))

## 3.9.0

 - **FIX**(core,macos): update path to firebase sdk version for SPM ([#16890](https://github.com/firebase/flutterfire/issues/16890)). ([4a190da0](https://github.com/firebase/flutterfire/commit/4a190da0c353d295ff7fb9fea73119218a365687))
 - **FIX**(core,macos): exclude files pulled in from remote dependency. SPM integration ([#16834](https://github.com/firebase/flutterfire/issues/16834)). ([a8a22b17](https://github.com/firebase/flutterfire/commit/a8a22b172657ba2568d2cce5a54db4da3189efa0))
 - **FIX**(core): auth Swift support requires `FLTFirebaseCorePlugin` & `messages` to be shared ([#16774](https://github.com/firebase/flutterfire/issues/16774)). ([f89483cd](https://github.com/firebase/flutterfire/commit/f89483cd9a3b4900d9b79151bb383ae35aa3dd4f))
 - **FIX**(core): auth Swift support requires `FLTFirebaseCorePlugin` & `messages` to be shared ([#16774](https://github.com/firebase/flutterfire/issues/16774)). ([ba5f2414](https://github.com/firebase/flutterfire/commit/ba5f2414c86f3fe200df07671f6ad84087646c86))
 - **FEAT**: bump Firebase android BOM to `v33.7.0` ([#16857](https://github.com/firebase/flutterfire/issues/16857)). ([0048bd13](https://github.com/firebase/flutterfire/commit/0048bd138f67102ff7cfa0539c244819b4ce8c7d))

## 3.8.1

 - **FIX**(core): auth Swift support requires `FLTFirebaseCorePlugin` & `messages` to be shared ([#16774](https://github.com/firebase/flutterfire/issues/16774)). ([f89483cd](https://github.com/firebase/flutterfire/commit/f89483cd9a3b4900d9b79151bb383ae35aa3dd4f))

## 3.8.0

 - **FEAT**(firestore): Swift Package Manager support ([#13329](https://github.com/firebase/flutterfire/issues/13329)). ([0420eabb](https://github.com/firebase/flutterfire/commit/0420eabb3ab247e0e3998bedcb9779fe35c46920))

## 3.7.0

 - **FIX**(core,ios): ensure iOS SDK version can be found from Package.swift ([#13804](https://github.com/firebase/flutterfire/issues/13804)). ([83f4dad6](https://github.com/firebase/flutterfire/commit/83f4dad65aae08e2979d009b03e9adb4ca907df7))
 - **FIX**(core,ios): update Package.swift and header imports for backwards compatibility ([#13545](https://github.com/firebase/flutterfire/issues/13545)). ([07eb25fa](https://github.com/firebase/flutterfire/commit/07eb25fa67a8c7c3e21275bacd234641721de8fc))
 - **FEAT**: update Android SDK to version 33.5.1 ([#13803](https://github.com/firebase/flutterfire/issues/13803)). ([66394540](https://github.com/firebase/flutterfire/commit/6639454043c09a47d444046c08a398c9aef5315f))
 - **FEAT**: bump firebase iOS SDK to `v11.4.0` ([#13552](https://github.com/firebase/flutterfire/issues/13552)). ([a4be6973](https://github.com/firebase/flutterfire/commit/a4be69731d41aade5dfcfb154af3292551633874))
 - **FEAT**: bump Firebase android BOM to `v33.5.0` ([#13538](https://github.com/firebase/flutterfire/issues/13538)). ([d3cfc0e7](https://github.com/firebase/flutterfire/commit/d3cfc0e778b8173a370f645448569db380bb6cef))

## 3.6.0

 - **FEAT**: bump iOS SDK to version 11.2.0 ([#13338](https://github.com/firebase/flutterfire/issues/13338)). ([ff1e5f67](https://github.com/firebase/flutterfire/commit/ff1e5f672cee29731dc4d21251611030add9e605))
 - **FEAT**: bump Firebase android BOM to `33.3.0` ([#13390](https://github.com/firebase/flutterfire/issues/13390)). ([15c0284e](https://github.com/firebase/flutterfire/commit/15c0284e3f3555ff888e7817e0811b64b3d3164e))

## 3.5.0

 - **FEAT**(fdc): Initial Release of Data Connect ([#13313](https://github.com/firebase/flutterfire/issues/13313)). ([603a6726](https://github.com/firebase/flutterfire/commit/603a67261a2f7cbdd6ef594bfaef480aeb820683))
 - **FEAT**(core): support for using SPM (Swift Package Manager) ([#12786](https://github.com/firebase/flutterfire/issues/12786)). ([4e28103f](https://github.com/firebase/flutterfire/commit/4e28103fafd84c6613df647e7f0dbb6a068ca8ea))

## 3.4.1

 - Update a dependency to the latest release.

## 3.4.0

 - **FEAT**: bump iOS SDK to version 11.0.0 ([#13158](https://github.com/firebase/flutterfire/issues/13158)). ([c0e0c997](https://github.com/firebase/flutterfire/commit/c0e0c99703ea394d1bb873ac225c5fe3539b002d))

## 3.3.0

 - **FEAT**: bump iOS SDK to version 10.29.0 ([#13113](https://github.com/firebase/flutterfire/issues/13113)). ([45fa2f58](https://github.com/firebase/flutterfire/commit/45fa2f589abe60a4bf06ac5fd64895c7df94c19c))

## 3.2.0

 - **FEAT**: bump Firebase iOS SDK to `10.28.0` ([#12999](https://github.com/firebase/flutterfire/issues/12999)). ([e7bd7882](https://github.com/firebase/flutterfire/commit/e7bd7882d213cf291a2fbd49acc81c03b92df746))

## 3.1.1

 - **FIX**(auth,windows): fix a crash that could happen when using `sendEmailVerification` or `sendPasswordResetEmail` ([#12946](https://github.com/firebase/flutterfire/issues/12946)). ([a1008290](https://github.com/firebase/flutterfire/commit/a100829087dbf83ea59e73c3811d87b67e2a4012))

## 3.1.0

 - **FEAT**: add support for demo project ([#11973](https://github.com/firebase/flutterfire/issues/11973)). ([859ec1dd](https://github.com/firebase/flutterfire/commit/859ec1dd4424c422bbdf96617a77d123d8b1f409))

## 3.0.0

> Note: This release has breaking changes.

 - **FEAT**: bump Firebase android SDK to `33.1.0` ([#12874](https://github.com/firebase/flutterfire/issues/12874)). ([f67914c4](https://github.com/firebase/flutterfire/commit/f67914c463d92e52e2594765baf7d53cd9235fb6))
 - **FEAT**: bump Firebase iOS SDK to `10.27.0` ([#12871](https://github.com/firebase/flutterfire/issues/12871)). ([fcb3c212](https://github.com/firebase/flutterfire/commit/fcb3c2123c25bafce9aea25fafcf4bddbe08a9d0))
 - **FEAT**: bump CPP SDK to version 12.0.0 ([#12866](https://github.com/firebase/flutterfire/issues/12866)). ([6efc0d47](https://github.com/firebase/flutterfire/commit/6efc0d47c9caf32752a4b92c3f1d24739383ef38))
 - **BREAKING** **REFACTOR**: android plugins require `minSdk 21`, auth requires `minSdk 23` ahead of android BOM `>=33.0.0` ([#12873](https://github.com/firebase/flutterfire/issues/12873)). ([52accfc6](https://github.com/firebase/flutterfire/commit/52accfc6c39d6360d9c0f36efe369ede990b7362))
 - **BREAKING** **REFACTOR**: bump all iOS deployment targets to iOS 13 ahead of Firebase iOS SDK `v11` breaking change ([#12872](https://github.com/firebase/flutterfire/issues/12872)). ([de0cea2c](https://github.com/firebase/flutterfire/commit/de0cea2c3c36694a76361be784255986fac84a43))

## 2.32.0

 - **FEAT**: bump CPP SDK to version 11.10.0 ([#12749](https://github.com/firebase/flutterfire/issues/12749)). ([2e410a23](https://github.com/firebase/flutterfire/commit/2e410a232758292baa70f8e78464bd3c62ec0373))

## 2.31.1

 - **FIX**(storage,windows): putFile(), putString(), putData() & Task streaming event fixes ([#12723](https://github.com/firebase/flutterfire/issues/12723)). ([de69e07a](https://github.com/firebase/flutterfire/commit/de69e07a36a9e2ce967d9f4470f4a14e987abf53))

## 2.31.0

 - **FEAT**: bump firebase iOS SDK to `10.25.0` ([#12738](https://github.com/firebase/flutterfire/issues/12738)). ([86b05c3c](https://github.com/firebase/flutterfire/commit/86b05c3c25d4ebc8b8c142e71593c0210f06d6be))

## 2.30.1

 - Update a dependency to the latest release.

## 2.30.0

 - **FEAT**: bump Firebase iOS SDK to `10.24.0` ([#12626](https://github.com/firebase/flutterfire/issues/12626)). ([b39c0e25](https://github.com/firebase/flutterfire/commit/b39c0e258233438acf368da891102784b7af2542))

## 2.29.0

 - **FEAT**: bump Android SDK to version 32.8.0 ([#12584](https://github.com/firebase/flutterfire/issues/12584)). ([a81d9104](https://github.com/firebase/flutterfire/commit/a81d9104f72e88e917612ab7f11ba7ed6b1bdd76))

## 2.28.0

 - **FEAT**(android): Bump `compileSdk` version of Android plugins to latest stable (34) ([#12566](https://github.com/firebase/flutterfire/issues/12566)). ([e891fab2](https://github.com/firebase/flutterfire/commit/e891fab291e9beebc223000b133a6097e066a7fc))

## 2.27.2

 - **FIX**: bump Android SDK to version 32.7.4 ([#12499](https://github.com/firebase/flutterfire/issues/12499)). ([39cdd623](https://github.com/firebase/flutterfire/commit/39cdd6235ae8aed2537fd39031c50d2d36a44b43))

## 2.27.1

 - Update a dependency to the latest release.

## 2.27.0

 - **FEAT**: bump Android SDK to version 3.7.3 ([#12443](https://github.com/firebase/flutterfire/issues/12443)). ([2509d91a](https://github.com/firebase/flutterfire/commit/2509d91aa7d95af19407b5823815b65085902347))

## 2.26.0

 - **FIX**(core,android): fix a null issue when initializing `fromResource()` ([#12404](https://github.com/firebase/flutterfire/issues/12404)). ([635cd781](https://github.com/firebase/flutterfire/commit/635cd7819476d8768b4ccbae323e230e6063967b))
 - **FEAT**: bump iOS SDK to version 10.22.0 ([#12430](https://github.com/firebase/flutterfire/issues/12430)). ([741c5519](https://github.com/firebase/flutterfire/commit/741c55196677d248603153b2ccca323c7591b2d6))

## 2.25.5

 - **FIX**(core,web): fix compatibility with TrustedTypes ([#12383](https://github.com/firebase/flutterfire/issues/12383)). ([6c1f73d0](https://github.com/firebase/flutterfire/commit/6c1f73d0c8357db83e1ee81e084a3a5b531e0e0c))

## 2.25.4

 - Update a dependency to the latest release.

## 2.25.3

 - Update a dependency to the latest release.

## 2.25.2

 - **FIX**(auth,web): fix null safety issue in typing JS Interop ([#12250](https://github.com/firebase/flutterfire/issues/12250)). ([d0d30405](https://github.com/firebase/flutterfire/commit/d0d30405a895ae221603ddd158b1cb1636312fb4))

## 2.25.1

 - Update a dependency to the latest release.

## 2.25.0

 - **FIX**(auth,ios): Initialise static dictionary for custom auth domains ([#12157](https://github.com/firebase/flutterfire/issues/12157)). ([1262f3c6](https://github.com/firebase/flutterfire/commit/1262f3c6c5fb659217ccd609a5c6dc9e37ab8815))
 - **FEAT**: bump Android SDK to version `32.7.1` ([#12213](https://github.com/firebase/flutterfire/issues/12213)). ([3c75bb52](https://github.com/firebase/flutterfire/commit/3c75bb527acbd7bb7a0d9f712d85e6fbc281e5e9))
 - **FEAT**: bump iOS SDK to version `10.20.0` ([#12214](https://github.com/firebase/flutterfire/issues/12214)). ([e34e072a](https://github.com/firebase/flutterfire/commit/e34e072a94f19ef83c45080c52228c57d99971c9))
 - **FEAT**: bump firebase iOS SDK to `10.19.0` ([#12125](https://github.com/firebase/flutterfire/issues/12125)). ([c3861567](https://github.com/firebase/flutterfire/commit/c38615672d53d4a4775cd7897ccbef3902b7fee4))
 - **FEAT**: bump firebase android SDK BOM to `32.7.0` ([#12124](https://github.com/firebase/flutterfire/issues/12124)). ([a691f3d1](https://github.com/firebase/flutterfire/commit/a691f3d1309b29d6603b15a8aecf21287979e428))
 - **DOCS**: change old documentation links of packages in README files ([#12136](https://github.com/firebase/flutterfire/issues/12136)). ([24b9ac7e](https://github.com/firebase/flutterfire/commit/24b9ac7ec29fc9ca466c0941c2cff26d75b8568d))

## 2.24.2

 - **FIX**(core,windows): fix release build of Firebase Auth, Firestore and Storage on Windows ([#11997](https://github.com/firebase/flutterfire/issues/11997)). ([12b186a8](https://github.com/firebase/flutterfire/commit/12b186a82578f792d7f4c500f145f5bd4f398545))

## 2.24.1

 - Update a dependency to the latest release.

## 2.24.0

 - **FEAT**(auth): add support for custom domains on mobile ([#11925](https://github.com/firebase/flutterfire/issues/11925)). ([552119c7](https://github.com/firebase/flutterfire/commit/552119c78e2750a929c6226de22f9f6d8df948a4))

## 2.23.0

 - **FIX**(core,apple): remove usage of deprecated options `trackingID` and `androidClientID` ([#11893](https://github.com/firebase/flutterfire/issues/11893)). ([4dfbe5a4](https://github.com/firebase/flutterfire/commit/4dfbe5a485284ae7fa1356284e7971e96db15f27))
 - **FEAT**: bump iOS SDK to version 10.18.0 ([#11916](https://github.com/firebase/flutterfire/issues/11916)). ([abbea170](https://github.com/firebase/flutterfire/commit/abbea170a6d87f6e313f0244395b60f5b2b3f64e))
 - **FEAT**: bump firebase android SDK BOM to `32.6.0` ([#11910](https://github.com/firebase/flutterfire/issues/11910)). ([8467816c](https://github.com/firebase/flutterfire/commit/8467816c234f979b40fa1ad4f2737e27ccd33271))

## 2.22.0

 - **FEAT**: update iOS SDK to version 10.17.0 ([#11839](https://github.com/firebase/flutterfire/issues/11839)). ([f78838ae](https://github.com/firebase/flutterfire/commit/f78838ae480e28f0f83f1b7cf10bf424ac0593d6))
 - **FEAT**(windows): add platform logging for core, auth, firestore and storage ([#11790](https://github.com/firebase/flutterfire/issues/11790)). ([e7d428d1](https://github.com/firebase/flutterfire/commit/e7d428d14be1535a2d579d4b2d376fbb81f06742))

## 2.21.0

 - **FEAT**: bump Firebase android SDK BoM `32.5.0` ([#11803](https://github.com/firebase/flutterfire/issues/11803)). ([adf98ea4](https://github.com/firebase/flutterfire/commit/adf98ea49bfb1c601f452f00c2d0dd74ada858f2))

## 2.20.0

 - **FIX**(core,windows): remove unused map of string that was causing a crash ([#11745](https://github.com/firebase/flutterfire/issues/11745)). ([895da052](https://github.com/firebase/flutterfire/commit/895da052207d832d30c9eeceafabac3051e1dabb))
 - **FIX**(core,windows): allow user to override MSVC_RUNTIME_MODE ([#11150](https://github.com/firebase/flutterfire/issues/11150)). ([3be28676](https://github.com/firebase/flutterfire/commit/3be28676578c53ce4a26bc2f8f480630b579350c))
 - **FEAT**: bump Firebase iOS SDK `10.16.0` ([#11698](https://github.com/firebase/flutterfire/issues/11698)). ([666f90ea](https://github.com/firebase/flutterfire/commit/666f90ea1eb090ee3f2397c9ffde8ddaf934f36c))
 - **FEAT**(storage,windows): Add windows support ([#11617](https://github.com/firebase/flutterfire/issues/11617)). ([87ea02c8](https://github.com/firebase/flutterfire/commit/87ea02c8ae03eb351636cf202961ad0df6caebd8))

## 2.19.0

 - **FEAT**(firestore,windows): add Filters to windows ([#11726](https://github.com/firebase/flutterfire/issues/11726)). ([dde59d46](https://github.com/firebase/flutterfire/commit/dde59d466e1b6cc483ba29654a35f198d6e8c9ae))

## 2.18.0

 - **FEAT**: Full support of AGP 8 ([#11699](https://github.com/firebase/flutterfire/issues/11699)). ([bdb5b270](https://github.com/firebase/flutterfire/commit/bdb5b27084d225809883bdaa6aa5954650551927))
 - **FEAT**(firestore,windows): add support to Windows ([#11516](https://github.com/firebase/flutterfire/issues/11516)). ([e51d2a2d](https://github.com/firebase/flutterfire/commit/e51d2a2d287f4162f5a67d8200f1bf57fc2afe14))

## 2.17.0

 - **FEAT**: bump Firebase android SDK `32.3.1` ([#11663](https://github.com/firebase/flutterfire/issues/11663)). ([639bc2ea](https://github.com/firebase/flutterfire/commit/639bc2eaabe320a533ec643d4f0c91d2ab3ea5d1))

## 2.16.0

 - **FEAT**: bump Firebase iOS SDK `10.15.0` ([#11586](https://github.com/firebase/flutterfire/issues/11586)). ([baedd3ee](https://github.com/firebase/flutterfire/commit/baedd3eec24e8df9fa0602b92c60fc2535cd449b))
 - **FEAT**: bump Firebase android SDK `32.2.3` ([#11587](https://github.com/firebase/flutterfire/issues/11587)). ([26415d54](https://github.com/firebase/flutterfire/commit/26415d5477634704c13a1e2dbaad5b7f4cf41c06))
 - **FEAT**(core,windows): Change the windows plugin compiling way ([#11594](https://github.com/firebase/flutterfire/issues/11594)). ([3dab95e0](https://github.com/firebase/flutterfire/commit/3dab95e01f7f71680aff84db4e9dccfe1e77643b))
 - **FEAT**(auth,windows): add Windows support to auth plugin ([#11089](https://github.com/firebase/flutterfire/issues/11089)). ([0cedfc85](https://github.com/firebase/flutterfire/commit/0cedfc8580bedd9e21b262537e643dbace0d7114))

## 2.15.1

 - Update a dependency to the latest release.

## 2.15.0

 - **FEAT**: bump Firebase android SDK to `32.2.0` ([#11282](https://github.com/firebase/flutterfire/issues/11282)). ([7fc1f643](https://github.com/firebase/flutterfire/commit/7fc1f643303ceb8294c9b46390148969e306faeb))
 - **FEAT**(core,windows): Add api to access firebase cpp objects ([#11254](https://github.com/firebase/flutterfire/issues/11254)). ([c26f9d8e](https://github.com/firebase/flutterfire/commit/c26f9d8ef78336277667b50f67de60bbda4c2622))
 - **FEAT**: bump Firebase iOS SDK to `10.12.0` ([#11268](https://github.com/firebase/flutterfire/issues/11268)). ([31637246](https://github.com/firebase/flutterfire/commit/316372467888af24698aab20509bdb0832875293))
 - **FEAT**: bump Firebase Android SDK to 32.1.1 ([#11256](https://github.com/firebase/flutterfire/issues/11256)). ([81156d10](https://github.com/firebase/flutterfire/commit/81156d1062d3eb3c6c83833887ca054cf66cfa13))
 - **FEAT**: bump Firebase iOS SDK to 10.11.0 ([#11257](https://github.com/firebase/flutterfire/issues/11257)). ([179a91b4](https://github.com/firebase/flutterfire/commit/179a91b44191940e4e63398630b12aa9d178314c))

## 2.14.0

 - **FIX**(core,apple): pass boolean value instead of int to `setDataCollectionDefaultEnabled()` ([#11039](https://github.com/firebase/flutterfire/issues/11039)). ([67b051fd](https://github.com/firebase/flutterfire/commit/67b051fda24d4e7f50023a24001bdc6b0cc7f7bf))
 - **FEAT**: bump Firebase iOS SDK to `10.10.0`. Requires Xcode version >= `14.1`. ([#11088](https://github.com/firebase/flutterfire/issues/11088)). ([615b2d48](https://github.com/firebase/flutterfire/commit/615b2d48b7559f8bee4211111d2a0ae00ed84c3e))

## 2.13.1

 - **FIX**(core,windows): building improvements ([#10972](https://github.com/firebase/flutterfire/issues/10972)). ([4897fa02](https://github.com/firebase/flutterfire/commit/4897fa02e2963961f24f1ff3a5b8d5e890e919ce))

## 2.13.0

 - **FEAT**: bump Firebase Android SDK to 32.0.0 ([#10913](https://github.com/firebase/flutterfire/issues/10913)). ([77459105](https://github.com/firebase/flutterfire/commit/774591050a94e9162eef0aee49bfc7fab97db1c6))
 - **FEAT**: bump Firebase iOS SDK to 10.9.0 ([#10949](https://github.com/firebase/flutterfire/issues/10949)). ([73d4bc0f](https://github.com/firebase/flutterfire/commit/73d4bc0f32440a9b8e9af6ee4ef28a92e2847a3d))

## 2.12.0

 - **FEAT**: update dependency constraints to `sdk: '>=2.18.0 <4.0.0'` `flutter: '>=3.3.0'` ([#10946](https://github.com/firebase/flutterfire/issues/10946)). ([2772d10f](https://github.com/firebase/flutterfire/commit/2772d10fe510dcc28ec2d37a26b266c935699fa6))

## 2.11.0

 - **FIX**: add support for AGP 8.0 ([#10901](https://github.com/firebase/flutterfire/issues/10901)). ([a3b96735](https://github.com/firebase/flutterfire/commit/a3b967354294c295a9be8d699a6adb7f4b1dba7f))
 - **FEAT**(core): add support for Windows via Firebase C++ desktop SDK ([#10496](https://github.com/firebase/flutterfire/issues/10496)). ([c0b8ad56](https://github.com/firebase/flutterfire/commit/c0b8ad5605d1fda6d897ea625224b5e61c5826ad))
 - **FEAT**: upgrade to dart 3 compatible dependencies ([#10890](https://github.com/firebase/flutterfire/issues/10890)). ([4bd7e59b](https://github.com/firebase/flutterfire/commit/4bd7e59b1f2b09a2230c49830159342dd4592041))

## 2.10.0

 - **FEAT**: bump Firebase Android SDK to 31.5.0 ([#10790](https://github.com/firebase/flutterfire/issues/10790)). ([34d766c0](https://github.com/firebase/flutterfire/commit/34d766c081b9a968559eaeaa75ad631bc5a637be))

## 2.9.0

 - **FEAT**: bump Firebase Android SDK to 31.4.0 ([#10690](https://github.com/firebase/flutterfire/issues/10690)). ([fcc8e9a6](https://github.com/firebase/flutterfire/commit/fcc8e9a62bc94d5cd4844dcd87c5feefa0821107))
 - **FEAT**: bump Firebase Android SDK to 31.3.0 ([#10664](https://github.com/firebase/flutterfire/issues/10664)). ([531ce04b](https://github.com/firebase/flutterfire/commit/531ce04bfbddcfe179b0d906ac9728fc29a39f8f))
 - **FEAT**: bump Firebase Android SDK to 31.2.3 ([#10644](https://github.com/firebase/flutterfire/issues/10644)). ([419ad220](https://github.com/firebase/flutterfire/commit/419ad2205df4f9e8b403df7ebc0b66521b654a43))
 - **FEAT**: bump Firebase iOS SDK to `10.7.0` ([#10638](https://github.com/firebase/flutterfire/issues/10638)). ([3ba8db57](https://github.com/firebase/flutterfire/commit/3ba8db579a24e244930d9a57fba3c28c3ec5180f))
 - **FEAT**: bump dart sdk constraint to 2.18 ([#10618](https://github.com/firebase/flutterfire/issues/10618)). ([f80948a2](https://github.com/firebase/flutterfire/commit/f80948a28b62eead358bdb900d5a0dfb97cebb33))

## 2.8.0

 - **FEAT**: bump Firebase iOS SDK 10.6.0 ([#10613](https://github.com/firebase/flutterfire/issues/10613)). ([7a3d0b5d](https://github.com/firebase/flutterfire/commit/7a3d0b5d2074b67470d255da2dd9c37b246a201d))
 - **FEAT**: bump Firebase iOS SDK `10.5.0` ([#10532](https://github.com/firebase/flutterfire/issues/10532)). ([c77fc4d4](https://github.com/firebase/flutterfire/commit/c77fc4d497532ffff352a3486abf01a98bc44869))

## 2.7.1

 - Update a dependency to the latest release.

## 2.7.0

 - **FEAT**: bump Firebase Android SDK to 31.2.2 ([#10492](https://github.com/firebase/flutterfire/issues/10492)). ([8990537a](https://github.com/firebase/flutterfire/commit/8990537a2547480462c0ebb4b79e60fca6a00bbb))

## 2.6.1

 - Update a dependency to the latest release.

## 2.6.0

 - **FEAT**: add support for TrustedType ([#10312](https://github.com/firebase/flutterfire/issues/10312)). ([da74aabb](https://github.com/firebase/flutterfire/commit/da74aabb0aa7350319179c1cb586b7bd3591d415))

## 2.5.0

 - **REFACTOR**: upgrade project to remove warnings from Flutter 3.7 ([#10344](https://github.com/firebase/flutterfire/issues/10344)). ([e0087c84](https://github.com/firebase/flutterfire/commit/e0087c845c7526c11a4241a26d39d4673b0ad29d))
 - **FEAT**: bump Firebase Android SDK to `31.2.0` ([#10369](https://github.com/firebase/flutterfire/issues/10369)). ([3a8b3b01](https://github.com/firebase/flutterfire/commit/3a8b3b01f6a311308509bfb8407ba13a05dd6a2d))

## 2.4.1

 - Update a dependency to the latest release.

## 2.4.0

 - **FEAT**: bump Firebase iOS SDK to 10.3.0 ([#10063](https://github.com/firebase/flutterfire/issues/10063)). ([a0910a1e](https://github.com/firebase/flutterfire/commit/a0910a1e49d7ff258f647a4a13b89b219e6eb157))

## 2.3.0

 - **FEAT**: bump Firebase iOS SDK to 10.2.0 ([#9954](https://github.com/firebase/flutterfire/issues/9954)). ([b0c67c83](https://github.com/firebase/flutterfire/commit/b0c67c83cd4adc14fa6d32b490e6ecd5dc478c3c))
 - **FEAT**: bump Firebase Android SDK to `31.0.3` ([#9952](https://github.com/firebase/flutterfire/issues/9952)). ([7095ae44](https://github.com/firebase/flutterfire/commit/7095ae444f1c2825478d1a0e707cd3c99ad87731))

## 2.2.0

 - **FEAT**: Firebase iOS SDK version `10.1.0` ([#9869](https://github.com/firebase/flutterfire/issues/9869)). ([b9b464fa](https://github.com/firebase/flutterfire/commit/b9b464faa9887045b8132eb791227e8bc01ea683))

## 2.1.1

 - **REFACTOR**: add `verify` to `QueryPlatform` and change internal `verifyToken` API to `verify` ([#9711](https://github.com/firebase/flutterfire/issues/9711)). ([c99a842f](https://github.com/firebase/flutterfire/commit/c99a842f3e3f5f10246e73f51530cc58c42b49a3))

## 2.1.0

 - **FEAT**: Firebase android SDK BOM - `31.0.1` ([#9767](https://github.com/firebase/flutterfire/issues/9767)). ([7088b2de](https://github.com/firebase/flutterfire/commit/7088b2de4198bf3d0e647fc8f2ff4165f6515387))

## 2.0.0

> Note: This release has breaking changes.

 - **BREAKING** **FEAT**: Firebase iOS SDK version: `10.0.0` ([#9708](https://github.com/firebase/flutterfire/issues/9708)). ([9627c56a](https://github.com/firebase/flutterfire/commit/9627c56a37d657d0250b6f6b87d0fec1c31d4ba3))
 - **BREAKING** **FEAT**: Firebase android SDK BOM `31.0.0` ([#9724](https://github.com/firebase/flutterfire/issues/9724)). ([29ba1a08](https://github.com/firebase/flutterfire/commit/29ba1a082e026c4f0f0913c10183a72eadb23343))

## 1.24.0

 - **FEAT**: Bump Firebase iOS SDK to `9.6.0` ([#9531](https://github.com/firebase/flutterfire/issues/9531)). ([2138f4aa](https://github.com/firebase/flutterfire/commit/2138f4aaaace51d5dce4809fb42e1e4ff20ed251))

## 1.23.0

 - **FEAT**: Bump Firebase android SDK to 30.5.0 ([#9573](https://github.com/firebase/flutterfire/issues/9573)). ([3ec750e1](https://github.com/firebase/flutterfire/commit/3ec750e1612671527fe7c0e576ca900821c1535b))
 - **DOCS**: update inline documentation on `initializeApp()` behaviour ([#9431](https://github.com/firebase/flutterfire/issues/9431)). ([3af5b676](https://github.com/firebase/flutterfire/commit/3af5b67664149b54ec73b328a04d94c06f389221))

## 1.22.0

 - **FEAT**: Bump Firebase iOS SDK to 9.5.0 ([#9492](https://github.com/firebase/flutterfire/issues/9492)). ([d246ba2a](https://github.com/firebase/flutterfire/commit/d246ba2aeec3da0bf5e2b4171ea2d1ec67618226))

## 1.21.1

 - Update a dependency to the latest release.

## 1.21.0

 - **FEAT**: Bump Firebase iOS SDK to 9.4.0 ([#9357](https://github.com/firebase/flutterfire/issues/9357)). ([4f356ff4](https://github.com/firebase/flutterfire/commit/4f356ff4fd5ec939c373265dd173d1cb73de1678))
 - **FEAT**: Bump Firebase android SDK to 30.3.2 ([#9358](https://github.com/firebase/flutterfire/issues/9358)). ([d6934398](https://github.com/firebase/flutterfire/commit/d69343988006cf809c61f4c31e41bd5aa8075cf5))

## 1.20.1

 - **FIX**: broken homepage link in pubspec.yaml ([#9314](https://github.com/firebase/flutterfire/issues/9314)). ([7649c27f](https://github.com/firebase/flutterfire/commit/7649c27fde639aec8c70a1acfd86c938eeb77537))

## 1.20.0

 - **FEAT**: bump Firebase Android SDK to 30.3.0 ([#9161](https://github.com/firebase/flutterfire/issues/9161)). ([d1f96310](https://github.com/firebase/flutterfire/commit/d1f96310310c7584c4af751e1e75dc178aacce89))
 - **FEAT**: add phone MFA ([#9044](https://github.com/firebase/flutterfire/issues/9044)). ([1b85c8b7](https://github.com/firebase/flutterfire/commit/1b85c8b7fbcc3f21767f23981cb35061772d483f))
 - **FEAT**: update to 9.3.0 ([#9137](https://github.com/firebase/flutterfire/issues/9137)). ([97f6417b](https://github.com/firebase/flutterfire/commit/97f6417bf66f88e6621afa177c73245b9a7d5c73))

## 1.19.2

 - Update a dependency to the latest release.

## 1.19.1

 - **FIX**: bump `firebase_core_platform_interface` version to fix previous release. ([bea70ea5](https://github.com/firebase/flutterfire/commit/bea70ea5cbbb62cbfd2a7a74ae3a07cb12b3ee5a))

## 1.19.0

 - **FEAT**: Bump Firebase iOS SDK to `9.2.0` (#8594). ([79610162](https://github.com/firebase/flutterfire/commit/79610162460b8877f3bc727464a7065106f08079))

## 1.18.0

 - **REFACTOR**: migrate from hash* to Object.hash* (#8797). ([3dfc0997](https://github.com/firebase/flutterfire/commit/3dfc0997050ee4351207c355b2c22b46885f971f))
 - **REFACTOR**: use "firebase" instead of "FirebaseExtended" as organisation in all links for this repository (#8791). ([d90b8357](https://github.com/firebase/flutterfire/commit/d90b8357db01d65e753021358668f0b129713e6b))
 - **FEAT**: bump Firebase Android SDK to 30.1.0 (#8847). ([796f1e74](https://github.com/firebase/flutterfire/commit/796f1e744fa361a023aba4ec7f491387a9e2f0f8))
 - **DOCS**: point to "firebase.google" domain for hyperlinks in the usage section of `README.md` files (for the missing packages) (#8818). ([5bda8c92](https://github.com/firebase/flutterfire/commit/5bda8c92be1651a941d1285d36e885ee0b967b11))

## 1.17.1

 - **DOCS**: use camel case style for "FlutterFire" in `README.md` (#8749). ([41462a42](https://github.com/firebase/flutterfire/commit/41462a423ad783d20e5d303ed41898b061bccc48))

## 1.17.0

 - **REFACTOR**: remove deprecated `Tasks.call` for android and replace with `TaskCompletionSource`. ([#8581](https://github.com/firebase/flutterfire/issues/8581)). ([374c9df3](https://github.com/firebase/flutterfire/commit/374c9df33bbb6b354ea526dcc6cc7812fa4452c0))
 - **FEAT**: bump Firebase Android SDK to 30.0.0 ([#8617](https://github.com/firebase/flutterfire/issues/8617)). ([72158aaf](https://github.com/firebase/flutterfire/commit/72158aaf9721dbf5f20c362f0c99853273507538))
 - **FEAT**: allow initializing default Firebase apps via `FirebaseOptions.fromResource` on Android ([#8566](https://github.com/firebase/flutterfire/issues/8566)). ([30216c4a](https://github.com/firebase/flutterfire/commit/30216c4a4c06c20f9c4c2b9a235a4aa9a48816a0))

## 1.16.0

 - **FEAT**: allow initializing default Firebase apps via `FirebaseOptions.fromResource` on Android (#8566). ([30216c4a](https://github.com/firebase/flutterfire/commit/30216c4a4c06c20f9c4c2b9a235a4aa9a48816a0))

## 1.15.0

 - **FEAT**: bump Firebase Android SDK to `29.3.1` (#8494). ([17b9c289](https://github.com/firebase/flutterfire/commit/17b9c2894ee901afd2631664b01829cd4df1dd16))
 - **FEAT**: Update Firebase iOS SDK to `8.15.0` (#8454). ([faaf4496](https://github.com/firebase/flutterfire/commit/faaf449624ff4081cbbc0f241fec3134492cbdb3))

## 1.14.1

 - Update a dependency to the latest release.

## 1.14.0

 - **FEAT**: Bump Firebase iOS SDK to `8.14.0`. (#8370). ([41bb9800](https://github.com/firebase/flutterfire/commit/41bb98004327013f90c93709513c419d04382475))
 - **FEAT**: bump Firebase Android SDK to `29.3.0` (#8283). ([a6c646a0](https://github.com/firebase/flutterfire/commit/a6c646a0d23600e5e4ae6d40ca4b23c7e73fc257))
 - **DOCS**: Update inline code documentation for initializing Firebase app. (#8329). ([19727798](https://github.com/firebase/flutterfire/commit/19727798a8dcfde103665eb8209b714e49327a11))

## 1.13.1

 - **FIX**: update all Dart SDK version constraints to Dart >= 2.16.0 (#8184). ([df4a5bab](https://github.com/firebase/flutterfire/commit/df4a5bab3c029399b4f257a5dd658d302efe3908))

## 1.13.0

 - **FEAT**: refactor error handling to preserve stack traces on platform exceptions (#8156). ([6ac77d99](https://github.com/firebase/flutterfire/commit/6ac77d99042de2a1950f89b35972e3ee1116dc9f))

## 1.12.0

 - **FEAT**: bump Firebase iOS SDK to `8.11.0` & Android SDK to `29.0.4` (#7942). ([c23adf08](https://github.com/firebase/flutterfire/commit/c23adf0853466941d0afb174dd425a43b44ce501))

## 1.11.0

 - **FIX**: bump Android `compileSdkVersion` to 31 (#7726). ([a9562bac](https://github.com/firebase/flutterfire/commit/a9562bac60ba927fb3664a47a7f7eaceb277dca6))
 - **FIX**: bump Firebase Android SDK version to `29.0.3` (from `29.0.0`). ([2ab4abaf](https://github.com/firebase/flutterfire/commit/2ab4abafbed279183d298f129cd14aebb588c86d))
 - **FIX**: workaround an SDK issue on Android where calling `initializeApp` when having `In App Messaging` installed causes a crash. ([8f5204e7](https://github.com/firebase/flutterfire/commit/8f5204e7e59e92869d61764c051e5687e118282d))
 - **FEAT**: bump Firebase iOS SDK version to `8.10.0`. (#7775). ([ac9709e0](https://github.com/firebase/flutterfire/commit/ac9709e00a0e3d1706b793750ed2e65d9ae9440b))

## 1.10.6

 - **REFACTOR**: fix all `unnecessary_import` analyzer issues introduced with Flutter 2.8. ([7f0e82c9](https://github.com/firebase/flutterfire/commit/7f0e82c978a3f5a707dd95c7e9136a3e106ff75e))

## 1.10.5

 - Update a dependency to the latest release.

## 1.10.4

 - Update a dependency to the latest release.

## 1.10.3

 - Update a dependency to the latest release.

## 1.10.2

 - Update a dependency to the latest release.

## 1.10.1

 - **REFACTOR**: migrate remaining examples & e2e tests to null-safety (#7393).

## 1.10.0

 - **FEAT**: support initializing default `FirebaseApp` instances from Dart (#6549).

## 1.9.0

 - **FEAT**: bump Firebase Android SDK version to `29.0.0` (#7296).
 - **FEAT**: bump Firebase iOS SDK to `8.9.0` (#7289).

## 1.8.0

 - **FEAT**: Firebase iOS SDK version bumped to `8.8.0` (#7213).
 - **REFACTOR**: remove deprecated Flutter Android v1 Embedding usages, including in example app (#7158).
 - **STYLE**: macOS & iOS; explicitly include header that defines `TARGET_OS_OSX` (#7116).

## 1.7.0

 - **FEAT**: bump Firebase iOS SDK to `8.7.0` & Android SDK to `28.4.1` (#7083).
 - **CHORE**: update gradle version across packages (#7054).

## 1.6.0

 - **FEAT**: update Firebase Android SDK to `28.3.1` & Firebase iOS SDK to `8.6.0` (#6847).

## 1.5.0

 - **STYLE**: enable additional lint rules (#6832).
 - **FEAT**: lower iOS & macOS deployment targets for relevant plugins (#6757).
 - **FEAT**: iOS sdk version bump 8.5.0. (#6786).

## 1.4.0

 - **FEAT**: bump Firebase iOS SDK version to 8.3.0 (#6568).
 - **CHORE**: update v2 embedding support (#6506).
 - **CHORE**: rm deprecated jcenter repository (#6431).

## 1.3.0

 - **FEAT**: Upgrade Firebase Android BoM version to 28.1.0 (#6338).

## 1.2.1

 - **DOCS**: Add Flutter Favorite badge (#6190).

## 1.2.0

 - **FEAT**: upgrade Firebase Android SDK BoM version from 28.0.0 to 28.0.1.
 - **FEAT**: upgrade Firebase JS SDK version to 8.6.1.
 - **FIX**: podspec osx version checking script should use a version range instead of a single fixed version.

## 1.1.1

 - Update a dependency to the latest release.

## 1.1.0

 - **FEAT**: update iOS Firebase SDK from 7.3 to 7.11 (#5896).

## 1.0.4

 - **REFACTOR**: Share guard functions across plugins (#5783).
 - **CHORE**: update Web plugins to use Firebase JS SDK version 8.4.1 (#4464).

## 1.0.3

 - **REFACTOR**: Remove deprecated gradle property android.enableR8=true (#5463).
 - **CHORE**: add repository urls to pubspecs (#5542).
 - **CHORE**: bump min Dart SDK constraint to 2.12.0 (#5430).
 - **CHORE**: publish packages (#5429).
 - **CHORE**: publish packages.

## 1.0.2

 - Update a dependency to the latest release.

## 1.0.1

 - Update a dependency to the latest release.

## 1.0.0

 - Graduate package to a stable release. See pre-releases prior to this version for changelog entries.

## 1.0.0-1.0.nullsafety.0

 - Bump "firebase_core" to `1.0.0-1.0.nullsafety.0`.

## 0.8.0-1.0.nullsafety.2

 - **TESTS**: update mockito API usage in tests

## 0.8.0-1.0.nullsafety.1

 - **REFACTOR**: pubspec & dependency updates (#4932).
 - **REFACTOR**: replace deprecated `RaisedButton` widget with `ElevatedButton`.

## 0.8.0-1.0.nullsafety.0

 - Bump "firebase_core" to `0.8.0-1.0.nullsafety.0`.

## 0.8.0-nullsafety.1

 - **FEAT**: bump firebase-core to 4.0.0-nullsafety.0 and firebase-core-web to 0.3.0-nullsafety.0.

## 0.8.0-nullsafety.0

- **FIX**: Bump package to 0.8.0 for nullsafety. (fixes issue #4728)

## 0.7.0-nullsafety.0

 - **REFACTOR**: Migrate non-nullable types (#4656).

## 0.7.0

> Note: This release has breaking changes.

 - **FEAT**: add check on podspec to assist upgrading users deployment target.
 - **BUILD**: commit Podfiles with 10.12 deployment target.
 - **BUILD**: remove default sdk version, version should always come from firebase_core, or be user defined.
 - **BUILD**: set macOS deployment target to 10.12 (from 10.11).
 - **BREAKING** **BUILD**: set osx min supported platform version to 10.12.

## 0.6.0

> Note: This release has breaking changes.

 - **FEAT**: bump firebase-android-sdk to v26.2.0.
 - **BREAKING** **REFACTOR**: remove all currently deprecated APIs.
 - **BREAKING** **FEAT**: forward port to firebase-ios-sdk v7.3.0.
   - Due to this SDK upgrade, iOS 10 is now the minimum supported version by FlutterFire. Please update your build target version.
 - **CHORE**: harmonize dependencies and version handling.

## 0.5.3

 - **FEAT**: bump android `com.android.tools.build` & `'com.google.gms:google-services` versions (#4269).

## 0.5.2+1

 - Update a dependency to the latest release.

## 0.5.2

 - **FEAT**: add not-in & != query support (#3748).
 - **FEAT**: bump compileSdkVersion to 29 (#3975).
 - **FEAT**: bump `compileSdkVersion` to 29 in preparation for upcoming Play Store requirement.
 - **CHORE**: publish packages.
 - **CHORE**: publish packages.

## 0.5.1

 - **FEAT**: bump compileSdkVersion to 29 (#3975).
 - **FEAT**: update Firebase Android SDK BoM version to 25.12.0 (from 25.3.1).
 - **FEAT**: update Firebase iOS SDK version to 6.33.0 (from 6.26.0).

## 0.5.0+1

 - **FIX**: remove unused dart:async import (#3611).

## 0.5.0

* Allow iOS and macOS to be imported as a module.
* DEPRECATED: `FirebaseApp.configure` method is now deprecated in favor of the `Firebase.initializeApp` method.
* DEPRECATED: `FirebaseApp.allApps` method is now deprecated in favor of the `Firebase.apps` property.
  * Previously, `allApps` was async & `apps` is now synchronous.
* DEPRECATED: `FirebaseApp.appNamed` method is now deprecated in favor of the `Firebase.app` method.
* BREAKING: `FirebaseApp.options` getter is now synchronous.

* `FirebaseOptions` has been reworked to better match web property names:
  * DEPRECATED: `googleAppID` is now deprecated in favor of `appId`.
  * DEPRECATED: `projectID` is now deprecated in favor of `projectId`.
  * DEPRECATED: `bundleID` is now deprecated in favor of `bundleId`.
  * DEPRECATED: `clientID` is now deprecated in favor of `androidClientId`.
  * DEPRECATED: `trackingID` is now deprecated in favor of `trackingId`.
  * DEPRECATED: `gcmSenderID` is now deprecated in favor of `messagingSenderId`.
  * Added support for `authDomain`.
  * Added support for `trackingId`.
  * Required properties are now `apiKey`, `appId`, `messagingSenderId` & `projectId`.

* Added support for deleting Firebase app instances via the `delete` method on `FirebaseApp`.
* Added support for returning consistent error messages from `firebase-dart` plugin.
  * Any FlutterFire related errors now throw a `FirebaseException`.
* Added a `FirebaseException` class to handle all FlutterFire related errors.
  * Matching the web sdk, the exception returns a formatted "[plugin/code] message" message when thrown.
* Added support for `setAutomaticDataCollectionEnabled` & `isAutomaticDataCollectionEnabled` on a `FirebaseApp` instance.
* Added support for `setAutomaticResourceManagementEnabled` on a `FirebaseApp` instance.

* Android: Gradle build tools updated to 3.6.3 from 3.3.0.
* Android: Removed Gradle ‘hacks’ and upgrade Flutter SDK requirement from `>=1.12.13+hotfix.4` to `>=1.12.13+hotfix.5` - based on PR https://github.com/flutter/plugins/pull/2651
* Android: Switched to using Firebase BoM to manage SDK versions

## 0.4.5

* Update lower bound of dart dependency to 2.0.0.

## 0.4.4+3

* Fix for missing UserAgent.h compilation failures.

## 0.4.4+2

* Update dependency on firebase_core_platform_interface to 1.0.4.

## 0.4.4+1

* Make the pedantic dev_dependency explicit.

## 0.4.4

* Add macOS support

## 0.4.3+3

* Fix overrides a deprecated API.

## 0.4.3+2

* Add integration instructions for the `web` platform.

## 0.4.3+1

* Move `Platform.isIOS` check behind a configurable import so that pub.dev registers
  this as a Web plugin.

## 0.4.3

* Enable the `web` implementation by default.
* Raise minimum required Flutter SDK version to 1.12.13+hotfix.4

## 0.4.2+2

* Remove the deprecated `author:` field from pubspec.yaml
* Migrate the plugin to the pubspec platforms manifest.
* Bump the minimum Flutter version to 1.10.0.

## 0.4.2+1

* Check `kIsWeb` before checking `Platform.isIos` for the default app name.

## 0.4.2

* Migrate to `firebase_core_platform_interface`.

## 0.4.1+6

* Update the homepage now that the package structure has changed.

## 0.4.1+5

* Remove deprecated [firebase-core](https://firebase.google.com/support/release-notes/android) dependency.

## 0.4.1+4

* Remove visibleForTesting annotation from FirebaseApp constructor.

## 0.4.1+3

* Updated README instructions for contributing for consistency with other Flutterfire plugins.

## 0.4.1+2

* Remove AndroidX warning.

## 0.4.1+1

* Include lifecycle dependency as a compileOnly one on Android to resolve
  potential version conflicts with other transitive libraries.

## 0.4.1

* Support the v2 Android embedding.

## 0.4.0+9

* Update documentation to reflect new repository location.
* Update unit tests to call `TestWidgetsFlutterBinding.ensureInitialized`.

## 0.4.0+8

* Update google-services Android gradle plugin to 4.3.0 in documentation and examples.

## 0.4.0+7

* Fix Android compilation warning.

## 0.4.0+6

* Automatically use version from pubspec.yaml when reporting usage to Firebase.

## 0.4.0+5

* Rollback of automatic plugin version retrieval.

## 0.4.0+4

* Automate the retrieval of the plugin's version when reporting usage to Firebase.

## 0.4.0+3

* Add missing template type parameter to `invokeMethod` calls.
* Bump minimum Flutter version to 1.5.0.
* Replace invokeMethod with invokeMapMethod wherever necessary.

## 0.4.0+2

* Update user agent name. Set to `flutter-fire-core` for consistency with other
  libraries.

## 0.4.0+1

* Send user agent to Firebase.

## 0.4.0

* Update Android dependencies to latest.

## 0.3.4

* Updates Android firebase-core dependency to a version that is compatible with other Flutterfire plugins.

## 0.3.3

* Remove Gradle BoM to avoid Gradle version issues.

## 0.3.2

* Move Android dependency to Gradle BoM to help maintain compatibility
  with other FlutterFire plugins.

## 0.3.1+1

* Add nil check on static functions to prevent crashes or unwanted behaviors.

## 0.3.1

* Remove an assertion that can interfere with hot-restart.

## 0.3.0+2

* Remove categories.

## 0.3.0+1

* Log a more detailed warning at build time about the previous AndroidX
  migration.

## 0.3.0

* **Breaking change**. Migrate from the deprecated original Android Support
  Library to AndroidX. This shouldn't result in any functional changes, but it
  requires any Android apps using this plugin to [also
  migrate](https://developer.android.com/jetpack/androidx/migrate) if they're
  using the original support library.

## 0.2.5+1

* Bump Android dependencies to latest.

## 0.2.5

* Bump Android and Firebase dependency versions.

## 0.2.4

* Updated Gradle tooling to match Android Studio 3.1.2.

## 0.2.3

* Updated Google Play Services dependencies to version 15.0.0.

## 0.2.2

* Simplified podspec for Cocoapods 1.5.0, avoiding link issues in app archives.

## 0.2.1

* Fix setting project ID on Android.

## 0.2.0

* **Breaking change**. Options API is now async to interoperate with native code that configures Firebase apps.
* Provide a getter for the default app
* Fix setting of GCM sender ID on iOS

## 0.1.2

* Fix projectID on iOS

## 0.1.1

* Fix behavior of constructor for named Firebase apps.

## 0.1.0

* **Breaking change**. Set SDK constraints to match the Flutter beta release.

## 0.0.7

* Fixed Dart 2 type errors.

## 0.0.6

* Enabled use in Swift projects.

## 0.0.5

* Moved to the io.flutter.plugins org.

## 0.0.4

* Fixed warnings from the Dart 2.0 analyzer.
* Simplified and upgraded Android project template to Android SDK 27.
* Updated package description.

# 0.0.3

* **Breaking change**. Upgraded to Gradle 4.1 and Android Studio Gradle plugin
  3.0.1. Older Flutter projects need to upgrade their Gradle setup as well in
  order to use this version of the plugin. Instructions can be found
  [here](https://github.com/flutter/flutter/wiki/Updating-Flutter-projects-to-Gradle-4.1-and-Android-Studio-Gradle-plugin-3.0.1).

## 0.0.2

* Fixes for database URL on Android
* Make GCM sender id optional on Android
* Relax GMS dependency to 11.+

## 0.0.1

* Initial Release

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/README.md

**크기**: 1327 bytes | **라인 수**: 29 | **타입**: text

```
[<img src="https://raw.githubusercontent.com/firebase/flutterfire/main/.github/images/flutter_favorite.png" width="200" />](https://flutter.dev/docs/development/packages-and-plugins/favorites)

# Firebase Core for Flutter

[![pub package](https://img.shields.io/pub/v/firebase_core.svg)](https://pub.dev/packages/firebase_core)

A Flutter plugin to use the Firebase Core API, which enables connecting to multiple Firebase apps.

To learn more about Firebase, please visit the [Firebase website](https://firebase.google.com)

## Getting Started

To get started with FlutterFire, please [see the documentation](https://firebase.google.com/docs/flutter/setup?platform=ios).

## Usage

To use this plugin, please visit the [Core Usage documentation](https://firebase.google.com/docs/flutter/setup)

## Issues and feedback

Please file FlutterFire specific issues, bugs, or feature requests in our [issue tracker](https://github.com/firebase/flutterfire/issues/new).

Plugin issues that are not specific to FlutterFire can be filed in the [Flutter issue tracker](https://github.com/flutter/flutter/issues/new).

To contribute a change to this plugin,
please review our [contribution guide](https://github.com/firebase/flutterfire/blob/main/CONTRIBUTING.md)
and open a [pull request](https://github.com/firebase/flutterfire/pulls).


```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/firebase_core/pubspec.yaml

**크기**: 1163 bytes | **라인 수**: 50 | **타입**: text

```
name: firebase_core
description: Flutter plugin for Firebase Core, enabling connecting to multiple
  Firebase apps.
homepage: https://firebase.google.com/docs/flutter/setup
repository: https://github.com/firebase/flutterfire/tree/main/packages/firebase_core/firebase_core
version: 4.1.1
topics:
  - firebase
  - core

false_secrets:
  - example/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.3.0'

dependencies:
  firebase_core_platform_interface: ^6.0.1
  firebase_core_web: ^3.1.1
  flutter:
    sdk: flutter
  meta: ^1.8.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0
  plugin_platform_interface: ^2.1.3

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.core
        pluginClass: FlutterFirebaseCorePlugin
      ios:
        pluginClass: FLTFirebaseCorePlugin
      macos:
        pluginClass: FLTFirebaseCorePlugin
      web:
        default_package: firebase_core_web
      windows:
        pluginClass: FirebaseCorePluginCApi

firebase:
  google_services_gradle_plugin_version: '4.3.15'
  crashlytics_gradle_plugin_version: '2.8.1'
  performance_gradle_plugin_version: '1.4.1'

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/lib/main.dart

**크기**: 4575 bytes | **라인 수**: 142 | **타입**: text

```
import 'package:baseflow_plugin_template/baseflow_plugin_template.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler_platform_interface/permission_handler_platform_interface.dart';

void main() {
  runApp(BaseflowPluginExample(
      pluginName: 'Permission Handler',
      githubURL: 'https://github.com/Baseflow/flutter-permission-handler',
      pubDevURL: 'https://pub.dev/packages/permission_handler',
      pages: [PermissionHandlerWidget.createPage()]));
}

///Defines the main theme color
final MaterialColor themeMaterialColor =
    BaseflowPluginExample.createMaterialColor(
        const Color.fromRGBO(48, 49, 60, 1));

/// A Flutter application demonstrating the functionality of this plugin
class PermissionHandlerWidget extends StatefulWidget {
  /// Create a page containing the functionality of this plugin
  static ExamplePage createPage() {
    return ExamplePage(
        Icons.location_on, (context) => PermissionHandlerWidget());
  }

  @override
  _PermissionHandlerWidgetState createState() =>
      _PermissionHandlerWidgetState();
}

class _PermissionHandlerWidgetState extends State<PermissionHandlerWidget> {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: ListView(
          children: Permission.values
              .where((permission) {
                return permission != Permission.unknown &&
                    permission != Permission.mediaLibrary &&
                    permission != Permission.photos &&
                    permission != Permission.photosAddOnly &&
                    permission != Permission.reminders &&
                    permission != Permission.appTrackingTransparency &&
                    permission != Permission.criticalAlerts;
              })
              .map((permission) => PermissionWidget(permission))
              .toList()),
    );
  }
}

/// Permission widget containing information about the passed [Permission]
class PermissionWidget extends StatefulWidget {
  /// Constructs a [PermissionWidget] for the supplied [Permission]
  const PermissionWidget(this._permission);

  final Permission _permission;

  @override
  _PermissionState createState() => _PermissionState(_permission);
}

class _PermissionState extends State<PermissionWidget> {
  _PermissionState(this._permission);

  final Permission _permission;
  final PermissionHandlerPlatform _permissionHandler =
      PermissionHandlerPlatform.instance;
  PermissionStatus _permissionStatus = PermissionStatus.denied;

  @override
  void initState() {
    super.initState();

    _listenForPermissionStatus();
  }

  void _listenForPermissionStatus() async {
    final status = await _permissionHandler.checkPermissionStatus(_permission);
    setState(() => _permissionStatus = status);
  }

  Color getPermissionColor() {
    switch (_permissionStatus) {
      case PermissionStatus.denied:
        return Colors.red;
      case PermissionStatus.granted:
        return Colors.green;
      case PermissionStatus.limited:
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(
        _permission.toString(),
        style: Theme.of(context).textTheme.bodyLarge,
      ),
      subtitle: Text(
        _permissionStatus.toString(),
        style: TextStyle(color: getPermissionColor()),
      ),
      trailing: (_permission is PermissionWithService)
          ? IconButton(
              icon: const Icon(
                Icons.info,
                color: Colors.white,
              ),
              onPressed: () {
                checkServiceStatus(
                    context, _permission as PermissionWithService);
              })
          : null,
      onTap: () {
        requestPermission(_permission);
      },
    );
  }

  void checkServiceStatus(
      BuildContext context, PermissionWithService permission) async {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(
          (await _permissionHandler.checkServiceStatus(permission)).toString()),
    ));
  }

  Future<void> requestPermission(Permission permission) async {
    final status = await _permissionHandler.requestPermissions([permission]);

    setState(() {
      print(status);
      _permissionStatus = status[permission] ?? PermissionStatus.denied;
      print(_permissionStatus);
    });
  }
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/flutter/CMakeLists.txt

**크기**: 3489 bytes | **라인 수**: 104 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      windows-x64 $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/flutter/generated_plugin_registrant.h

**크기**: 302 bytes | **라인 수**: 16 | **타입**: text

```
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/CMakeLists.txt

**크기**: 572 bytes | **라인 수**: 18 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)
apply_standard_settings(${BINARY_NAME})
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
add_dependencies(${BINARY_NAME} flutter_assemble)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/flutter_window.cpp

**크기**: 1823 bytes | **라인 수**: 62 | **타입**: text

```
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());
  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/flutter_window.h

**크기**: 961 bytes | **라인 수**: 34 | **타입**: text

```
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/main.cpp

**크기**: 1310 bytes | **라인 수**: 44 | **타입**: text

```
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.CreateAndShow(L"example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/resource.h

**크기**: 448 bytes | **라인 수**: 17 | **타입**: text

```
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/utils.cpp

**크기**: 1715 bytes | **라인 수**: 65 | **타입**: text

```
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr);
  if (target_length == 0) {
    return std::string();
  }
  std::string utf8_string;
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, utf8_string.data(),
      target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/utils.h

**크기**: 691 bytes | **라인 수**: 20 | **타입**: text

```
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/win32_window.cpp

**크기**: 7269 bytes | **라인 수**: 246 | **타입**: text

```
#include "win32_window.h"

#include <flutter_windows.h>

#include "resource.h"

namespace {

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
    FreeLibrary(user32_module);
  }
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::CreateAndShow(const std::wstring& title,
                                const Point& origin,
                                const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  return OnCreate();
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/runner/win32_window.h

**크기**: 3448 bytes | **라인 수**: 99 | **타입**: text

```
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates and shows a win32 window with |title| and position and size using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size to will treat the width height passed in to this function
  // as logical pixels and scale to appropriate for the default monitor. Returns
  // true if the window was created successfully.
  bool CreateAndShow(const std::wstring& title,
                     const Point& origin,
                     const Size& size);

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responsponds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/windows/CMakeLists.txt

**크기**: 3419 bytes | **라인 수**: 96 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(example LANGUAGES CXX)

set(BINARY_NAME "example")

cmake_policy(SET CMP0063 NEW)

set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Configure build options.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()

set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")

# Flutter library and tool build rules.
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build
add_subdirectory("runner")

# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/README.md

**크기**: 585 bytes | **라인 수**: 17 | **타입**: text

```
# permission_handler_example

Demonstrates how to use the permission_handler plugin.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://flutter.io/docs/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://flutter.io/docs/cookbook)

For help getting started with Flutter, view our
[online documentation](https://flutter.io/docs), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/example/pubspec.yaml

**크기**: 983 bytes | **라인 수**: 34 | **타입**: text

```
name: permission_handler_windows_example
description: Demonstrates how to use the permission_handler_windows plugin.

environment:
  sdk: ">=2.15.0 <3.0.0"

dependencies:
  baseflow_plugin_template: ^2.1.1
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter

  permission_handler_windows:
    # When depending on this package from a real application you should use:
    #   permission_handler_windows: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../

  url_launcher: ^6.0.12

flutter:
  uses-material-design: true

  assets:
    - res/images/baseflow_logo_def_light-02.png
    - res/images/poweredByBaseflowLogoLight@3x.png
    - packages/baseflow_plugin_template/logo.png
    - packages/baseflow_plugin_template/poweredByBaseflow.png

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/windows/include/permission_handler_windows/permission_handler_windows_plugin.h

**크기**: 842 bytes | **라인 수**: 24 | **타입**: text

```
#ifndef PACKAGES_PERMISSION_HANDLER_PERMISSION_HANDLER_WINDOWS_WINDOWS_INCLUDE_PERMISSION_HANDLER_WINDOWS_PERMISSION_HANDLER_PLUGIN_H_
#define PACKAGES_PERMISSION_HANDLER_PERMISSION_HANDLER_WINDOWS_WINDOWS_INCLUDE_PERMISSION_HANDLER_WINDOWS_PERMISSION_HANDLER_PLUGIN_H_

#include <flutter_plugin_registrar.h>

#ifdef FLUTTER_PLUGIN_IMPL
#define FLUTTER_PLUGIN_EXPORT __declspec(dllexport)
#else
#define FLUTTER_PLUGIN_EXPORT __declspec(dllimport)
#endif

#if defined(__cplusplus)
extern "C" {
#endif

FLUTTER_PLUGIN_EXPORT void PermissionHandlerWindowsPluginRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar);

#if defined(__cplusplus)
}  // extern "C"
#endif

#endif  // PACKAGES_PERMISSION_HANDLER_PERMISSION_HANDLER_WINDOWS_WINDOWS_INCLUDE_PERMISSION_HANDLER_WINDOWS_PERMISSION_HANDLER_PLUGIN_H_

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/windows/CMakeLists.txt

**크기**: 2229 bytes | **라인 수**: 61 | **타입**: text

```
cmake_minimum_required(VERSION 3.15)
set(PROJECT_NAME "permission_handler_windows")
set(CPPWINRT_VERSION "2.0.210806.1")
project(${PROJECT_NAME} LANGUAGES CXX)
include(FetchContent)

# This value is used when generating builds using this plugin, so it must
# not be changed
set(PLUGIN_NAME "${PROJECT_NAME}_plugin")

FetchContent_Declare(nuget
  URL "https://dist.nuget.org/win-x86-commandline/v6.0.0/nuget.exe"
  URL_HASH SHA256=04eb6c4fe4213907e2773e1be1bbbd730e9a655a3c9c58387ce8d4a714a5b9e1
  DOWNLOAD_NO_EXTRACT true
)

find_program(NUGET nuget)
if (NOT NUGET)
    message("Nuget.exe not found, trying to download or use cached version.")
    FetchContent_MakeAvailable(nuget)
    set(NUGET ${nuget_SOURCE_DIR}/nuget.exe)
endif()

execute_process(COMMAND
    ${NUGET} install Microsoft.Windows.CppWinRT -Version ${CPPWINRT_VERSION} -OutputDirectory packages
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    RESULT_VARIABLE ret)
if (NOT ret EQUAL 0)
    message(FATAL_ERROR "Failed to install nuget package Microsoft.Windows.CppWinRT.${CPPWINRT_VERSION}")
endif()

set(CPPWINRT ${CMAKE_BINARY_DIR}/packages/Microsoft.Windows.CppWinRT.${CPPWINRT_VERSION}/bin/cppwinrt.exe)
execute_process(COMMAND
    ${CPPWINRT} -input sdk -output include
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    RESULT_VARIABLE ret)
if (NOT ret EQUAL 0)
    message(FATAL_ERROR "Failed to run cppwinrt.exe")
endif()

include_directories(BEFORE SYSTEM ${CMAKE_BINARY_DIR}/include)

add_library(${PLUGIN_NAME} SHARED
  "include/permission_handler_windows/permission_handler_windows_plugin.h"
  "permission_handler_windows_plugin.cpp"
)
apply_standard_settings(${PLUGIN_NAME})
set_target_properties(${PLUGIN_NAME} PROPERTIES CXX_VISIBILITY_PRESET hidden)
target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_20)
target_compile_options(${PLUGIN_NAME} PRIVATE /await)
target_compile_definitions(${PLUGIN_NAME} PRIVATE FLUTTER_PLUGIN_IMPL)
target_include_directories(${PLUGIN_NAME} INTERFACE
  "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(${PLUGIN_NAME} PRIVATE flutter flutter_wrapper_plugin)

# List of absolute paths to libraries that should be bundled with the plugin
set(permission_handler_windows_bundled_libraries
  ""
  PARENT_SCOPE
)

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/windows/permission_constants.h

**크기**: 2004 bytes | **라인 수**: 71 | **타입**: text

```
#include <string>

class PermissionConstants {
public:
    inline static int PERMISSION_CODE = 24;
    inline static int PERMISSION_CODE_IGNORE_BATTERY_OPTIMIZATIONS = 209;
    inline static int PERMISSION_CODE_MANAGE_EXTERNAL_STORAGE = 210;
    inline static int PERMISSION_CODE_SYSTEM_ALERT_WINDOW = 211;
    inline static int PERMISSION_CODE_REQUEST_INSTALL_PACKAGES = 212;
    inline static int PERMISSION_CODE_ACCESS_NOTIFICATION_POLICY = 213;

    //PERMISSION_GROUP
    enum class PermissionGroup {
        CALENDAR = 0,
        CAMERA = 1,
        CONTACTS = 2,
        LOCATION = 3,
        LOCATION_ALWAYS = 4,
        LOCATION_WHEN_IN_USE = 5,
        MEDIA_LIBRARY = 6,
        MICROPHONE = 7,
        PHONE = 8,
        PHOTOS = 9,
        PHOTOS_ADD_ONLY = 10,
        REMINDERS = 11,
        SENSORS = 12,
        SMS = 13,
        SPEECH = 14,
        STORAGE = 15,
        IGNORE_BATTERY_OPTIMIZATIONS = 16,
        NOTIFICATION = 17,
        ACCESS_MEDIA_LOCATION = 18,
        ACTIVITY_RECOGNITION = 19,
        UNKNOWN = 20,
        BLUETOOTH = 21,
        MANAGE_EXTERNAL_STORAGE = 22,
        SYSTEM_ALERT_WINDOW = 23,
        REQUEST_INSTALL_PACKAGES = 24,
        APP_TRACK_TRANSPARENCY = 25,
        CRITICAL_ALERTS = 26,
        ACCESS_NOTIFICATION_POLICY = 27,
        BLUETOOTH_SCAN = 28,
        BLUETOOTH_ADVERTISE = 29,
        BLUETOOTH_CONNECT = 30,
        NEARBY_WIFI_DEVICES = 31,
        VIDEOS = 32,
        AUDIO = 33,
        SCHEDULE_EXACT_ALARM = 34,
        SENSORS_ALWAYS = 35,
        CALENDAR_WRITE_ONLY = 36,
        CALENDAR_FULL_ACCESS = 37,
        ASSISTANT = 38
    };

    //PERMISSION_STATUS
    enum class PermissionStatus {
        DENIED = 0,
        GRANTED = 1,
        RESTRICTED = 2,
        LIMITED = 3,
        NEVER_ASK_AGAIN = 4
    };

    //SERVICE_STATUS
    enum class ServiceStatus {
        DISABLED = 0,
        ENABLED = 1,
        NOT_APPLICABLE = 2
    };
};

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/windows/permission_handler_windows_plugin.cpp

**크기**: 7117 bytes | **라인 수**: 194 | **타입**: text

```
#include "include/permission_handler_windows/permission_handler_windows_plugin.h"

#include <flutter/method_channel.h>
#include <flutter/plugin_registrar_windows.h>
#include <flutter/standard_method_codec.h>
#include <flutter/event_channel.h>
#include <flutter/event_stream_handler.h>
#include <flutter/event_stream_handler_functions.h>
#include <flutter/encodable_value.h>
#include <windows.h>

#include <memory>
#include <optional>
#include <sstream>
#include <map>
#include <string>
#include <variant>
#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Devices.Geolocation.h>
#include <winrt/Windows.Devices.Bluetooth.h>
#include <winrt/Windows.Devices.Radios.h>
#include <winrt/Windows.Foundation.Collections.h>

#include "permission_constants.h"

namespace {

using namespace flutter;
using namespace winrt;
using namespace winrt::Windows::Devices::Geolocation;
using namespace winrt::Windows::Devices::Bluetooth;
using namespace winrt::Windows::Devices::Radios;

template<typename T>
T GetArgument(const std::string arg, const EncodableValue* args, T fallback) {
  T result {fallback};
  const auto* arguments = std::get_if<EncodableMap>(args);
  if (arguments) {
    auto result_it = arguments->find(EncodableValue(arg));
    if (result_it != arguments->end()) {
      result = std::get<T>(result_it->second);
    }
  }
  return result;
}

class PermissionHandlerWindowsPlugin : public Plugin {
 public:
  static void RegisterWithRegistrar(PluginRegistrar* registrar);

  PermissionHandlerWindowsPlugin();

  virtual ~PermissionHandlerWindowsPlugin();

  // Disallow copy and move.
  PermissionHandlerWindowsPlugin(const PermissionHandlerWindowsPlugin&) = delete;
  PermissionHandlerWindowsPlugin& operator=(const PermissionHandlerWindowsPlugin&) = delete;

  // Called when a method is called on the plugin channel.
  void HandleMethodCall(const MethodCall<>&,
                        std::unique_ptr<MethodResult<>>);

 private:
  void IsLocationServiceEnabled(std::unique_ptr<MethodResult<>> result);
  winrt::fire_and_forget IsBluetoothServiceEnabled(std::unique_ptr<MethodResult<>> result);

  winrt::Windows::Devices::Geolocation::Geolocator geolocator;
  winrt::Windows::Devices::Geolocation::Geolocator::PositionChanged_revoker m_positionChangedRevoker;
};

// static
void PermissionHandlerWindowsPlugin::RegisterWithRegistrar(
    PluginRegistrar* registrar) {

  auto channel = std::make_unique<MethodChannel<>>(
    registrar->messenger(), "flutter.baseflow.com/permissions/methods",
    &StandardMethodCodec::GetInstance());

  std::unique_ptr<PermissionHandlerWindowsPlugin> plugin = std::make_unique<PermissionHandlerWindowsPlugin>();

  channel->SetMethodCallHandler(
    [plugin_pointer = plugin.get()](const auto& call, auto result) {
      plugin_pointer->HandleMethodCall(call, std::move(result));
    });

  registrar->AddPlugin(std::move(plugin));
}

PermissionHandlerWindowsPlugin::PermissionHandlerWindowsPlugin(){
  m_positionChangedRevoker = geolocator.PositionChanged(winrt::auto_revoke,
    [this](Geolocator const& geolocator, PositionChangedEventArgs e)
    {
    });
}

PermissionHandlerWindowsPlugin::~PermissionHandlerWindowsPlugin() = default;

void PermissionHandlerWindowsPlugin::HandleMethodCall(
    const MethodCall<>& method_call,
    std::unique_ptr<MethodResult<>> result) {
  
  auto methodName = method_call.method_name();
  if (methodName.compare("checkServiceStatus") == 0) {
    auto permission = (PermissionConstants::PermissionGroup)std::get<int>(*method_call.arguments());
    if (permission == PermissionConstants::PermissionGroup::LOCATION ||
        permission == PermissionConstants::PermissionGroup::LOCATION_ALWAYS ||
        permission == PermissionConstants::PermissionGroup::LOCATION_WHEN_IN_USE) {
        IsLocationServiceEnabled(std::move(result));
        return;
    }
    if(permission == PermissionConstants::PermissionGroup::BLUETOOTH){
        IsBluetoothServiceEnabled(std::move(result));
        return;
    }

    if (permission == PermissionConstants::PermissionGroup::IGNORE_BATTERY_OPTIMIZATIONS) {
        result->Success(EncodableValue((int)PermissionConstants::ServiceStatus::ENABLED));
        return;
    }

    result->Success(EncodableValue((int)PermissionConstants::ServiceStatus::NOT_APPLICABLE));
    
  } else if (methodName.compare("checkPermissionStatus") == 0) {
    result->Success(EncodableValue((int)PermissionConstants::PermissionStatus::GRANTED));
  } else if (methodName.compare("requestPermissions") == 0) {
    auto permissionsEncoded = std::get<EncodableList>(*method_call.arguments());
    std::vector<int> permissions;
    permissions.reserve( permissionsEncoded.size() );
    std::transform( permissionsEncoded.begin(), permissionsEncoded.end(),
                    std::back_inserter( permissions ),
                    [](const EncodableValue& encoded) {
                      return std::get<int>(encoded);
                    });
    
    EncodableMap requestResults;

    for (int i=0;i<permissions.size();i++) {
      auto permissionStatus = PermissionConstants::PermissionStatus::GRANTED;
      requestResults.insert({EncodableValue(permissions[i]), EncodableValue((int)permissionStatus)});
    }

    result->Success(requestResults);
  } else if (methodName.compare("shouldShowRequestPermissionRationale") == 0
          || methodName.compare("openAppSettings")) {
    result->Success(EncodableValue(false));
  } else {
    result->NotImplemented();
  }
}

void PermissionHandlerWindowsPlugin::IsLocationServiceEnabled(std::unique_ptr<MethodResult<>> result) {
  result->Success(EncodableValue((int)(geolocator.LocationStatus() != PositionStatus::NotAvailable
        ? PermissionConstants::ServiceStatus::ENABLED
        : PermissionConstants::ServiceStatus::DISABLED)));
}

winrt::fire_and_forget PermissionHandlerWindowsPlugin::IsBluetoothServiceEnabled(std::unique_ptr<MethodResult<>> result) {
  auto btAdapter = co_await BluetoothAdapter::GetDefaultAsync();

  if (btAdapter == nullptr) {
    result->Success(EncodableValue((int)PermissionConstants::ServiceStatus::DISABLED));
    co_return;
  }
  
  if (!btAdapter.IsCentralRoleSupported()) {
    result->Success(EncodableValue((int)PermissionConstants::ServiceStatus::DISABLED));
    co_return;
  }
  
  auto radios = co_await Radio::GetRadiosAsync();

  for (uint32_t i=0; i<radios.Size(); i++) {
    auto radio = radios.GetAt(i);
    if(radio.Kind() == RadioKind::Bluetooth) {
      co_await radio.SetStateAsync(RadioState::On);
      result->Success(EncodableValue((int)(radio.State() == RadioState::On
            ? PermissionConstants::ServiceStatus::ENABLED
            : PermissionConstants::ServiceStatus::DISABLED)));
      co_return;
    }
  }

  result->Success(EncodableValue((int)PermissionConstants::ServiceStatus::DISABLED));
}

}  // namespace

void PermissionHandlerWindowsPluginRegisterWithRegistrar(
    FlutterDesktopPluginRegistrarRef registrar) {
  PermissionHandlerWindowsPlugin::RegisterWithRegistrar(
      PluginRegistrarManager::GetInstance()
          ->GetRegistrar<PluginRegistrarWindows>(registrar));
}

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/CHANGELOG.md

**크기**: 779 bytes | **라인 수**: 25 | **타입**: text

```
## 0.2.1

* Updates the dependency on `permission_handler_platform_interface` to version 4.1.0 (SiriKit support is only available for iOS and macOS).

## 0.2.0

* Implements the `Permission.calendarWriteOnly` and `Permission.calendarFullAccess` permissions.
* Bumps `permission_handler_platform_interface` to version `4.0.0`.

## 0.1.3

* Adds the new Android 13 permission "BODY_SENSORS_BACKGROUND" to PermissionHandlerEnums.h.

## 0.1.2

* Adds the new Android 13 permissions "SCHEDULE_EXACT_ALARM, READ_MEDIA_IMAGES, READ_MEDIA_VIDEO and READ_MEDIA_AUDIO" to permission_constants.h.

## 0.1.1

* Adds the new Android 13 NEARBY_WIFI_DEVICES permission to permission_constants.h.

## 0.1.0

* Adds an initial implementation of Windows support for the permission_handler plugin.

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/README.md

**크기**: 1743 bytes | **라인 수**: 24 | **타입**: text

```
# permission_handler_windows

[![pub package](https://img.shields.io/pub/v/permission_handler_windows.svg)](https://pub.dartlang.org/packages/permission_handler_windows) ![Build status](https://github.com/Baseflow/flutter-permission-handler/workflows/permission_handler_android/badge.svg?branch=master) [![style: flutter lints](https://img.shields.io/badge/style-flutter_lints-40c4ff.svg)](https://pub.dev/packages/flutter_lints)

The official Windows implementation of the [permission_handler](https://pub.dev/packages/permission_handler) plugin by [Baseflow](https://baseflow.com).

## Usage

Starting from version 9.2.0 of the [permission_handler](https://pub.dev/packages/permission_handler) plugin this is the endorsed Windows implementation. This means it will automatically be added to your dependencies when you depend on `permission_handler: ^9.2.0` in your applications pubspec.yaml.

More detailed instructions on using the API can be found in the [README.md](../permission_handler/README.md) of the [permission_handler](https://pub.dev/packages/permission_handler) package.

## Issues

Please file any issues, bugs or feature requests as an issue on our [GitHub](https://github.com/Baseflow/flutter-permission-handler/issues) page. Commercial support is available, you can contact us at <hello@baseflow.com>.

## Want to contribute

If you would like to contribute to the plugin (e.g. by improving the documentation, solving a bug or adding a cool new feature), please carefully review our [contribution guide](../CONTRIBUTING.md) and send us your [pull request](https://github.com/Baseflow/flutter-permission-handler/pulls).

## Author

This permission_handler plugin for Flutter is developed by [Baseflow](https://baseflow.com).

```

### noisetime/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/pubspec.yaml

**크기**: 604 bytes | **라인 수**: 26 | **타입**: text

```
name: permission_handler_windows
description: Permission plugin for Flutter. This plugin provides the Windows API to request and check permissions.
version: 0.2.1
homepage: https://github.com/baseflow/flutter-permission-handler

flutter:
  plugin:
    implements: permission_handler
    platforms:
      windows:
        pluginClass: PermissionHandlerWindowsPlugin

dependencies:
  flutter:
    sdk: flutter
  permission_handler_platform_interface: ^4.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  plugin_platform_interface: ^2.0.0

environment:
  sdk: ">=2.12.0 <4.0.0"
  flutter: ">=2.0.0"

```

### noisetime/windows/flutter/CMakeLists.txt

**크기**: 3742 bytes | **라인 수**: 110 | **타입**: text

```
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

### noisetime/windows/flutter/generated_plugin_registrant.h

**크기**: 302 bytes | **라인 수**: 16 | **타입**: text

```
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

```

### noisetime/windows/runner/CMakeLists.txt

**크기**: 1796 bytes | **라인 수**: 41 | **타입**: text

```
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

```

### noisetime/windows/runner/flutter_window.cpp

**크기**: 2122 bytes | **라인 수**: 72 | **타입**: text

```
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

### noisetime/windows/runner/flutter_window.h

**크기**: 928 bytes | **라인 수**: 34 | **타입**: text

```
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

### noisetime/windows/runner/main.cpp

**크기**: 1262 bytes | **라인 수**: 44 | **타입**: text

```
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"noisetime", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

### noisetime/windows/runner/resource.h

**크기**: 432 bytes | **라인 수**: 17 | **타입**: text

```
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

### noisetime/windows/runner/utils.cpp

**크기**: 1797 bytes | **라인 수**: 66 | **타입**: text

```
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

### noisetime/windows/runner/utils.h

**크기**: 672 bytes | **라인 수**: 20 | **타입**: text

```
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

### noisetime/windows/runner/win32_window.cpp

**크기**: 8534 bytes | **라인 수**: 289 | **타입**: text

```
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

```

### noisetime/windows/runner/win32_window.h

**크기**: 3522 bytes | **라인 수**: 103 | **타입**: text

```
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

### noisetime/windows/CMakeLists.txt

**크기**: 4154 bytes | **라인 수**: 109 | **타입**: text

```
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(noisetime LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "noisetime")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

### noisetime/README.md

**크기**: 552 bytes | **라인 수**: 17 | **타입**: text

```
# noisetime

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

```

### noisetime/analysis_options.yaml

**크기**: 1420 bytes | **라인 수**: 29 | **타입**: text

```
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

```

### noisetime/firebase.json

**크기**: 381 bytes | **라인 수**: 1 | **타입**: text

```
{"flutter":{"platforms":{"android":{"default":{"projectId":"noisetime-youth","appId":"1:130019319095:android:def30a9ce1dc05db1b0eb2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"noisetime-youth","configurations":{"android":"1:130019319095:android:def30a9ce1dc05db1b0eb2","ios":"1:130019319095:ios:c5fdbba9e7dce87b1b0eb2"}}}}}}
```

### noisetime/pubspec.yaml

**크기**: 3992 bytes | **라인 수**: 96 | **타입**: text

```
name: noisetime
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: '>=3.4.0 <4.0.0'

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter


  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.6
  cloud_firestore: ^6.0.2
  firebase_auth: ^6.1.0
  google_sign_in: ^6.2.2
  provider: ^6.1.5+1
  noise_meter: ^5.0.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^3.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/assets-and-images/#from-packages

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/custom-fonts/#from-packages

```

### README.md

**크기**: 216 bytes | **라인 수**: 3 | **타입**: text

```
Get started by customizing your environment (defined in the .idx/dev.nix file) with the tools and IDE extensions you'll need for your project!

Learn more at https://developers.google.com/idx/guides/customize-idx-env
```

